
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Store
 * 
 */
export type Store = $Result.DefaultSelection<Prisma.$StorePayload>
/**
 * Model StoreEmployee
 * 
 */
export type StoreEmployee = $Result.DefaultSelection<Prisma.$StoreEmployeePayload>
/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = $Result.DefaultSelection<Prisma.$ProductCategoryPayload>
/**
 * Model StoreProduct
 * 
 */
export type StoreProduct = $Result.DefaultSelection<Prisma.$StoreProductPayload>
/**
 * Model StorePriceHistory
 * 
 */
export type StorePriceHistory = $Result.DefaultSelection<Prisma.$StorePriceHistoryPayload>
/**
 * Model Sale
 * 
 */
export type Sale = $Result.DefaultSelection<Prisma.$SalePayload>
/**
 * Model SaleItem
 * 
 */
export type SaleItem = $Result.DefaultSelection<Prisma.$SaleItemPayload>
/**
 * Model SalePayment
 * 
 */
export type SalePayment = $Result.DefaultSelection<Prisma.$SalePaymentPayload>
/**
 * Model SaleReturn
 * 
 */
export type SaleReturn = $Result.DefaultSelection<Prisma.$SaleReturnPayload>
/**
 * Model SaleReturnItem
 * 
 */
export type SaleReturnItem = $Result.DefaultSelection<Prisma.$SaleReturnItemPayload>
/**
 * Model StoreSupplier
 * 
 */
export type StoreSupplier = $Result.DefaultSelection<Prisma.$StoreSupplierPayload>
/**
 * Model StorePurchaseOrder
 * 
 */
export type StorePurchaseOrder = $Result.DefaultSelection<Prisma.$StorePurchaseOrderPayload>
/**
 * Model StorePurchaseItem
 * 
 */
export type StorePurchaseItem = $Result.DefaultSelection<Prisma.$StorePurchaseItemPayload>
/**
 * Model StockMovement
 * 
 */
export type StockMovement = $Result.DefaultSelection<Prisma.$StockMovementPayload>
/**
 * Model TransferOrder
 * 
 */
export type TransferOrder = $Result.DefaultSelection<Prisma.$TransferOrderPayload>
/**
 * Model TransferOrderItem
 * 
 */
export type TransferOrderItem = $Result.DefaultSelection<Prisma.$TransferOrderItemPayload>
/**
 * Model StoreCustomer
 * 
 */
export type StoreCustomer = $Result.DefaultSelection<Prisma.$StoreCustomerPayload>
/**
 * Model StoreLoyaltyConfig
 * 
 */
export type StoreLoyaltyConfig = $Result.DefaultSelection<Prisma.$StoreLoyaltyConfigPayload>
/**
 * Model StoreLoyaltyTransaction
 * 
 */
export type StoreLoyaltyTransaction = $Result.DefaultSelection<Prisma.$StoreLoyaltyTransactionPayload>
/**
 * Model StoreTaxRule
 * 
 */
export type StoreTaxRule = $Result.DefaultSelection<Prisma.$StoreTaxRulePayload>
/**
 * Model StorePaymentConfig
 * 
 */
export type StorePaymentConfig = $Result.DefaultSelection<Prisma.$StorePaymentConfigPayload>
/**
 * Model StoreReceiptConfig
 * 
 */
export type StoreReceiptConfig = $Result.DefaultSelection<Prisma.$StoreReceiptConfigPayload>
/**
 * Model StoreDeviceConfig
 * 
 */
export type StoreDeviceConfig = $Result.DefaultSelection<Prisma.$StoreDeviceConfigPayload>
/**
 * Model StoreIntegration
 * 
 */
export type StoreIntegration = $Result.DefaultSelection<Prisma.$StoreIntegrationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const StoreDiscountType: {
  DISCOUNT_PERCENTAGE: 'DISCOUNT_PERCENTAGE',
  DISCOUNT_FIXED: 'DISCOUNT_FIXED'
};

export type StoreDiscountType = (typeof StoreDiscountType)[keyof typeof StoreDiscountType]


export const StoreSaleStatus: {
  COMPLETED: 'COMPLETED',
  VOIDED: 'VOIDED',
  REFUNDED: 'REFUNDED',
  PARTIAL_REFUND: 'PARTIAL_REFUND'
};

export type StoreSaleStatus = (typeof StoreSaleStatus)[keyof typeof StoreSaleStatus]


export const PaymentMethod: {
  CASH: 'CASH',
  BANK_TRANSFER: 'BANK_TRANSFER',
  CARD: 'CARD',
  CHECK: 'CHECK'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const StoreReturnStatus: {
  STORE_RETURN_PENDING: 'STORE_RETURN_PENDING',
  STORE_RETURN_APPROVED: 'STORE_RETURN_APPROVED',
  STORE_RETURN_COMPLETED: 'STORE_RETURN_COMPLETED',
  STORE_RETURN_REJECTED: 'STORE_RETURN_REJECTED'
};

export type StoreReturnStatus = (typeof StoreReturnStatus)[keyof typeof StoreReturnStatus]


export const StorePurchaseStatus: {
  STORE_PO_DRAFT: 'STORE_PO_DRAFT',
  STORE_PO_ORDERED: 'STORE_PO_ORDERED',
  STORE_PO_PARTIAL: 'STORE_PO_PARTIAL',
  STORE_PO_RECEIVED: 'STORE_PO_RECEIVED',
  STORE_PO_CANCELLED: 'STORE_PO_CANCELLED'
};

export type StorePurchaseStatus = (typeof StorePurchaseStatus)[keyof typeof StorePurchaseStatus]


export const StoreMovementType: {
  STOCK_IN: 'STOCK_IN',
  STOCK_OUT: 'STOCK_OUT',
  STOCK_ADJUSTMENT: 'STOCK_ADJUSTMENT',
  STOCK_TRANSFER: 'STOCK_TRANSFER',
  STOCK_RETURN: 'STOCK_RETURN'
};

export type StoreMovementType = (typeof StoreMovementType)[keyof typeof StoreMovementType]


export const TransferOrderStatus: {
  DRAFT: 'DRAFT',
  SENT: 'SENT',
  RECEIVED: 'RECEIVED'
};

export type TransferOrderStatus = (typeof TransferOrderStatus)[keyof typeof TransferOrderStatus]


export const LoyaltyTier: {
  BRONZE: 'BRONZE',
  SILVER: 'SILVER',
  GOLD: 'GOLD',
  PLATINUM: 'PLATINUM'
};

export type LoyaltyTier = (typeof LoyaltyTier)[keyof typeof LoyaltyTier]


export const LoyaltyTransactionType: {
  EARN: 'EARN',
  REDEEM: 'REDEEM',
  ADJUST: 'ADJUST',
  EXPIRE: 'EXPIRE'
};

export type LoyaltyTransactionType = (typeof LoyaltyTransactionType)[keyof typeof LoyaltyTransactionType]


export const StoreDeviceType: {
  RECEIPT_PRINTER: 'RECEIPT_PRINTER',
  FISCAL_PRINTER: 'FISCAL_PRINTER',
  BARCODE_SCANNER: 'BARCODE_SCANNER',
  WEIGHT_SCALE: 'WEIGHT_SCALE',
  CASH_DRAWER: 'CASH_DRAWER',
  BANK_TERMINAL: 'BANK_TERMINAL',
  CUSTOMER_DISPLAY: 'CUSTOMER_DISPLAY'
};

export type StoreDeviceType = (typeof StoreDeviceType)[keyof typeof StoreDeviceType]


export const StoreIntegrationType: {
  RS_GE: 'RS_GE',
  WOOCOMMERCE: 'WOOCOMMERCE',
  SHOPIFY: 'SHOPIFY',
  GLOVO: 'GLOVO',
  EXTRA_GE: 'EXTRA_GE',
  BANK_TBC: 'BANK_TBC',
  BANK_BOG: 'BANK_BOG',
  BANK_LIBERTY: 'BANK_LIBERTY'
};

export type StoreIntegrationType = (typeof StoreIntegrationType)[keyof typeof StoreIntegrationType]

}

export type StoreDiscountType = $Enums.StoreDiscountType

export const StoreDiscountType: typeof $Enums.StoreDiscountType

export type StoreSaleStatus = $Enums.StoreSaleStatus

export const StoreSaleStatus: typeof $Enums.StoreSaleStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type StoreReturnStatus = $Enums.StoreReturnStatus

export const StoreReturnStatus: typeof $Enums.StoreReturnStatus

export type StorePurchaseStatus = $Enums.StorePurchaseStatus

export const StorePurchaseStatus: typeof $Enums.StorePurchaseStatus

export type StoreMovementType = $Enums.StoreMovementType

export const StoreMovementType: typeof $Enums.StoreMovementType

export type TransferOrderStatus = $Enums.TransferOrderStatus

export const TransferOrderStatus: typeof $Enums.TransferOrderStatus

export type LoyaltyTier = $Enums.LoyaltyTier

export const LoyaltyTier: typeof $Enums.LoyaltyTier

export type LoyaltyTransactionType = $Enums.LoyaltyTransactionType

export const LoyaltyTransactionType: typeof $Enums.LoyaltyTransactionType

export type StoreDeviceType = $Enums.StoreDeviceType

export const StoreDeviceType: typeof $Enums.StoreDeviceType

export type StoreIntegrationType = $Enums.StoreIntegrationType

export const StoreIntegrationType: typeof $Enums.StoreIntegrationType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Organizations
 * const organizations = await prisma.organization.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Organizations
   * const organizations = await prisma.organization.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.store`: Exposes CRUD operations for the **Store** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.store.findMany()
    * ```
    */
  get store(): Prisma.StoreDelegate<ExtArgs>;

  /**
   * `prisma.storeEmployee`: Exposes CRUD operations for the **StoreEmployee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreEmployees
    * const storeEmployees = await prisma.storeEmployee.findMany()
    * ```
    */
  get storeEmployee(): Prisma.StoreEmployeeDelegate<ExtArgs>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<ExtArgs>;

  /**
   * `prisma.storeProduct`: Exposes CRUD operations for the **StoreProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreProducts
    * const storeProducts = await prisma.storeProduct.findMany()
    * ```
    */
  get storeProduct(): Prisma.StoreProductDelegate<ExtArgs>;

  /**
   * `prisma.storePriceHistory`: Exposes CRUD operations for the **StorePriceHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StorePriceHistories
    * const storePriceHistories = await prisma.storePriceHistory.findMany()
    * ```
    */
  get storePriceHistory(): Prisma.StorePriceHistoryDelegate<ExtArgs>;

  /**
   * `prisma.sale`: Exposes CRUD operations for the **Sale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales
    * const sales = await prisma.sale.findMany()
    * ```
    */
  get sale(): Prisma.SaleDelegate<ExtArgs>;

  /**
   * `prisma.saleItem`: Exposes CRUD operations for the **SaleItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleItems
    * const saleItems = await prisma.saleItem.findMany()
    * ```
    */
  get saleItem(): Prisma.SaleItemDelegate<ExtArgs>;

  /**
   * `prisma.salePayment`: Exposes CRUD operations for the **SalePayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalePayments
    * const salePayments = await prisma.salePayment.findMany()
    * ```
    */
  get salePayment(): Prisma.SalePaymentDelegate<ExtArgs>;

  /**
   * `prisma.saleReturn`: Exposes CRUD operations for the **SaleReturn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleReturns
    * const saleReturns = await prisma.saleReturn.findMany()
    * ```
    */
  get saleReturn(): Prisma.SaleReturnDelegate<ExtArgs>;

  /**
   * `prisma.saleReturnItem`: Exposes CRUD operations for the **SaleReturnItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleReturnItems
    * const saleReturnItems = await prisma.saleReturnItem.findMany()
    * ```
    */
  get saleReturnItem(): Prisma.SaleReturnItemDelegate<ExtArgs>;

  /**
   * `prisma.storeSupplier`: Exposes CRUD operations for the **StoreSupplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreSuppliers
    * const storeSuppliers = await prisma.storeSupplier.findMany()
    * ```
    */
  get storeSupplier(): Prisma.StoreSupplierDelegate<ExtArgs>;

  /**
   * `prisma.storePurchaseOrder`: Exposes CRUD operations for the **StorePurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StorePurchaseOrders
    * const storePurchaseOrders = await prisma.storePurchaseOrder.findMany()
    * ```
    */
  get storePurchaseOrder(): Prisma.StorePurchaseOrderDelegate<ExtArgs>;

  /**
   * `prisma.storePurchaseItem`: Exposes CRUD operations for the **StorePurchaseItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StorePurchaseItems
    * const storePurchaseItems = await prisma.storePurchaseItem.findMany()
    * ```
    */
  get storePurchaseItem(): Prisma.StorePurchaseItemDelegate<ExtArgs>;

  /**
   * `prisma.stockMovement`: Exposes CRUD operations for the **StockMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockMovements
    * const stockMovements = await prisma.stockMovement.findMany()
    * ```
    */
  get stockMovement(): Prisma.StockMovementDelegate<ExtArgs>;

  /**
   * `prisma.transferOrder`: Exposes CRUD operations for the **TransferOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransferOrders
    * const transferOrders = await prisma.transferOrder.findMany()
    * ```
    */
  get transferOrder(): Prisma.TransferOrderDelegate<ExtArgs>;

  /**
   * `prisma.transferOrderItem`: Exposes CRUD operations for the **TransferOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransferOrderItems
    * const transferOrderItems = await prisma.transferOrderItem.findMany()
    * ```
    */
  get transferOrderItem(): Prisma.TransferOrderItemDelegate<ExtArgs>;

  /**
   * `prisma.storeCustomer`: Exposes CRUD operations for the **StoreCustomer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreCustomers
    * const storeCustomers = await prisma.storeCustomer.findMany()
    * ```
    */
  get storeCustomer(): Prisma.StoreCustomerDelegate<ExtArgs>;

  /**
   * `prisma.storeLoyaltyConfig`: Exposes CRUD operations for the **StoreLoyaltyConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreLoyaltyConfigs
    * const storeLoyaltyConfigs = await prisma.storeLoyaltyConfig.findMany()
    * ```
    */
  get storeLoyaltyConfig(): Prisma.StoreLoyaltyConfigDelegate<ExtArgs>;

  /**
   * `prisma.storeLoyaltyTransaction`: Exposes CRUD operations for the **StoreLoyaltyTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreLoyaltyTransactions
    * const storeLoyaltyTransactions = await prisma.storeLoyaltyTransaction.findMany()
    * ```
    */
  get storeLoyaltyTransaction(): Prisma.StoreLoyaltyTransactionDelegate<ExtArgs>;

  /**
   * `prisma.storeTaxRule`: Exposes CRUD operations for the **StoreTaxRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreTaxRules
    * const storeTaxRules = await prisma.storeTaxRule.findMany()
    * ```
    */
  get storeTaxRule(): Prisma.StoreTaxRuleDelegate<ExtArgs>;

  /**
   * `prisma.storePaymentConfig`: Exposes CRUD operations for the **StorePaymentConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StorePaymentConfigs
    * const storePaymentConfigs = await prisma.storePaymentConfig.findMany()
    * ```
    */
  get storePaymentConfig(): Prisma.StorePaymentConfigDelegate<ExtArgs>;

  /**
   * `prisma.storeReceiptConfig`: Exposes CRUD operations for the **StoreReceiptConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreReceiptConfigs
    * const storeReceiptConfigs = await prisma.storeReceiptConfig.findMany()
    * ```
    */
  get storeReceiptConfig(): Prisma.StoreReceiptConfigDelegate<ExtArgs>;

  /**
   * `prisma.storeDeviceConfig`: Exposes CRUD operations for the **StoreDeviceConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreDeviceConfigs
    * const storeDeviceConfigs = await prisma.storeDeviceConfig.findMany()
    * ```
    */
  get storeDeviceConfig(): Prisma.StoreDeviceConfigDelegate<ExtArgs>;

  /**
   * `prisma.storeIntegration`: Exposes CRUD operations for the **StoreIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreIntegrations
    * const storeIntegrations = await prisma.storeIntegration.findMany()
    * ```
    */
  get storeIntegration(): Prisma.StoreIntegrationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Organization: 'Organization',
    User: 'User',
    Store: 'Store',
    StoreEmployee: 'StoreEmployee',
    ProductCategory: 'ProductCategory',
    StoreProduct: 'StoreProduct',
    StorePriceHistory: 'StorePriceHistory',
    Sale: 'Sale',
    SaleItem: 'SaleItem',
    SalePayment: 'SalePayment',
    SaleReturn: 'SaleReturn',
    SaleReturnItem: 'SaleReturnItem',
    StoreSupplier: 'StoreSupplier',
    StorePurchaseOrder: 'StorePurchaseOrder',
    StorePurchaseItem: 'StorePurchaseItem',
    StockMovement: 'StockMovement',
    TransferOrder: 'TransferOrder',
    TransferOrderItem: 'TransferOrderItem',
    StoreCustomer: 'StoreCustomer',
    StoreLoyaltyConfig: 'StoreLoyaltyConfig',
    StoreLoyaltyTransaction: 'StoreLoyaltyTransaction',
    StoreTaxRule: 'StoreTaxRule',
    StorePaymentConfig: 'StorePaymentConfig',
    StoreReceiptConfig: 'StoreReceiptConfig',
    StoreDeviceConfig: 'StoreDeviceConfig',
    StoreIntegration: 'StoreIntegration'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "organization" | "user" | "store" | "storeEmployee" | "productCategory" | "storeProduct" | "storePriceHistory" | "sale" | "saleItem" | "salePayment" | "saleReturn" | "saleReturnItem" | "storeSupplier" | "storePurchaseOrder" | "storePurchaseItem" | "stockMovement" | "transferOrder" | "transferOrderItem" | "storeCustomer" | "storeLoyaltyConfig" | "storeLoyaltyTransaction" | "storeTaxRule" | "storePaymentConfig" | "storeReceiptConfig" | "storeDeviceConfig" | "storeIntegration"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Store: {
        payload: Prisma.$StorePayload<ExtArgs>
        fields: Prisma.StoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findFirst: {
            args: Prisma.StoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findMany: {
            args: Prisma.StoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          create: {
            args: Prisma.StoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          createMany: {
            args: Prisma.StoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          delete: {
            args: Prisma.StoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          update: {
            args: Prisma.StoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          deleteMany: {
            args: Prisma.StoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          aggregate: {
            args: Prisma.StoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStore>
          }
          groupBy: {
            args: Prisma.StoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreCountArgs<ExtArgs>
            result: $Utils.Optional<StoreCountAggregateOutputType> | number
          }
        }
      }
      StoreEmployee: {
        payload: Prisma.$StoreEmployeePayload<ExtArgs>
        fields: Prisma.StoreEmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreEmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreEmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreEmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreEmployeePayload>
          }
          findFirst: {
            args: Prisma.StoreEmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreEmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreEmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreEmployeePayload>
          }
          findMany: {
            args: Prisma.StoreEmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreEmployeePayload>[]
          }
          create: {
            args: Prisma.StoreEmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreEmployeePayload>
          }
          createMany: {
            args: Prisma.StoreEmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreEmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreEmployeePayload>[]
          }
          delete: {
            args: Prisma.StoreEmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreEmployeePayload>
          }
          update: {
            args: Prisma.StoreEmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreEmployeePayload>
          }
          deleteMany: {
            args: Prisma.StoreEmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreEmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreEmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreEmployeePayload>
          }
          aggregate: {
            args: Prisma.StoreEmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreEmployee>
          }
          groupBy: {
            args: Prisma.StoreEmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreEmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreEmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<StoreEmployeeCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: Prisma.$ProductCategoryPayload<ExtArgs>
        fields: Prisma.ProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      StoreProduct: {
        payload: Prisma.$StoreProductPayload<ExtArgs>
        fields: Prisma.StoreProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload>
          }
          findFirst: {
            args: Prisma.StoreProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload>
          }
          findMany: {
            args: Prisma.StoreProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload>[]
          }
          create: {
            args: Prisma.StoreProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload>
          }
          createMany: {
            args: Prisma.StoreProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload>[]
          }
          delete: {
            args: Prisma.StoreProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload>
          }
          update: {
            args: Prisma.StoreProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload>
          }
          deleteMany: {
            args: Prisma.StoreProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload>
          }
          aggregate: {
            args: Prisma.StoreProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreProduct>
          }
          groupBy: {
            args: Prisma.StoreProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreProductCountArgs<ExtArgs>
            result: $Utils.Optional<StoreProductCountAggregateOutputType> | number
          }
        }
      }
      StorePriceHistory: {
        payload: Prisma.$StorePriceHistoryPayload<ExtArgs>
        fields: Prisma.StorePriceHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StorePriceHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePriceHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StorePriceHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePriceHistoryPayload>
          }
          findFirst: {
            args: Prisma.StorePriceHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePriceHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StorePriceHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePriceHistoryPayload>
          }
          findMany: {
            args: Prisma.StorePriceHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePriceHistoryPayload>[]
          }
          create: {
            args: Prisma.StorePriceHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePriceHistoryPayload>
          }
          createMany: {
            args: Prisma.StorePriceHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StorePriceHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePriceHistoryPayload>[]
          }
          delete: {
            args: Prisma.StorePriceHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePriceHistoryPayload>
          }
          update: {
            args: Prisma.StorePriceHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePriceHistoryPayload>
          }
          deleteMany: {
            args: Prisma.StorePriceHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StorePriceHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StorePriceHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePriceHistoryPayload>
          }
          aggregate: {
            args: Prisma.StorePriceHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStorePriceHistory>
          }
          groupBy: {
            args: Prisma.StorePriceHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<StorePriceHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.StorePriceHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<StorePriceHistoryCountAggregateOutputType> | number
          }
        }
      }
      Sale: {
        payload: Prisma.$SalePayload<ExtArgs>
        fields: Prisma.SaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findFirst: {
            args: Prisma.SaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findMany: {
            args: Prisma.SaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          create: {
            args: Prisma.SaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          createMany: {
            args: Prisma.SaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          delete: {
            args: Prisma.SaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          update: {
            args: Prisma.SaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          deleteMany: {
            args: Prisma.SaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          aggregate: {
            args: Prisma.SaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSale>
          }
          groupBy: {
            args: Prisma.SaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleCountArgs<ExtArgs>
            result: $Utils.Optional<SaleCountAggregateOutputType> | number
          }
        }
      }
      SaleItem: {
        payload: Prisma.$SaleItemPayload<ExtArgs>
        fields: Prisma.SaleItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          findFirst: {
            args: Prisma.SaleItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          findMany: {
            args: Prisma.SaleItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>[]
          }
          create: {
            args: Prisma.SaleItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          createMany: {
            args: Prisma.SaleItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>[]
          }
          delete: {
            args: Prisma.SaleItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          update: {
            args: Prisma.SaleItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          deleteMany: {
            args: Prisma.SaleItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaleItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          aggregate: {
            args: Prisma.SaleItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleItem>
          }
          groupBy: {
            args: Prisma.SaleItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleItemCountArgs<ExtArgs>
            result: $Utils.Optional<SaleItemCountAggregateOutputType> | number
          }
        }
      }
      SalePayment: {
        payload: Prisma.$SalePaymentPayload<ExtArgs>
        fields: Prisma.SalePaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalePaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalePaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload>
          }
          findFirst: {
            args: Prisma.SalePaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalePaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload>
          }
          findMany: {
            args: Prisma.SalePaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload>[]
          }
          create: {
            args: Prisma.SalePaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload>
          }
          createMany: {
            args: Prisma.SalePaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalePaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload>[]
          }
          delete: {
            args: Prisma.SalePaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload>
          }
          update: {
            args: Prisma.SalePaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload>
          }
          deleteMany: {
            args: Prisma.SalePaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalePaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SalePaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePaymentPayload>
          }
          aggregate: {
            args: Prisma.SalePaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalePayment>
          }
          groupBy: {
            args: Prisma.SalePaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalePaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalePaymentCountArgs<ExtArgs>
            result: $Utils.Optional<SalePaymentCountAggregateOutputType> | number
          }
        }
      }
      SaleReturn: {
        payload: Prisma.$SaleReturnPayload<ExtArgs>
        fields: Prisma.SaleReturnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleReturnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleReturnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnPayload>
          }
          findFirst: {
            args: Prisma.SaleReturnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleReturnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnPayload>
          }
          findMany: {
            args: Prisma.SaleReturnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnPayload>[]
          }
          create: {
            args: Prisma.SaleReturnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnPayload>
          }
          createMany: {
            args: Prisma.SaleReturnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleReturnCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnPayload>[]
          }
          delete: {
            args: Prisma.SaleReturnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnPayload>
          }
          update: {
            args: Prisma.SaleReturnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnPayload>
          }
          deleteMany: {
            args: Prisma.SaleReturnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleReturnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaleReturnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnPayload>
          }
          aggregate: {
            args: Prisma.SaleReturnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleReturn>
          }
          groupBy: {
            args: Prisma.SaleReturnGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleReturnGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleReturnCountArgs<ExtArgs>
            result: $Utils.Optional<SaleReturnCountAggregateOutputType> | number
          }
        }
      }
      SaleReturnItem: {
        payload: Prisma.$SaleReturnItemPayload<ExtArgs>
        fields: Prisma.SaleReturnItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleReturnItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleReturnItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnItemPayload>
          }
          findFirst: {
            args: Prisma.SaleReturnItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleReturnItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnItemPayload>
          }
          findMany: {
            args: Prisma.SaleReturnItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnItemPayload>[]
          }
          create: {
            args: Prisma.SaleReturnItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnItemPayload>
          }
          createMany: {
            args: Prisma.SaleReturnItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleReturnItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnItemPayload>[]
          }
          delete: {
            args: Prisma.SaleReturnItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnItemPayload>
          }
          update: {
            args: Prisma.SaleReturnItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnItemPayload>
          }
          deleteMany: {
            args: Prisma.SaleReturnItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleReturnItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaleReturnItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleReturnItemPayload>
          }
          aggregate: {
            args: Prisma.SaleReturnItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleReturnItem>
          }
          groupBy: {
            args: Prisma.SaleReturnItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleReturnItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleReturnItemCountArgs<ExtArgs>
            result: $Utils.Optional<SaleReturnItemCountAggregateOutputType> | number
          }
        }
      }
      StoreSupplier: {
        payload: Prisma.$StoreSupplierPayload<ExtArgs>
        fields: Prisma.StoreSupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreSupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreSupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreSupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreSupplierPayload>
          }
          findFirst: {
            args: Prisma.StoreSupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreSupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreSupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreSupplierPayload>
          }
          findMany: {
            args: Prisma.StoreSupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreSupplierPayload>[]
          }
          create: {
            args: Prisma.StoreSupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreSupplierPayload>
          }
          createMany: {
            args: Prisma.StoreSupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreSupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreSupplierPayload>[]
          }
          delete: {
            args: Prisma.StoreSupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreSupplierPayload>
          }
          update: {
            args: Prisma.StoreSupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreSupplierPayload>
          }
          deleteMany: {
            args: Prisma.StoreSupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreSupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreSupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreSupplierPayload>
          }
          aggregate: {
            args: Prisma.StoreSupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreSupplier>
          }
          groupBy: {
            args: Prisma.StoreSupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreSupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreSupplierCountArgs<ExtArgs>
            result: $Utils.Optional<StoreSupplierCountAggregateOutputType> | number
          }
        }
      }
      StorePurchaseOrder: {
        payload: Prisma.$StorePurchaseOrderPayload<ExtArgs>
        fields: Prisma.StorePurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StorePurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StorePurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.StorePurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StorePurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.StorePurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.StorePurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.StorePurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StorePurchaseOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseOrderPayload>[]
          }
          delete: {
            args: Prisma.StorePurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseOrderPayload>
          }
          update: {
            args: Prisma.StorePurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.StorePurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StorePurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StorePurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.StorePurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStorePurchaseOrder>
          }
          groupBy: {
            args: Prisma.StorePurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<StorePurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.StorePurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<StorePurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      StorePurchaseItem: {
        payload: Prisma.$StorePurchaseItemPayload<ExtArgs>
        fields: Prisma.StorePurchaseItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StorePurchaseItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StorePurchaseItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseItemPayload>
          }
          findFirst: {
            args: Prisma.StorePurchaseItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StorePurchaseItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseItemPayload>
          }
          findMany: {
            args: Prisma.StorePurchaseItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseItemPayload>[]
          }
          create: {
            args: Prisma.StorePurchaseItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseItemPayload>
          }
          createMany: {
            args: Prisma.StorePurchaseItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StorePurchaseItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseItemPayload>[]
          }
          delete: {
            args: Prisma.StorePurchaseItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseItemPayload>
          }
          update: {
            args: Prisma.StorePurchaseItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseItemPayload>
          }
          deleteMany: {
            args: Prisma.StorePurchaseItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StorePurchaseItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StorePurchaseItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePurchaseItemPayload>
          }
          aggregate: {
            args: Prisma.StorePurchaseItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStorePurchaseItem>
          }
          groupBy: {
            args: Prisma.StorePurchaseItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<StorePurchaseItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.StorePurchaseItemCountArgs<ExtArgs>
            result: $Utils.Optional<StorePurchaseItemCountAggregateOutputType> | number
          }
        }
      }
      StockMovement: {
        payload: Prisma.$StockMovementPayload<ExtArgs>
        fields: Prisma.StockMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          findFirst: {
            args: Prisma.StockMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          findMany: {
            args: Prisma.StockMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
          }
          create: {
            args: Prisma.StockMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          createMany: {
            args: Prisma.StockMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
          }
          delete: {
            args: Prisma.StockMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          update: {
            args: Prisma.StockMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          deleteMany: {
            args: Prisma.StockMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StockMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          aggregate: {
            args: Prisma.StockMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockMovement>
          }
          groupBy: {
            args: Prisma.StockMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockMovementCountArgs<ExtArgs>
            result: $Utils.Optional<StockMovementCountAggregateOutputType> | number
          }
        }
      }
      TransferOrder: {
        payload: Prisma.$TransferOrderPayload<ExtArgs>
        fields: Prisma.TransferOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload>
          }
          findFirst: {
            args: Prisma.TransferOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload>
          }
          findMany: {
            args: Prisma.TransferOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload>[]
          }
          create: {
            args: Prisma.TransferOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload>
          }
          createMany: {
            args: Prisma.TransferOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload>[]
          }
          delete: {
            args: Prisma.TransferOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload>
          }
          update: {
            args: Prisma.TransferOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload>
          }
          deleteMany: {
            args: Prisma.TransferOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransferOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderPayload>
          }
          aggregate: {
            args: Prisma.TransferOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransferOrder>
          }
          groupBy: {
            args: Prisma.TransferOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferOrderCountArgs<ExtArgs>
            result: $Utils.Optional<TransferOrderCountAggregateOutputType> | number
          }
        }
      }
      TransferOrderItem: {
        payload: Prisma.$TransferOrderItemPayload<ExtArgs>
        fields: Prisma.TransferOrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferOrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferOrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload>
          }
          findFirst: {
            args: Prisma.TransferOrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferOrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload>
          }
          findMany: {
            args: Prisma.TransferOrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload>[]
          }
          create: {
            args: Prisma.TransferOrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload>
          }
          createMany: {
            args: Prisma.TransferOrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferOrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload>[]
          }
          delete: {
            args: Prisma.TransferOrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload>
          }
          update: {
            args: Prisma.TransferOrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload>
          }
          deleteMany: {
            args: Prisma.TransferOrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferOrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransferOrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferOrderItemPayload>
          }
          aggregate: {
            args: Prisma.TransferOrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransferOrderItem>
          }
          groupBy: {
            args: Prisma.TransferOrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferOrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferOrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<TransferOrderItemCountAggregateOutputType> | number
          }
        }
      }
      StoreCustomer: {
        payload: Prisma.$StoreCustomerPayload<ExtArgs>
        fields: Prisma.StoreCustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreCustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreCustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreCustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreCustomerPayload>
          }
          findFirst: {
            args: Prisma.StoreCustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreCustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreCustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreCustomerPayload>
          }
          findMany: {
            args: Prisma.StoreCustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreCustomerPayload>[]
          }
          create: {
            args: Prisma.StoreCustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreCustomerPayload>
          }
          createMany: {
            args: Prisma.StoreCustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreCustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreCustomerPayload>[]
          }
          delete: {
            args: Prisma.StoreCustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreCustomerPayload>
          }
          update: {
            args: Prisma.StoreCustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreCustomerPayload>
          }
          deleteMany: {
            args: Prisma.StoreCustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreCustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreCustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreCustomerPayload>
          }
          aggregate: {
            args: Prisma.StoreCustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreCustomer>
          }
          groupBy: {
            args: Prisma.StoreCustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreCustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreCustomerCountArgs<ExtArgs>
            result: $Utils.Optional<StoreCustomerCountAggregateOutputType> | number
          }
        }
      }
      StoreLoyaltyConfig: {
        payload: Prisma.$StoreLoyaltyConfigPayload<ExtArgs>
        fields: Prisma.StoreLoyaltyConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreLoyaltyConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreLoyaltyConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyConfigPayload>
          }
          findFirst: {
            args: Prisma.StoreLoyaltyConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreLoyaltyConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyConfigPayload>
          }
          findMany: {
            args: Prisma.StoreLoyaltyConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyConfigPayload>[]
          }
          create: {
            args: Prisma.StoreLoyaltyConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyConfigPayload>
          }
          createMany: {
            args: Prisma.StoreLoyaltyConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreLoyaltyConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyConfigPayload>[]
          }
          delete: {
            args: Prisma.StoreLoyaltyConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyConfigPayload>
          }
          update: {
            args: Prisma.StoreLoyaltyConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyConfigPayload>
          }
          deleteMany: {
            args: Prisma.StoreLoyaltyConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreLoyaltyConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreLoyaltyConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyConfigPayload>
          }
          aggregate: {
            args: Prisma.StoreLoyaltyConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreLoyaltyConfig>
          }
          groupBy: {
            args: Prisma.StoreLoyaltyConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreLoyaltyConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreLoyaltyConfigCountArgs<ExtArgs>
            result: $Utils.Optional<StoreLoyaltyConfigCountAggregateOutputType> | number
          }
        }
      }
      StoreLoyaltyTransaction: {
        payload: Prisma.$StoreLoyaltyTransactionPayload<ExtArgs>
        fields: Prisma.StoreLoyaltyTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreLoyaltyTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreLoyaltyTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyTransactionPayload>
          }
          findFirst: {
            args: Prisma.StoreLoyaltyTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreLoyaltyTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyTransactionPayload>
          }
          findMany: {
            args: Prisma.StoreLoyaltyTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyTransactionPayload>[]
          }
          create: {
            args: Prisma.StoreLoyaltyTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyTransactionPayload>
          }
          createMany: {
            args: Prisma.StoreLoyaltyTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreLoyaltyTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyTransactionPayload>[]
          }
          delete: {
            args: Prisma.StoreLoyaltyTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyTransactionPayload>
          }
          update: {
            args: Prisma.StoreLoyaltyTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyTransactionPayload>
          }
          deleteMany: {
            args: Prisma.StoreLoyaltyTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreLoyaltyTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreLoyaltyTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreLoyaltyTransactionPayload>
          }
          aggregate: {
            args: Prisma.StoreLoyaltyTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreLoyaltyTransaction>
          }
          groupBy: {
            args: Prisma.StoreLoyaltyTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreLoyaltyTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreLoyaltyTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<StoreLoyaltyTransactionCountAggregateOutputType> | number
          }
        }
      }
      StoreTaxRule: {
        payload: Prisma.$StoreTaxRulePayload<ExtArgs>
        fields: Prisma.StoreTaxRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreTaxRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreTaxRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreTaxRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreTaxRulePayload>
          }
          findFirst: {
            args: Prisma.StoreTaxRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreTaxRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreTaxRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreTaxRulePayload>
          }
          findMany: {
            args: Prisma.StoreTaxRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreTaxRulePayload>[]
          }
          create: {
            args: Prisma.StoreTaxRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreTaxRulePayload>
          }
          createMany: {
            args: Prisma.StoreTaxRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreTaxRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreTaxRulePayload>[]
          }
          delete: {
            args: Prisma.StoreTaxRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreTaxRulePayload>
          }
          update: {
            args: Prisma.StoreTaxRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreTaxRulePayload>
          }
          deleteMany: {
            args: Prisma.StoreTaxRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreTaxRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreTaxRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreTaxRulePayload>
          }
          aggregate: {
            args: Prisma.StoreTaxRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreTaxRule>
          }
          groupBy: {
            args: Prisma.StoreTaxRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreTaxRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreTaxRuleCountArgs<ExtArgs>
            result: $Utils.Optional<StoreTaxRuleCountAggregateOutputType> | number
          }
        }
      }
      StorePaymentConfig: {
        payload: Prisma.$StorePaymentConfigPayload<ExtArgs>
        fields: Prisma.StorePaymentConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StorePaymentConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePaymentConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StorePaymentConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePaymentConfigPayload>
          }
          findFirst: {
            args: Prisma.StorePaymentConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePaymentConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StorePaymentConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePaymentConfigPayload>
          }
          findMany: {
            args: Prisma.StorePaymentConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePaymentConfigPayload>[]
          }
          create: {
            args: Prisma.StorePaymentConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePaymentConfigPayload>
          }
          createMany: {
            args: Prisma.StorePaymentConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StorePaymentConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePaymentConfigPayload>[]
          }
          delete: {
            args: Prisma.StorePaymentConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePaymentConfigPayload>
          }
          update: {
            args: Prisma.StorePaymentConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePaymentConfigPayload>
          }
          deleteMany: {
            args: Prisma.StorePaymentConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StorePaymentConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StorePaymentConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePaymentConfigPayload>
          }
          aggregate: {
            args: Prisma.StorePaymentConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStorePaymentConfig>
          }
          groupBy: {
            args: Prisma.StorePaymentConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<StorePaymentConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.StorePaymentConfigCountArgs<ExtArgs>
            result: $Utils.Optional<StorePaymentConfigCountAggregateOutputType> | number
          }
        }
      }
      StoreReceiptConfig: {
        payload: Prisma.$StoreReceiptConfigPayload<ExtArgs>
        fields: Prisma.StoreReceiptConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreReceiptConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreReceiptConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreReceiptConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreReceiptConfigPayload>
          }
          findFirst: {
            args: Prisma.StoreReceiptConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreReceiptConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreReceiptConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreReceiptConfigPayload>
          }
          findMany: {
            args: Prisma.StoreReceiptConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreReceiptConfigPayload>[]
          }
          create: {
            args: Prisma.StoreReceiptConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreReceiptConfigPayload>
          }
          createMany: {
            args: Prisma.StoreReceiptConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreReceiptConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreReceiptConfigPayload>[]
          }
          delete: {
            args: Prisma.StoreReceiptConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreReceiptConfigPayload>
          }
          update: {
            args: Prisma.StoreReceiptConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreReceiptConfigPayload>
          }
          deleteMany: {
            args: Prisma.StoreReceiptConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreReceiptConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreReceiptConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreReceiptConfigPayload>
          }
          aggregate: {
            args: Prisma.StoreReceiptConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreReceiptConfig>
          }
          groupBy: {
            args: Prisma.StoreReceiptConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreReceiptConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreReceiptConfigCountArgs<ExtArgs>
            result: $Utils.Optional<StoreReceiptConfigCountAggregateOutputType> | number
          }
        }
      }
      StoreDeviceConfig: {
        payload: Prisma.$StoreDeviceConfigPayload<ExtArgs>
        fields: Prisma.StoreDeviceConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreDeviceConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreDeviceConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreDeviceConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreDeviceConfigPayload>
          }
          findFirst: {
            args: Prisma.StoreDeviceConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreDeviceConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreDeviceConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreDeviceConfigPayload>
          }
          findMany: {
            args: Prisma.StoreDeviceConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreDeviceConfigPayload>[]
          }
          create: {
            args: Prisma.StoreDeviceConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreDeviceConfigPayload>
          }
          createMany: {
            args: Prisma.StoreDeviceConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreDeviceConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreDeviceConfigPayload>[]
          }
          delete: {
            args: Prisma.StoreDeviceConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreDeviceConfigPayload>
          }
          update: {
            args: Prisma.StoreDeviceConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreDeviceConfigPayload>
          }
          deleteMany: {
            args: Prisma.StoreDeviceConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreDeviceConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreDeviceConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreDeviceConfigPayload>
          }
          aggregate: {
            args: Prisma.StoreDeviceConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreDeviceConfig>
          }
          groupBy: {
            args: Prisma.StoreDeviceConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreDeviceConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreDeviceConfigCountArgs<ExtArgs>
            result: $Utils.Optional<StoreDeviceConfigCountAggregateOutputType> | number
          }
        }
      }
      StoreIntegration: {
        payload: Prisma.$StoreIntegrationPayload<ExtArgs>
        fields: Prisma.StoreIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreIntegrationPayload>
          }
          findFirst: {
            args: Prisma.StoreIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreIntegrationPayload>
          }
          findMany: {
            args: Prisma.StoreIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreIntegrationPayload>[]
          }
          create: {
            args: Prisma.StoreIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreIntegrationPayload>
          }
          createMany: {
            args: Prisma.StoreIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreIntegrationPayload>[]
          }
          delete: {
            args: Prisma.StoreIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreIntegrationPayload>
          }
          update: {
            args: Prisma.StoreIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.StoreIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreIntegrationPayload>
          }
          aggregate: {
            args: Prisma.StoreIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreIntegration>
          }
          groupBy: {
            args: Prisma.StoreIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<StoreIntegrationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    users: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | OrganizationCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type StoreCountOutputType
   */

  export type StoreCountOutputType = {
    employees: number
    products: number
    categories: number
    sales: number
    purchases: number
    suppliers: number
    customers: number
    stockMovements: number
    taxRules: number
    transferOrdersOut: number
    transferOrdersIn: number
    paymentMethods: number
    devices: number
    integrations: number
  }

  export type StoreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | StoreCountOutputTypeCountEmployeesArgs
    products?: boolean | StoreCountOutputTypeCountProductsArgs
    categories?: boolean | StoreCountOutputTypeCountCategoriesArgs
    sales?: boolean | StoreCountOutputTypeCountSalesArgs
    purchases?: boolean | StoreCountOutputTypeCountPurchasesArgs
    suppliers?: boolean | StoreCountOutputTypeCountSuppliersArgs
    customers?: boolean | StoreCountOutputTypeCountCustomersArgs
    stockMovements?: boolean | StoreCountOutputTypeCountStockMovementsArgs
    taxRules?: boolean | StoreCountOutputTypeCountTaxRulesArgs
    transferOrdersOut?: boolean | StoreCountOutputTypeCountTransferOrdersOutArgs
    transferOrdersIn?: boolean | StoreCountOutputTypeCountTransferOrdersInArgs
    paymentMethods?: boolean | StoreCountOutputTypeCountPaymentMethodsArgs
    devices?: boolean | StoreCountOutputTypeCountDevicesArgs
    integrations?: boolean | StoreCountOutputTypeCountIntegrationsArgs
  }

  // Custom InputTypes
  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCountOutputType
     */
    select?: StoreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreEmployeeWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreProductWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorePurchaseOrderWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreSupplierWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreCustomerWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountStockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountTaxRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreTaxRuleWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountTransferOrdersOutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferOrderWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountTransferOrdersInArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferOrderWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountPaymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorePaymentConfigWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreDeviceConfigWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreIntegrationWhereInput
  }


  /**
   * Count Type StoreEmployeeCountOutputType
   */

  export type StoreEmployeeCountOutputType = {
    sales: number
  }

  export type StoreEmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | StoreEmployeeCountOutputTypeCountSalesArgs
  }

  // Custom InputTypes
  /**
   * StoreEmployeeCountOutputType without action
   */
  export type StoreEmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreEmployeeCountOutputType
     */
    select?: StoreEmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoreEmployeeCountOutputType without action
   */
  export type StoreEmployeeCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }


  /**
   * Count Type ProductCategoryCountOutputType
   */

  export type ProductCategoryCountOutputType = {
    children: number
    products: number
  }

  export type ProductCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ProductCategoryCountOutputTypeCountChildrenArgs
    products?: boolean | ProductCategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategoryCountOutputType
     */
    select?: ProductCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreProductWhereInput
  }


  /**
   * Count Type StoreProductCountOutputType
   */

  export type StoreProductCountOutputType = {
    saleItems: number
    saleReturnItems: number
    purchaseItems: number
    stockMovements: number
    priceHistory: number
    transferOrderItems: number
  }

  export type StoreProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saleItems?: boolean | StoreProductCountOutputTypeCountSaleItemsArgs
    saleReturnItems?: boolean | StoreProductCountOutputTypeCountSaleReturnItemsArgs
    purchaseItems?: boolean | StoreProductCountOutputTypeCountPurchaseItemsArgs
    stockMovements?: boolean | StoreProductCountOutputTypeCountStockMovementsArgs
    priceHistory?: boolean | StoreProductCountOutputTypeCountPriceHistoryArgs
    transferOrderItems?: boolean | StoreProductCountOutputTypeCountTransferOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * StoreProductCountOutputType without action
   */
  export type StoreProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProductCountOutputType
     */
    select?: StoreProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoreProductCountOutputType without action
   */
  export type StoreProductCountOutputTypeCountSaleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleItemWhereInput
  }

  /**
   * StoreProductCountOutputType without action
   */
  export type StoreProductCountOutputTypeCountSaleReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleReturnItemWhereInput
  }

  /**
   * StoreProductCountOutputType without action
   */
  export type StoreProductCountOutputTypeCountPurchaseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorePurchaseItemWhereInput
  }

  /**
   * StoreProductCountOutputType without action
   */
  export type StoreProductCountOutputTypeCountStockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
  }

  /**
   * StoreProductCountOutputType without action
   */
  export type StoreProductCountOutputTypeCountPriceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorePriceHistoryWhereInput
  }

  /**
   * StoreProductCountOutputType without action
   */
  export type StoreProductCountOutputTypeCountTransferOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferOrderItemWhereInput
  }


  /**
   * Count Type SaleCountOutputType
   */

  export type SaleCountOutputType = {
    items: number
    payments: number
    returns: number
  }

  export type SaleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | SaleCountOutputTypeCountItemsArgs
    payments?: boolean | SaleCountOutputTypeCountPaymentsArgs
    returns?: boolean | SaleCountOutputTypeCountReturnsArgs
  }

  // Custom InputTypes
  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleCountOutputType
     */
    select?: SaleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleItemWhereInput
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalePaymentWhereInput
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountReturnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleReturnWhereInput
  }


  /**
   * Count Type SaleReturnCountOutputType
   */

  export type SaleReturnCountOutputType = {
    items: number
  }

  export type SaleReturnCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | SaleReturnCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * SaleReturnCountOutputType without action
   */
  export type SaleReturnCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturnCountOutputType
     */
    select?: SaleReturnCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SaleReturnCountOutputType without action
   */
  export type SaleReturnCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleReturnItemWhereInput
  }


  /**
   * Count Type StoreSupplierCountOutputType
   */

  export type StoreSupplierCountOutputType = {
    purchaseOrders: number
  }

  export type StoreSupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrders?: boolean | StoreSupplierCountOutputTypeCountPurchaseOrdersArgs
  }

  // Custom InputTypes
  /**
   * StoreSupplierCountOutputType without action
   */
  export type StoreSupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreSupplierCountOutputType
     */
    select?: StoreSupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoreSupplierCountOutputType without action
   */
  export type StoreSupplierCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorePurchaseOrderWhereInput
  }


  /**
   * Count Type StorePurchaseOrderCountOutputType
   */

  export type StorePurchaseOrderCountOutputType = {
    items: number
  }

  export type StorePurchaseOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | StorePurchaseOrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * StorePurchaseOrderCountOutputType without action
   */
  export type StorePurchaseOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseOrderCountOutputType
     */
    select?: StorePurchaseOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StorePurchaseOrderCountOutputType without action
   */
  export type StorePurchaseOrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorePurchaseItemWhereInput
  }


  /**
   * Count Type TransferOrderCountOutputType
   */

  export type TransferOrderCountOutputType = {
    items: number
  }

  export type TransferOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | TransferOrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * TransferOrderCountOutputType without action
   */
  export type TransferOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderCountOutputType
     */
    select?: TransferOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransferOrderCountOutputType without action
   */
  export type TransferOrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferOrderItemWhereInput
  }


  /**
   * Count Type StoreCustomerCountOutputType
   */

  export type StoreCustomerCountOutputType = {
    sales: number
    loyaltyTransactions: number
  }

  export type StoreCustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | StoreCustomerCountOutputTypeCountSalesArgs
    loyaltyTransactions?: boolean | StoreCustomerCountOutputTypeCountLoyaltyTransactionsArgs
  }

  // Custom InputTypes
  /**
   * StoreCustomerCountOutputType without action
   */
  export type StoreCustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCustomerCountOutputType
     */
    select?: StoreCustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoreCustomerCountOutputType without action
   */
  export type StoreCustomerCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }

  /**
   * StoreCustomerCountOutputType without action
   */
  export type StoreCustomerCountOutputTypeCountLoyaltyTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreLoyaltyTransactionWhereInput
  }


  /**
   * Count Type StoreTaxRuleCountOutputType
   */

  export type StoreTaxRuleCountOutputType = {
    products: number
  }

  export type StoreTaxRuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | StoreTaxRuleCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * StoreTaxRuleCountOutputType without action
   */
  export type StoreTaxRuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreTaxRuleCountOutputType
     */
    select?: StoreTaxRuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoreTaxRuleCountOutputType without action
   */
  export type StoreTaxRuleCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreProductWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    email: string | null
    phone: string | null
    address: string | null
    logo: string | null
    company: string | null
    taxId: string | null
    city: string | null
    country: string | null
    website: string | null
    bankName: string | null
    bankAccount: string | null
    tenantId: string | null
    hotelCode: string | null
    storeCode: string | null
    databaseUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    email: string | null
    phone: string | null
    address: string | null
    logo: string | null
    company: string | null
    taxId: string | null
    city: string | null
    country: string | null
    website: string | null
    bankName: string | null
    bankAccount: string | null
    tenantId: string | null
    hotelCode: string | null
    storeCode: string | null
    databaseUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    email: number
    phone: number
    address: number
    logo: number
    company: number
    taxId: number
    city: number
    country: number
    website: number
    bankName: number
    bankAccount: number
    tenantId: number
    hotelCode: number
    storeCode: number
    databaseUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    email?: true
    phone?: true
    address?: true
    logo?: true
    company?: true
    taxId?: true
    city?: true
    country?: true
    website?: true
    bankName?: true
    bankAccount?: true
    tenantId?: true
    hotelCode?: true
    storeCode?: true
    databaseUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    email?: true
    phone?: true
    address?: true
    logo?: true
    company?: true
    taxId?: true
    city?: true
    country?: true
    website?: true
    bankName?: true
    bankAccount?: true
    tenantId?: true
    hotelCode?: true
    storeCode?: true
    databaseUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    email?: true
    phone?: true
    address?: true
    logo?: true
    company?: true
    taxId?: true
    city?: true
    country?: true
    website?: true
    bankName?: true
    bankAccount?: true
    tenantId?: true
    hotelCode?: true
    storeCode?: true
    databaseUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    slug: string
    email: string
    phone: string | null
    address: string | null
    logo: string | null
    company: string | null
    taxId: string | null
    city: string | null
    country: string | null
    website: string | null
    bankName: string | null
    bankAccount: string | null
    tenantId: string
    hotelCode: string
    storeCode: string | null
    databaseUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    logo?: boolean
    company?: boolean
    taxId?: boolean
    city?: boolean
    country?: boolean
    website?: boolean
    bankName?: boolean
    bankAccount?: boolean
    tenantId?: boolean
    hotelCode?: boolean
    storeCode?: boolean
    databaseUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Organization$usersArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    logo?: boolean
    company?: boolean
    taxId?: boolean
    city?: boolean
    country?: boolean
    website?: boolean
    bankName?: boolean
    bankAccount?: boolean
    tenantId?: boolean
    hotelCode?: boolean
    storeCode?: boolean
    databaseUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    logo?: boolean
    company?: boolean
    taxId?: boolean
    city?: boolean
    country?: boolean
    website?: boolean
    bankName?: boolean
    bankAccount?: boolean
    tenantId?: boolean
    hotelCode?: boolean
    storeCode?: boolean
    databaseUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Organization$usersArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      email: string
      phone: string | null
      address: string | null
      logo: string | null
      company: string | null
      taxId: string | null
      city: string | null
      country: string | null
      website: string | null
      bankName: string | null
      bankAccount: string | null
      tenantId: string
      hotelCode: string
      storeCode: string | null
      databaseUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Organization$usersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */ 
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly slug: FieldRef<"Organization", 'String'>
    readonly email: FieldRef<"Organization", 'String'>
    readonly phone: FieldRef<"Organization", 'String'>
    readonly address: FieldRef<"Organization", 'String'>
    readonly logo: FieldRef<"Organization", 'String'>
    readonly company: FieldRef<"Organization", 'String'>
    readonly taxId: FieldRef<"Organization", 'String'>
    readonly city: FieldRef<"Organization", 'String'>
    readonly country: FieldRef<"Organization", 'String'>
    readonly website: FieldRef<"Organization", 'String'>
    readonly bankName: FieldRef<"Organization", 'String'>
    readonly bankAccount: FieldRef<"Organization", 'String'>
    readonly tenantId: FieldRef<"Organization", 'String'>
    readonly hotelCode: FieldRef<"Organization", 'String'>
    readonly storeCode: FieldRef<"Organization", 'String'>
    readonly databaseUrl: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization.users
   */
  export type Organization$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    avatar: string | null
    emailVerified: Date | null
    lastLoginAt: Date | null
    organizationId: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    avatar: string | null
    emailVerified: Date | null
    lastLoginAt: Date | null
    organizationId: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    avatar: number
    emailVerified: number
    lastLoginAt: number
    organizationId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    avatar?: true
    emailVerified?: true
    lastLoginAt?: true
    organizationId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    avatar?: true
    emailVerified?: true
    lastLoginAt?: true
    organizationId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    avatar?: true
    emailVerified?: true
    lastLoginAt?: true
    organizationId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    password: string
    avatar: string | null
    emailVerified: Date | null
    lastLoginAt: Date | null
    organizationId: string | null
    role: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    avatar?: boolean
    emailVerified?: boolean
    lastLoginAt?: boolean
    organizationId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | User$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    avatar?: boolean
    emailVerified?: boolean
    lastLoginAt?: boolean
    organizationId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | User$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    avatar?: boolean
    emailVerified?: boolean
    lastLoginAt?: boolean
    organizationId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | User$organizationArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | User$organizationArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      password: string
      avatar: string | null
      emailVerified: Date | null
      lastLoginAt: Date | null
      organizationId: string | null
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends User$organizationArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly organizationId: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.organization
   */
  export type User$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Store
   */

  export type AggregateStore = {
    _count: StoreCountAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  export type StoreMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    slug: string | null
    address: string | null
    phone: string | null
    email: string | null
    taxId: string | null
    currency: string | null
    timezone: string | null
    logoUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    slug: string | null
    address: string | null
    phone: string | null
    email: string | null
    taxId: string | null
    currency: string | null
    timezone: string | null
    logoUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    slug: number
    address: number
    phone: number
    email: number
    taxId: number
    currency: number
    timezone: number
    logoUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoreMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    slug?: true
    address?: true
    phone?: true
    email?: true
    taxId?: true
    currency?: true
    timezone?: true
    logoUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    slug?: true
    address?: true
    phone?: true
    email?: true
    taxId?: true
    currency?: true
    timezone?: true
    logoUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    slug?: true
    address?: true
    phone?: true
    email?: true
    taxId?: true
    currency?: true
    timezone?: true
    logoUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Store to aggregate.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stores
    **/
    _count?: true | StoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreMaxAggregateInputType
  }

  export type GetStoreAggregateType<T extends StoreAggregateArgs> = {
        [P in keyof T & keyof AggregateStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore[P]>
      : GetScalarType<T[P], AggregateStore[P]>
  }




  export type StoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreWhereInput
    orderBy?: StoreOrderByWithAggregationInput | StoreOrderByWithAggregationInput[]
    by: StoreScalarFieldEnum[] | StoreScalarFieldEnum
    having?: StoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreCountAggregateInputType | true
    _min?: StoreMinAggregateInputType
    _max?: StoreMaxAggregateInputType
  }

  export type StoreGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    slug: string
    address: string | null
    phone: string | null
    email: string | null
    taxId: string | null
    currency: string
    timezone: string
    logoUrl: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StoreCountAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  type GetStoreGroupByPayload<T extends StoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreGroupByOutputType[P]>
            : GetScalarType<T[P], StoreGroupByOutputType[P]>
        }
      >
    >


  export type StoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    slug?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    taxId?: boolean
    currency?: boolean
    timezone?: boolean
    logoUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employees?: boolean | Store$employeesArgs<ExtArgs>
    products?: boolean | Store$productsArgs<ExtArgs>
    categories?: boolean | Store$categoriesArgs<ExtArgs>
    sales?: boolean | Store$salesArgs<ExtArgs>
    purchases?: boolean | Store$purchasesArgs<ExtArgs>
    suppliers?: boolean | Store$suppliersArgs<ExtArgs>
    customers?: boolean | Store$customersArgs<ExtArgs>
    stockMovements?: boolean | Store$stockMovementsArgs<ExtArgs>
    taxRules?: boolean | Store$taxRulesArgs<ExtArgs>
    loyaltyConfig?: boolean | Store$loyaltyConfigArgs<ExtArgs>
    transferOrdersOut?: boolean | Store$transferOrdersOutArgs<ExtArgs>
    transferOrdersIn?: boolean | Store$transferOrdersInArgs<ExtArgs>
    paymentMethods?: boolean | Store$paymentMethodsArgs<ExtArgs>
    receiptConfig?: boolean | Store$receiptConfigArgs<ExtArgs>
    devices?: boolean | Store$devicesArgs<ExtArgs>
    integrations?: boolean | Store$integrationsArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type StoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    slug?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    taxId?: boolean
    currency?: boolean
    timezone?: boolean
    logoUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["store"]>

  export type StoreSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    slug?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    taxId?: boolean
    currency?: boolean
    timezone?: boolean
    logoUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | Store$employeesArgs<ExtArgs>
    products?: boolean | Store$productsArgs<ExtArgs>
    categories?: boolean | Store$categoriesArgs<ExtArgs>
    sales?: boolean | Store$salesArgs<ExtArgs>
    purchases?: boolean | Store$purchasesArgs<ExtArgs>
    suppliers?: boolean | Store$suppliersArgs<ExtArgs>
    customers?: boolean | Store$customersArgs<ExtArgs>
    stockMovements?: boolean | Store$stockMovementsArgs<ExtArgs>
    taxRules?: boolean | Store$taxRulesArgs<ExtArgs>
    loyaltyConfig?: boolean | Store$loyaltyConfigArgs<ExtArgs>
    transferOrdersOut?: boolean | Store$transferOrdersOutArgs<ExtArgs>
    transferOrdersIn?: boolean | Store$transferOrdersInArgs<ExtArgs>
    paymentMethods?: boolean | Store$paymentMethodsArgs<ExtArgs>
    receiptConfig?: boolean | Store$receiptConfigArgs<ExtArgs>
    devices?: boolean | Store$devicesArgs<ExtArgs>
    integrations?: boolean | Store$integrationsArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Store"
    objects: {
      employees: Prisma.$StoreEmployeePayload<ExtArgs>[]
      products: Prisma.$StoreProductPayload<ExtArgs>[]
      categories: Prisma.$ProductCategoryPayload<ExtArgs>[]
      sales: Prisma.$SalePayload<ExtArgs>[]
      purchases: Prisma.$StorePurchaseOrderPayload<ExtArgs>[]
      suppliers: Prisma.$StoreSupplierPayload<ExtArgs>[]
      customers: Prisma.$StoreCustomerPayload<ExtArgs>[]
      stockMovements: Prisma.$StockMovementPayload<ExtArgs>[]
      taxRules: Prisma.$StoreTaxRulePayload<ExtArgs>[]
      loyaltyConfig: Prisma.$StoreLoyaltyConfigPayload<ExtArgs> | null
      transferOrdersOut: Prisma.$TransferOrderPayload<ExtArgs>[]
      transferOrdersIn: Prisma.$TransferOrderPayload<ExtArgs>[]
      paymentMethods: Prisma.$StorePaymentConfigPayload<ExtArgs>[]
      receiptConfig: Prisma.$StoreReceiptConfigPayload<ExtArgs> | null
      devices: Prisma.$StoreDeviceConfigPayload<ExtArgs>[]
      integrations: Prisma.$StoreIntegrationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      slug: string
      address: string | null
      phone: string | null
      email: string | null
      taxId: string | null
      currency: string
      timezone: string
      logoUrl: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["store"]>
    composites: {}
  }

  type StoreGetPayload<S extends boolean | null | undefined | StoreDefaultArgs> = $Result.GetResult<Prisma.$StorePayload, S>

  type StoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoreCountAggregateInputType | true
    }

  export interface StoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Store'], meta: { name: 'Store' } }
    /**
     * Find zero or one Store that matches the filter.
     * @param {StoreFindUniqueArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreFindUniqueArgs>(args: SelectSubset<T, StoreFindUniqueArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Store that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoreFindUniqueOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Store that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreFindFirstArgs>(args?: SelectSubset<T, StoreFindFirstArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Store that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.store.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.store.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeWithIdOnly = await prisma.store.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreFindManyArgs>(args?: SelectSubset<T, StoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Store.
     * @param {StoreCreateArgs} args - Arguments to create a Store.
     * @example
     * // Create one Store
     * const Store = await prisma.store.create({
     *   data: {
     *     // ... data to create a Store
     *   }
     * })
     * 
     */
    create<T extends StoreCreateArgs>(args: SelectSubset<T, StoreCreateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Stores.
     * @param {StoreCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreCreateManyArgs>(args?: SelectSubset<T, StoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stores and returns the data saved in the database.
     * @param {StoreCreateManyAndReturnArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stores and only return the `id`
     * const storeWithIdOnly = await prisma.store.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Store.
     * @param {StoreDeleteArgs} args - Arguments to delete one Store.
     * @example
     * // Delete one Store
     * const Store = await prisma.store.delete({
     *   where: {
     *     // ... filter to delete one Store
     *   }
     * })
     * 
     */
    delete<T extends StoreDeleteArgs>(args: SelectSubset<T, StoreDeleteArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Store.
     * @param {StoreUpdateArgs} args - Arguments to update one Store.
     * @example
     * // Update one Store
     * const store = await prisma.store.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreUpdateArgs>(args: SelectSubset<T, StoreUpdateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Stores.
     * @param {StoreDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.store.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreDeleteManyArgs>(args?: SelectSubset<T, StoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreUpdateManyArgs>(args: SelectSubset<T, StoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Store.
     * @param {StoreUpsertArgs} args - Arguments to update or create a Store.
     * @example
     * // Update or create a Store
     * const store = await prisma.store.upsert({
     *   create: {
     *     // ... data to create a Store
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store we want to update
     *   }
     * })
     */
    upsert<T extends StoreUpsertArgs>(args: SelectSubset<T, StoreUpsertArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.store.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends StoreCountArgs>(
      args?: Subset<T, StoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreAggregateArgs>(args: Subset<T, StoreAggregateArgs>): Prisma.PrismaPromise<GetStoreAggregateType<T>>

    /**
     * Group by Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreGroupByArgs['orderBy'] }
        : { orderBy?: StoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Store model
   */
  readonly fields: StoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Store.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends Store$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Store$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreEmployeePayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends Store$productsArgs<ExtArgs> = {}>(args?: Subset<T, Store$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "findMany"> | Null>
    categories<T extends Store$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Store$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    sales<T extends Store$salesArgs<ExtArgs> = {}>(args?: Subset<T, Store$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany"> | Null>
    purchases<T extends Store$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Store$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePurchaseOrderPayload<ExtArgs>, T, "findMany"> | Null>
    suppliers<T extends Store$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, Store$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreSupplierPayload<ExtArgs>, T, "findMany"> | Null>
    customers<T extends Store$customersArgs<ExtArgs> = {}>(args?: Subset<T, Store$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreCustomerPayload<ExtArgs>, T, "findMany"> | Null>
    stockMovements<T extends Store$stockMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Store$stockMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany"> | Null>
    taxRules<T extends Store$taxRulesArgs<ExtArgs> = {}>(args?: Subset<T, Store$taxRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreTaxRulePayload<ExtArgs>, T, "findMany"> | Null>
    loyaltyConfig<T extends Store$loyaltyConfigArgs<ExtArgs> = {}>(args?: Subset<T, Store$loyaltyConfigArgs<ExtArgs>>): Prisma__StoreLoyaltyConfigClient<$Result.GetResult<Prisma.$StoreLoyaltyConfigPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    transferOrdersOut<T extends Store$transferOrdersOutArgs<ExtArgs> = {}>(args?: Subset<T, Store$transferOrdersOutArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "findMany"> | Null>
    transferOrdersIn<T extends Store$transferOrdersInArgs<ExtArgs> = {}>(args?: Subset<T, Store$transferOrdersInArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "findMany"> | Null>
    paymentMethods<T extends Store$paymentMethodsArgs<ExtArgs> = {}>(args?: Subset<T, Store$paymentMethodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePaymentConfigPayload<ExtArgs>, T, "findMany"> | Null>
    receiptConfig<T extends Store$receiptConfigArgs<ExtArgs> = {}>(args?: Subset<T, Store$receiptConfigArgs<ExtArgs>>): Prisma__StoreReceiptConfigClient<$Result.GetResult<Prisma.$StoreReceiptConfigPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    devices<T extends Store$devicesArgs<ExtArgs> = {}>(args?: Subset<T, Store$devicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreDeviceConfigPayload<ExtArgs>, T, "findMany"> | Null>
    integrations<T extends Store$integrationsArgs<ExtArgs> = {}>(args?: Subset<T, Store$integrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreIntegrationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Store model
   */ 
  interface StoreFieldRefs {
    readonly id: FieldRef<"Store", 'String'>
    readonly tenantId: FieldRef<"Store", 'String'>
    readonly name: FieldRef<"Store", 'String'>
    readonly slug: FieldRef<"Store", 'String'>
    readonly address: FieldRef<"Store", 'String'>
    readonly phone: FieldRef<"Store", 'String'>
    readonly email: FieldRef<"Store", 'String'>
    readonly taxId: FieldRef<"Store", 'String'>
    readonly currency: FieldRef<"Store", 'String'>
    readonly timezone: FieldRef<"Store", 'String'>
    readonly logoUrl: FieldRef<"Store", 'String'>
    readonly isActive: FieldRef<"Store", 'Boolean'>
    readonly createdAt: FieldRef<"Store", 'DateTime'>
    readonly updatedAt: FieldRef<"Store", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Store findUnique
   */
  export type StoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findUniqueOrThrow
   */
  export type StoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findFirst
   */
  export type StoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findFirstOrThrow
   */
  export type StoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findMany
   */
  export type StoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store create
   */
  export type StoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to create a Store.
     */
    data: XOR<StoreCreateInput, StoreUncheckedCreateInput>
  }

  /**
   * Store createMany
   */
  export type StoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Store createManyAndReturn
   */
  export type StoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Store update
   */
  export type StoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to update a Store.
     */
    data: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
    /**
     * Choose, which Store to update.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store updateMany
   */
  export type StoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
  }

  /**
   * Store upsert
   */
  export type StoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The filter to search for the Store to update in case it exists.
     */
    where: StoreWhereUniqueInput
    /**
     * In case the Store found by the `where` argument doesn't exist, create a new Store with this data.
     */
    create: XOR<StoreCreateInput, StoreUncheckedCreateInput>
    /**
     * In case the Store was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
  }

  /**
   * Store delete
   */
  export type StoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter which Store to delete.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store deleteMany
   */
  export type StoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to delete
     */
    where?: StoreWhereInput
  }

  /**
   * Store.employees
   */
  export type Store$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreEmployee
     */
    select?: StoreEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreEmployeeInclude<ExtArgs> | null
    where?: StoreEmployeeWhereInput
    orderBy?: StoreEmployeeOrderByWithRelationInput | StoreEmployeeOrderByWithRelationInput[]
    cursor?: StoreEmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreEmployeeScalarFieldEnum | StoreEmployeeScalarFieldEnum[]
  }

  /**
   * Store.products
   */
  export type Store$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreProductInclude<ExtArgs> | null
    where?: StoreProductWhereInput
    orderBy?: StoreProductOrderByWithRelationInput | StoreProductOrderByWithRelationInput[]
    cursor?: StoreProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreProductScalarFieldEnum | StoreProductScalarFieldEnum[]
  }

  /**
   * Store.categories
   */
  export type Store$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * Store.sales
   */
  export type Store$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Store.purchases
   */
  export type Store$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseOrder
     */
    select?: StorePurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseOrderInclude<ExtArgs> | null
    where?: StorePurchaseOrderWhereInput
    orderBy?: StorePurchaseOrderOrderByWithRelationInput | StorePurchaseOrderOrderByWithRelationInput[]
    cursor?: StorePurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorePurchaseOrderScalarFieldEnum | StorePurchaseOrderScalarFieldEnum[]
  }

  /**
   * Store.suppliers
   */
  export type Store$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreSupplier
     */
    select?: StoreSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreSupplierInclude<ExtArgs> | null
    where?: StoreSupplierWhereInput
    orderBy?: StoreSupplierOrderByWithRelationInput | StoreSupplierOrderByWithRelationInput[]
    cursor?: StoreSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreSupplierScalarFieldEnum | StoreSupplierScalarFieldEnum[]
  }

  /**
   * Store.customers
   */
  export type Store$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCustomer
     */
    select?: StoreCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreCustomerInclude<ExtArgs> | null
    where?: StoreCustomerWhereInput
    orderBy?: StoreCustomerOrderByWithRelationInput | StoreCustomerOrderByWithRelationInput[]
    cursor?: StoreCustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreCustomerScalarFieldEnum | StoreCustomerScalarFieldEnum[]
  }

  /**
   * Store.stockMovements
   */
  export type Store$stockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    cursor?: StockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * Store.taxRules
   */
  export type Store$taxRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreTaxRule
     */
    select?: StoreTaxRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreTaxRuleInclude<ExtArgs> | null
    where?: StoreTaxRuleWhereInput
    orderBy?: StoreTaxRuleOrderByWithRelationInput | StoreTaxRuleOrderByWithRelationInput[]
    cursor?: StoreTaxRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreTaxRuleScalarFieldEnum | StoreTaxRuleScalarFieldEnum[]
  }

  /**
   * Store.loyaltyConfig
   */
  export type Store$loyaltyConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyConfig
     */
    select?: StoreLoyaltyConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyConfigInclude<ExtArgs> | null
    where?: StoreLoyaltyConfigWhereInput
  }

  /**
   * Store.transferOrdersOut
   */
  export type Store$transferOrdersOutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    where?: TransferOrderWhereInput
    orderBy?: TransferOrderOrderByWithRelationInput | TransferOrderOrderByWithRelationInput[]
    cursor?: TransferOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferOrderScalarFieldEnum | TransferOrderScalarFieldEnum[]
  }

  /**
   * Store.transferOrdersIn
   */
  export type Store$transferOrdersInArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    where?: TransferOrderWhereInput
    orderBy?: TransferOrderOrderByWithRelationInput | TransferOrderOrderByWithRelationInput[]
    cursor?: TransferOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferOrderScalarFieldEnum | TransferOrderScalarFieldEnum[]
  }

  /**
   * Store.paymentMethods
   */
  export type Store$paymentMethodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePaymentConfig
     */
    select?: StorePaymentConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePaymentConfigInclude<ExtArgs> | null
    where?: StorePaymentConfigWhereInput
    orderBy?: StorePaymentConfigOrderByWithRelationInput | StorePaymentConfigOrderByWithRelationInput[]
    cursor?: StorePaymentConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorePaymentConfigScalarFieldEnum | StorePaymentConfigScalarFieldEnum[]
  }

  /**
   * Store.receiptConfig
   */
  export type Store$receiptConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreReceiptConfig
     */
    select?: StoreReceiptConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreReceiptConfigInclude<ExtArgs> | null
    where?: StoreReceiptConfigWhereInput
  }

  /**
   * Store.devices
   */
  export type Store$devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreDeviceConfig
     */
    select?: StoreDeviceConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreDeviceConfigInclude<ExtArgs> | null
    where?: StoreDeviceConfigWhereInput
    orderBy?: StoreDeviceConfigOrderByWithRelationInput | StoreDeviceConfigOrderByWithRelationInput[]
    cursor?: StoreDeviceConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreDeviceConfigScalarFieldEnum | StoreDeviceConfigScalarFieldEnum[]
  }

  /**
   * Store.integrations
   */
  export type Store$integrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreIntegration
     */
    select?: StoreIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreIntegrationInclude<ExtArgs> | null
    where?: StoreIntegrationWhereInput
    orderBy?: StoreIntegrationOrderByWithRelationInput | StoreIntegrationOrderByWithRelationInput[]
    cursor?: StoreIntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreIntegrationScalarFieldEnum | StoreIntegrationScalarFieldEnum[]
  }

  /**
   * Store without action
   */
  export type StoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
  }


  /**
   * Model StoreEmployee
   */

  export type AggregateStoreEmployee = {
    _count: StoreEmployeeCountAggregateOutputType | null
    _min: StoreEmployeeMinAggregateOutputType | null
    _max: StoreEmployeeMaxAggregateOutputType | null
  }

  export type StoreEmployeeMinAggregateOutputType = {
    id: string | null
    storeId: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    role: string | null
    pin: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreEmployeeMaxAggregateOutputType = {
    id: string | null
    storeId: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    role: string | null
    pin: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreEmployeeCountAggregateOutputType = {
    id: number
    storeId: number
    userId: number
    firstName: number
    lastName: number
    phone: number
    email: number
    role: number
    pin: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoreEmployeeMinAggregateInputType = {
    id?: true
    storeId?: true
    userId?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    role?: true
    pin?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreEmployeeMaxAggregateInputType = {
    id?: true
    storeId?: true
    userId?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    role?: true
    pin?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreEmployeeCountAggregateInputType = {
    id?: true
    storeId?: true
    userId?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    role?: true
    pin?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoreEmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreEmployee to aggregate.
     */
    where?: StoreEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreEmployees to fetch.
     */
    orderBy?: StoreEmployeeOrderByWithRelationInput | StoreEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreEmployees
    **/
    _count?: true | StoreEmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreEmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreEmployeeMaxAggregateInputType
  }

  export type GetStoreEmployeeAggregateType<T extends StoreEmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreEmployee[P]>
      : GetScalarType<T[P], AggregateStoreEmployee[P]>
  }




  export type StoreEmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreEmployeeWhereInput
    orderBy?: StoreEmployeeOrderByWithAggregationInput | StoreEmployeeOrderByWithAggregationInput[]
    by: StoreEmployeeScalarFieldEnum[] | StoreEmployeeScalarFieldEnum
    having?: StoreEmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreEmployeeCountAggregateInputType | true
    _min?: StoreEmployeeMinAggregateInputType
    _max?: StoreEmployeeMaxAggregateInputType
  }

  export type StoreEmployeeGroupByOutputType = {
    id: string
    storeId: string
    userId: string | null
    firstName: string
    lastName: string
    phone: string | null
    email: string | null
    role: string
    pin: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StoreEmployeeCountAggregateOutputType | null
    _min: StoreEmployeeMinAggregateOutputType | null
    _max: StoreEmployeeMaxAggregateOutputType | null
  }

  type GetStoreEmployeeGroupByPayload<T extends StoreEmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreEmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreEmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreEmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], StoreEmployeeGroupByOutputType[P]>
        }
      >
    >


  export type StoreEmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    role?: boolean
    pin?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    sales?: boolean | StoreEmployee$salesArgs<ExtArgs>
    _count?: boolean | StoreEmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeEmployee"]>

  export type StoreEmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    role?: boolean
    pin?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeEmployee"]>

  export type StoreEmployeeSelectScalar = {
    id?: boolean
    storeId?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    role?: boolean
    pin?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoreEmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    sales?: boolean | StoreEmployee$salesArgs<ExtArgs>
    _count?: boolean | StoreEmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoreEmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $StoreEmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreEmployee"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      sales: Prisma.$SalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeId: string
      userId: string | null
      firstName: string
      lastName: string
      phone: string | null
      email: string | null
      role: string
      pin: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storeEmployee"]>
    composites: {}
  }

  type StoreEmployeeGetPayload<S extends boolean | null | undefined | StoreEmployeeDefaultArgs> = $Result.GetResult<Prisma.$StoreEmployeePayload, S>

  type StoreEmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoreEmployeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoreEmployeeCountAggregateInputType | true
    }

  export interface StoreEmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreEmployee'], meta: { name: 'StoreEmployee' } }
    /**
     * Find zero or one StoreEmployee that matches the filter.
     * @param {StoreEmployeeFindUniqueArgs} args - Arguments to find a StoreEmployee
     * @example
     * // Get one StoreEmployee
     * const storeEmployee = await prisma.storeEmployee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreEmployeeFindUniqueArgs>(args: SelectSubset<T, StoreEmployeeFindUniqueArgs<ExtArgs>>): Prisma__StoreEmployeeClient<$Result.GetResult<Prisma.$StoreEmployeePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StoreEmployee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoreEmployeeFindUniqueOrThrowArgs} args - Arguments to find a StoreEmployee
     * @example
     * // Get one StoreEmployee
     * const storeEmployee = await prisma.storeEmployee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreEmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreEmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreEmployeeClient<$Result.GetResult<Prisma.$StoreEmployeePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StoreEmployee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreEmployeeFindFirstArgs} args - Arguments to find a StoreEmployee
     * @example
     * // Get one StoreEmployee
     * const storeEmployee = await prisma.storeEmployee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreEmployeeFindFirstArgs>(args?: SelectSubset<T, StoreEmployeeFindFirstArgs<ExtArgs>>): Prisma__StoreEmployeeClient<$Result.GetResult<Prisma.$StoreEmployeePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StoreEmployee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreEmployeeFindFirstOrThrowArgs} args - Arguments to find a StoreEmployee
     * @example
     * // Get one StoreEmployee
     * const storeEmployee = await prisma.storeEmployee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreEmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreEmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreEmployeeClient<$Result.GetResult<Prisma.$StoreEmployeePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StoreEmployees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreEmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreEmployees
     * const storeEmployees = await prisma.storeEmployee.findMany()
     * 
     * // Get first 10 StoreEmployees
     * const storeEmployees = await prisma.storeEmployee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeEmployeeWithIdOnly = await prisma.storeEmployee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreEmployeeFindManyArgs>(args?: SelectSubset<T, StoreEmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreEmployeePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StoreEmployee.
     * @param {StoreEmployeeCreateArgs} args - Arguments to create a StoreEmployee.
     * @example
     * // Create one StoreEmployee
     * const StoreEmployee = await prisma.storeEmployee.create({
     *   data: {
     *     // ... data to create a StoreEmployee
     *   }
     * })
     * 
     */
    create<T extends StoreEmployeeCreateArgs>(args: SelectSubset<T, StoreEmployeeCreateArgs<ExtArgs>>): Prisma__StoreEmployeeClient<$Result.GetResult<Prisma.$StoreEmployeePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StoreEmployees.
     * @param {StoreEmployeeCreateManyArgs} args - Arguments to create many StoreEmployees.
     * @example
     * // Create many StoreEmployees
     * const storeEmployee = await prisma.storeEmployee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreEmployeeCreateManyArgs>(args?: SelectSubset<T, StoreEmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoreEmployees and returns the data saved in the database.
     * @param {StoreEmployeeCreateManyAndReturnArgs} args - Arguments to create many StoreEmployees.
     * @example
     * // Create many StoreEmployees
     * const storeEmployee = await prisma.storeEmployee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoreEmployees and only return the `id`
     * const storeEmployeeWithIdOnly = await prisma.storeEmployee.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreEmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreEmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreEmployeePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StoreEmployee.
     * @param {StoreEmployeeDeleteArgs} args - Arguments to delete one StoreEmployee.
     * @example
     * // Delete one StoreEmployee
     * const StoreEmployee = await prisma.storeEmployee.delete({
     *   where: {
     *     // ... filter to delete one StoreEmployee
     *   }
     * })
     * 
     */
    delete<T extends StoreEmployeeDeleteArgs>(args: SelectSubset<T, StoreEmployeeDeleteArgs<ExtArgs>>): Prisma__StoreEmployeeClient<$Result.GetResult<Prisma.$StoreEmployeePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StoreEmployee.
     * @param {StoreEmployeeUpdateArgs} args - Arguments to update one StoreEmployee.
     * @example
     * // Update one StoreEmployee
     * const storeEmployee = await prisma.storeEmployee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreEmployeeUpdateArgs>(args: SelectSubset<T, StoreEmployeeUpdateArgs<ExtArgs>>): Prisma__StoreEmployeeClient<$Result.GetResult<Prisma.$StoreEmployeePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StoreEmployees.
     * @param {StoreEmployeeDeleteManyArgs} args - Arguments to filter StoreEmployees to delete.
     * @example
     * // Delete a few StoreEmployees
     * const { count } = await prisma.storeEmployee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreEmployeeDeleteManyArgs>(args?: SelectSubset<T, StoreEmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreEmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreEmployees
     * const storeEmployee = await prisma.storeEmployee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreEmployeeUpdateManyArgs>(args: SelectSubset<T, StoreEmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoreEmployee.
     * @param {StoreEmployeeUpsertArgs} args - Arguments to update or create a StoreEmployee.
     * @example
     * // Update or create a StoreEmployee
     * const storeEmployee = await prisma.storeEmployee.upsert({
     *   create: {
     *     // ... data to create a StoreEmployee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreEmployee we want to update
     *   }
     * })
     */
    upsert<T extends StoreEmployeeUpsertArgs>(args: SelectSubset<T, StoreEmployeeUpsertArgs<ExtArgs>>): Prisma__StoreEmployeeClient<$Result.GetResult<Prisma.$StoreEmployeePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StoreEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreEmployeeCountArgs} args - Arguments to filter StoreEmployees to count.
     * @example
     * // Count the number of StoreEmployees
     * const count = await prisma.storeEmployee.count({
     *   where: {
     *     // ... the filter for the StoreEmployees we want to count
     *   }
     * })
    **/
    count<T extends StoreEmployeeCountArgs>(
      args?: Subset<T, StoreEmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreEmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreEmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreEmployeeAggregateArgs>(args: Subset<T, StoreEmployeeAggregateArgs>): Prisma.PrismaPromise<GetStoreEmployeeAggregateType<T>>

    /**
     * Group by StoreEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreEmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreEmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreEmployeeGroupByArgs['orderBy'] }
        : { orderBy?: StoreEmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreEmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreEmployee model
   */
  readonly fields: StoreEmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreEmployee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreEmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sales<T extends StoreEmployee$salesArgs<ExtArgs> = {}>(args?: Subset<T, StoreEmployee$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreEmployee model
   */ 
  interface StoreEmployeeFieldRefs {
    readonly id: FieldRef<"StoreEmployee", 'String'>
    readonly storeId: FieldRef<"StoreEmployee", 'String'>
    readonly userId: FieldRef<"StoreEmployee", 'String'>
    readonly firstName: FieldRef<"StoreEmployee", 'String'>
    readonly lastName: FieldRef<"StoreEmployee", 'String'>
    readonly phone: FieldRef<"StoreEmployee", 'String'>
    readonly email: FieldRef<"StoreEmployee", 'String'>
    readonly role: FieldRef<"StoreEmployee", 'String'>
    readonly pin: FieldRef<"StoreEmployee", 'String'>
    readonly isActive: FieldRef<"StoreEmployee", 'Boolean'>
    readonly createdAt: FieldRef<"StoreEmployee", 'DateTime'>
    readonly updatedAt: FieldRef<"StoreEmployee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoreEmployee findUnique
   */
  export type StoreEmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreEmployee
     */
    select?: StoreEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which StoreEmployee to fetch.
     */
    where: StoreEmployeeWhereUniqueInput
  }

  /**
   * StoreEmployee findUniqueOrThrow
   */
  export type StoreEmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreEmployee
     */
    select?: StoreEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which StoreEmployee to fetch.
     */
    where: StoreEmployeeWhereUniqueInput
  }

  /**
   * StoreEmployee findFirst
   */
  export type StoreEmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreEmployee
     */
    select?: StoreEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which StoreEmployee to fetch.
     */
    where?: StoreEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreEmployees to fetch.
     */
    orderBy?: StoreEmployeeOrderByWithRelationInput | StoreEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreEmployees.
     */
    cursor?: StoreEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreEmployees.
     */
    distinct?: StoreEmployeeScalarFieldEnum | StoreEmployeeScalarFieldEnum[]
  }

  /**
   * StoreEmployee findFirstOrThrow
   */
  export type StoreEmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreEmployee
     */
    select?: StoreEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which StoreEmployee to fetch.
     */
    where?: StoreEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreEmployees to fetch.
     */
    orderBy?: StoreEmployeeOrderByWithRelationInput | StoreEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreEmployees.
     */
    cursor?: StoreEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreEmployees.
     */
    distinct?: StoreEmployeeScalarFieldEnum | StoreEmployeeScalarFieldEnum[]
  }

  /**
   * StoreEmployee findMany
   */
  export type StoreEmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreEmployee
     */
    select?: StoreEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which StoreEmployees to fetch.
     */
    where?: StoreEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreEmployees to fetch.
     */
    orderBy?: StoreEmployeeOrderByWithRelationInput | StoreEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreEmployees.
     */
    cursor?: StoreEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreEmployees.
     */
    skip?: number
    distinct?: StoreEmployeeScalarFieldEnum | StoreEmployeeScalarFieldEnum[]
  }

  /**
   * StoreEmployee create
   */
  export type StoreEmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreEmployee
     */
    select?: StoreEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreEmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a StoreEmployee.
     */
    data: XOR<StoreEmployeeCreateInput, StoreEmployeeUncheckedCreateInput>
  }

  /**
   * StoreEmployee createMany
   */
  export type StoreEmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreEmployees.
     */
    data: StoreEmployeeCreateManyInput | StoreEmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreEmployee createManyAndReturn
   */
  export type StoreEmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreEmployee
     */
    select?: StoreEmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StoreEmployees.
     */
    data: StoreEmployeeCreateManyInput | StoreEmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreEmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoreEmployee update
   */
  export type StoreEmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreEmployee
     */
    select?: StoreEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreEmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a StoreEmployee.
     */
    data: XOR<StoreEmployeeUpdateInput, StoreEmployeeUncheckedUpdateInput>
    /**
     * Choose, which StoreEmployee to update.
     */
    where: StoreEmployeeWhereUniqueInput
  }

  /**
   * StoreEmployee updateMany
   */
  export type StoreEmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreEmployees.
     */
    data: XOR<StoreEmployeeUpdateManyMutationInput, StoreEmployeeUncheckedUpdateManyInput>
    /**
     * Filter which StoreEmployees to update
     */
    where?: StoreEmployeeWhereInput
  }

  /**
   * StoreEmployee upsert
   */
  export type StoreEmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreEmployee
     */
    select?: StoreEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreEmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the StoreEmployee to update in case it exists.
     */
    where: StoreEmployeeWhereUniqueInput
    /**
     * In case the StoreEmployee found by the `where` argument doesn't exist, create a new StoreEmployee with this data.
     */
    create: XOR<StoreEmployeeCreateInput, StoreEmployeeUncheckedCreateInput>
    /**
     * In case the StoreEmployee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreEmployeeUpdateInput, StoreEmployeeUncheckedUpdateInput>
  }

  /**
   * StoreEmployee delete
   */
  export type StoreEmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreEmployee
     */
    select?: StoreEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreEmployeeInclude<ExtArgs> | null
    /**
     * Filter which StoreEmployee to delete.
     */
    where: StoreEmployeeWhereUniqueInput
  }

  /**
   * StoreEmployee deleteMany
   */
  export type StoreEmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreEmployees to delete
     */
    where?: StoreEmployeeWhereInput
  }

  /**
   * StoreEmployee.sales
   */
  export type StoreEmployee$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * StoreEmployee without action
   */
  export type StoreEmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreEmployee
     */
    select?: StoreEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreEmployeeInclude<ExtArgs> | null
  }


  /**
   * Model ProductCategory
   */

  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ProductCategorySumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: string | null
    storeId: string | null
    name: string | null
    nameKa: string | null
    slug: string | null
    description: string | null
    color: string | null
    icon: string | null
    sortOrder: number | null
    parentId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: string | null
    storeId: string | null
    name: string | null
    nameKa: string | null
    slug: string | null
    description: string | null
    color: string | null
    icon: string | null
    sortOrder: number | null
    parentId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    storeId: number
    name: number
    nameKa: number
    slug: number
    description: number
    color: number
    icon: number
    sortOrder: number
    parentId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductCategoryAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ProductCategorySumAggregateInputType = {
    sortOrder?: true
  }

  export type ProductCategoryMinAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    nameKa?: true
    slug?: true
    description?: true
    color?: true
    icon?: true
    sortOrder?: true
    parentId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    nameKa?: true
    slug?: true
    description?: true
    color?: true
    icon?: true
    sortOrder?: true
    parentId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    nameKa?: true
    slug?: true
    description?: true
    color?: true
    icon?: true
    sortOrder?: true
    parentId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithAggregationInput | ProductCategoryOrderByWithAggregationInput[]
    by: ProductCategoryScalarFieldEnum[] | ProductCategoryScalarFieldEnum
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _avg?: ProductCategoryAvgAggregateInputType
    _sum?: ProductCategorySumAggregateInputType
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type ProductCategoryGroupByOutputType = {
    id: string
    storeId: string
    name: string
    nameKa: string | null
    slug: string
    description: string | null
    color: string | null
    icon: string | null
    sortOrder: number
    parentId: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    name?: boolean
    nameKa?: boolean
    slug?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    sortOrder?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
    children?: boolean | ProductCategory$childrenArgs<ExtArgs>
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    name?: boolean
    nameKa?: boolean
    slug?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    sortOrder?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectScalar = {
    id?: boolean
    storeId?: boolean
    name?: boolean
    nameKa?: boolean
    slug?: boolean
    description?: boolean
    color?: boolean
    icon?: boolean
    sortOrder?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
    children?: boolean | ProductCategory$childrenArgs<ExtArgs>
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    parent?: boolean | ProductCategory$parentArgs<ExtArgs>
  }

  export type $ProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCategory"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      parent: Prisma.$ProductCategoryPayload<ExtArgs> | null
      children: Prisma.$ProductCategoryPayload<ExtArgs>[]
      products: Prisma.$StoreProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeId: string
      name: string
      nameKa: string | null
      slug: string
      description: string | null
      color: string | null
      icon: string | null
      sortOrder: number
      parentId: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productCategory"]>
    composites: {}
  }

  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCategoryFindManyArgs>(args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCategoryCreateArgs>(args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductCategories.
     * @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCategories and returns the data saved in the database.
     * @param {ProductCategoryCreateManyAndReturnArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCategoryDeleteArgs>(args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCategoryUpdateArgs>(args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCategoryUpsertArgs>(args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCategory model
   */
  readonly fields: ProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent<T extends ProductCategory$parentArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$parentArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends ProductCategory$childrenArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends ProductCategory$productsArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCategory model
   */ 
  interface ProductCategoryFieldRefs {
    readonly id: FieldRef<"ProductCategory", 'String'>
    readonly storeId: FieldRef<"ProductCategory", 'String'>
    readonly name: FieldRef<"ProductCategory", 'String'>
    readonly nameKa: FieldRef<"ProductCategory", 'String'>
    readonly slug: FieldRef<"ProductCategory", 'String'>
    readonly description: FieldRef<"ProductCategory", 'String'>
    readonly color: FieldRef<"ProductCategory", 'String'>
    readonly icon: FieldRef<"ProductCategory", 'String'>
    readonly sortOrder: FieldRef<"ProductCategory", 'Int'>
    readonly parentId: FieldRef<"ProductCategory", 'String'>
    readonly isActive: FieldRef<"ProductCategory", 'Boolean'>
    readonly createdAt: FieldRef<"ProductCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }

  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory createManyAndReturn
   */
  export type ProductCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCategory.parent
   */
  export type ProductCategory$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCategory.children
   */
  export type ProductCategory$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory.products
   */
  export type ProductCategory$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreProductInclude<ExtArgs> | null
    where?: StoreProductWhereInput
    orderBy?: StoreProductOrderByWithRelationInput | StoreProductOrderByWithRelationInput[]
    cursor?: StoreProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreProductScalarFieldEnum | StoreProductScalarFieldEnum[]
  }

  /**
   * ProductCategory without action
   */
  export type ProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Model StoreProduct
   */

  export type AggregateStoreProduct = {
    _count: StoreProductCountAggregateOutputType | null
    _avg: StoreProductAvgAggregateOutputType | null
    _sum: StoreProductSumAggregateOutputType | null
    _min: StoreProductMinAggregateOutputType | null
    _max: StoreProductMaxAggregateOutputType | null
  }

  export type StoreProductAvgAggregateOutputType = {
    costPrice: Decimal | null
    sellingPrice: Decimal | null
    wholesalePrice: Decimal | null
    currentStock: Decimal | null
    minStock: Decimal | null
    maxStock: Decimal | null
    sortOrder: number | null
  }

  export type StoreProductSumAggregateOutputType = {
    costPrice: Decimal | null
    sellingPrice: Decimal | null
    wholesalePrice: Decimal | null
    currentStock: Decimal | null
    minStock: Decimal | null
    maxStock: Decimal | null
    sortOrder: number | null
  }

  export type StoreProductMinAggregateOutputType = {
    id: string | null
    storeId: string | null
    categoryId: string | null
    sku: string | null
    barcode: string | null
    name: string | null
    nameKa: string | null
    description: string | null
    imageUrl: string | null
    costPrice: Decimal | null
    sellingPrice: Decimal | null
    wholesalePrice: Decimal | null
    currentStock: Decimal | null
    minStock: Decimal | null
    maxStock: Decimal | null
    unit: string | null
    taxRuleId: string | null
    isActive: boolean | null
    isFavorite: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreProductMaxAggregateOutputType = {
    id: string | null
    storeId: string | null
    categoryId: string | null
    sku: string | null
    barcode: string | null
    name: string | null
    nameKa: string | null
    description: string | null
    imageUrl: string | null
    costPrice: Decimal | null
    sellingPrice: Decimal | null
    wholesalePrice: Decimal | null
    currentStock: Decimal | null
    minStock: Decimal | null
    maxStock: Decimal | null
    unit: string | null
    taxRuleId: string | null
    isActive: boolean | null
    isFavorite: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreProductCountAggregateOutputType = {
    id: number
    storeId: number
    categoryId: number
    sku: number
    barcode: number
    name: number
    nameKa: number
    description: number
    imageUrl: number
    costPrice: number
    sellingPrice: number
    wholesalePrice: number
    currentStock: number
    minStock: number
    maxStock: number
    unit: number
    taxRuleId: number
    isActive: number
    isFavorite: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoreProductAvgAggregateInputType = {
    costPrice?: true
    sellingPrice?: true
    wholesalePrice?: true
    currentStock?: true
    minStock?: true
    maxStock?: true
    sortOrder?: true
  }

  export type StoreProductSumAggregateInputType = {
    costPrice?: true
    sellingPrice?: true
    wholesalePrice?: true
    currentStock?: true
    minStock?: true
    maxStock?: true
    sortOrder?: true
  }

  export type StoreProductMinAggregateInputType = {
    id?: true
    storeId?: true
    categoryId?: true
    sku?: true
    barcode?: true
    name?: true
    nameKa?: true
    description?: true
    imageUrl?: true
    costPrice?: true
    sellingPrice?: true
    wholesalePrice?: true
    currentStock?: true
    minStock?: true
    maxStock?: true
    unit?: true
    taxRuleId?: true
    isActive?: true
    isFavorite?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreProductMaxAggregateInputType = {
    id?: true
    storeId?: true
    categoryId?: true
    sku?: true
    barcode?: true
    name?: true
    nameKa?: true
    description?: true
    imageUrl?: true
    costPrice?: true
    sellingPrice?: true
    wholesalePrice?: true
    currentStock?: true
    minStock?: true
    maxStock?: true
    unit?: true
    taxRuleId?: true
    isActive?: true
    isFavorite?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreProductCountAggregateInputType = {
    id?: true
    storeId?: true
    categoryId?: true
    sku?: true
    barcode?: true
    name?: true
    nameKa?: true
    description?: true
    imageUrl?: true
    costPrice?: true
    sellingPrice?: true
    wholesalePrice?: true
    currentStock?: true
    minStock?: true
    maxStock?: true
    unit?: true
    taxRuleId?: true
    isActive?: true
    isFavorite?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoreProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreProduct to aggregate.
     */
    where?: StoreProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreProducts to fetch.
     */
    orderBy?: StoreProductOrderByWithRelationInput | StoreProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreProducts
    **/
    _count?: true | StoreProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreProductMaxAggregateInputType
  }

  export type GetStoreProductAggregateType<T extends StoreProductAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreProduct[P]>
      : GetScalarType<T[P], AggregateStoreProduct[P]>
  }




  export type StoreProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreProductWhereInput
    orderBy?: StoreProductOrderByWithAggregationInput | StoreProductOrderByWithAggregationInput[]
    by: StoreProductScalarFieldEnum[] | StoreProductScalarFieldEnum
    having?: StoreProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreProductCountAggregateInputType | true
    _avg?: StoreProductAvgAggregateInputType
    _sum?: StoreProductSumAggregateInputType
    _min?: StoreProductMinAggregateInputType
    _max?: StoreProductMaxAggregateInputType
  }

  export type StoreProductGroupByOutputType = {
    id: string
    storeId: string
    categoryId: string | null
    sku: string
    barcode: string | null
    name: string
    nameKa: string | null
    description: string | null
    imageUrl: string | null
    costPrice: Decimal
    sellingPrice: Decimal
    wholesalePrice: Decimal | null
    currentStock: Decimal
    minStock: Decimal
    maxStock: Decimal | null
    unit: string
    taxRuleId: string | null
    isActive: boolean
    isFavorite: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: StoreProductCountAggregateOutputType | null
    _avg: StoreProductAvgAggregateOutputType | null
    _sum: StoreProductSumAggregateOutputType | null
    _min: StoreProductMinAggregateOutputType | null
    _max: StoreProductMaxAggregateOutputType | null
  }

  type GetStoreProductGroupByPayload<T extends StoreProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreProductGroupByOutputType[P]>
            : GetScalarType<T[P], StoreProductGroupByOutputType[P]>
        }
      >
    >


  export type StoreProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    categoryId?: boolean
    sku?: boolean
    barcode?: boolean
    name?: boolean
    nameKa?: boolean
    description?: boolean
    imageUrl?: boolean
    costPrice?: boolean
    sellingPrice?: boolean
    wholesalePrice?: boolean
    currentStock?: boolean
    minStock?: boolean
    maxStock?: boolean
    unit?: boolean
    taxRuleId?: boolean
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    category?: boolean | StoreProduct$categoryArgs<ExtArgs>
    taxRule?: boolean | StoreProduct$taxRuleArgs<ExtArgs>
    saleItems?: boolean | StoreProduct$saleItemsArgs<ExtArgs>
    saleReturnItems?: boolean | StoreProduct$saleReturnItemsArgs<ExtArgs>
    purchaseItems?: boolean | StoreProduct$purchaseItemsArgs<ExtArgs>
    stockMovements?: boolean | StoreProduct$stockMovementsArgs<ExtArgs>
    priceHistory?: boolean | StoreProduct$priceHistoryArgs<ExtArgs>
    transferOrderItems?: boolean | StoreProduct$transferOrderItemsArgs<ExtArgs>
    _count?: boolean | StoreProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeProduct"]>

  export type StoreProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    categoryId?: boolean
    sku?: boolean
    barcode?: boolean
    name?: boolean
    nameKa?: boolean
    description?: boolean
    imageUrl?: boolean
    costPrice?: boolean
    sellingPrice?: boolean
    wholesalePrice?: boolean
    currentStock?: boolean
    minStock?: boolean
    maxStock?: boolean
    unit?: boolean
    taxRuleId?: boolean
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    category?: boolean | StoreProduct$categoryArgs<ExtArgs>
    taxRule?: boolean | StoreProduct$taxRuleArgs<ExtArgs>
  }, ExtArgs["result"]["storeProduct"]>

  export type StoreProductSelectScalar = {
    id?: boolean
    storeId?: boolean
    categoryId?: boolean
    sku?: boolean
    barcode?: boolean
    name?: boolean
    nameKa?: boolean
    description?: boolean
    imageUrl?: boolean
    costPrice?: boolean
    sellingPrice?: boolean
    wholesalePrice?: boolean
    currentStock?: boolean
    minStock?: boolean
    maxStock?: boolean
    unit?: boolean
    taxRuleId?: boolean
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoreProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    category?: boolean | StoreProduct$categoryArgs<ExtArgs>
    taxRule?: boolean | StoreProduct$taxRuleArgs<ExtArgs>
    saleItems?: boolean | StoreProduct$saleItemsArgs<ExtArgs>
    saleReturnItems?: boolean | StoreProduct$saleReturnItemsArgs<ExtArgs>
    purchaseItems?: boolean | StoreProduct$purchaseItemsArgs<ExtArgs>
    stockMovements?: boolean | StoreProduct$stockMovementsArgs<ExtArgs>
    priceHistory?: boolean | StoreProduct$priceHistoryArgs<ExtArgs>
    transferOrderItems?: boolean | StoreProduct$transferOrderItemsArgs<ExtArgs>
    _count?: boolean | StoreProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoreProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    category?: boolean | StoreProduct$categoryArgs<ExtArgs>
    taxRule?: boolean | StoreProduct$taxRuleArgs<ExtArgs>
  }

  export type $StoreProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreProduct"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      category: Prisma.$ProductCategoryPayload<ExtArgs> | null
      taxRule: Prisma.$StoreTaxRulePayload<ExtArgs> | null
      saleItems: Prisma.$SaleItemPayload<ExtArgs>[]
      saleReturnItems: Prisma.$SaleReturnItemPayload<ExtArgs>[]
      purchaseItems: Prisma.$StorePurchaseItemPayload<ExtArgs>[]
      stockMovements: Prisma.$StockMovementPayload<ExtArgs>[]
      priceHistory: Prisma.$StorePriceHistoryPayload<ExtArgs>[]
      transferOrderItems: Prisma.$TransferOrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeId: string
      categoryId: string | null
      sku: string
      barcode: string | null
      name: string
      nameKa: string | null
      description: string | null
      imageUrl: string | null
      costPrice: Prisma.Decimal
      sellingPrice: Prisma.Decimal
      wholesalePrice: Prisma.Decimal | null
      currentStock: Prisma.Decimal
      minStock: Prisma.Decimal
      maxStock: Prisma.Decimal | null
      unit: string
      taxRuleId: string | null
      isActive: boolean
      isFavorite: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storeProduct"]>
    composites: {}
  }

  type StoreProductGetPayload<S extends boolean | null | undefined | StoreProductDefaultArgs> = $Result.GetResult<Prisma.$StoreProductPayload, S>

  type StoreProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoreProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoreProductCountAggregateInputType | true
    }

  export interface StoreProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreProduct'], meta: { name: 'StoreProduct' } }
    /**
     * Find zero or one StoreProduct that matches the filter.
     * @param {StoreProductFindUniqueArgs} args - Arguments to find a StoreProduct
     * @example
     * // Get one StoreProduct
     * const storeProduct = await prisma.storeProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreProductFindUniqueArgs>(args: SelectSubset<T, StoreProductFindUniqueArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StoreProduct that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoreProductFindUniqueOrThrowArgs} args - Arguments to find a StoreProduct
     * @example
     * // Get one StoreProduct
     * const storeProduct = await prisma.storeProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreProductFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StoreProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreProductFindFirstArgs} args - Arguments to find a StoreProduct
     * @example
     * // Get one StoreProduct
     * const storeProduct = await prisma.storeProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreProductFindFirstArgs>(args?: SelectSubset<T, StoreProductFindFirstArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StoreProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreProductFindFirstOrThrowArgs} args - Arguments to find a StoreProduct
     * @example
     * // Get one StoreProduct
     * const storeProduct = await prisma.storeProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreProductFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StoreProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreProducts
     * const storeProducts = await prisma.storeProduct.findMany()
     * 
     * // Get first 10 StoreProducts
     * const storeProducts = await prisma.storeProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeProductWithIdOnly = await prisma.storeProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreProductFindManyArgs>(args?: SelectSubset<T, StoreProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StoreProduct.
     * @param {StoreProductCreateArgs} args - Arguments to create a StoreProduct.
     * @example
     * // Create one StoreProduct
     * const StoreProduct = await prisma.storeProduct.create({
     *   data: {
     *     // ... data to create a StoreProduct
     *   }
     * })
     * 
     */
    create<T extends StoreProductCreateArgs>(args: SelectSubset<T, StoreProductCreateArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StoreProducts.
     * @param {StoreProductCreateManyArgs} args - Arguments to create many StoreProducts.
     * @example
     * // Create many StoreProducts
     * const storeProduct = await prisma.storeProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreProductCreateManyArgs>(args?: SelectSubset<T, StoreProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoreProducts and returns the data saved in the database.
     * @param {StoreProductCreateManyAndReturnArgs} args - Arguments to create many StoreProducts.
     * @example
     * // Create many StoreProducts
     * const storeProduct = await prisma.storeProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoreProducts and only return the `id`
     * const storeProductWithIdOnly = await prisma.storeProduct.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreProductCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StoreProduct.
     * @param {StoreProductDeleteArgs} args - Arguments to delete one StoreProduct.
     * @example
     * // Delete one StoreProduct
     * const StoreProduct = await prisma.storeProduct.delete({
     *   where: {
     *     // ... filter to delete one StoreProduct
     *   }
     * })
     * 
     */
    delete<T extends StoreProductDeleteArgs>(args: SelectSubset<T, StoreProductDeleteArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StoreProduct.
     * @param {StoreProductUpdateArgs} args - Arguments to update one StoreProduct.
     * @example
     * // Update one StoreProduct
     * const storeProduct = await prisma.storeProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreProductUpdateArgs>(args: SelectSubset<T, StoreProductUpdateArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StoreProducts.
     * @param {StoreProductDeleteManyArgs} args - Arguments to filter StoreProducts to delete.
     * @example
     * // Delete a few StoreProducts
     * const { count } = await prisma.storeProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreProductDeleteManyArgs>(args?: SelectSubset<T, StoreProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreProducts
     * const storeProduct = await prisma.storeProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreProductUpdateManyArgs>(args: SelectSubset<T, StoreProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoreProduct.
     * @param {StoreProductUpsertArgs} args - Arguments to update or create a StoreProduct.
     * @example
     * // Update or create a StoreProduct
     * const storeProduct = await prisma.storeProduct.upsert({
     *   create: {
     *     // ... data to create a StoreProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreProduct we want to update
     *   }
     * })
     */
    upsert<T extends StoreProductUpsertArgs>(args: SelectSubset<T, StoreProductUpsertArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StoreProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreProductCountArgs} args - Arguments to filter StoreProducts to count.
     * @example
     * // Count the number of StoreProducts
     * const count = await prisma.storeProduct.count({
     *   where: {
     *     // ... the filter for the StoreProducts we want to count
     *   }
     * })
    **/
    count<T extends StoreProductCountArgs>(
      args?: Subset<T, StoreProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreProductAggregateArgs>(args: Subset<T, StoreProductAggregateArgs>): Prisma.PrismaPromise<GetStoreProductAggregateType<T>>

    /**
     * Group by StoreProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreProductGroupByArgs['orderBy'] }
        : { orderBy?: StoreProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreProduct model
   */
  readonly fields: StoreProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    category<T extends StoreProduct$categoryArgs<ExtArgs> = {}>(args?: Subset<T, StoreProduct$categoryArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    taxRule<T extends StoreProduct$taxRuleArgs<ExtArgs> = {}>(args?: Subset<T, StoreProduct$taxRuleArgs<ExtArgs>>): Prisma__StoreTaxRuleClient<$Result.GetResult<Prisma.$StoreTaxRulePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    saleItems<T extends StoreProduct$saleItemsArgs<ExtArgs> = {}>(args?: Subset<T, StoreProduct$saleItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findMany"> | Null>
    saleReturnItems<T extends StoreProduct$saleReturnItemsArgs<ExtArgs> = {}>(args?: Subset<T, StoreProduct$saleReturnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleReturnItemPayload<ExtArgs>, T, "findMany"> | Null>
    purchaseItems<T extends StoreProduct$purchaseItemsArgs<ExtArgs> = {}>(args?: Subset<T, StoreProduct$purchaseItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePurchaseItemPayload<ExtArgs>, T, "findMany"> | Null>
    stockMovements<T extends StoreProduct$stockMovementsArgs<ExtArgs> = {}>(args?: Subset<T, StoreProduct$stockMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany"> | Null>
    priceHistory<T extends StoreProduct$priceHistoryArgs<ExtArgs> = {}>(args?: Subset<T, StoreProduct$priceHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePriceHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    transferOrderItems<T extends StoreProduct$transferOrderItemsArgs<ExtArgs> = {}>(args?: Subset<T, StoreProduct$transferOrderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreProduct model
   */ 
  interface StoreProductFieldRefs {
    readonly id: FieldRef<"StoreProduct", 'String'>
    readonly storeId: FieldRef<"StoreProduct", 'String'>
    readonly categoryId: FieldRef<"StoreProduct", 'String'>
    readonly sku: FieldRef<"StoreProduct", 'String'>
    readonly barcode: FieldRef<"StoreProduct", 'String'>
    readonly name: FieldRef<"StoreProduct", 'String'>
    readonly nameKa: FieldRef<"StoreProduct", 'String'>
    readonly description: FieldRef<"StoreProduct", 'String'>
    readonly imageUrl: FieldRef<"StoreProduct", 'String'>
    readonly costPrice: FieldRef<"StoreProduct", 'Decimal'>
    readonly sellingPrice: FieldRef<"StoreProduct", 'Decimal'>
    readonly wholesalePrice: FieldRef<"StoreProduct", 'Decimal'>
    readonly currentStock: FieldRef<"StoreProduct", 'Decimal'>
    readonly minStock: FieldRef<"StoreProduct", 'Decimal'>
    readonly maxStock: FieldRef<"StoreProduct", 'Decimal'>
    readonly unit: FieldRef<"StoreProduct", 'String'>
    readonly taxRuleId: FieldRef<"StoreProduct", 'String'>
    readonly isActive: FieldRef<"StoreProduct", 'Boolean'>
    readonly isFavorite: FieldRef<"StoreProduct", 'Boolean'>
    readonly sortOrder: FieldRef<"StoreProduct", 'Int'>
    readonly createdAt: FieldRef<"StoreProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"StoreProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoreProduct findUnique
   */
  export type StoreProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreProductInclude<ExtArgs> | null
    /**
     * Filter, which StoreProduct to fetch.
     */
    where: StoreProductWhereUniqueInput
  }

  /**
   * StoreProduct findUniqueOrThrow
   */
  export type StoreProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreProductInclude<ExtArgs> | null
    /**
     * Filter, which StoreProduct to fetch.
     */
    where: StoreProductWhereUniqueInput
  }

  /**
   * StoreProduct findFirst
   */
  export type StoreProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreProductInclude<ExtArgs> | null
    /**
     * Filter, which StoreProduct to fetch.
     */
    where?: StoreProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreProducts to fetch.
     */
    orderBy?: StoreProductOrderByWithRelationInput | StoreProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreProducts.
     */
    cursor?: StoreProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreProducts.
     */
    distinct?: StoreProductScalarFieldEnum | StoreProductScalarFieldEnum[]
  }

  /**
   * StoreProduct findFirstOrThrow
   */
  export type StoreProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreProductInclude<ExtArgs> | null
    /**
     * Filter, which StoreProduct to fetch.
     */
    where?: StoreProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreProducts to fetch.
     */
    orderBy?: StoreProductOrderByWithRelationInput | StoreProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreProducts.
     */
    cursor?: StoreProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreProducts.
     */
    distinct?: StoreProductScalarFieldEnum | StoreProductScalarFieldEnum[]
  }

  /**
   * StoreProduct findMany
   */
  export type StoreProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreProductInclude<ExtArgs> | null
    /**
     * Filter, which StoreProducts to fetch.
     */
    where?: StoreProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreProducts to fetch.
     */
    orderBy?: StoreProductOrderByWithRelationInput | StoreProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreProducts.
     */
    cursor?: StoreProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreProducts.
     */
    skip?: number
    distinct?: StoreProductScalarFieldEnum | StoreProductScalarFieldEnum[]
  }

  /**
   * StoreProduct create
   */
  export type StoreProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreProductInclude<ExtArgs> | null
    /**
     * The data needed to create a StoreProduct.
     */
    data: XOR<StoreProductCreateInput, StoreProductUncheckedCreateInput>
  }

  /**
   * StoreProduct createMany
   */
  export type StoreProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreProducts.
     */
    data: StoreProductCreateManyInput | StoreProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreProduct createManyAndReturn
   */
  export type StoreProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StoreProducts.
     */
    data: StoreProductCreateManyInput | StoreProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoreProduct update
   */
  export type StoreProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreProductInclude<ExtArgs> | null
    /**
     * The data needed to update a StoreProduct.
     */
    data: XOR<StoreProductUpdateInput, StoreProductUncheckedUpdateInput>
    /**
     * Choose, which StoreProduct to update.
     */
    where: StoreProductWhereUniqueInput
  }

  /**
   * StoreProduct updateMany
   */
  export type StoreProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreProducts.
     */
    data: XOR<StoreProductUpdateManyMutationInput, StoreProductUncheckedUpdateManyInput>
    /**
     * Filter which StoreProducts to update
     */
    where?: StoreProductWhereInput
  }

  /**
   * StoreProduct upsert
   */
  export type StoreProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreProductInclude<ExtArgs> | null
    /**
     * The filter to search for the StoreProduct to update in case it exists.
     */
    where: StoreProductWhereUniqueInput
    /**
     * In case the StoreProduct found by the `where` argument doesn't exist, create a new StoreProduct with this data.
     */
    create: XOR<StoreProductCreateInput, StoreProductUncheckedCreateInput>
    /**
     * In case the StoreProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreProductUpdateInput, StoreProductUncheckedUpdateInput>
  }

  /**
   * StoreProduct delete
   */
  export type StoreProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreProductInclude<ExtArgs> | null
    /**
     * Filter which StoreProduct to delete.
     */
    where: StoreProductWhereUniqueInput
  }

  /**
   * StoreProduct deleteMany
   */
  export type StoreProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreProducts to delete
     */
    where?: StoreProductWhereInput
  }

  /**
   * StoreProduct.category
   */
  export type StoreProduct$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
  }

  /**
   * StoreProduct.taxRule
   */
  export type StoreProduct$taxRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreTaxRule
     */
    select?: StoreTaxRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreTaxRuleInclude<ExtArgs> | null
    where?: StoreTaxRuleWhereInput
  }

  /**
   * StoreProduct.saleItems
   */
  export type StoreProduct$saleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    where?: SaleItemWhereInput
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    cursor?: SaleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * StoreProduct.saleReturnItems
   */
  export type StoreProduct$saleReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturnItem
     */
    select?: SaleReturnItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnItemInclude<ExtArgs> | null
    where?: SaleReturnItemWhereInput
    orderBy?: SaleReturnItemOrderByWithRelationInput | SaleReturnItemOrderByWithRelationInput[]
    cursor?: SaleReturnItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleReturnItemScalarFieldEnum | SaleReturnItemScalarFieldEnum[]
  }

  /**
   * StoreProduct.purchaseItems
   */
  export type StoreProduct$purchaseItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseItem
     */
    select?: StorePurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseItemInclude<ExtArgs> | null
    where?: StorePurchaseItemWhereInput
    orderBy?: StorePurchaseItemOrderByWithRelationInput | StorePurchaseItemOrderByWithRelationInput[]
    cursor?: StorePurchaseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorePurchaseItemScalarFieldEnum | StorePurchaseItemScalarFieldEnum[]
  }

  /**
   * StoreProduct.stockMovements
   */
  export type StoreProduct$stockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    cursor?: StockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StoreProduct.priceHistory
   */
  export type StoreProduct$priceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePriceHistory
     */
    select?: StorePriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePriceHistoryInclude<ExtArgs> | null
    where?: StorePriceHistoryWhereInput
    orderBy?: StorePriceHistoryOrderByWithRelationInput | StorePriceHistoryOrderByWithRelationInput[]
    cursor?: StorePriceHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorePriceHistoryScalarFieldEnum | StorePriceHistoryScalarFieldEnum[]
  }

  /**
   * StoreProduct.transferOrderItems
   */
  export type StoreProduct$transferOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    where?: TransferOrderItemWhereInput
    orderBy?: TransferOrderItemOrderByWithRelationInput | TransferOrderItemOrderByWithRelationInput[]
    cursor?: TransferOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferOrderItemScalarFieldEnum | TransferOrderItemScalarFieldEnum[]
  }

  /**
   * StoreProduct without action
   */
  export type StoreProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreProductInclude<ExtArgs> | null
  }


  /**
   * Model StorePriceHistory
   */

  export type AggregateStorePriceHistory = {
    _count: StorePriceHistoryCountAggregateOutputType | null
    _avg: StorePriceHistoryAvgAggregateOutputType | null
    _sum: StorePriceHistorySumAggregateOutputType | null
    _min: StorePriceHistoryMinAggregateOutputType | null
    _max: StorePriceHistoryMaxAggregateOutputType | null
  }

  export type StorePriceHistoryAvgAggregateOutputType = {
    costPrice: Decimal | null
    sellingPrice: Decimal | null
  }

  export type StorePriceHistorySumAggregateOutputType = {
    costPrice: Decimal | null
    sellingPrice: Decimal | null
  }

  export type StorePriceHistoryMinAggregateOutputType = {
    id: string | null
    productId: string | null
    costPrice: Decimal | null
    sellingPrice: Decimal | null
    changedBy: string | null
    changedAt: Date | null
  }

  export type StorePriceHistoryMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    costPrice: Decimal | null
    sellingPrice: Decimal | null
    changedBy: string | null
    changedAt: Date | null
  }

  export type StorePriceHistoryCountAggregateOutputType = {
    id: number
    productId: number
    costPrice: number
    sellingPrice: number
    changedBy: number
    changedAt: number
    _all: number
  }


  export type StorePriceHistoryAvgAggregateInputType = {
    costPrice?: true
    sellingPrice?: true
  }

  export type StorePriceHistorySumAggregateInputType = {
    costPrice?: true
    sellingPrice?: true
  }

  export type StorePriceHistoryMinAggregateInputType = {
    id?: true
    productId?: true
    costPrice?: true
    sellingPrice?: true
    changedBy?: true
    changedAt?: true
  }

  export type StorePriceHistoryMaxAggregateInputType = {
    id?: true
    productId?: true
    costPrice?: true
    sellingPrice?: true
    changedBy?: true
    changedAt?: true
  }

  export type StorePriceHistoryCountAggregateInputType = {
    id?: true
    productId?: true
    costPrice?: true
    sellingPrice?: true
    changedBy?: true
    changedAt?: true
    _all?: true
  }

  export type StorePriceHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorePriceHistory to aggregate.
     */
    where?: StorePriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePriceHistories to fetch.
     */
    orderBy?: StorePriceHistoryOrderByWithRelationInput | StorePriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StorePriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StorePriceHistories
    **/
    _count?: true | StorePriceHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StorePriceHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StorePriceHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorePriceHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorePriceHistoryMaxAggregateInputType
  }

  export type GetStorePriceHistoryAggregateType<T extends StorePriceHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateStorePriceHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorePriceHistory[P]>
      : GetScalarType<T[P], AggregateStorePriceHistory[P]>
  }




  export type StorePriceHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorePriceHistoryWhereInput
    orderBy?: StorePriceHistoryOrderByWithAggregationInput | StorePriceHistoryOrderByWithAggregationInput[]
    by: StorePriceHistoryScalarFieldEnum[] | StorePriceHistoryScalarFieldEnum
    having?: StorePriceHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorePriceHistoryCountAggregateInputType | true
    _avg?: StorePriceHistoryAvgAggregateInputType
    _sum?: StorePriceHistorySumAggregateInputType
    _min?: StorePriceHistoryMinAggregateInputType
    _max?: StorePriceHistoryMaxAggregateInputType
  }

  export type StorePriceHistoryGroupByOutputType = {
    id: string
    productId: string
    costPrice: Decimal
    sellingPrice: Decimal
    changedBy: string | null
    changedAt: Date
    _count: StorePriceHistoryCountAggregateOutputType | null
    _avg: StorePriceHistoryAvgAggregateOutputType | null
    _sum: StorePriceHistorySumAggregateOutputType | null
    _min: StorePriceHistoryMinAggregateOutputType | null
    _max: StorePriceHistoryMaxAggregateOutputType | null
  }

  type GetStorePriceHistoryGroupByPayload<T extends StorePriceHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StorePriceHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorePriceHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorePriceHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], StorePriceHistoryGroupByOutputType[P]>
        }
      >
    >


  export type StorePriceHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    costPrice?: boolean
    sellingPrice?: boolean
    changedBy?: boolean
    changedAt?: boolean
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storePriceHistory"]>

  export type StorePriceHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    costPrice?: boolean
    sellingPrice?: boolean
    changedBy?: boolean
    changedAt?: boolean
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storePriceHistory"]>

  export type StorePriceHistorySelectScalar = {
    id?: boolean
    productId?: boolean
    costPrice?: boolean
    sellingPrice?: boolean
    changedBy?: boolean
    changedAt?: boolean
  }

  export type StorePriceHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }
  export type StorePriceHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }

  export type $StorePriceHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StorePriceHistory"
    objects: {
      product: Prisma.$StoreProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      costPrice: Prisma.Decimal
      sellingPrice: Prisma.Decimal
      changedBy: string | null
      changedAt: Date
    }, ExtArgs["result"]["storePriceHistory"]>
    composites: {}
  }

  type StorePriceHistoryGetPayload<S extends boolean | null | undefined | StorePriceHistoryDefaultArgs> = $Result.GetResult<Prisma.$StorePriceHistoryPayload, S>

  type StorePriceHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StorePriceHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StorePriceHistoryCountAggregateInputType | true
    }

  export interface StorePriceHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StorePriceHistory'], meta: { name: 'StorePriceHistory' } }
    /**
     * Find zero or one StorePriceHistory that matches the filter.
     * @param {StorePriceHistoryFindUniqueArgs} args - Arguments to find a StorePriceHistory
     * @example
     * // Get one StorePriceHistory
     * const storePriceHistory = await prisma.storePriceHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StorePriceHistoryFindUniqueArgs>(args: SelectSubset<T, StorePriceHistoryFindUniqueArgs<ExtArgs>>): Prisma__StorePriceHistoryClient<$Result.GetResult<Prisma.$StorePriceHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StorePriceHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StorePriceHistoryFindUniqueOrThrowArgs} args - Arguments to find a StorePriceHistory
     * @example
     * // Get one StorePriceHistory
     * const storePriceHistory = await prisma.storePriceHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StorePriceHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, StorePriceHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StorePriceHistoryClient<$Result.GetResult<Prisma.$StorePriceHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StorePriceHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePriceHistoryFindFirstArgs} args - Arguments to find a StorePriceHistory
     * @example
     * // Get one StorePriceHistory
     * const storePriceHistory = await prisma.storePriceHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StorePriceHistoryFindFirstArgs>(args?: SelectSubset<T, StorePriceHistoryFindFirstArgs<ExtArgs>>): Prisma__StorePriceHistoryClient<$Result.GetResult<Prisma.$StorePriceHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StorePriceHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePriceHistoryFindFirstOrThrowArgs} args - Arguments to find a StorePriceHistory
     * @example
     * // Get one StorePriceHistory
     * const storePriceHistory = await prisma.storePriceHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StorePriceHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, StorePriceHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__StorePriceHistoryClient<$Result.GetResult<Prisma.$StorePriceHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StorePriceHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePriceHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StorePriceHistories
     * const storePriceHistories = await prisma.storePriceHistory.findMany()
     * 
     * // Get first 10 StorePriceHistories
     * const storePriceHistories = await prisma.storePriceHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storePriceHistoryWithIdOnly = await prisma.storePriceHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StorePriceHistoryFindManyArgs>(args?: SelectSubset<T, StorePriceHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePriceHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StorePriceHistory.
     * @param {StorePriceHistoryCreateArgs} args - Arguments to create a StorePriceHistory.
     * @example
     * // Create one StorePriceHistory
     * const StorePriceHistory = await prisma.storePriceHistory.create({
     *   data: {
     *     // ... data to create a StorePriceHistory
     *   }
     * })
     * 
     */
    create<T extends StorePriceHistoryCreateArgs>(args: SelectSubset<T, StorePriceHistoryCreateArgs<ExtArgs>>): Prisma__StorePriceHistoryClient<$Result.GetResult<Prisma.$StorePriceHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StorePriceHistories.
     * @param {StorePriceHistoryCreateManyArgs} args - Arguments to create many StorePriceHistories.
     * @example
     * // Create many StorePriceHistories
     * const storePriceHistory = await prisma.storePriceHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StorePriceHistoryCreateManyArgs>(args?: SelectSubset<T, StorePriceHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StorePriceHistories and returns the data saved in the database.
     * @param {StorePriceHistoryCreateManyAndReturnArgs} args - Arguments to create many StorePriceHistories.
     * @example
     * // Create many StorePriceHistories
     * const storePriceHistory = await prisma.storePriceHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StorePriceHistories and only return the `id`
     * const storePriceHistoryWithIdOnly = await prisma.storePriceHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StorePriceHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, StorePriceHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePriceHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StorePriceHistory.
     * @param {StorePriceHistoryDeleteArgs} args - Arguments to delete one StorePriceHistory.
     * @example
     * // Delete one StorePriceHistory
     * const StorePriceHistory = await prisma.storePriceHistory.delete({
     *   where: {
     *     // ... filter to delete one StorePriceHistory
     *   }
     * })
     * 
     */
    delete<T extends StorePriceHistoryDeleteArgs>(args: SelectSubset<T, StorePriceHistoryDeleteArgs<ExtArgs>>): Prisma__StorePriceHistoryClient<$Result.GetResult<Prisma.$StorePriceHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StorePriceHistory.
     * @param {StorePriceHistoryUpdateArgs} args - Arguments to update one StorePriceHistory.
     * @example
     * // Update one StorePriceHistory
     * const storePriceHistory = await prisma.storePriceHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StorePriceHistoryUpdateArgs>(args: SelectSubset<T, StorePriceHistoryUpdateArgs<ExtArgs>>): Prisma__StorePriceHistoryClient<$Result.GetResult<Prisma.$StorePriceHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StorePriceHistories.
     * @param {StorePriceHistoryDeleteManyArgs} args - Arguments to filter StorePriceHistories to delete.
     * @example
     * // Delete a few StorePriceHistories
     * const { count } = await prisma.storePriceHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StorePriceHistoryDeleteManyArgs>(args?: SelectSubset<T, StorePriceHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorePriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePriceHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StorePriceHistories
     * const storePriceHistory = await prisma.storePriceHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StorePriceHistoryUpdateManyArgs>(args: SelectSubset<T, StorePriceHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StorePriceHistory.
     * @param {StorePriceHistoryUpsertArgs} args - Arguments to update or create a StorePriceHistory.
     * @example
     * // Update or create a StorePriceHistory
     * const storePriceHistory = await prisma.storePriceHistory.upsert({
     *   create: {
     *     // ... data to create a StorePriceHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StorePriceHistory we want to update
     *   }
     * })
     */
    upsert<T extends StorePriceHistoryUpsertArgs>(args: SelectSubset<T, StorePriceHistoryUpsertArgs<ExtArgs>>): Prisma__StorePriceHistoryClient<$Result.GetResult<Prisma.$StorePriceHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StorePriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePriceHistoryCountArgs} args - Arguments to filter StorePriceHistories to count.
     * @example
     * // Count the number of StorePriceHistories
     * const count = await prisma.storePriceHistory.count({
     *   where: {
     *     // ... the filter for the StorePriceHistories we want to count
     *   }
     * })
    **/
    count<T extends StorePriceHistoryCountArgs>(
      args?: Subset<T, StorePriceHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorePriceHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StorePriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePriceHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorePriceHistoryAggregateArgs>(args: Subset<T, StorePriceHistoryAggregateArgs>): Prisma.PrismaPromise<GetStorePriceHistoryAggregateType<T>>

    /**
     * Group by StorePriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePriceHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorePriceHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorePriceHistoryGroupByArgs['orderBy'] }
        : { orderBy?: StorePriceHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorePriceHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorePriceHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StorePriceHistory model
   */
  readonly fields: StorePriceHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StorePriceHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StorePriceHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends StoreProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreProductDefaultArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StorePriceHistory model
   */ 
  interface StorePriceHistoryFieldRefs {
    readonly id: FieldRef<"StorePriceHistory", 'String'>
    readonly productId: FieldRef<"StorePriceHistory", 'String'>
    readonly costPrice: FieldRef<"StorePriceHistory", 'Decimal'>
    readonly sellingPrice: FieldRef<"StorePriceHistory", 'Decimal'>
    readonly changedBy: FieldRef<"StorePriceHistory", 'String'>
    readonly changedAt: FieldRef<"StorePriceHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StorePriceHistory findUnique
   */
  export type StorePriceHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePriceHistory
     */
    select?: StorePriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StorePriceHistory to fetch.
     */
    where: StorePriceHistoryWhereUniqueInput
  }

  /**
   * StorePriceHistory findUniqueOrThrow
   */
  export type StorePriceHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePriceHistory
     */
    select?: StorePriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StorePriceHistory to fetch.
     */
    where: StorePriceHistoryWhereUniqueInput
  }

  /**
   * StorePriceHistory findFirst
   */
  export type StorePriceHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePriceHistory
     */
    select?: StorePriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StorePriceHistory to fetch.
     */
    where?: StorePriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePriceHistories to fetch.
     */
    orderBy?: StorePriceHistoryOrderByWithRelationInput | StorePriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorePriceHistories.
     */
    cursor?: StorePriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorePriceHistories.
     */
    distinct?: StorePriceHistoryScalarFieldEnum | StorePriceHistoryScalarFieldEnum[]
  }

  /**
   * StorePriceHistory findFirstOrThrow
   */
  export type StorePriceHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePriceHistory
     */
    select?: StorePriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StorePriceHistory to fetch.
     */
    where?: StorePriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePriceHistories to fetch.
     */
    orderBy?: StorePriceHistoryOrderByWithRelationInput | StorePriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorePriceHistories.
     */
    cursor?: StorePriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorePriceHistories.
     */
    distinct?: StorePriceHistoryScalarFieldEnum | StorePriceHistoryScalarFieldEnum[]
  }

  /**
   * StorePriceHistory findMany
   */
  export type StorePriceHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePriceHistory
     */
    select?: StorePriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StorePriceHistories to fetch.
     */
    where?: StorePriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePriceHistories to fetch.
     */
    orderBy?: StorePriceHistoryOrderByWithRelationInput | StorePriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StorePriceHistories.
     */
    cursor?: StorePriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePriceHistories.
     */
    skip?: number
    distinct?: StorePriceHistoryScalarFieldEnum | StorePriceHistoryScalarFieldEnum[]
  }

  /**
   * StorePriceHistory create
   */
  export type StorePriceHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePriceHistory
     */
    select?: StorePriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePriceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a StorePriceHistory.
     */
    data: XOR<StorePriceHistoryCreateInput, StorePriceHistoryUncheckedCreateInput>
  }

  /**
   * StorePriceHistory createMany
   */
  export type StorePriceHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StorePriceHistories.
     */
    data: StorePriceHistoryCreateManyInput | StorePriceHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StorePriceHistory createManyAndReturn
   */
  export type StorePriceHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePriceHistory
     */
    select?: StorePriceHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StorePriceHistories.
     */
    data: StorePriceHistoryCreateManyInput | StorePriceHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePriceHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StorePriceHistory update
   */
  export type StorePriceHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePriceHistory
     */
    select?: StorePriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePriceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a StorePriceHistory.
     */
    data: XOR<StorePriceHistoryUpdateInput, StorePriceHistoryUncheckedUpdateInput>
    /**
     * Choose, which StorePriceHistory to update.
     */
    where: StorePriceHistoryWhereUniqueInput
  }

  /**
   * StorePriceHistory updateMany
   */
  export type StorePriceHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StorePriceHistories.
     */
    data: XOR<StorePriceHistoryUpdateManyMutationInput, StorePriceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which StorePriceHistories to update
     */
    where?: StorePriceHistoryWhereInput
  }

  /**
   * StorePriceHistory upsert
   */
  export type StorePriceHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePriceHistory
     */
    select?: StorePriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePriceHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the StorePriceHistory to update in case it exists.
     */
    where: StorePriceHistoryWhereUniqueInput
    /**
     * In case the StorePriceHistory found by the `where` argument doesn't exist, create a new StorePriceHistory with this data.
     */
    create: XOR<StorePriceHistoryCreateInput, StorePriceHistoryUncheckedCreateInput>
    /**
     * In case the StorePriceHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StorePriceHistoryUpdateInput, StorePriceHistoryUncheckedUpdateInput>
  }

  /**
   * StorePriceHistory delete
   */
  export type StorePriceHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePriceHistory
     */
    select?: StorePriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePriceHistoryInclude<ExtArgs> | null
    /**
     * Filter which StorePriceHistory to delete.
     */
    where: StorePriceHistoryWhereUniqueInput
  }

  /**
   * StorePriceHistory deleteMany
   */
  export type StorePriceHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorePriceHistories to delete
     */
    where?: StorePriceHistoryWhereInput
  }

  /**
   * StorePriceHistory without action
   */
  export type StorePriceHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePriceHistory
     */
    select?: StorePriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePriceHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Sale
   */

  export type AggregateSale = {
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  export type SaleAvgAggregateOutputType = {
    subtotal: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    total: Decimal | null
    paidAmount: Decimal | null
    changeAmount: Decimal | null
  }

  export type SaleSumAggregateOutputType = {
    subtotal: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    total: Decimal | null
    paidAmount: Decimal | null
    changeAmount: Decimal | null
  }

  export type SaleMinAggregateOutputType = {
    id: string | null
    storeId: string | null
    saleNumber: string | null
    customerId: string | null
    employeeId: string | null
    subtotal: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    discountType: $Enums.StoreDiscountType | null
    total: Decimal | null
    paidAmount: Decimal | null
    changeAmount: Decimal | null
    status: $Enums.StoreSaleStatus | null
    notes: string | null
    receiptPrinted: boolean | null
    fiscalPrinted: boolean | null
    fiscalNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleMaxAggregateOutputType = {
    id: string | null
    storeId: string | null
    saleNumber: string | null
    customerId: string | null
    employeeId: string | null
    subtotal: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    discountType: $Enums.StoreDiscountType | null
    total: Decimal | null
    paidAmount: Decimal | null
    changeAmount: Decimal | null
    status: $Enums.StoreSaleStatus | null
    notes: string | null
    receiptPrinted: boolean | null
    fiscalPrinted: boolean | null
    fiscalNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleCountAggregateOutputType = {
    id: number
    storeId: number
    saleNumber: number
    customerId: number
    employeeId: number
    subtotal: number
    taxAmount: number
    discountAmount: number
    discountType: number
    total: number
    paidAmount: number
    changeAmount: number
    status: number
    notes: number
    receiptPrinted: number
    fiscalPrinted: number
    fiscalNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SaleAvgAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
    paidAmount?: true
    changeAmount?: true
  }

  export type SaleSumAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
    paidAmount?: true
    changeAmount?: true
  }

  export type SaleMinAggregateInputType = {
    id?: true
    storeId?: true
    saleNumber?: true
    customerId?: true
    employeeId?: true
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    discountType?: true
    total?: true
    paidAmount?: true
    changeAmount?: true
    status?: true
    notes?: true
    receiptPrinted?: true
    fiscalPrinted?: true
    fiscalNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleMaxAggregateInputType = {
    id?: true
    storeId?: true
    saleNumber?: true
    customerId?: true
    employeeId?: true
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    discountType?: true
    total?: true
    paidAmount?: true
    changeAmount?: true
    status?: true
    notes?: true
    receiptPrinted?: true
    fiscalPrinted?: true
    fiscalNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleCountAggregateInputType = {
    id?: true
    storeId?: true
    saleNumber?: true
    customerId?: true
    employeeId?: true
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    discountType?: true
    total?: true
    paidAmount?: true
    changeAmount?: true
    status?: true
    notes?: true
    receiptPrinted?: true
    fiscalPrinted?: true
    fiscalNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sale to aggregate.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sales
    **/
    _count?: true | SaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleMaxAggregateInputType
  }

  export type GetSaleAggregateType<T extends SaleAggregateArgs> = {
        [P in keyof T & keyof AggregateSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSale[P]>
      : GetScalarType<T[P], AggregateSale[P]>
  }




  export type SaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithAggregationInput | SaleOrderByWithAggregationInput[]
    by: SaleScalarFieldEnum[] | SaleScalarFieldEnum
    having?: SaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleCountAggregateInputType | true
    _avg?: SaleAvgAggregateInputType
    _sum?: SaleSumAggregateInputType
    _min?: SaleMinAggregateInputType
    _max?: SaleMaxAggregateInputType
  }

  export type SaleGroupByOutputType = {
    id: string
    storeId: string
    saleNumber: string
    customerId: string | null
    employeeId: string | null
    subtotal: Decimal
    taxAmount: Decimal
    discountAmount: Decimal
    discountType: $Enums.StoreDiscountType | null
    total: Decimal
    paidAmount: Decimal
    changeAmount: Decimal
    status: $Enums.StoreSaleStatus
    notes: string | null
    receiptPrinted: boolean
    fiscalPrinted: boolean
    fiscalNumber: string | null
    createdAt: Date
    updatedAt: Date
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  type GetSaleGroupByPayload<T extends SaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleGroupByOutputType[P]>
            : GetScalarType<T[P], SaleGroupByOutputType[P]>
        }
      >
    >


  export type SaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    saleNumber?: boolean
    customerId?: boolean
    employeeId?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    discountType?: boolean
    total?: boolean
    paidAmount?: boolean
    changeAmount?: boolean
    status?: boolean
    notes?: boolean
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    customer?: boolean | Sale$customerArgs<ExtArgs>
    employee?: boolean | Sale$employeeArgs<ExtArgs>
    items?: boolean | Sale$itemsArgs<ExtArgs>
    payments?: boolean | Sale$paymentsArgs<ExtArgs>
    returns?: boolean | Sale$returnsArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    saleNumber?: boolean
    customerId?: boolean
    employeeId?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    discountType?: boolean
    total?: boolean
    paidAmount?: boolean
    changeAmount?: boolean
    status?: boolean
    notes?: boolean
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    customer?: boolean | Sale$customerArgs<ExtArgs>
    employee?: boolean | Sale$employeeArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectScalar = {
    id?: boolean
    storeId?: boolean
    saleNumber?: boolean
    customerId?: boolean
    employeeId?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    discountType?: boolean
    total?: boolean
    paidAmount?: boolean
    changeAmount?: boolean
    status?: boolean
    notes?: boolean
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    customer?: boolean | Sale$customerArgs<ExtArgs>
    employee?: boolean | Sale$employeeArgs<ExtArgs>
    items?: boolean | Sale$itemsArgs<ExtArgs>
    payments?: boolean | Sale$paymentsArgs<ExtArgs>
    returns?: boolean | Sale$returnsArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    customer?: boolean | Sale$customerArgs<ExtArgs>
    employee?: boolean | Sale$employeeArgs<ExtArgs>
  }

  export type $SalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sale"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      customer: Prisma.$StoreCustomerPayload<ExtArgs> | null
      employee: Prisma.$StoreEmployeePayload<ExtArgs> | null
      items: Prisma.$SaleItemPayload<ExtArgs>[]
      payments: Prisma.$SalePaymentPayload<ExtArgs>[]
      returns: Prisma.$SaleReturnPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeId: string
      saleNumber: string
      customerId: string | null
      employeeId: string | null
      subtotal: Prisma.Decimal
      taxAmount: Prisma.Decimal
      discountAmount: Prisma.Decimal
      discountType: $Enums.StoreDiscountType | null
      total: Prisma.Decimal
      paidAmount: Prisma.Decimal
      changeAmount: Prisma.Decimal
      status: $Enums.StoreSaleStatus
      notes: string | null
      receiptPrinted: boolean
      fiscalPrinted: boolean
      fiscalNumber: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sale"]>
    composites: {}
  }

  type SaleGetPayload<S extends boolean | null | undefined | SaleDefaultArgs> = $Result.GetResult<Prisma.$SalePayload, S>

  type SaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SaleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SaleCountAggregateInputType | true
    }

  export interface SaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sale'], meta: { name: 'Sale' } }
    /**
     * Find zero or one Sale that matches the filter.
     * @param {SaleFindUniqueArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleFindUniqueArgs>(args: SelectSubset<T, SaleFindUniqueArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sale that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SaleFindUniqueOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleFindFirstArgs>(args?: SelectSubset<T, SaleFindFirstArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales
     * const sales = await prisma.sale.findMany()
     * 
     * // Get first 10 Sales
     * const sales = await prisma.sale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleWithIdOnly = await prisma.sale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleFindManyArgs>(args?: SelectSubset<T, SaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sale.
     * @param {SaleCreateArgs} args - Arguments to create a Sale.
     * @example
     * // Create one Sale
     * const Sale = await prisma.sale.create({
     *   data: {
     *     // ... data to create a Sale
     *   }
     * })
     * 
     */
    create<T extends SaleCreateArgs>(args: SelectSubset<T, SaleCreateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sales.
     * @param {SaleCreateManyArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleCreateManyArgs>(args?: SelectSubset<T, SaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sales and returns the data saved in the database.
     * @param {SaleCreateManyAndReturnArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sales and only return the `id`
     * const saleWithIdOnly = await prisma.sale.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Sale.
     * @param {SaleDeleteArgs} args - Arguments to delete one Sale.
     * @example
     * // Delete one Sale
     * const Sale = await prisma.sale.delete({
     *   where: {
     *     // ... filter to delete one Sale
     *   }
     * })
     * 
     */
    delete<T extends SaleDeleteArgs>(args: SelectSubset<T, SaleDeleteArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sale.
     * @param {SaleUpdateArgs} args - Arguments to update one Sale.
     * @example
     * // Update one Sale
     * const sale = await prisma.sale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleUpdateArgs>(args: SelectSubset<T, SaleUpdateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sales.
     * @param {SaleDeleteManyArgs} args - Arguments to filter Sales to delete.
     * @example
     * // Delete a few Sales
     * const { count } = await prisma.sale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleDeleteManyArgs>(args?: SelectSubset<T, SaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleUpdateManyArgs>(args: SelectSubset<T, SaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sale.
     * @param {SaleUpsertArgs} args - Arguments to update or create a Sale.
     * @example
     * // Update or create a Sale
     * const sale = await prisma.sale.upsert({
     *   create: {
     *     // ... data to create a Sale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sale we want to update
     *   }
     * })
     */
    upsert<T extends SaleUpsertArgs>(args: SelectSubset<T, SaleUpsertArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleCountArgs} args - Arguments to filter Sales to count.
     * @example
     * // Count the number of Sales
     * const count = await prisma.sale.count({
     *   where: {
     *     // ... the filter for the Sales we want to count
     *   }
     * })
    **/
    count<T extends SaleCountArgs>(
      args?: Subset<T, SaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleAggregateArgs>(args: Subset<T, SaleAggregateArgs>): Prisma.PrismaPromise<GetSaleAggregateType<T>>

    /**
     * Group by Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleGroupByArgs['orderBy'] }
        : { orderBy?: SaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sale model
   */
  readonly fields: SaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    customer<T extends Sale$customerArgs<ExtArgs> = {}>(args?: Subset<T, Sale$customerArgs<ExtArgs>>): Prisma__StoreCustomerClient<$Result.GetResult<Prisma.$StoreCustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    employee<T extends Sale$employeeArgs<ExtArgs> = {}>(args?: Subset<T, Sale$employeeArgs<ExtArgs>>): Prisma__StoreEmployeeClient<$Result.GetResult<Prisma.$StoreEmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    items<T extends Sale$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Sale$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Sale$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Sale$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "findMany"> | Null>
    returns<T extends Sale$returnsArgs<ExtArgs> = {}>(args?: Subset<T, Sale$returnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleReturnPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sale model
   */ 
  interface SaleFieldRefs {
    readonly id: FieldRef<"Sale", 'String'>
    readonly storeId: FieldRef<"Sale", 'String'>
    readonly saleNumber: FieldRef<"Sale", 'String'>
    readonly customerId: FieldRef<"Sale", 'String'>
    readonly employeeId: FieldRef<"Sale", 'String'>
    readonly subtotal: FieldRef<"Sale", 'Decimal'>
    readonly taxAmount: FieldRef<"Sale", 'Decimal'>
    readonly discountAmount: FieldRef<"Sale", 'Decimal'>
    readonly discountType: FieldRef<"Sale", 'StoreDiscountType'>
    readonly total: FieldRef<"Sale", 'Decimal'>
    readonly paidAmount: FieldRef<"Sale", 'Decimal'>
    readonly changeAmount: FieldRef<"Sale", 'Decimal'>
    readonly status: FieldRef<"Sale", 'StoreSaleStatus'>
    readonly notes: FieldRef<"Sale", 'String'>
    readonly receiptPrinted: FieldRef<"Sale", 'Boolean'>
    readonly fiscalPrinted: FieldRef<"Sale", 'Boolean'>
    readonly fiscalNumber: FieldRef<"Sale", 'String'>
    readonly createdAt: FieldRef<"Sale", 'DateTime'>
    readonly updatedAt: FieldRef<"Sale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sale findUnique
   */
  export type SaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findUniqueOrThrow
   */
  export type SaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findFirst
   */
  export type SaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findFirstOrThrow
   */
  export type SaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findMany
   */
  export type SaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sales to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale create
   */
  export type SaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to create a Sale.
     */
    data: XOR<SaleCreateInput, SaleUncheckedCreateInput>
  }

  /**
   * Sale createMany
   */
  export type SaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sale createManyAndReturn
   */
  export type SaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sale update
   */
  export type SaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to update a Sale.
     */
    data: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
    /**
     * Choose, which Sale to update.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale updateMany
   */
  export type SaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
  }

  /**
   * Sale upsert
   */
  export type SaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The filter to search for the Sale to update in case it exists.
     */
    where: SaleWhereUniqueInput
    /**
     * In case the Sale found by the `where` argument doesn't exist, create a new Sale with this data.
     */
    create: XOR<SaleCreateInput, SaleUncheckedCreateInput>
    /**
     * In case the Sale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
  }

  /**
   * Sale delete
   */
  export type SaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter which Sale to delete.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale deleteMany
   */
  export type SaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sales to delete
     */
    where?: SaleWhereInput
  }

  /**
   * Sale.customer
   */
  export type Sale$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCustomer
     */
    select?: StoreCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreCustomerInclude<ExtArgs> | null
    where?: StoreCustomerWhereInput
  }

  /**
   * Sale.employee
   */
  export type Sale$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreEmployee
     */
    select?: StoreEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreEmployeeInclude<ExtArgs> | null
    where?: StoreEmployeeWhereInput
  }

  /**
   * Sale.items
   */
  export type Sale$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    where?: SaleItemWhereInput
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    cursor?: SaleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * Sale.payments
   */
  export type Sale$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    where?: SalePaymentWhereInput
    orderBy?: SalePaymentOrderByWithRelationInput | SalePaymentOrderByWithRelationInput[]
    cursor?: SalePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalePaymentScalarFieldEnum | SalePaymentScalarFieldEnum[]
  }

  /**
   * Sale.returns
   */
  export type Sale$returnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturn
     */
    select?: SaleReturnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnInclude<ExtArgs> | null
    where?: SaleReturnWhereInput
    orderBy?: SaleReturnOrderByWithRelationInput | SaleReturnOrderByWithRelationInput[]
    cursor?: SaleReturnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleReturnScalarFieldEnum | SaleReturnScalarFieldEnum[]
  }

  /**
   * Sale without action
   */
  export type SaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
  }


  /**
   * Model SaleItem
   */

  export type AggregateSaleItem = {
    _count: SaleItemCountAggregateOutputType | null
    _avg: SaleItemAvgAggregateOutputType | null
    _sum: SaleItemSumAggregateOutputType | null
    _min: SaleItemMinAggregateOutputType | null
    _max: SaleItemMaxAggregateOutputType | null
  }

  export type SaleItemAvgAggregateOutputType = {
    quantity: Decimal | null
    unitPrice: Decimal | null
    costPrice: Decimal | null
    discount: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
  }

  export type SaleItemSumAggregateOutputType = {
    quantity: Decimal | null
    unitPrice: Decimal | null
    costPrice: Decimal | null
    discount: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
  }

  export type SaleItemMinAggregateOutputType = {
    id: string | null
    saleId: string | null
    productId: string | null
    productName: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    costPrice: Decimal | null
    discount: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
  }

  export type SaleItemMaxAggregateOutputType = {
    id: string | null
    saleId: string | null
    productId: string | null
    productName: string | null
    quantity: Decimal | null
    unitPrice: Decimal | null
    costPrice: Decimal | null
    discount: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
  }

  export type SaleItemCountAggregateOutputType = {
    id: number
    saleId: number
    productId: number
    productName: number
    quantity: number
    unitPrice: number
    costPrice: number
    discount: number
    taxAmount: number
    total: number
    _all: number
  }


  export type SaleItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    costPrice?: true
    discount?: true
    taxAmount?: true
    total?: true
  }

  export type SaleItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    costPrice?: true
    discount?: true
    taxAmount?: true
    total?: true
  }

  export type SaleItemMinAggregateInputType = {
    id?: true
    saleId?: true
    productId?: true
    productName?: true
    quantity?: true
    unitPrice?: true
    costPrice?: true
    discount?: true
    taxAmount?: true
    total?: true
  }

  export type SaleItemMaxAggregateInputType = {
    id?: true
    saleId?: true
    productId?: true
    productName?: true
    quantity?: true
    unitPrice?: true
    costPrice?: true
    discount?: true
    taxAmount?: true
    total?: true
  }

  export type SaleItemCountAggregateInputType = {
    id?: true
    saleId?: true
    productId?: true
    productName?: true
    quantity?: true
    unitPrice?: true
    costPrice?: true
    discount?: true
    taxAmount?: true
    total?: true
    _all?: true
  }

  export type SaleItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleItem to aggregate.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleItems
    **/
    _count?: true | SaleItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleItemMaxAggregateInputType
  }

  export type GetSaleItemAggregateType<T extends SaleItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleItem[P]>
      : GetScalarType<T[P], AggregateSaleItem[P]>
  }




  export type SaleItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleItemWhereInput
    orderBy?: SaleItemOrderByWithAggregationInput | SaleItemOrderByWithAggregationInput[]
    by: SaleItemScalarFieldEnum[] | SaleItemScalarFieldEnum
    having?: SaleItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleItemCountAggregateInputType | true
    _avg?: SaleItemAvgAggregateInputType
    _sum?: SaleItemSumAggregateInputType
    _min?: SaleItemMinAggregateInputType
    _max?: SaleItemMaxAggregateInputType
  }

  export type SaleItemGroupByOutputType = {
    id: string
    saleId: string
    productId: string
    productName: string
    quantity: Decimal
    unitPrice: Decimal
    costPrice: Decimal
    discount: Decimal
    taxAmount: Decimal
    total: Decimal
    _count: SaleItemCountAggregateOutputType | null
    _avg: SaleItemAvgAggregateOutputType | null
    _sum: SaleItemSumAggregateOutputType | null
    _min: SaleItemMinAggregateOutputType | null
    _max: SaleItemMaxAggregateOutputType | null
  }

  type GetSaleItemGroupByPayload<T extends SaleItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleItemGroupByOutputType[P]>
            : GetScalarType<T[P], SaleItemGroupByOutputType[P]>
        }
      >
    >


  export type SaleItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    productId?: boolean
    productName?: boolean
    quantity?: boolean
    unitPrice?: boolean
    costPrice?: boolean
    discount?: boolean
    taxAmount?: boolean
    total?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleItem"]>

  export type SaleItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    productId?: boolean
    productName?: boolean
    quantity?: boolean
    unitPrice?: boolean
    costPrice?: boolean
    discount?: boolean
    taxAmount?: boolean
    total?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleItem"]>

  export type SaleItemSelectScalar = {
    id?: boolean
    saleId?: boolean
    productId?: boolean
    productName?: boolean
    quantity?: boolean
    unitPrice?: boolean
    costPrice?: boolean
    discount?: boolean
    taxAmount?: boolean
    total?: boolean
  }

  export type SaleItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }
  export type SaleItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }

  export type $SaleItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleItem"
    objects: {
      sale: Prisma.$SalePayload<ExtArgs>
      product: Prisma.$StoreProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      saleId: string
      productId: string
      productName: string
      quantity: Prisma.Decimal
      unitPrice: Prisma.Decimal
      costPrice: Prisma.Decimal
      discount: Prisma.Decimal
      taxAmount: Prisma.Decimal
      total: Prisma.Decimal
    }, ExtArgs["result"]["saleItem"]>
    composites: {}
  }

  type SaleItemGetPayload<S extends boolean | null | undefined | SaleItemDefaultArgs> = $Result.GetResult<Prisma.$SaleItemPayload, S>

  type SaleItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SaleItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SaleItemCountAggregateInputType | true
    }

  export interface SaleItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleItem'], meta: { name: 'SaleItem' } }
    /**
     * Find zero or one SaleItem that matches the filter.
     * @param {SaleItemFindUniqueArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleItemFindUniqueArgs>(args: SelectSubset<T, SaleItemFindUniqueArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SaleItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SaleItemFindUniqueOrThrowArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SaleItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemFindFirstArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleItemFindFirstArgs>(args?: SelectSubset<T, SaleItemFindFirstArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SaleItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemFindFirstOrThrowArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SaleItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleItems
     * const saleItems = await prisma.saleItem.findMany()
     * 
     * // Get first 10 SaleItems
     * const saleItems = await prisma.saleItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleItemWithIdOnly = await prisma.saleItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleItemFindManyArgs>(args?: SelectSubset<T, SaleItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SaleItem.
     * @param {SaleItemCreateArgs} args - Arguments to create a SaleItem.
     * @example
     * // Create one SaleItem
     * const SaleItem = await prisma.saleItem.create({
     *   data: {
     *     // ... data to create a SaleItem
     *   }
     * })
     * 
     */
    create<T extends SaleItemCreateArgs>(args: SelectSubset<T, SaleItemCreateArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SaleItems.
     * @param {SaleItemCreateManyArgs} args - Arguments to create many SaleItems.
     * @example
     * // Create many SaleItems
     * const saleItem = await prisma.saleItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleItemCreateManyArgs>(args?: SelectSubset<T, SaleItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleItems and returns the data saved in the database.
     * @param {SaleItemCreateManyAndReturnArgs} args - Arguments to create many SaleItems.
     * @example
     * // Create many SaleItems
     * const saleItem = await prisma.saleItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleItems and only return the `id`
     * const saleItemWithIdOnly = await prisma.saleItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleItemCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SaleItem.
     * @param {SaleItemDeleteArgs} args - Arguments to delete one SaleItem.
     * @example
     * // Delete one SaleItem
     * const SaleItem = await prisma.saleItem.delete({
     *   where: {
     *     // ... filter to delete one SaleItem
     *   }
     * })
     * 
     */
    delete<T extends SaleItemDeleteArgs>(args: SelectSubset<T, SaleItemDeleteArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SaleItem.
     * @param {SaleItemUpdateArgs} args - Arguments to update one SaleItem.
     * @example
     * // Update one SaleItem
     * const saleItem = await prisma.saleItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleItemUpdateArgs>(args: SelectSubset<T, SaleItemUpdateArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SaleItems.
     * @param {SaleItemDeleteManyArgs} args - Arguments to filter SaleItems to delete.
     * @example
     * // Delete a few SaleItems
     * const { count } = await prisma.saleItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleItemDeleteManyArgs>(args?: SelectSubset<T, SaleItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleItems
     * const saleItem = await prisma.saleItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleItemUpdateManyArgs>(args: SelectSubset<T, SaleItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SaleItem.
     * @param {SaleItemUpsertArgs} args - Arguments to update or create a SaleItem.
     * @example
     * // Update or create a SaleItem
     * const saleItem = await prisma.saleItem.upsert({
     *   create: {
     *     // ... data to create a SaleItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleItem we want to update
     *   }
     * })
     */
    upsert<T extends SaleItemUpsertArgs>(args: SelectSubset<T, SaleItemUpsertArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SaleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemCountArgs} args - Arguments to filter SaleItems to count.
     * @example
     * // Count the number of SaleItems
     * const count = await prisma.saleItem.count({
     *   where: {
     *     // ... the filter for the SaleItems we want to count
     *   }
     * })
    **/
    count<T extends SaleItemCountArgs>(
      args?: Subset<T, SaleItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleItemAggregateArgs>(args: Subset<T, SaleItemAggregateArgs>): Prisma.PrismaPromise<GetSaleItemAggregateType<T>>

    /**
     * Group by SaleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleItemGroupByArgs['orderBy'] }
        : { orderBy?: SaleItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleItem model
   */
  readonly fields: SaleItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends StoreProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreProductDefaultArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleItem model
   */ 
  interface SaleItemFieldRefs {
    readonly id: FieldRef<"SaleItem", 'String'>
    readonly saleId: FieldRef<"SaleItem", 'String'>
    readonly productId: FieldRef<"SaleItem", 'String'>
    readonly productName: FieldRef<"SaleItem", 'String'>
    readonly quantity: FieldRef<"SaleItem", 'Decimal'>
    readonly unitPrice: FieldRef<"SaleItem", 'Decimal'>
    readonly costPrice: FieldRef<"SaleItem", 'Decimal'>
    readonly discount: FieldRef<"SaleItem", 'Decimal'>
    readonly taxAmount: FieldRef<"SaleItem", 'Decimal'>
    readonly total: FieldRef<"SaleItem", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * SaleItem findUnique
   */
  export type SaleItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem findUniqueOrThrow
   */
  export type SaleItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem findFirst
   */
  export type SaleItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleItems.
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleItems.
     */
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * SaleItem findFirstOrThrow
   */
  export type SaleItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleItems.
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleItems.
     */
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * SaleItem findMany
   */
  export type SaleItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItems to fetch.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleItems.
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * SaleItem create
   */
  export type SaleItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleItem.
     */
    data: XOR<SaleItemCreateInput, SaleItemUncheckedCreateInput>
  }

  /**
   * SaleItem createMany
   */
  export type SaleItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleItems.
     */
    data: SaleItemCreateManyInput | SaleItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleItem createManyAndReturn
   */
  export type SaleItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SaleItems.
     */
    data: SaleItemCreateManyInput | SaleItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleItem update
   */
  export type SaleItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleItem.
     */
    data: XOR<SaleItemUpdateInput, SaleItemUncheckedUpdateInput>
    /**
     * Choose, which SaleItem to update.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem updateMany
   */
  export type SaleItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleItems.
     */
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyInput>
    /**
     * Filter which SaleItems to update
     */
    where?: SaleItemWhereInput
  }

  /**
   * SaleItem upsert
   */
  export type SaleItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleItem to update in case it exists.
     */
    where: SaleItemWhereUniqueInput
    /**
     * In case the SaleItem found by the `where` argument doesn't exist, create a new SaleItem with this data.
     */
    create: XOR<SaleItemCreateInput, SaleItemUncheckedCreateInput>
    /**
     * In case the SaleItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleItemUpdateInput, SaleItemUncheckedUpdateInput>
  }

  /**
   * SaleItem delete
   */
  export type SaleItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter which SaleItem to delete.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem deleteMany
   */
  export type SaleItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleItems to delete
     */
    where?: SaleItemWhereInput
  }

  /**
   * SaleItem without action
   */
  export type SaleItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
  }


  /**
   * Model SalePayment
   */

  export type AggregateSalePayment = {
    _count: SalePaymentCountAggregateOutputType | null
    _avg: SalePaymentAvgAggregateOutputType | null
    _sum: SalePaymentSumAggregateOutputType | null
    _min: SalePaymentMinAggregateOutputType | null
    _max: SalePaymentMaxAggregateOutputType | null
  }

  export type SalePaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type SalePaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type SalePaymentMinAggregateOutputType = {
    id: string | null
    saleId: string | null
    method: $Enums.PaymentMethod | null
    amount: Decimal | null
    reference: string | null
    createdAt: Date | null
  }

  export type SalePaymentMaxAggregateOutputType = {
    id: string | null
    saleId: string | null
    method: $Enums.PaymentMethod | null
    amount: Decimal | null
    reference: string | null
    createdAt: Date | null
  }

  export type SalePaymentCountAggregateOutputType = {
    id: number
    saleId: number
    method: number
    amount: number
    reference: number
    createdAt: number
    _all: number
  }


  export type SalePaymentAvgAggregateInputType = {
    amount?: true
  }

  export type SalePaymentSumAggregateInputType = {
    amount?: true
  }

  export type SalePaymentMinAggregateInputType = {
    id?: true
    saleId?: true
    method?: true
    amount?: true
    reference?: true
    createdAt?: true
  }

  export type SalePaymentMaxAggregateInputType = {
    id?: true
    saleId?: true
    method?: true
    amount?: true
    reference?: true
    createdAt?: true
  }

  export type SalePaymentCountAggregateInputType = {
    id?: true
    saleId?: true
    method?: true
    amount?: true
    reference?: true
    createdAt?: true
    _all?: true
  }

  export type SalePaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalePayment to aggregate.
     */
    where?: SalePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalePayments to fetch.
     */
    orderBy?: SalePaymentOrderByWithRelationInput | SalePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalePayments
    **/
    _count?: true | SalePaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalePaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalePaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalePaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalePaymentMaxAggregateInputType
  }

  export type GetSalePaymentAggregateType<T extends SalePaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateSalePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalePayment[P]>
      : GetScalarType<T[P], AggregateSalePayment[P]>
  }




  export type SalePaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalePaymentWhereInput
    orderBy?: SalePaymentOrderByWithAggregationInput | SalePaymentOrderByWithAggregationInput[]
    by: SalePaymentScalarFieldEnum[] | SalePaymentScalarFieldEnum
    having?: SalePaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalePaymentCountAggregateInputType | true
    _avg?: SalePaymentAvgAggregateInputType
    _sum?: SalePaymentSumAggregateInputType
    _min?: SalePaymentMinAggregateInputType
    _max?: SalePaymentMaxAggregateInputType
  }

  export type SalePaymentGroupByOutputType = {
    id: string
    saleId: string
    method: $Enums.PaymentMethod
    amount: Decimal
    reference: string | null
    createdAt: Date
    _count: SalePaymentCountAggregateOutputType | null
    _avg: SalePaymentAvgAggregateOutputType | null
    _sum: SalePaymentSumAggregateOutputType | null
    _min: SalePaymentMinAggregateOutputType | null
    _max: SalePaymentMaxAggregateOutputType | null
  }

  type GetSalePaymentGroupByPayload<T extends SalePaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalePaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalePaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalePaymentGroupByOutputType[P]>
            : GetScalarType<T[P], SalePaymentGroupByOutputType[P]>
        }
      >
    >


  export type SalePaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    method?: boolean
    amount?: boolean
    reference?: boolean
    createdAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salePayment"]>

  export type SalePaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    method?: boolean
    amount?: boolean
    reference?: boolean
    createdAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salePayment"]>

  export type SalePaymentSelectScalar = {
    id?: boolean
    saleId?: boolean
    method?: boolean
    amount?: boolean
    reference?: boolean
    createdAt?: boolean
  }

  export type SalePaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }
  export type SalePaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }

  export type $SalePaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalePayment"
    objects: {
      sale: Prisma.$SalePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      saleId: string
      method: $Enums.PaymentMethod
      amount: Prisma.Decimal
      reference: string | null
      createdAt: Date
    }, ExtArgs["result"]["salePayment"]>
    composites: {}
  }

  type SalePaymentGetPayload<S extends boolean | null | undefined | SalePaymentDefaultArgs> = $Result.GetResult<Prisma.$SalePaymentPayload, S>

  type SalePaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SalePaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalePaymentCountAggregateInputType | true
    }

  export interface SalePaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalePayment'], meta: { name: 'SalePayment' } }
    /**
     * Find zero or one SalePayment that matches the filter.
     * @param {SalePaymentFindUniqueArgs} args - Arguments to find a SalePayment
     * @example
     * // Get one SalePayment
     * const salePayment = await prisma.salePayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalePaymentFindUniqueArgs>(args: SelectSubset<T, SalePaymentFindUniqueArgs<ExtArgs>>): Prisma__SalePaymentClient<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SalePayment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SalePaymentFindUniqueOrThrowArgs} args - Arguments to find a SalePayment
     * @example
     * // Get one SalePayment
     * const salePayment = await prisma.salePayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalePaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, SalePaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalePaymentClient<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SalePayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalePaymentFindFirstArgs} args - Arguments to find a SalePayment
     * @example
     * // Get one SalePayment
     * const salePayment = await prisma.salePayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalePaymentFindFirstArgs>(args?: SelectSubset<T, SalePaymentFindFirstArgs<ExtArgs>>): Prisma__SalePaymentClient<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SalePayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalePaymentFindFirstOrThrowArgs} args - Arguments to find a SalePayment
     * @example
     * // Get one SalePayment
     * const salePayment = await prisma.salePayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalePaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, SalePaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalePaymentClient<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SalePayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalePaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalePayments
     * const salePayments = await prisma.salePayment.findMany()
     * 
     * // Get first 10 SalePayments
     * const salePayments = await prisma.salePayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salePaymentWithIdOnly = await prisma.salePayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalePaymentFindManyArgs>(args?: SelectSubset<T, SalePaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SalePayment.
     * @param {SalePaymentCreateArgs} args - Arguments to create a SalePayment.
     * @example
     * // Create one SalePayment
     * const SalePayment = await prisma.salePayment.create({
     *   data: {
     *     // ... data to create a SalePayment
     *   }
     * })
     * 
     */
    create<T extends SalePaymentCreateArgs>(args: SelectSubset<T, SalePaymentCreateArgs<ExtArgs>>): Prisma__SalePaymentClient<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SalePayments.
     * @param {SalePaymentCreateManyArgs} args - Arguments to create many SalePayments.
     * @example
     * // Create many SalePayments
     * const salePayment = await prisma.salePayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalePaymentCreateManyArgs>(args?: SelectSubset<T, SalePaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalePayments and returns the data saved in the database.
     * @param {SalePaymentCreateManyAndReturnArgs} args - Arguments to create many SalePayments.
     * @example
     * // Create many SalePayments
     * const salePayment = await prisma.salePayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalePayments and only return the `id`
     * const salePaymentWithIdOnly = await prisma.salePayment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalePaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, SalePaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SalePayment.
     * @param {SalePaymentDeleteArgs} args - Arguments to delete one SalePayment.
     * @example
     * // Delete one SalePayment
     * const SalePayment = await prisma.salePayment.delete({
     *   where: {
     *     // ... filter to delete one SalePayment
     *   }
     * })
     * 
     */
    delete<T extends SalePaymentDeleteArgs>(args: SelectSubset<T, SalePaymentDeleteArgs<ExtArgs>>): Prisma__SalePaymentClient<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SalePayment.
     * @param {SalePaymentUpdateArgs} args - Arguments to update one SalePayment.
     * @example
     * // Update one SalePayment
     * const salePayment = await prisma.salePayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalePaymentUpdateArgs>(args: SelectSubset<T, SalePaymentUpdateArgs<ExtArgs>>): Prisma__SalePaymentClient<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SalePayments.
     * @param {SalePaymentDeleteManyArgs} args - Arguments to filter SalePayments to delete.
     * @example
     * // Delete a few SalePayments
     * const { count } = await prisma.salePayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalePaymentDeleteManyArgs>(args?: SelectSubset<T, SalePaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalePaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalePayments
     * const salePayment = await prisma.salePayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalePaymentUpdateManyArgs>(args: SelectSubset<T, SalePaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalePayment.
     * @param {SalePaymentUpsertArgs} args - Arguments to update or create a SalePayment.
     * @example
     * // Update or create a SalePayment
     * const salePayment = await prisma.salePayment.upsert({
     *   create: {
     *     // ... data to create a SalePayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalePayment we want to update
     *   }
     * })
     */
    upsert<T extends SalePaymentUpsertArgs>(args: SelectSubset<T, SalePaymentUpsertArgs<ExtArgs>>): Prisma__SalePaymentClient<$Result.GetResult<Prisma.$SalePaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SalePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalePaymentCountArgs} args - Arguments to filter SalePayments to count.
     * @example
     * // Count the number of SalePayments
     * const count = await prisma.salePayment.count({
     *   where: {
     *     // ... the filter for the SalePayments we want to count
     *   }
     * })
    **/
    count<T extends SalePaymentCountArgs>(
      args?: Subset<T, SalePaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalePaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalePaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalePaymentAggregateArgs>(args: Subset<T, SalePaymentAggregateArgs>): Prisma.PrismaPromise<GetSalePaymentAggregateType<T>>

    /**
     * Group by SalePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalePaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalePaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalePaymentGroupByArgs['orderBy'] }
        : { orderBy?: SalePaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalePaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalePaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalePayment model
   */
  readonly fields: SalePaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalePayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalePaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalePayment model
   */ 
  interface SalePaymentFieldRefs {
    readonly id: FieldRef<"SalePayment", 'String'>
    readonly saleId: FieldRef<"SalePayment", 'String'>
    readonly method: FieldRef<"SalePayment", 'PaymentMethod'>
    readonly amount: FieldRef<"SalePayment", 'Decimal'>
    readonly reference: FieldRef<"SalePayment", 'String'>
    readonly createdAt: FieldRef<"SalePayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalePayment findUnique
   */
  export type SalePaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalePayment to fetch.
     */
    where: SalePaymentWhereUniqueInput
  }

  /**
   * SalePayment findUniqueOrThrow
   */
  export type SalePaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalePayment to fetch.
     */
    where: SalePaymentWhereUniqueInput
  }

  /**
   * SalePayment findFirst
   */
  export type SalePaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalePayment to fetch.
     */
    where?: SalePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalePayments to fetch.
     */
    orderBy?: SalePaymentOrderByWithRelationInput | SalePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalePayments.
     */
    cursor?: SalePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalePayments.
     */
    distinct?: SalePaymentScalarFieldEnum | SalePaymentScalarFieldEnum[]
  }

  /**
   * SalePayment findFirstOrThrow
   */
  export type SalePaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalePayment to fetch.
     */
    where?: SalePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalePayments to fetch.
     */
    orderBy?: SalePaymentOrderByWithRelationInput | SalePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalePayments.
     */
    cursor?: SalePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalePayments.
     */
    distinct?: SalePaymentScalarFieldEnum | SalePaymentScalarFieldEnum[]
  }

  /**
   * SalePayment findMany
   */
  export type SalePaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalePayments to fetch.
     */
    where?: SalePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalePayments to fetch.
     */
    orderBy?: SalePaymentOrderByWithRelationInput | SalePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalePayments.
     */
    cursor?: SalePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalePayments.
     */
    skip?: number
    distinct?: SalePaymentScalarFieldEnum | SalePaymentScalarFieldEnum[]
  }

  /**
   * SalePayment create
   */
  export type SalePaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a SalePayment.
     */
    data: XOR<SalePaymentCreateInput, SalePaymentUncheckedCreateInput>
  }

  /**
   * SalePayment createMany
   */
  export type SalePaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalePayments.
     */
    data: SalePaymentCreateManyInput | SalePaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalePayment createManyAndReturn
   */
  export type SalePaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SalePayments.
     */
    data: SalePaymentCreateManyInput | SalePaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalePayment update
   */
  export type SalePaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a SalePayment.
     */
    data: XOR<SalePaymentUpdateInput, SalePaymentUncheckedUpdateInput>
    /**
     * Choose, which SalePayment to update.
     */
    where: SalePaymentWhereUniqueInput
  }

  /**
   * SalePayment updateMany
   */
  export type SalePaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalePayments.
     */
    data: XOR<SalePaymentUpdateManyMutationInput, SalePaymentUncheckedUpdateManyInput>
    /**
     * Filter which SalePayments to update
     */
    where?: SalePaymentWhereInput
  }

  /**
   * SalePayment upsert
   */
  export type SalePaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the SalePayment to update in case it exists.
     */
    where: SalePaymentWhereUniqueInput
    /**
     * In case the SalePayment found by the `where` argument doesn't exist, create a new SalePayment with this data.
     */
    create: XOR<SalePaymentCreateInput, SalePaymentUncheckedCreateInput>
    /**
     * In case the SalePayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalePaymentUpdateInput, SalePaymentUncheckedUpdateInput>
  }

  /**
   * SalePayment delete
   */
  export type SalePaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
    /**
     * Filter which SalePayment to delete.
     */
    where: SalePaymentWhereUniqueInput
  }

  /**
   * SalePayment deleteMany
   */
  export type SalePaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalePayments to delete
     */
    where?: SalePaymentWhereInput
  }

  /**
   * SalePayment without action
   */
  export type SalePaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalePayment
     */
    select?: SalePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalePaymentInclude<ExtArgs> | null
  }


  /**
   * Model SaleReturn
   */

  export type AggregateSaleReturn = {
    _count: SaleReturnCountAggregateOutputType | null
    _avg: SaleReturnAvgAggregateOutputType | null
    _sum: SaleReturnSumAggregateOutputType | null
    _min: SaleReturnMinAggregateOutputType | null
    _max: SaleReturnMaxAggregateOutputType | null
  }

  export type SaleReturnAvgAggregateOutputType = {
    refundAmount: Decimal | null
  }

  export type SaleReturnSumAggregateOutputType = {
    refundAmount: Decimal | null
  }

  export type SaleReturnMinAggregateOutputType = {
    id: string | null
    saleId: string | null
    reason: string | null
    refundAmount: Decimal | null
    refundMethod: $Enums.PaymentMethod | null
    status: $Enums.StoreReturnStatus | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type SaleReturnMaxAggregateOutputType = {
    id: string | null
    saleId: string | null
    reason: string | null
    refundAmount: Decimal | null
    refundMethod: $Enums.PaymentMethod | null
    status: $Enums.StoreReturnStatus | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type SaleReturnCountAggregateOutputType = {
    id: number
    saleId: number
    reason: number
    refundAmount: number
    refundMethod: number
    status: number
    createdAt: number
    processedAt: number
    _all: number
  }


  export type SaleReturnAvgAggregateInputType = {
    refundAmount?: true
  }

  export type SaleReturnSumAggregateInputType = {
    refundAmount?: true
  }

  export type SaleReturnMinAggregateInputType = {
    id?: true
    saleId?: true
    reason?: true
    refundAmount?: true
    refundMethod?: true
    status?: true
    createdAt?: true
    processedAt?: true
  }

  export type SaleReturnMaxAggregateInputType = {
    id?: true
    saleId?: true
    reason?: true
    refundAmount?: true
    refundMethod?: true
    status?: true
    createdAt?: true
    processedAt?: true
  }

  export type SaleReturnCountAggregateInputType = {
    id?: true
    saleId?: true
    reason?: true
    refundAmount?: true
    refundMethod?: true
    status?: true
    createdAt?: true
    processedAt?: true
    _all?: true
  }

  export type SaleReturnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleReturn to aggregate.
     */
    where?: SaleReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleReturns to fetch.
     */
    orderBy?: SaleReturnOrderByWithRelationInput | SaleReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleReturns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleReturns
    **/
    _count?: true | SaleReturnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleReturnAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleReturnSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleReturnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleReturnMaxAggregateInputType
  }

  export type GetSaleReturnAggregateType<T extends SaleReturnAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleReturn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleReturn[P]>
      : GetScalarType<T[P], AggregateSaleReturn[P]>
  }




  export type SaleReturnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleReturnWhereInput
    orderBy?: SaleReturnOrderByWithAggregationInput | SaleReturnOrderByWithAggregationInput[]
    by: SaleReturnScalarFieldEnum[] | SaleReturnScalarFieldEnum
    having?: SaleReturnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleReturnCountAggregateInputType | true
    _avg?: SaleReturnAvgAggregateInputType
    _sum?: SaleReturnSumAggregateInputType
    _min?: SaleReturnMinAggregateInputType
    _max?: SaleReturnMaxAggregateInputType
  }

  export type SaleReturnGroupByOutputType = {
    id: string
    saleId: string
    reason: string
    refundAmount: Decimal
    refundMethod: $Enums.PaymentMethod
    status: $Enums.StoreReturnStatus
    createdAt: Date
    processedAt: Date | null
    _count: SaleReturnCountAggregateOutputType | null
    _avg: SaleReturnAvgAggregateOutputType | null
    _sum: SaleReturnSumAggregateOutputType | null
    _min: SaleReturnMinAggregateOutputType | null
    _max: SaleReturnMaxAggregateOutputType | null
  }

  type GetSaleReturnGroupByPayload<T extends SaleReturnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleReturnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleReturnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleReturnGroupByOutputType[P]>
            : GetScalarType<T[P], SaleReturnGroupByOutputType[P]>
        }
      >
    >


  export type SaleReturnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    reason?: boolean
    refundAmount?: boolean
    refundMethod?: boolean
    status?: boolean
    createdAt?: boolean
    processedAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    items?: boolean | SaleReturn$itemsArgs<ExtArgs>
    _count?: boolean | SaleReturnCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleReturn"]>

  export type SaleReturnSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    reason?: boolean
    refundAmount?: boolean
    refundMethod?: boolean
    status?: boolean
    createdAt?: boolean
    processedAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleReturn"]>

  export type SaleReturnSelectScalar = {
    id?: boolean
    saleId?: boolean
    reason?: boolean
    refundAmount?: boolean
    refundMethod?: boolean
    status?: boolean
    createdAt?: boolean
    processedAt?: boolean
  }

  export type SaleReturnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    items?: boolean | SaleReturn$itemsArgs<ExtArgs>
    _count?: boolean | SaleReturnCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SaleReturnIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }

  export type $SaleReturnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleReturn"
    objects: {
      sale: Prisma.$SalePayload<ExtArgs>
      items: Prisma.$SaleReturnItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      saleId: string
      reason: string
      refundAmount: Prisma.Decimal
      refundMethod: $Enums.PaymentMethod
      status: $Enums.StoreReturnStatus
      createdAt: Date
      processedAt: Date | null
    }, ExtArgs["result"]["saleReturn"]>
    composites: {}
  }

  type SaleReturnGetPayload<S extends boolean | null | undefined | SaleReturnDefaultArgs> = $Result.GetResult<Prisma.$SaleReturnPayload, S>

  type SaleReturnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SaleReturnFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SaleReturnCountAggregateInputType | true
    }

  export interface SaleReturnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleReturn'], meta: { name: 'SaleReturn' } }
    /**
     * Find zero or one SaleReturn that matches the filter.
     * @param {SaleReturnFindUniqueArgs} args - Arguments to find a SaleReturn
     * @example
     * // Get one SaleReturn
     * const saleReturn = await prisma.saleReturn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleReturnFindUniqueArgs>(args: SelectSubset<T, SaleReturnFindUniqueArgs<ExtArgs>>): Prisma__SaleReturnClient<$Result.GetResult<Prisma.$SaleReturnPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SaleReturn that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SaleReturnFindUniqueOrThrowArgs} args - Arguments to find a SaleReturn
     * @example
     * // Get one SaleReturn
     * const saleReturn = await prisma.saleReturn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleReturnFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleReturnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleReturnClient<$Result.GetResult<Prisma.$SaleReturnPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SaleReturn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleReturnFindFirstArgs} args - Arguments to find a SaleReturn
     * @example
     * // Get one SaleReturn
     * const saleReturn = await prisma.saleReturn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleReturnFindFirstArgs>(args?: SelectSubset<T, SaleReturnFindFirstArgs<ExtArgs>>): Prisma__SaleReturnClient<$Result.GetResult<Prisma.$SaleReturnPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SaleReturn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleReturnFindFirstOrThrowArgs} args - Arguments to find a SaleReturn
     * @example
     * // Get one SaleReturn
     * const saleReturn = await prisma.saleReturn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleReturnFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleReturnFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleReturnClient<$Result.GetResult<Prisma.$SaleReturnPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SaleReturns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleReturnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleReturns
     * const saleReturns = await prisma.saleReturn.findMany()
     * 
     * // Get first 10 SaleReturns
     * const saleReturns = await prisma.saleReturn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleReturnWithIdOnly = await prisma.saleReturn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleReturnFindManyArgs>(args?: SelectSubset<T, SaleReturnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleReturnPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SaleReturn.
     * @param {SaleReturnCreateArgs} args - Arguments to create a SaleReturn.
     * @example
     * // Create one SaleReturn
     * const SaleReturn = await prisma.saleReturn.create({
     *   data: {
     *     // ... data to create a SaleReturn
     *   }
     * })
     * 
     */
    create<T extends SaleReturnCreateArgs>(args: SelectSubset<T, SaleReturnCreateArgs<ExtArgs>>): Prisma__SaleReturnClient<$Result.GetResult<Prisma.$SaleReturnPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SaleReturns.
     * @param {SaleReturnCreateManyArgs} args - Arguments to create many SaleReturns.
     * @example
     * // Create many SaleReturns
     * const saleReturn = await prisma.saleReturn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleReturnCreateManyArgs>(args?: SelectSubset<T, SaleReturnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleReturns and returns the data saved in the database.
     * @param {SaleReturnCreateManyAndReturnArgs} args - Arguments to create many SaleReturns.
     * @example
     * // Create many SaleReturns
     * const saleReturn = await prisma.saleReturn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleReturns and only return the `id`
     * const saleReturnWithIdOnly = await prisma.saleReturn.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleReturnCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleReturnCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleReturnPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SaleReturn.
     * @param {SaleReturnDeleteArgs} args - Arguments to delete one SaleReturn.
     * @example
     * // Delete one SaleReturn
     * const SaleReturn = await prisma.saleReturn.delete({
     *   where: {
     *     // ... filter to delete one SaleReturn
     *   }
     * })
     * 
     */
    delete<T extends SaleReturnDeleteArgs>(args: SelectSubset<T, SaleReturnDeleteArgs<ExtArgs>>): Prisma__SaleReturnClient<$Result.GetResult<Prisma.$SaleReturnPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SaleReturn.
     * @param {SaleReturnUpdateArgs} args - Arguments to update one SaleReturn.
     * @example
     * // Update one SaleReturn
     * const saleReturn = await prisma.saleReturn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleReturnUpdateArgs>(args: SelectSubset<T, SaleReturnUpdateArgs<ExtArgs>>): Prisma__SaleReturnClient<$Result.GetResult<Prisma.$SaleReturnPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SaleReturns.
     * @param {SaleReturnDeleteManyArgs} args - Arguments to filter SaleReturns to delete.
     * @example
     * // Delete a few SaleReturns
     * const { count } = await prisma.saleReturn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleReturnDeleteManyArgs>(args?: SelectSubset<T, SaleReturnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleReturns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleReturnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleReturns
     * const saleReturn = await prisma.saleReturn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleReturnUpdateManyArgs>(args: SelectSubset<T, SaleReturnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SaleReturn.
     * @param {SaleReturnUpsertArgs} args - Arguments to update or create a SaleReturn.
     * @example
     * // Update or create a SaleReturn
     * const saleReturn = await prisma.saleReturn.upsert({
     *   create: {
     *     // ... data to create a SaleReturn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleReturn we want to update
     *   }
     * })
     */
    upsert<T extends SaleReturnUpsertArgs>(args: SelectSubset<T, SaleReturnUpsertArgs<ExtArgs>>): Prisma__SaleReturnClient<$Result.GetResult<Prisma.$SaleReturnPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SaleReturns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleReturnCountArgs} args - Arguments to filter SaleReturns to count.
     * @example
     * // Count the number of SaleReturns
     * const count = await prisma.saleReturn.count({
     *   where: {
     *     // ... the filter for the SaleReturns we want to count
     *   }
     * })
    **/
    count<T extends SaleReturnCountArgs>(
      args?: Subset<T, SaleReturnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleReturnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleReturn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleReturnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleReturnAggregateArgs>(args: Subset<T, SaleReturnAggregateArgs>): Prisma.PrismaPromise<GetSaleReturnAggregateType<T>>

    /**
     * Group by SaleReturn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleReturnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleReturnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleReturnGroupByArgs['orderBy'] }
        : { orderBy?: SaleReturnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleReturnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleReturnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleReturn model
   */
  readonly fields: SaleReturnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleReturn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleReturnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends SaleReturn$itemsArgs<ExtArgs> = {}>(args?: Subset<T, SaleReturn$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleReturnItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleReturn model
   */ 
  interface SaleReturnFieldRefs {
    readonly id: FieldRef<"SaleReturn", 'String'>
    readonly saleId: FieldRef<"SaleReturn", 'String'>
    readonly reason: FieldRef<"SaleReturn", 'String'>
    readonly refundAmount: FieldRef<"SaleReturn", 'Decimal'>
    readonly refundMethod: FieldRef<"SaleReturn", 'PaymentMethod'>
    readonly status: FieldRef<"SaleReturn", 'StoreReturnStatus'>
    readonly createdAt: FieldRef<"SaleReturn", 'DateTime'>
    readonly processedAt: FieldRef<"SaleReturn", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SaleReturn findUnique
   */
  export type SaleReturnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturn
     */
    select?: SaleReturnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnInclude<ExtArgs> | null
    /**
     * Filter, which SaleReturn to fetch.
     */
    where: SaleReturnWhereUniqueInput
  }

  /**
   * SaleReturn findUniqueOrThrow
   */
  export type SaleReturnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturn
     */
    select?: SaleReturnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnInclude<ExtArgs> | null
    /**
     * Filter, which SaleReturn to fetch.
     */
    where: SaleReturnWhereUniqueInput
  }

  /**
   * SaleReturn findFirst
   */
  export type SaleReturnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturn
     */
    select?: SaleReturnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnInclude<ExtArgs> | null
    /**
     * Filter, which SaleReturn to fetch.
     */
    where?: SaleReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleReturns to fetch.
     */
    orderBy?: SaleReturnOrderByWithRelationInput | SaleReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleReturns.
     */
    cursor?: SaleReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleReturns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleReturns.
     */
    distinct?: SaleReturnScalarFieldEnum | SaleReturnScalarFieldEnum[]
  }

  /**
   * SaleReturn findFirstOrThrow
   */
  export type SaleReturnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturn
     */
    select?: SaleReturnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnInclude<ExtArgs> | null
    /**
     * Filter, which SaleReturn to fetch.
     */
    where?: SaleReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleReturns to fetch.
     */
    orderBy?: SaleReturnOrderByWithRelationInput | SaleReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleReturns.
     */
    cursor?: SaleReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleReturns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleReturns.
     */
    distinct?: SaleReturnScalarFieldEnum | SaleReturnScalarFieldEnum[]
  }

  /**
   * SaleReturn findMany
   */
  export type SaleReturnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturn
     */
    select?: SaleReturnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnInclude<ExtArgs> | null
    /**
     * Filter, which SaleReturns to fetch.
     */
    where?: SaleReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleReturns to fetch.
     */
    orderBy?: SaleReturnOrderByWithRelationInput | SaleReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleReturns.
     */
    cursor?: SaleReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleReturns.
     */
    skip?: number
    distinct?: SaleReturnScalarFieldEnum | SaleReturnScalarFieldEnum[]
  }

  /**
   * SaleReturn create
   */
  export type SaleReturnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturn
     */
    select?: SaleReturnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleReturn.
     */
    data: XOR<SaleReturnCreateInput, SaleReturnUncheckedCreateInput>
  }

  /**
   * SaleReturn createMany
   */
  export type SaleReturnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleReturns.
     */
    data: SaleReturnCreateManyInput | SaleReturnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleReturn createManyAndReturn
   */
  export type SaleReturnCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturn
     */
    select?: SaleReturnSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SaleReturns.
     */
    data: SaleReturnCreateManyInput | SaleReturnCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleReturn update
   */
  export type SaleReturnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturn
     */
    select?: SaleReturnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleReturn.
     */
    data: XOR<SaleReturnUpdateInput, SaleReturnUncheckedUpdateInput>
    /**
     * Choose, which SaleReturn to update.
     */
    where: SaleReturnWhereUniqueInput
  }

  /**
   * SaleReturn updateMany
   */
  export type SaleReturnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleReturns.
     */
    data: XOR<SaleReturnUpdateManyMutationInput, SaleReturnUncheckedUpdateManyInput>
    /**
     * Filter which SaleReturns to update
     */
    where?: SaleReturnWhereInput
  }

  /**
   * SaleReturn upsert
   */
  export type SaleReturnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturn
     */
    select?: SaleReturnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleReturn to update in case it exists.
     */
    where: SaleReturnWhereUniqueInput
    /**
     * In case the SaleReturn found by the `where` argument doesn't exist, create a new SaleReturn with this data.
     */
    create: XOR<SaleReturnCreateInput, SaleReturnUncheckedCreateInput>
    /**
     * In case the SaleReturn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleReturnUpdateInput, SaleReturnUncheckedUpdateInput>
  }

  /**
   * SaleReturn delete
   */
  export type SaleReturnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturn
     */
    select?: SaleReturnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnInclude<ExtArgs> | null
    /**
     * Filter which SaleReturn to delete.
     */
    where: SaleReturnWhereUniqueInput
  }

  /**
   * SaleReturn deleteMany
   */
  export type SaleReturnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleReturns to delete
     */
    where?: SaleReturnWhereInput
  }

  /**
   * SaleReturn.items
   */
  export type SaleReturn$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturnItem
     */
    select?: SaleReturnItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnItemInclude<ExtArgs> | null
    where?: SaleReturnItemWhereInput
    orderBy?: SaleReturnItemOrderByWithRelationInput | SaleReturnItemOrderByWithRelationInput[]
    cursor?: SaleReturnItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleReturnItemScalarFieldEnum | SaleReturnItemScalarFieldEnum[]
  }

  /**
   * SaleReturn without action
   */
  export type SaleReturnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturn
     */
    select?: SaleReturnSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnInclude<ExtArgs> | null
  }


  /**
   * Model SaleReturnItem
   */

  export type AggregateSaleReturnItem = {
    _count: SaleReturnItemCountAggregateOutputType | null
    _avg: SaleReturnItemAvgAggregateOutputType | null
    _sum: SaleReturnItemSumAggregateOutputType | null
    _min: SaleReturnItemMinAggregateOutputType | null
    _max: SaleReturnItemMaxAggregateOutputType | null
  }

  export type SaleReturnItemAvgAggregateOutputType = {
    quantity: Decimal | null
    refundAmount: Decimal | null
  }

  export type SaleReturnItemSumAggregateOutputType = {
    quantity: Decimal | null
    refundAmount: Decimal | null
  }

  export type SaleReturnItemMinAggregateOutputType = {
    id: string | null
    returnId: string | null
    productId: string | null
    quantity: Decimal | null
    refundAmount: Decimal | null
  }

  export type SaleReturnItemMaxAggregateOutputType = {
    id: string | null
    returnId: string | null
    productId: string | null
    quantity: Decimal | null
    refundAmount: Decimal | null
  }

  export type SaleReturnItemCountAggregateOutputType = {
    id: number
    returnId: number
    productId: number
    quantity: number
    refundAmount: number
    _all: number
  }


  export type SaleReturnItemAvgAggregateInputType = {
    quantity?: true
    refundAmount?: true
  }

  export type SaleReturnItemSumAggregateInputType = {
    quantity?: true
    refundAmount?: true
  }

  export type SaleReturnItemMinAggregateInputType = {
    id?: true
    returnId?: true
    productId?: true
    quantity?: true
    refundAmount?: true
  }

  export type SaleReturnItemMaxAggregateInputType = {
    id?: true
    returnId?: true
    productId?: true
    quantity?: true
    refundAmount?: true
  }

  export type SaleReturnItemCountAggregateInputType = {
    id?: true
    returnId?: true
    productId?: true
    quantity?: true
    refundAmount?: true
    _all?: true
  }

  export type SaleReturnItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleReturnItem to aggregate.
     */
    where?: SaleReturnItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleReturnItems to fetch.
     */
    orderBy?: SaleReturnItemOrderByWithRelationInput | SaleReturnItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleReturnItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleReturnItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleReturnItems
    **/
    _count?: true | SaleReturnItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleReturnItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleReturnItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleReturnItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleReturnItemMaxAggregateInputType
  }

  export type GetSaleReturnItemAggregateType<T extends SaleReturnItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleReturnItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleReturnItem[P]>
      : GetScalarType<T[P], AggregateSaleReturnItem[P]>
  }




  export type SaleReturnItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleReturnItemWhereInput
    orderBy?: SaleReturnItemOrderByWithAggregationInput | SaleReturnItemOrderByWithAggregationInput[]
    by: SaleReturnItemScalarFieldEnum[] | SaleReturnItemScalarFieldEnum
    having?: SaleReturnItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleReturnItemCountAggregateInputType | true
    _avg?: SaleReturnItemAvgAggregateInputType
    _sum?: SaleReturnItemSumAggregateInputType
    _min?: SaleReturnItemMinAggregateInputType
    _max?: SaleReturnItemMaxAggregateInputType
  }

  export type SaleReturnItemGroupByOutputType = {
    id: string
    returnId: string
    productId: string
    quantity: Decimal
    refundAmount: Decimal
    _count: SaleReturnItemCountAggregateOutputType | null
    _avg: SaleReturnItemAvgAggregateOutputType | null
    _sum: SaleReturnItemSumAggregateOutputType | null
    _min: SaleReturnItemMinAggregateOutputType | null
    _max: SaleReturnItemMaxAggregateOutputType | null
  }

  type GetSaleReturnItemGroupByPayload<T extends SaleReturnItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleReturnItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleReturnItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleReturnItemGroupByOutputType[P]>
            : GetScalarType<T[P], SaleReturnItemGroupByOutputType[P]>
        }
      >
    >


  export type SaleReturnItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnId?: boolean
    productId?: boolean
    quantity?: boolean
    refundAmount?: boolean
    saleReturn?: boolean | SaleReturnDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleReturnItem"]>

  export type SaleReturnItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnId?: boolean
    productId?: boolean
    quantity?: boolean
    refundAmount?: boolean
    saleReturn?: boolean | SaleReturnDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleReturnItem"]>

  export type SaleReturnItemSelectScalar = {
    id?: boolean
    returnId?: boolean
    productId?: boolean
    quantity?: boolean
    refundAmount?: boolean
  }

  export type SaleReturnItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saleReturn?: boolean | SaleReturnDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }
  export type SaleReturnItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saleReturn?: boolean | SaleReturnDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }

  export type $SaleReturnItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleReturnItem"
    objects: {
      saleReturn: Prisma.$SaleReturnPayload<ExtArgs>
      product: Prisma.$StoreProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      returnId: string
      productId: string
      quantity: Prisma.Decimal
      refundAmount: Prisma.Decimal
    }, ExtArgs["result"]["saleReturnItem"]>
    composites: {}
  }

  type SaleReturnItemGetPayload<S extends boolean | null | undefined | SaleReturnItemDefaultArgs> = $Result.GetResult<Prisma.$SaleReturnItemPayload, S>

  type SaleReturnItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SaleReturnItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SaleReturnItemCountAggregateInputType | true
    }

  export interface SaleReturnItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleReturnItem'], meta: { name: 'SaleReturnItem' } }
    /**
     * Find zero or one SaleReturnItem that matches the filter.
     * @param {SaleReturnItemFindUniqueArgs} args - Arguments to find a SaleReturnItem
     * @example
     * // Get one SaleReturnItem
     * const saleReturnItem = await prisma.saleReturnItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleReturnItemFindUniqueArgs>(args: SelectSubset<T, SaleReturnItemFindUniqueArgs<ExtArgs>>): Prisma__SaleReturnItemClient<$Result.GetResult<Prisma.$SaleReturnItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SaleReturnItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SaleReturnItemFindUniqueOrThrowArgs} args - Arguments to find a SaleReturnItem
     * @example
     * // Get one SaleReturnItem
     * const saleReturnItem = await prisma.saleReturnItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleReturnItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleReturnItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleReturnItemClient<$Result.GetResult<Prisma.$SaleReturnItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SaleReturnItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleReturnItemFindFirstArgs} args - Arguments to find a SaleReturnItem
     * @example
     * // Get one SaleReturnItem
     * const saleReturnItem = await prisma.saleReturnItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleReturnItemFindFirstArgs>(args?: SelectSubset<T, SaleReturnItemFindFirstArgs<ExtArgs>>): Prisma__SaleReturnItemClient<$Result.GetResult<Prisma.$SaleReturnItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SaleReturnItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleReturnItemFindFirstOrThrowArgs} args - Arguments to find a SaleReturnItem
     * @example
     * // Get one SaleReturnItem
     * const saleReturnItem = await prisma.saleReturnItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleReturnItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleReturnItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleReturnItemClient<$Result.GetResult<Prisma.$SaleReturnItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SaleReturnItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleReturnItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleReturnItems
     * const saleReturnItems = await prisma.saleReturnItem.findMany()
     * 
     * // Get first 10 SaleReturnItems
     * const saleReturnItems = await prisma.saleReturnItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleReturnItemWithIdOnly = await prisma.saleReturnItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleReturnItemFindManyArgs>(args?: SelectSubset<T, SaleReturnItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleReturnItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SaleReturnItem.
     * @param {SaleReturnItemCreateArgs} args - Arguments to create a SaleReturnItem.
     * @example
     * // Create one SaleReturnItem
     * const SaleReturnItem = await prisma.saleReturnItem.create({
     *   data: {
     *     // ... data to create a SaleReturnItem
     *   }
     * })
     * 
     */
    create<T extends SaleReturnItemCreateArgs>(args: SelectSubset<T, SaleReturnItemCreateArgs<ExtArgs>>): Prisma__SaleReturnItemClient<$Result.GetResult<Prisma.$SaleReturnItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SaleReturnItems.
     * @param {SaleReturnItemCreateManyArgs} args - Arguments to create many SaleReturnItems.
     * @example
     * // Create many SaleReturnItems
     * const saleReturnItem = await prisma.saleReturnItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleReturnItemCreateManyArgs>(args?: SelectSubset<T, SaleReturnItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleReturnItems and returns the data saved in the database.
     * @param {SaleReturnItemCreateManyAndReturnArgs} args - Arguments to create many SaleReturnItems.
     * @example
     * // Create many SaleReturnItems
     * const saleReturnItem = await prisma.saleReturnItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleReturnItems and only return the `id`
     * const saleReturnItemWithIdOnly = await prisma.saleReturnItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleReturnItemCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleReturnItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleReturnItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SaleReturnItem.
     * @param {SaleReturnItemDeleteArgs} args - Arguments to delete one SaleReturnItem.
     * @example
     * // Delete one SaleReturnItem
     * const SaleReturnItem = await prisma.saleReturnItem.delete({
     *   where: {
     *     // ... filter to delete one SaleReturnItem
     *   }
     * })
     * 
     */
    delete<T extends SaleReturnItemDeleteArgs>(args: SelectSubset<T, SaleReturnItemDeleteArgs<ExtArgs>>): Prisma__SaleReturnItemClient<$Result.GetResult<Prisma.$SaleReturnItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SaleReturnItem.
     * @param {SaleReturnItemUpdateArgs} args - Arguments to update one SaleReturnItem.
     * @example
     * // Update one SaleReturnItem
     * const saleReturnItem = await prisma.saleReturnItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleReturnItemUpdateArgs>(args: SelectSubset<T, SaleReturnItemUpdateArgs<ExtArgs>>): Prisma__SaleReturnItemClient<$Result.GetResult<Prisma.$SaleReturnItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SaleReturnItems.
     * @param {SaleReturnItemDeleteManyArgs} args - Arguments to filter SaleReturnItems to delete.
     * @example
     * // Delete a few SaleReturnItems
     * const { count } = await prisma.saleReturnItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleReturnItemDeleteManyArgs>(args?: SelectSubset<T, SaleReturnItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleReturnItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleReturnItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleReturnItems
     * const saleReturnItem = await prisma.saleReturnItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleReturnItemUpdateManyArgs>(args: SelectSubset<T, SaleReturnItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SaleReturnItem.
     * @param {SaleReturnItemUpsertArgs} args - Arguments to update or create a SaleReturnItem.
     * @example
     * // Update or create a SaleReturnItem
     * const saleReturnItem = await prisma.saleReturnItem.upsert({
     *   create: {
     *     // ... data to create a SaleReturnItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleReturnItem we want to update
     *   }
     * })
     */
    upsert<T extends SaleReturnItemUpsertArgs>(args: SelectSubset<T, SaleReturnItemUpsertArgs<ExtArgs>>): Prisma__SaleReturnItemClient<$Result.GetResult<Prisma.$SaleReturnItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SaleReturnItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleReturnItemCountArgs} args - Arguments to filter SaleReturnItems to count.
     * @example
     * // Count the number of SaleReturnItems
     * const count = await prisma.saleReturnItem.count({
     *   where: {
     *     // ... the filter for the SaleReturnItems we want to count
     *   }
     * })
    **/
    count<T extends SaleReturnItemCountArgs>(
      args?: Subset<T, SaleReturnItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleReturnItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleReturnItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleReturnItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleReturnItemAggregateArgs>(args: Subset<T, SaleReturnItemAggregateArgs>): Prisma.PrismaPromise<GetSaleReturnItemAggregateType<T>>

    /**
     * Group by SaleReturnItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleReturnItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleReturnItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleReturnItemGroupByArgs['orderBy'] }
        : { orderBy?: SaleReturnItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleReturnItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleReturnItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleReturnItem model
   */
  readonly fields: SaleReturnItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleReturnItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleReturnItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    saleReturn<T extends SaleReturnDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleReturnDefaultArgs<ExtArgs>>): Prisma__SaleReturnClient<$Result.GetResult<Prisma.$SaleReturnPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends StoreProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreProductDefaultArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleReturnItem model
   */ 
  interface SaleReturnItemFieldRefs {
    readonly id: FieldRef<"SaleReturnItem", 'String'>
    readonly returnId: FieldRef<"SaleReturnItem", 'String'>
    readonly productId: FieldRef<"SaleReturnItem", 'String'>
    readonly quantity: FieldRef<"SaleReturnItem", 'Decimal'>
    readonly refundAmount: FieldRef<"SaleReturnItem", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * SaleReturnItem findUnique
   */
  export type SaleReturnItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturnItem
     */
    select?: SaleReturnItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleReturnItem to fetch.
     */
    where: SaleReturnItemWhereUniqueInput
  }

  /**
   * SaleReturnItem findUniqueOrThrow
   */
  export type SaleReturnItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturnItem
     */
    select?: SaleReturnItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleReturnItem to fetch.
     */
    where: SaleReturnItemWhereUniqueInput
  }

  /**
   * SaleReturnItem findFirst
   */
  export type SaleReturnItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturnItem
     */
    select?: SaleReturnItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleReturnItem to fetch.
     */
    where?: SaleReturnItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleReturnItems to fetch.
     */
    orderBy?: SaleReturnItemOrderByWithRelationInput | SaleReturnItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleReturnItems.
     */
    cursor?: SaleReturnItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleReturnItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleReturnItems.
     */
    distinct?: SaleReturnItemScalarFieldEnum | SaleReturnItemScalarFieldEnum[]
  }

  /**
   * SaleReturnItem findFirstOrThrow
   */
  export type SaleReturnItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturnItem
     */
    select?: SaleReturnItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleReturnItem to fetch.
     */
    where?: SaleReturnItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleReturnItems to fetch.
     */
    orderBy?: SaleReturnItemOrderByWithRelationInput | SaleReturnItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleReturnItems.
     */
    cursor?: SaleReturnItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleReturnItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleReturnItems.
     */
    distinct?: SaleReturnItemScalarFieldEnum | SaleReturnItemScalarFieldEnum[]
  }

  /**
   * SaleReturnItem findMany
   */
  export type SaleReturnItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturnItem
     */
    select?: SaleReturnItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleReturnItems to fetch.
     */
    where?: SaleReturnItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleReturnItems to fetch.
     */
    orderBy?: SaleReturnItemOrderByWithRelationInput | SaleReturnItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleReturnItems.
     */
    cursor?: SaleReturnItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleReturnItems.
     */
    skip?: number
    distinct?: SaleReturnItemScalarFieldEnum | SaleReturnItemScalarFieldEnum[]
  }

  /**
   * SaleReturnItem create
   */
  export type SaleReturnItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturnItem
     */
    select?: SaleReturnItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleReturnItem.
     */
    data: XOR<SaleReturnItemCreateInput, SaleReturnItemUncheckedCreateInput>
  }

  /**
   * SaleReturnItem createMany
   */
  export type SaleReturnItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleReturnItems.
     */
    data: SaleReturnItemCreateManyInput | SaleReturnItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleReturnItem createManyAndReturn
   */
  export type SaleReturnItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturnItem
     */
    select?: SaleReturnItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SaleReturnItems.
     */
    data: SaleReturnItemCreateManyInput | SaleReturnItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleReturnItem update
   */
  export type SaleReturnItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturnItem
     */
    select?: SaleReturnItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleReturnItem.
     */
    data: XOR<SaleReturnItemUpdateInput, SaleReturnItemUncheckedUpdateInput>
    /**
     * Choose, which SaleReturnItem to update.
     */
    where: SaleReturnItemWhereUniqueInput
  }

  /**
   * SaleReturnItem updateMany
   */
  export type SaleReturnItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleReturnItems.
     */
    data: XOR<SaleReturnItemUpdateManyMutationInput, SaleReturnItemUncheckedUpdateManyInput>
    /**
     * Filter which SaleReturnItems to update
     */
    where?: SaleReturnItemWhereInput
  }

  /**
   * SaleReturnItem upsert
   */
  export type SaleReturnItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturnItem
     */
    select?: SaleReturnItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleReturnItem to update in case it exists.
     */
    where: SaleReturnItemWhereUniqueInput
    /**
     * In case the SaleReturnItem found by the `where` argument doesn't exist, create a new SaleReturnItem with this data.
     */
    create: XOR<SaleReturnItemCreateInput, SaleReturnItemUncheckedCreateInput>
    /**
     * In case the SaleReturnItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleReturnItemUpdateInput, SaleReturnItemUncheckedUpdateInput>
  }

  /**
   * SaleReturnItem delete
   */
  export type SaleReturnItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturnItem
     */
    select?: SaleReturnItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnItemInclude<ExtArgs> | null
    /**
     * Filter which SaleReturnItem to delete.
     */
    where: SaleReturnItemWhereUniqueInput
  }

  /**
   * SaleReturnItem deleteMany
   */
  export type SaleReturnItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleReturnItems to delete
     */
    where?: SaleReturnItemWhereInput
  }

  /**
   * SaleReturnItem without action
   */
  export type SaleReturnItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleReturnItem
     */
    select?: SaleReturnItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleReturnItemInclude<ExtArgs> | null
  }


  /**
   * Model StoreSupplier
   */

  export type AggregateStoreSupplier = {
    _count: StoreSupplierCountAggregateOutputType | null
    _min: StoreSupplierMinAggregateOutputType | null
    _max: StoreSupplierMaxAggregateOutputType | null
  }

  export type StoreSupplierMinAggregateOutputType = {
    id: string | null
    storeId: string | null
    name: string | null
    contactPerson: string | null
    phone: string | null
    email: string | null
    address: string | null
    taxId: string | null
    bankAccount: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreSupplierMaxAggregateOutputType = {
    id: string | null
    storeId: string | null
    name: string | null
    contactPerson: string | null
    phone: string | null
    email: string | null
    address: string | null
    taxId: string | null
    bankAccount: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreSupplierCountAggregateOutputType = {
    id: number
    storeId: number
    name: number
    contactPerson: number
    phone: number
    email: number
    address: number
    taxId: number
    bankAccount: number
    notes: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoreSupplierMinAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    contactPerson?: true
    phone?: true
    email?: true
    address?: true
    taxId?: true
    bankAccount?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreSupplierMaxAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    contactPerson?: true
    phone?: true
    email?: true
    address?: true
    taxId?: true
    bankAccount?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreSupplierCountAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    contactPerson?: true
    phone?: true
    email?: true
    address?: true
    taxId?: true
    bankAccount?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoreSupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreSupplier to aggregate.
     */
    where?: StoreSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreSuppliers to fetch.
     */
    orderBy?: StoreSupplierOrderByWithRelationInput | StoreSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreSuppliers
    **/
    _count?: true | StoreSupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreSupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreSupplierMaxAggregateInputType
  }

  export type GetStoreSupplierAggregateType<T extends StoreSupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreSupplier[P]>
      : GetScalarType<T[P], AggregateStoreSupplier[P]>
  }




  export type StoreSupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreSupplierWhereInput
    orderBy?: StoreSupplierOrderByWithAggregationInput | StoreSupplierOrderByWithAggregationInput[]
    by: StoreSupplierScalarFieldEnum[] | StoreSupplierScalarFieldEnum
    having?: StoreSupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreSupplierCountAggregateInputType | true
    _min?: StoreSupplierMinAggregateInputType
    _max?: StoreSupplierMaxAggregateInputType
  }

  export type StoreSupplierGroupByOutputType = {
    id: string
    storeId: string
    name: string
    contactPerson: string | null
    phone: string | null
    email: string | null
    address: string | null
    taxId: string | null
    bankAccount: string | null
    notes: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StoreSupplierCountAggregateOutputType | null
    _min: StoreSupplierMinAggregateOutputType | null
    _max: StoreSupplierMaxAggregateOutputType | null
  }

  type GetStoreSupplierGroupByPayload<T extends StoreSupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreSupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreSupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreSupplierGroupByOutputType[P]>
            : GetScalarType<T[P], StoreSupplierGroupByOutputType[P]>
        }
      >
    >


  export type StoreSupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    name?: boolean
    contactPerson?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    taxId?: boolean
    bankAccount?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    purchaseOrders?: boolean | StoreSupplier$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | StoreSupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeSupplier"]>

  export type StoreSupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    name?: boolean
    contactPerson?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    taxId?: boolean
    bankAccount?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeSupplier"]>

  export type StoreSupplierSelectScalar = {
    id?: boolean
    storeId?: boolean
    name?: boolean
    contactPerson?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    taxId?: boolean
    bankAccount?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoreSupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    purchaseOrders?: boolean | StoreSupplier$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | StoreSupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoreSupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $StoreSupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreSupplier"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      purchaseOrders: Prisma.$StorePurchaseOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeId: string
      name: string
      contactPerson: string | null
      phone: string | null
      email: string | null
      address: string | null
      taxId: string | null
      bankAccount: string | null
      notes: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storeSupplier"]>
    composites: {}
  }

  type StoreSupplierGetPayload<S extends boolean | null | undefined | StoreSupplierDefaultArgs> = $Result.GetResult<Prisma.$StoreSupplierPayload, S>

  type StoreSupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoreSupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoreSupplierCountAggregateInputType | true
    }

  export interface StoreSupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreSupplier'], meta: { name: 'StoreSupplier' } }
    /**
     * Find zero or one StoreSupplier that matches the filter.
     * @param {StoreSupplierFindUniqueArgs} args - Arguments to find a StoreSupplier
     * @example
     * // Get one StoreSupplier
     * const storeSupplier = await prisma.storeSupplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreSupplierFindUniqueArgs>(args: SelectSubset<T, StoreSupplierFindUniqueArgs<ExtArgs>>): Prisma__StoreSupplierClient<$Result.GetResult<Prisma.$StoreSupplierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StoreSupplier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoreSupplierFindUniqueOrThrowArgs} args - Arguments to find a StoreSupplier
     * @example
     * // Get one StoreSupplier
     * const storeSupplier = await prisma.storeSupplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreSupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreSupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreSupplierClient<$Result.GetResult<Prisma.$StoreSupplierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StoreSupplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreSupplierFindFirstArgs} args - Arguments to find a StoreSupplier
     * @example
     * // Get one StoreSupplier
     * const storeSupplier = await prisma.storeSupplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreSupplierFindFirstArgs>(args?: SelectSubset<T, StoreSupplierFindFirstArgs<ExtArgs>>): Prisma__StoreSupplierClient<$Result.GetResult<Prisma.$StoreSupplierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StoreSupplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreSupplierFindFirstOrThrowArgs} args - Arguments to find a StoreSupplier
     * @example
     * // Get one StoreSupplier
     * const storeSupplier = await prisma.storeSupplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreSupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreSupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreSupplierClient<$Result.GetResult<Prisma.$StoreSupplierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StoreSuppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreSupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreSuppliers
     * const storeSuppliers = await prisma.storeSupplier.findMany()
     * 
     * // Get first 10 StoreSuppliers
     * const storeSuppliers = await prisma.storeSupplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeSupplierWithIdOnly = await prisma.storeSupplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreSupplierFindManyArgs>(args?: SelectSubset<T, StoreSupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreSupplierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StoreSupplier.
     * @param {StoreSupplierCreateArgs} args - Arguments to create a StoreSupplier.
     * @example
     * // Create one StoreSupplier
     * const StoreSupplier = await prisma.storeSupplier.create({
     *   data: {
     *     // ... data to create a StoreSupplier
     *   }
     * })
     * 
     */
    create<T extends StoreSupplierCreateArgs>(args: SelectSubset<T, StoreSupplierCreateArgs<ExtArgs>>): Prisma__StoreSupplierClient<$Result.GetResult<Prisma.$StoreSupplierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StoreSuppliers.
     * @param {StoreSupplierCreateManyArgs} args - Arguments to create many StoreSuppliers.
     * @example
     * // Create many StoreSuppliers
     * const storeSupplier = await prisma.storeSupplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreSupplierCreateManyArgs>(args?: SelectSubset<T, StoreSupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoreSuppliers and returns the data saved in the database.
     * @param {StoreSupplierCreateManyAndReturnArgs} args - Arguments to create many StoreSuppliers.
     * @example
     * // Create many StoreSuppliers
     * const storeSupplier = await prisma.storeSupplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoreSuppliers and only return the `id`
     * const storeSupplierWithIdOnly = await prisma.storeSupplier.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreSupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreSupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreSupplierPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StoreSupplier.
     * @param {StoreSupplierDeleteArgs} args - Arguments to delete one StoreSupplier.
     * @example
     * // Delete one StoreSupplier
     * const StoreSupplier = await prisma.storeSupplier.delete({
     *   where: {
     *     // ... filter to delete one StoreSupplier
     *   }
     * })
     * 
     */
    delete<T extends StoreSupplierDeleteArgs>(args: SelectSubset<T, StoreSupplierDeleteArgs<ExtArgs>>): Prisma__StoreSupplierClient<$Result.GetResult<Prisma.$StoreSupplierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StoreSupplier.
     * @param {StoreSupplierUpdateArgs} args - Arguments to update one StoreSupplier.
     * @example
     * // Update one StoreSupplier
     * const storeSupplier = await prisma.storeSupplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreSupplierUpdateArgs>(args: SelectSubset<T, StoreSupplierUpdateArgs<ExtArgs>>): Prisma__StoreSupplierClient<$Result.GetResult<Prisma.$StoreSupplierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StoreSuppliers.
     * @param {StoreSupplierDeleteManyArgs} args - Arguments to filter StoreSuppliers to delete.
     * @example
     * // Delete a few StoreSuppliers
     * const { count } = await prisma.storeSupplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreSupplierDeleteManyArgs>(args?: SelectSubset<T, StoreSupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreSupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreSuppliers
     * const storeSupplier = await prisma.storeSupplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreSupplierUpdateManyArgs>(args: SelectSubset<T, StoreSupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoreSupplier.
     * @param {StoreSupplierUpsertArgs} args - Arguments to update or create a StoreSupplier.
     * @example
     * // Update or create a StoreSupplier
     * const storeSupplier = await prisma.storeSupplier.upsert({
     *   create: {
     *     // ... data to create a StoreSupplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreSupplier we want to update
     *   }
     * })
     */
    upsert<T extends StoreSupplierUpsertArgs>(args: SelectSubset<T, StoreSupplierUpsertArgs<ExtArgs>>): Prisma__StoreSupplierClient<$Result.GetResult<Prisma.$StoreSupplierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StoreSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreSupplierCountArgs} args - Arguments to filter StoreSuppliers to count.
     * @example
     * // Count the number of StoreSuppliers
     * const count = await prisma.storeSupplier.count({
     *   where: {
     *     // ... the filter for the StoreSuppliers we want to count
     *   }
     * })
    **/
    count<T extends StoreSupplierCountArgs>(
      args?: Subset<T, StoreSupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreSupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreSupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreSupplierAggregateArgs>(args: Subset<T, StoreSupplierAggregateArgs>): Prisma.PrismaPromise<GetStoreSupplierAggregateType<T>>

    /**
     * Group by StoreSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreSupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreSupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreSupplierGroupByArgs['orderBy'] }
        : { orderBy?: StoreSupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreSupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreSupplier model
   */
  readonly fields: StoreSupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreSupplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreSupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    purchaseOrders<T extends StoreSupplier$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, StoreSupplier$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePurchaseOrderPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreSupplier model
   */ 
  interface StoreSupplierFieldRefs {
    readonly id: FieldRef<"StoreSupplier", 'String'>
    readonly storeId: FieldRef<"StoreSupplier", 'String'>
    readonly name: FieldRef<"StoreSupplier", 'String'>
    readonly contactPerson: FieldRef<"StoreSupplier", 'String'>
    readonly phone: FieldRef<"StoreSupplier", 'String'>
    readonly email: FieldRef<"StoreSupplier", 'String'>
    readonly address: FieldRef<"StoreSupplier", 'String'>
    readonly taxId: FieldRef<"StoreSupplier", 'String'>
    readonly bankAccount: FieldRef<"StoreSupplier", 'String'>
    readonly notes: FieldRef<"StoreSupplier", 'String'>
    readonly isActive: FieldRef<"StoreSupplier", 'Boolean'>
    readonly createdAt: FieldRef<"StoreSupplier", 'DateTime'>
    readonly updatedAt: FieldRef<"StoreSupplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoreSupplier findUnique
   */
  export type StoreSupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreSupplier
     */
    select?: StoreSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreSupplierInclude<ExtArgs> | null
    /**
     * Filter, which StoreSupplier to fetch.
     */
    where: StoreSupplierWhereUniqueInput
  }

  /**
   * StoreSupplier findUniqueOrThrow
   */
  export type StoreSupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreSupplier
     */
    select?: StoreSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreSupplierInclude<ExtArgs> | null
    /**
     * Filter, which StoreSupplier to fetch.
     */
    where: StoreSupplierWhereUniqueInput
  }

  /**
   * StoreSupplier findFirst
   */
  export type StoreSupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreSupplier
     */
    select?: StoreSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreSupplierInclude<ExtArgs> | null
    /**
     * Filter, which StoreSupplier to fetch.
     */
    where?: StoreSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreSuppliers to fetch.
     */
    orderBy?: StoreSupplierOrderByWithRelationInput | StoreSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreSuppliers.
     */
    cursor?: StoreSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreSuppliers.
     */
    distinct?: StoreSupplierScalarFieldEnum | StoreSupplierScalarFieldEnum[]
  }

  /**
   * StoreSupplier findFirstOrThrow
   */
  export type StoreSupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreSupplier
     */
    select?: StoreSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreSupplierInclude<ExtArgs> | null
    /**
     * Filter, which StoreSupplier to fetch.
     */
    where?: StoreSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreSuppliers to fetch.
     */
    orderBy?: StoreSupplierOrderByWithRelationInput | StoreSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreSuppliers.
     */
    cursor?: StoreSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreSuppliers.
     */
    distinct?: StoreSupplierScalarFieldEnum | StoreSupplierScalarFieldEnum[]
  }

  /**
   * StoreSupplier findMany
   */
  export type StoreSupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreSupplier
     */
    select?: StoreSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreSupplierInclude<ExtArgs> | null
    /**
     * Filter, which StoreSuppliers to fetch.
     */
    where?: StoreSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreSuppliers to fetch.
     */
    orderBy?: StoreSupplierOrderByWithRelationInput | StoreSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreSuppliers.
     */
    cursor?: StoreSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreSuppliers.
     */
    skip?: number
    distinct?: StoreSupplierScalarFieldEnum | StoreSupplierScalarFieldEnum[]
  }

  /**
   * StoreSupplier create
   */
  export type StoreSupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreSupplier
     */
    select?: StoreSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreSupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a StoreSupplier.
     */
    data: XOR<StoreSupplierCreateInput, StoreSupplierUncheckedCreateInput>
  }

  /**
   * StoreSupplier createMany
   */
  export type StoreSupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreSuppliers.
     */
    data: StoreSupplierCreateManyInput | StoreSupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreSupplier createManyAndReturn
   */
  export type StoreSupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreSupplier
     */
    select?: StoreSupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StoreSuppliers.
     */
    data: StoreSupplierCreateManyInput | StoreSupplierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreSupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoreSupplier update
   */
  export type StoreSupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreSupplier
     */
    select?: StoreSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreSupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a StoreSupplier.
     */
    data: XOR<StoreSupplierUpdateInput, StoreSupplierUncheckedUpdateInput>
    /**
     * Choose, which StoreSupplier to update.
     */
    where: StoreSupplierWhereUniqueInput
  }

  /**
   * StoreSupplier updateMany
   */
  export type StoreSupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreSuppliers.
     */
    data: XOR<StoreSupplierUpdateManyMutationInput, StoreSupplierUncheckedUpdateManyInput>
    /**
     * Filter which StoreSuppliers to update
     */
    where?: StoreSupplierWhereInput
  }

  /**
   * StoreSupplier upsert
   */
  export type StoreSupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreSupplier
     */
    select?: StoreSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreSupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the StoreSupplier to update in case it exists.
     */
    where: StoreSupplierWhereUniqueInput
    /**
     * In case the StoreSupplier found by the `where` argument doesn't exist, create a new StoreSupplier with this data.
     */
    create: XOR<StoreSupplierCreateInput, StoreSupplierUncheckedCreateInput>
    /**
     * In case the StoreSupplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreSupplierUpdateInput, StoreSupplierUncheckedUpdateInput>
  }

  /**
   * StoreSupplier delete
   */
  export type StoreSupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreSupplier
     */
    select?: StoreSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreSupplierInclude<ExtArgs> | null
    /**
     * Filter which StoreSupplier to delete.
     */
    where: StoreSupplierWhereUniqueInput
  }

  /**
   * StoreSupplier deleteMany
   */
  export type StoreSupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreSuppliers to delete
     */
    where?: StoreSupplierWhereInput
  }

  /**
   * StoreSupplier.purchaseOrders
   */
  export type StoreSupplier$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseOrder
     */
    select?: StorePurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseOrderInclude<ExtArgs> | null
    where?: StorePurchaseOrderWhereInput
    orderBy?: StorePurchaseOrderOrderByWithRelationInput | StorePurchaseOrderOrderByWithRelationInput[]
    cursor?: StorePurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorePurchaseOrderScalarFieldEnum | StorePurchaseOrderScalarFieldEnum[]
  }

  /**
   * StoreSupplier without action
   */
  export type StoreSupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreSupplier
     */
    select?: StoreSupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreSupplierInclude<ExtArgs> | null
  }


  /**
   * Model StorePurchaseOrder
   */

  export type AggregateStorePurchaseOrder = {
    _count: StorePurchaseOrderCountAggregateOutputType | null
    _avg: StorePurchaseOrderAvgAggregateOutputType | null
    _sum: StorePurchaseOrderSumAggregateOutputType | null
    _min: StorePurchaseOrderMinAggregateOutputType | null
    _max: StorePurchaseOrderMaxAggregateOutputType | null
  }

  export type StorePurchaseOrderAvgAggregateOutputType = {
    subtotal: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
  }

  export type StorePurchaseOrderSumAggregateOutputType = {
    subtotal: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
  }

  export type StorePurchaseOrderMinAggregateOutputType = {
    id: string | null
    storeId: string | null
    supplierId: string | null
    orderNumber: string | null
    subtotal: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    status: $Enums.StorePurchaseStatus | null
    notes: string | null
    expectedDate: Date | null
    receivedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StorePurchaseOrderMaxAggregateOutputType = {
    id: string | null
    storeId: string | null
    supplierId: string | null
    orderNumber: string | null
    subtotal: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    status: $Enums.StorePurchaseStatus | null
    notes: string | null
    expectedDate: Date | null
    receivedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StorePurchaseOrderCountAggregateOutputType = {
    id: number
    storeId: number
    supplierId: number
    orderNumber: number
    subtotal: number
    taxAmount: number
    total: number
    status: number
    notes: number
    expectedDate: number
    receivedDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StorePurchaseOrderAvgAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    total?: true
  }

  export type StorePurchaseOrderSumAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    total?: true
  }

  export type StorePurchaseOrderMinAggregateInputType = {
    id?: true
    storeId?: true
    supplierId?: true
    orderNumber?: true
    subtotal?: true
    taxAmount?: true
    total?: true
    status?: true
    notes?: true
    expectedDate?: true
    receivedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StorePurchaseOrderMaxAggregateInputType = {
    id?: true
    storeId?: true
    supplierId?: true
    orderNumber?: true
    subtotal?: true
    taxAmount?: true
    total?: true
    status?: true
    notes?: true
    expectedDate?: true
    receivedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StorePurchaseOrderCountAggregateInputType = {
    id?: true
    storeId?: true
    supplierId?: true
    orderNumber?: true
    subtotal?: true
    taxAmount?: true
    total?: true
    status?: true
    notes?: true
    expectedDate?: true
    receivedDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StorePurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorePurchaseOrder to aggregate.
     */
    where?: StorePurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePurchaseOrders to fetch.
     */
    orderBy?: StorePurchaseOrderOrderByWithRelationInput | StorePurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StorePurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StorePurchaseOrders
    **/
    _count?: true | StorePurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StorePurchaseOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StorePurchaseOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorePurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorePurchaseOrderMaxAggregateInputType
  }

  export type GetStorePurchaseOrderAggregateType<T extends StorePurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateStorePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorePurchaseOrder[P]>
      : GetScalarType<T[P], AggregateStorePurchaseOrder[P]>
  }




  export type StorePurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorePurchaseOrderWhereInput
    orderBy?: StorePurchaseOrderOrderByWithAggregationInput | StorePurchaseOrderOrderByWithAggregationInput[]
    by: StorePurchaseOrderScalarFieldEnum[] | StorePurchaseOrderScalarFieldEnum
    having?: StorePurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorePurchaseOrderCountAggregateInputType | true
    _avg?: StorePurchaseOrderAvgAggregateInputType
    _sum?: StorePurchaseOrderSumAggregateInputType
    _min?: StorePurchaseOrderMinAggregateInputType
    _max?: StorePurchaseOrderMaxAggregateInputType
  }

  export type StorePurchaseOrderGroupByOutputType = {
    id: string
    storeId: string
    supplierId: string
    orderNumber: string
    subtotal: Decimal
    taxAmount: Decimal
    total: Decimal
    status: $Enums.StorePurchaseStatus
    notes: string | null
    expectedDate: Date | null
    receivedDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: StorePurchaseOrderCountAggregateOutputType | null
    _avg: StorePurchaseOrderAvgAggregateOutputType | null
    _sum: StorePurchaseOrderSumAggregateOutputType | null
    _min: StorePurchaseOrderMinAggregateOutputType | null
    _max: StorePurchaseOrderMaxAggregateOutputType | null
  }

  type GetStorePurchaseOrderGroupByPayload<T extends StorePurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StorePurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorePurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorePurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], StorePurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type StorePurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    supplierId?: boolean
    orderNumber?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    total?: boolean
    status?: boolean
    notes?: boolean
    expectedDate?: boolean
    receivedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    supplier?: boolean | StoreSupplierDefaultArgs<ExtArgs>
    items?: boolean | StorePurchaseOrder$itemsArgs<ExtArgs>
    _count?: boolean | StorePurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storePurchaseOrder"]>

  export type StorePurchaseOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    supplierId?: boolean
    orderNumber?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    total?: boolean
    status?: boolean
    notes?: boolean
    expectedDate?: boolean
    receivedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    supplier?: boolean | StoreSupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storePurchaseOrder"]>

  export type StorePurchaseOrderSelectScalar = {
    id?: boolean
    storeId?: boolean
    supplierId?: boolean
    orderNumber?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    total?: boolean
    status?: boolean
    notes?: boolean
    expectedDate?: boolean
    receivedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StorePurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    supplier?: boolean | StoreSupplierDefaultArgs<ExtArgs>
    items?: boolean | StorePurchaseOrder$itemsArgs<ExtArgs>
    _count?: boolean | StorePurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StorePurchaseOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    supplier?: boolean | StoreSupplierDefaultArgs<ExtArgs>
  }

  export type $StorePurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StorePurchaseOrder"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      supplier: Prisma.$StoreSupplierPayload<ExtArgs>
      items: Prisma.$StorePurchaseItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeId: string
      supplierId: string
      orderNumber: string
      subtotal: Prisma.Decimal
      taxAmount: Prisma.Decimal
      total: Prisma.Decimal
      status: $Enums.StorePurchaseStatus
      notes: string | null
      expectedDate: Date | null
      receivedDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storePurchaseOrder"]>
    composites: {}
  }

  type StorePurchaseOrderGetPayload<S extends boolean | null | undefined | StorePurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$StorePurchaseOrderPayload, S>

  type StorePurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StorePurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StorePurchaseOrderCountAggregateInputType | true
    }

  export interface StorePurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StorePurchaseOrder'], meta: { name: 'StorePurchaseOrder' } }
    /**
     * Find zero or one StorePurchaseOrder that matches the filter.
     * @param {StorePurchaseOrderFindUniqueArgs} args - Arguments to find a StorePurchaseOrder
     * @example
     * // Get one StorePurchaseOrder
     * const storePurchaseOrder = await prisma.storePurchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StorePurchaseOrderFindUniqueArgs>(args: SelectSubset<T, StorePurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__StorePurchaseOrderClient<$Result.GetResult<Prisma.$StorePurchaseOrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StorePurchaseOrder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StorePurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a StorePurchaseOrder
     * @example
     * // Get one StorePurchaseOrder
     * const storePurchaseOrder = await prisma.storePurchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StorePurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, StorePurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StorePurchaseOrderClient<$Result.GetResult<Prisma.$StorePurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StorePurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePurchaseOrderFindFirstArgs} args - Arguments to find a StorePurchaseOrder
     * @example
     * // Get one StorePurchaseOrder
     * const storePurchaseOrder = await prisma.storePurchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StorePurchaseOrderFindFirstArgs>(args?: SelectSubset<T, StorePurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__StorePurchaseOrderClient<$Result.GetResult<Prisma.$StorePurchaseOrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StorePurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a StorePurchaseOrder
     * @example
     * // Get one StorePurchaseOrder
     * const storePurchaseOrder = await prisma.storePurchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StorePurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, StorePurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__StorePurchaseOrderClient<$Result.GetResult<Prisma.$StorePurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StorePurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StorePurchaseOrders
     * const storePurchaseOrders = await prisma.storePurchaseOrder.findMany()
     * 
     * // Get first 10 StorePurchaseOrders
     * const storePurchaseOrders = await prisma.storePurchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storePurchaseOrderWithIdOnly = await prisma.storePurchaseOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StorePurchaseOrderFindManyArgs>(args?: SelectSubset<T, StorePurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePurchaseOrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StorePurchaseOrder.
     * @param {StorePurchaseOrderCreateArgs} args - Arguments to create a StorePurchaseOrder.
     * @example
     * // Create one StorePurchaseOrder
     * const StorePurchaseOrder = await prisma.storePurchaseOrder.create({
     *   data: {
     *     // ... data to create a StorePurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends StorePurchaseOrderCreateArgs>(args: SelectSubset<T, StorePurchaseOrderCreateArgs<ExtArgs>>): Prisma__StorePurchaseOrderClient<$Result.GetResult<Prisma.$StorePurchaseOrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StorePurchaseOrders.
     * @param {StorePurchaseOrderCreateManyArgs} args - Arguments to create many StorePurchaseOrders.
     * @example
     * // Create many StorePurchaseOrders
     * const storePurchaseOrder = await prisma.storePurchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StorePurchaseOrderCreateManyArgs>(args?: SelectSubset<T, StorePurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StorePurchaseOrders and returns the data saved in the database.
     * @param {StorePurchaseOrderCreateManyAndReturnArgs} args - Arguments to create many StorePurchaseOrders.
     * @example
     * // Create many StorePurchaseOrders
     * const storePurchaseOrder = await prisma.storePurchaseOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StorePurchaseOrders and only return the `id`
     * const storePurchaseOrderWithIdOnly = await prisma.storePurchaseOrder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StorePurchaseOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, StorePurchaseOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePurchaseOrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StorePurchaseOrder.
     * @param {StorePurchaseOrderDeleteArgs} args - Arguments to delete one StorePurchaseOrder.
     * @example
     * // Delete one StorePurchaseOrder
     * const StorePurchaseOrder = await prisma.storePurchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one StorePurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends StorePurchaseOrderDeleteArgs>(args: SelectSubset<T, StorePurchaseOrderDeleteArgs<ExtArgs>>): Prisma__StorePurchaseOrderClient<$Result.GetResult<Prisma.$StorePurchaseOrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StorePurchaseOrder.
     * @param {StorePurchaseOrderUpdateArgs} args - Arguments to update one StorePurchaseOrder.
     * @example
     * // Update one StorePurchaseOrder
     * const storePurchaseOrder = await prisma.storePurchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StorePurchaseOrderUpdateArgs>(args: SelectSubset<T, StorePurchaseOrderUpdateArgs<ExtArgs>>): Prisma__StorePurchaseOrderClient<$Result.GetResult<Prisma.$StorePurchaseOrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StorePurchaseOrders.
     * @param {StorePurchaseOrderDeleteManyArgs} args - Arguments to filter StorePurchaseOrders to delete.
     * @example
     * // Delete a few StorePurchaseOrders
     * const { count } = await prisma.storePurchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StorePurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, StorePurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorePurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StorePurchaseOrders
     * const storePurchaseOrder = await prisma.storePurchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StorePurchaseOrderUpdateManyArgs>(args: SelectSubset<T, StorePurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StorePurchaseOrder.
     * @param {StorePurchaseOrderUpsertArgs} args - Arguments to update or create a StorePurchaseOrder.
     * @example
     * // Update or create a StorePurchaseOrder
     * const storePurchaseOrder = await prisma.storePurchaseOrder.upsert({
     *   create: {
     *     // ... data to create a StorePurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StorePurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends StorePurchaseOrderUpsertArgs>(args: SelectSubset<T, StorePurchaseOrderUpsertArgs<ExtArgs>>): Prisma__StorePurchaseOrderClient<$Result.GetResult<Prisma.$StorePurchaseOrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StorePurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePurchaseOrderCountArgs} args - Arguments to filter StorePurchaseOrders to count.
     * @example
     * // Count the number of StorePurchaseOrders
     * const count = await prisma.storePurchaseOrder.count({
     *   where: {
     *     // ... the filter for the StorePurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends StorePurchaseOrderCountArgs>(
      args?: Subset<T, StorePurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorePurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StorePurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorePurchaseOrderAggregateArgs>(args: Subset<T, StorePurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetStorePurchaseOrderAggregateType<T>>

    /**
     * Group by StorePurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorePurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorePurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: StorePurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorePurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorePurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StorePurchaseOrder model
   */
  readonly fields: StorePurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StorePurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StorePurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    supplier<T extends StoreSupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreSupplierDefaultArgs<ExtArgs>>): Prisma__StoreSupplierClient<$Result.GetResult<Prisma.$StoreSupplierPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends StorePurchaseOrder$itemsArgs<ExtArgs> = {}>(args?: Subset<T, StorePurchaseOrder$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePurchaseItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StorePurchaseOrder model
   */ 
  interface StorePurchaseOrderFieldRefs {
    readonly id: FieldRef<"StorePurchaseOrder", 'String'>
    readonly storeId: FieldRef<"StorePurchaseOrder", 'String'>
    readonly supplierId: FieldRef<"StorePurchaseOrder", 'String'>
    readonly orderNumber: FieldRef<"StorePurchaseOrder", 'String'>
    readonly subtotal: FieldRef<"StorePurchaseOrder", 'Decimal'>
    readonly taxAmount: FieldRef<"StorePurchaseOrder", 'Decimal'>
    readonly total: FieldRef<"StorePurchaseOrder", 'Decimal'>
    readonly status: FieldRef<"StorePurchaseOrder", 'StorePurchaseStatus'>
    readonly notes: FieldRef<"StorePurchaseOrder", 'String'>
    readonly expectedDate: FieldRef<"StorePurchaseOrder", 'DateTime'>
    readonly receivedDate: FieldRef<"StorePurchaseOrder", 'DateTime'>
    readonly createdAt: FieldRef<"StorePurchaseOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"StorePurchaseOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StorePurchaseOrder findUnique
   */
  export type StorePurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseOrder
     */
    select?: StorePurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which StorePurchaseOrder to fetch.
     */
    where: StorePurchaseOrderWhereUniqueInput
  }

  /**
   * StorePurchaseOrder findUniqueOrThrow
   */
  export type StorePurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseOrder
     */
    select?: StorePurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which StorePurchaseOrder to fetch.
     */
    where: StorePurchaseOrderWhereUniqueInput
  }

  /**
   * StorePurchaseOrder findFirst
   */
  export type StorePurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseOrder
     */
    select?: StorePurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which StorePurchaseOrder to fetch.
     */
    where?: StorePurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePurchaseOrders to fetch.
     */
    orderBy?: StorePurchaseOrderOrderByWithRelationInput | StorePurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorePurchaseOrders.
     */
    cursor?: StorePurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorePurchaseOrders.
     */
    distinct?: StorePurchaseOrderScalarFieldEnum | StorePurchaseOrderScalarFieldEnum[]
  }

  /**
   * StorePurchaseOrder findFirstOrThrow
   */
  export type StorePurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseOrder
     */
    select?: StorePurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which StorePurchaseOrder to fetch.
     */
    where?: StorePurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePurchaseOrders to fetch.
     */
    orderBy?: StorePurchaseOrderOrderByWithRelationInput | StorePurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorePurchaseOrders.
     */
    cursor?: StorePurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorePurchaseOrders.
     */
    distinct?: StorePurchaseOrderScalarFieldEnum | StorePurchaseOrderScalarFieldEnum[]
  }

  /**
   * StorePurchaseOrder findMany
   */
  export type StorePurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseOrder
     */
    select?: StorePurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which StorePurchaseOrders to fetch.
     */
    where?: StorePurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePurchaseOrders to fetch.
     */
    orderBy?: StorePurchaseOrderOrderByWithRelationInput | StorePurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StorePurchaseOrders.
     */
    cursor?: StorePurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePurchaseOrders.
     */
    skip?: number
    distinct?: StorePurchaseOrderScalarFieldEnum | StorePurchaseOrderScalarFieldEnum[]
  }

  /**
   * StorePurchaseOrder create
   */
  export type StorePurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseOrder
     */
    select?: StorePurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a StorePurchaseOrder.
     */
    data: XOR<StorePurchaseOrderCreateInput, StorePurchaseOrderUncheckedCreateInput>
  }

  /**
   * StorePurchaseOrder createMany
   */
  export type StorePurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StorePurchaseOrders.
     */
    data: StorePurchaseOrderCreateManyInput | StorePurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StorePurchaseOrder createManyAndReturn
   */
  export type StorePurchaseOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseOrder
     */
    select?: StorePurchaseOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StorePurchaseOrders.
     */
    data: StorePurchaseOrderCreateManyInput | StorePurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StorePurchaseOrder update
   */
  export type StorePurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseOrder
     */
    select?: StorePurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a StorePurchaseOrder.
     */
    data: XOR<StorePurchaseOrderUpdateInput, StorePurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which StorePurchaseOrder to update.
     */
    where: StorePurchaseOrderWhereUniqueInput
  }

  /**
   * StorePurchaseOrder updateMany
   */
  export type StorePurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StorePurchaseOrders.
     */
    data: XOR<StorePurchaseOrderUpdateManyMutationInput, StorePurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which StorePurchaseOrders to update
     */
    where?: StorePurchaseOrderWhereInput
  }

  /**
   * StorePurchaseOrder upsert
   */
  export type StorePurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseOrder
     */
    select?: StorePurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the StorePurchaseOrder to update in case it exists.
     */
    where: StorePurchaseOrderWhereUniqueInput
    /**
     * In case the StorePurchaseOrder found by the `where` argument doesn't exist, create a new StorePurchaseOrder with this data.
     */
    create: XOR<StorePurchaseOrderCreateInput, StorePurchaseOrderUncheckedCreateInput>
    /**
     * In case the StorePurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StorePurchaseOrderUpdateInput, StorePurchaseOrderUncheckedUpdateInput>
  }

  /**
   * StorePurchaseOrder delete
   */
  export type StorePurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseOrder
     */
    select?: StorePurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which StorePurchaseOrder to delete.
     */
    where: StorePurchaseOrderWhereUniqueInput
  }

  /**
   * StorePurchaseOrder deleteMany
   */
  export type StorePurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorePurchaseOrders to delete
     */
    where?: StorePurchaseOrderWhereInput
  }

  /**
   * StorePurchaseOrder.items
   */
  export type StorePurchaseOrder$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseItem
     */
    select?: StorePurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseItemInclude<ExtArgs> | null
    where?: StorePurchaseItemWhereInput
    orderBy?: StorePurchaseItemOrderByWithRelationInput | StorePurchaseItemOrderByWithRelationInput[]
    cursor?: StorePurchaseItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorePurchaseItemScalarFieldEnum | StorePurchaseItemScalarFieldEnum[]
  }

  /**
   * StorePurchaseOrder without action
   */
  export type StorePurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseOrder
     */
    select?: StorePurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model StorePurchaseItem
   */

  export type AggregateStorePurchaseItem = {
    _count: StorePurchaseItemCountAggregateOutputType | null
    _avg: StorePurchaseItemAvgAggregateOutputType | null
    _sum: StorePurchaseItemSumAggregateOutputType | null
    _min: StorePurchaseItemMinAggregateOutputType | null
    _max: StorePurchaseItemMaxAggregateOutputType | null
  }

  export type StorePurchaseItemAvgAggregateOutputType = {
    quantity: Decimal | null
    unitCost: Decimal | null
    receivedQty: Decimal | null
    total: Decimal | null
  }

  export type StorePurchaseItemSumAggregateOutputType = {
    quantity: Decimal | null
    unitCost: Decimal | null
    receivedQty: Decimal | null
    total: Decimal | null
  }

  export type StorePurchaseItemMinAggregateOutputType = {
    id: string | null
    purchaseOrderId: string | null
    productId: string | null
    quantity: Decimal | null
    unitCost: Decimal | null
    receivedQty: Decimal | null
    total: Decimal | null
  }

  export type StorePurchaseItemMaxAggregateOutputType = {
    id: string | null
    purchaseOrderId: string | null
    productId: string | null
    quantity: Decimal | null
    unitCost: Decimal | null
    receivedQty: Decimal | null
    total: Decimal | null
  }

  export type StorePurchaseItemCountAggregateOutputType = {
    id: number
    purchaseOrderId: number
    productId: number
    quantity: number
    unitCost: number
    receivedQty: number
    total: number
    _all: number
  }


  export type StorePurchaseItemAvgAggregateInputType = {
    quantity?: true
    unitCost?: true
    receivedQty?: true
    total?: true
  }

  export type StorePurchaseItemSumAggregateInputType = {
    quantity?: true
    unitCost?: true
    receivedQty?: true
    total?: true
  }

  export type StorePurchaseItemMinAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantity?: true
    unitCost?: true
    receivedQty?: true
    total?: true
  }

  export type StorePurchaseItemMaxAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantity?: true
    unitCost?: true
    receivedQty?: true
    total?: true
  }

  export type StorePurchaseItemCountAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    productId?: true
    quantity?: true
    unitCost?: true
    receivedQty?: true
    total?: true
    _all?: true
  }

  export type StorePurchaseItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorePurchaseItem to aggregate.
     */
    where?: StorePurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePurchaseItems to fetch.
     */
    orderBy?: StorePurchaseItemOrderByWithRelationInput | StorePurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StorePurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StorePurchaseItems
    **/
    _count?: true | StorePurchaseItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StorePurchaseItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StorePurchaseItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorePurchaseItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorePurchaseItemMaxAggregateInputType
  }

  export type GetStorePurchaseItemAggregateType<T extends StorePurchaseItemAggregateArgs> = {
        [P in keyof T & keyof AggregateStorePurchaseItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorePurchaseItem[P]>
      : GetScalarType<T[P], AggregateStorePurchaseItem[P]>
  }




  export type StorePurchaseItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorePurchaseItemWhereInput
    orderBy?: StorePurchaseItemOrderByWithAggregationInput | StorePurchaseItemOrderByWithAggregationInput[]
    by: StorePurchaseItemScalarFieldEnum[] | StorePurchaseItemScalarFieldEnum
    having?: StorePurchaseItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorePurchaseItemCountAggregateInputType | true
    _avg?: StorePurchaseItemAvgAggregateInputType
    _sum?: StorePurchaseItemSumAggregateInputType
    _min?: StorePurchaseItemMinAggregateInputType
    _max?: StorePurchaseItemMaxAggregateInputType
  }

  export type StorePurchaseItemGroupByOutputType = {
    id: string
    purchaseOrderId: string
    productId: string
    quantity: Decimal
    unitCost: Decimal
    receivedQty: Decimal
    total: Decimal
    _count: StorePurchaseItemCountAggregateOutputType | null
    _avg: StorePurchaseItemAvgAggregateOutputType | null
    _sum: StorePurchaseItemSumAggregateOutputType | null
    _min: StorePurchaseItemMinAggregateOutputType | null
    _max: StorePurchaseItemMaxAggregateOutputType | null
  }

  type GetStorePurchaseItemGroupByPayload<T extends StorePurchaseItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StorePurchaseItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorePurchaseItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorePurchaseItemGroupByOutputType[P]>
            : GetScalarType<T[P], StorePurchaseItemGroupByOutputType[P]>
        }
      >
    >


  export type StorePurchaseItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitCost?: boolean
    receivedQty?: boolean
    total?: boolean
    purchaseOrder?: boolean | StorePurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storePurchaseItem"]>

  export type StorePurchaseItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitCost?: boolean
    receivedQty?: boolean
    total?: boolean
    purchaseOrder?: boolean | StorePurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storePurchaseItem"]>

  export type StorePurchaseItemSelectScalar = {
    id?: boolean
    purchaseOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitCost?: boolean
    receivedQty?: boolean
    total?: boolean
  }

  export type StorePurchaseItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | StorePurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }
  export type StorePurchaseItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | StorePurchaseOrderDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }

  export type $StorePurchaseItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StorePurchaseItem"
    objects: {
      purchaseOrder: Prisma.$StorePurchaseOrderPayload<ExtArgs>
      product: Prisma.$StoreProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      purchaseOrderId: string
      productId: string
      quantity: Prisma.Decimal
      unitCost: Prisma.Decimal
      receivedQty: Prisma.Decimal
      total: Prisma.Decimal
    }, ExtArgs["result"]["storePurchaseItem"]>
    composites: {}
  }

  type StorePurchaseItemGetPayload<S extends boolean | null | undefined | StorePurchaseItemDefaultArgs> = $Result.GetResult<Prisma.$StorePurchaseItemPayload, S>

  type StorePurchaseItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StorePurchaseItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StorePurchaseItemCountAggregateInputType | true
    }

  export interface StorePurchaseItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StorePurchaseItem'], meta: { name: 'StorePurchaseItem' } }
    /**
     * Find zero or one StorePurchaseItem that matches the filter.
     * @param {StorePurchaseItemFindUniqueArgs} args - Arguments to find a StorePurchaseItem
     * @example
     * // Get one StorePurchaseItem
     * const storePurchaseItem = await prisma.storePurchaseItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StorePurchaseItemFindUniqueArgs>(args: SelectSubset<T, StorePurchaseItemFindUniqueArgs<ExtArgs>>): Prisma__StorePurchaseItemClient<$Result.GetResult<Prisma.$StorePurchaseItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StorePurchaseItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StorePurchaseItemFindUniqueOrThrowArgs} args - Arguments to find a StorePurchaseItem
     * @example
     * // Get one StorePurchaseItem
     * const storePurchaseItem = await prisma.storePurchaseItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StorePurchaseItemFindUniqueOrThrowArgs>(args: SelectSubset<T, StorePurchaseItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StorePurchaseItemClient<$Result.GetResult<Prisma.$StorePurchaseItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StorePurchaseItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePurchaseItemFindFirstArgs} args - Arguments to find a StorePurchaseItem
     * @example
     * // Get one StorePurchaseItem
     * const storePurchaseItem = await prisma.storePurchaseItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StorePurchaseItemFindFirstArgs>(args?: SelectSubset<T, StorePurchaseItemFindFirstArgs<ExtArgs>>): Prisma__StorePurchaseItemClient<$Result.GetResult<Prisma.$StorePurchaseItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StorePurchaseItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePurchaseItemFindFirstOrThrowArgs} args - Arguments to find a StorePurchaseItem
     * @example
     * // Get one StorePurchaseItem
     * const storePurchaseItem = await prisma.storePurchaseItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StorePurchaseItemFindFirstOrThrowArgs>(args?: SelectSubset<T, StorePurchaseItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__StorePurchaseItemClient<$Result.GetResult<Prisma.$StorePurchaseItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StorePurchaseItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePurchaseItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StorePurchaseItems
     * const storePurchaseItems = await prisma.storePurchaseItem.findMany()
     * 
     * // Get first 10 StorePurchaseItems
     * const storePurchaseItems = await prisma.storePurchaseItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storePurchaseItemWithIdOnly = await prisma.storePurchaseItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StorePurchaseItemFindManyArgs>(args?: SelectSubset<T, StorePurchaseItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePurchaseItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StorePurchaseItem.
     * @param {StorePurchaseItemCreateArgs} args - Arguments to create a StorePurchaseItem.
     * @example
     * // Create one StorePurchaseItem
     * const StorePurchaseItem = await prisma.storePurchaseItem.create({
     *   data: {
     *     // ... data to create a StorePurchaseItem
     *   }
     * })
     * 
     */
    create<T extends StorePurchaseItemCreateArgs>(args: SelectSubset<T, StorePurchaseItemCreateArgs<ExtArgs>>): Prisma__StorePurchaseItemClient<$Result.GetResult<Prisma.$StorePurchaseItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StorePurchaseItems.
     * @param {StorePurchaseItemCreateManyArgs} args - Arguments to create many StorePurchaseItems.
     * @example
     * // Create many StorePurchaseItems
     * const storePurchaseItem = await prisma.storePurchaseItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StorePurchaseItemCreateManyArgs>(args?: SelectSubset<T, StorePurchaseItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StorePurchaseItems and returns the data saved in the database.
     * @param {StorePurchaseItemCreateManyAndReturnArgs} args - Arguments to create many StorePurchaseItems.
     * @example
     * // Create many StorePurchaseItems
     * const storePurchaseItem = await prisma.storePurchaseItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StorePurchaseItems and only return the `id`
     * const storePurchaseItemWithIdOnly = await prisma.storePurchaseItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StorePurchaseItemCreateManyAndReturnArgs>(args?: SelectSubset<T, StorePurchaseItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePurchaseItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StorePurchaseItem.
     * @param {StorePurchaseItemDeleteArgs} args - Arguments to delete one StorePurchaseItem.
     * @example
     * // Delete one StorePurchaseItem
     * const StorePurchaseItem = await prisma.storePurchaseItem.delete({
     *   where: {
     *     // ... filter to delete one StorePurchaseItem
     *   }
     * })
     * 
     */
    delete<T extends StorePurchaseItemDeleteArgs>(args: SelectSubset<T, StorePurchaseItemDeleteArgs<ExtArgs>>): Prisma__StorePurchaseItemClient<$Result.GetResult<Prisma.$StorePurchaseItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StorePurchaseItem.
     * @param {StorePurchaseItemUpdateArgs} args - Arguments to update one StorePurchaseItem.
     * @example
     * // Update one StorePurchaseItem
     * const storePurchaseItem = await prisma.storePurchaseItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StorePurchaseItemUpdateArgs>(args: SelectSubset<T, StorePurchaseItemUpdateArgs<ExtArgs>>): Prisma__StorePurchaseItemClient<$Result.GetResult<Prisma.$StorePurchaseItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StorePurchaseItems.
     * @param {StorePurchaseItemDeleteManyArgs} args - Arguments to filter StorePurchaseItems to delete.
     * @example
     * // Delete a few StorePurchaseItems
     * const { count } = await prisma.storePurchaseItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StorePurchaseItemDeleteManyArgs>(args?: SelectSubset<T, StorePurchaseItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorePurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePurchaseItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StorePurchaseItems
     * const storePurchaseItem = await prisma.storePurchaseItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StorePurchaseItemUpdateManyArgs>(args: SelectSubset<T, StorePurchaseItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StorePurchaseItem.
     * @param {StorePurchaseItemUpsertArgs} args - Arguments to update or create a StorePurchaseItem.
     * @example
     * // Update or create a StorePurchaseItem
     * const storePurchaseItem = await prisma.storePurchaseItem.upsert({
     *   create: {
     *     // ... data to create a StorePurchaseItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StorePurchaseItem we want to update
     *   }
     * })
     */
    upsert<T extends StorePurchaseItemUpsertArgs>(args: SelectSubset<T, StorePurchaseItemUpsertArgs<ExtArgs>>): Prisma__StorePurchaseItemClient<$Result.GetResult<Prisma.$StorePurchaseItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StorePurchaseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePurchaseItemCountArgs} args - Arguments to filter StorePurchaseItems to count.
     * @example
     * // Count the number of StorePurchaseItems
     * const count = await prisma.storePurchaseItem.count({
     *   where: {
     *     // ... the filter for the StorePurchaseItems we want to count
     *   }
     * })
    **/
    count<T extends StorePurchaseItemCountArgs>(
      args?: Subset<T, StorePurchaseItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorePurchaseItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StorePurchaseItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePurchaseItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorePurchaseItemAggregateArgs>(args: Subset<T, StorePurchaseItemAggregateArgs>): Prisma.PrismaPromise<GetStorePurchaseItemAggregateType<T>>

    /**
     * Group by StorePurchaseItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePurchaseItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorePurchaseItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorePurchaseItemGroupByArgs['orderBy'] }
        : { orderBy?: StorePurchaseItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorePurchaseItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorePurchaseItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StorePurchaseItem model
   */
  readonly fields: StorePurchaseItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StorePurchaseItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StorePurchaseItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseOrder<T extends StorePurchaseOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StorePurchaseOrderDefaultArgs<ExtArgs>>): Prisma__StorePurchaseOrderClient<$Result.GetResult<Prisma.$StorePurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends StoreProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreProductDefaultArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StorePurchaseItem model
   */ 
  interface StorePurchaseItemFieldRefs {
    readonly id: FieldRef<"StorePurchaseItem", 'String'>
    readonly purchaseOrderId: FieldRef<"StorePurchaseItem", 'String'>
    readonly productId: FieldRef<"StorePurchaseItem", 'String'>
    readonly quantity: FieldRef<"StorePurchaseItem", 'Decimal'>
    readonly unitCost: FieldRef<"StorePurchaseItem", 'Decimal'>
    readonly receivedQty: FieldRef<"StorePurchaseItem", 'Decimal'>
    readonly total: FieldRef<"StorePurchaseItem", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * StorePurchaseItem findUnique
   */
  export type StorePurchaseItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseItem
     */
    select?: StorePurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which StorePurchaseItem to fetch.
     */
    where: StorePurchaseItemWhereUniqueInput
  }

  /**
   * StorePurchaseItem findUniqueOrThrow
   */
  export type StorePurchaseItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseItem
     */
    select?: StorePurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which StorePurchaseItem to fetch.
     */
    where: StorePurchaseItemWhereUniqueInput
  }

  /**
   * StorePurchaseItem findFirst
   */
  export type StorePurchaseItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseItem
     */
    select?: StorePurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which StorePurchaseItem to fetch.
     */
    where?: StorePurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePurchaseItems to fetch.
     */
    orderBy?: StorePurchaseItemOrderByWithRelationInput | StorePurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorePurchaseItems.
     */
    cursor?: StorePurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorePurchaseItems.
     */
    distinct?: StorePurchaseItemScalarFieldEnum | StorePurchaseItemScalarFieldEnum[]
  }

  /**
   * StorePurchaseItem findFirstOrThrow
   */
  export type StorePurchaseItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseItem
     */
    select?: StorePurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which StorePurchaseItem to fetch.
     */
    where?: StorePurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePurchaseItems to fetch.
     */
    orderBy?: StorePurchaseItemOrderByWithRelationInput | StorePurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorePurchaseItems.
     */
    cursor?: StorePurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePurchaseItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorePurchaseItems.
     */
    distinct?: StorePurchaseItemScalarFieldEnum | StorePurchaseItemScalarFieldEnum[]
  }

  /**
   * StorePurchaseItem findMany
   */
  export type StorePurchaseItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseItem
     */
    select?: StorePurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseItemInclude<ExtArgs> | null
    /**
     * Filter, which StorePurchaseItems to fetch.
     */
    where?: StorePurchaseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePurchaseItems to fetch.
     */
    orderBy?: StorePurchaseItemOrderByWithRelationInput | StorePurchaseItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StorePurchaseItems.
     */
    cursor?: StorePurchaseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePurchaseItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePurchaseItems.
     */
    skip?: number
    distinct?: StorePurchaseItemScalarFieldEnum | StorePurchaseItemScalarFieldEnum[]
  }

  /**
   * StorePurchaseItem create
   */
  export type StorePurchaseItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseItem
     */
    select?: StorePurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseItemInclude<ExtArgs> | null
    /**
     * The data needed to create a StorePurchaseItem.
     */
    data: XOR<StorePurchaseItemCreateInput, StorePurchaseItemUncheckedCreateInput>
  }

  /**
   * StorePurchaseItem createMany
   */
  export type StorePurchaseItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StorePurchaseItems.
     */
    data: StorePurchaseItemCreateManyInput | StorePurchaseItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StorePurchaseItem createManyAndReturn
   */
  export type StorePurchaseItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseItem
     */
    select?: StorePurchaseItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StorePurchaseItems.
     */
    data: StorePurchaseItemCreateManyInput | StorePurchaseItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StorePurchaseItem update
   */
  export type StorePurchaseItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseItem
     */
    select?: StorePurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseItemInclude<ExtArgs> | null
    /**
     * The data needed to update a StorePurchaseItem.
     */
    data: XOR<StorePurchaseItemUpdateInput, StorePurchaseItemUncheckedUpdateInput>
    /**
     * Choose, which StorePurchaseItem to update.
     */
    where: StorePurchaseItemWhereUniqueInput
  }

  /**
   * StorePurchaseItem updateMany
   */
  export type StorePurchaseItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StorePurchaseItems.
     */
    data: XOR<StorePurchaseItemUpdateManyMutationInput, StorePurchaseItemUncheckedUpdateManyInput>
    /**
     * Filter which StorePurchaseItems to update
     */
    where?: StorePurchaseItemWhereInput
  }

  /**
   * StorePurchaseItem upsert
   */
  export type StorePurchaseItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseItem
     */
    select?: StorePurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseItemInclude<ExtArgs> | null
    /**
     * The filter to search for the StorePurchaseItem to update in case it exists.
     */
    where: StorePurchaseItemWhereUniqueInput
    /**
     * In case the StorePurchaseItem found by the `where` argument doesn't exist, create a new StorePurchaseItem with this data.
     */
    create: XOR<StorePurchaseItemCreateInput, StorePurchaseItemUncheckedCreateInput>
    /**
     * In case the StorePurchaseItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StorePurchaseItemUpdateInput, StorePurchaseItemUncheckedUpdateInput>
  }

  /**
   * StorePurchaseItem delete
   */
  export type StorePurchaseItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseItem
     */
    select?: StorePurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseItemInclude<ExtArgs> | null
    /**
     * Filter which StorePurchaseItem to delete.
     */
    where: StorePurchaseItemWhereUniqueInput
  }

  /**
   * StorePurchaseItem deleteMany
   */
  export type StorePurchaseItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorePurchaseItems to delete
     */
    where?: StorePurchaseItemWhereInput
  }

  /**
   * StorePurchaseItem without action
   */
  export type StorePurchaseItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePurchaseItem
     */
    select?: StorePurchaseItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePurchaseItemInclude<ExtArgs> | null
  }


  /**
   * Model StockMovement
   */

  export type AggregateStockMovement = {
    _count: StockMovementCountAggregateOutputType | null
    _avg: StockMovementAvgAggregateOutputType | null
    _sum: StockMovementSumAggregateOutputType | null
    _min: StockMovementMinAggregateOutputType | null
    _max: StockMovementMaxAggregateOutputType | null
  }

  export type StockMovementAvgAggregateOutputType = {
    quantity: Decimal | null
    previousStock: Decimal | null
    newStock: Decimal | null
  }

  export type StockMovementSumAggregateOutputType = {
    quantity: Decimal | null
    previousStock: Decimal | null
    newStock: Decimal | null
  }

  export type StockMovementMinAggregateOutputType = {
    id: string | null
    storeId: string | null
    productId: string | null
    type: $Enums.StoreMovementType | null
    quantity: Decimal | null
    previousStock: Decimal | null
    newStock: Decimal | null
    reason: string | null
    referenceType: string | null
    referenceId: string | null
    performedBy: string | null
    createdAt: Date | null
  }

  export type StockMovementMaxAggregateOutputType = {
    id: string | null
    storeId: string | null
    productId: string | null
    type: $Enums.StoreMovementType | null
    quantity: Decimal | null
    previousStock: Decimal | null
    newStock: Decimal | null
    reason: string | null
    referenceType: string | null
    referenceId: string | null
    performedBy: string | null
    createdAt: Date | null
  }

  export type StockMovementCountAggregateOutputType = {
    id: number
    storeId: number
    productId: number
    type: number
    quantity: number
    previousStock: number
    newStock: number
    reason: number
    referenceType: number
    referenceId: number
    performedBy: number
    createdAt: number
    _all: number
  }


  export type StockMovementAvgAggregateInputType = {
    quantity?: true
    previousStock?: true
    newStock?: true
  }

  export type StockMovementSumAggregateInputType = {
    quantity?: true
    previousStock?: true
    newStock?: true
  }

  export type StockMovementMinAggregateInputType = {
    id?: true
    storeId?: true
    productId?: true
    type?: true
    quantity?: true
    previousStock?: true
    newStock?: true
    reason?: true
    referenceType?: true
    referenceId?: true
    performedBy?: true
    createdAt?: true
  }

  export type StockMovementMaxAggregateInputType = {
    id?: true
    storeId?: true
    productId?: true
    type?: true
    quantity?: true
    previousStock?: true
    newStock?: true
    reason?: true
    referenceType?: true
    referenceId?: true
    performedBy?: true
    createdAt?: true
  }

  export type StockMovementCountAggregateInputType = {
    id?: true
    storeId?: true
    productId?: true
    type?: true
    quantity?: true
    previousStock?: true
    newStock?: true
    reason?: true
    referenceType?: true
    referenceId?: true
    performedBy?: true
    createdAt?: true
    _all?: true
  }

  export type StockMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMovement to aggregate.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockMovements
    **/
    _count?: true | StockMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMovementMaxAggregateInputType
  }

  export type GetStockMovementAggregateType<T extends StockMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateStockMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockMovement[P]>
      : GetScalarType<T[P], AggregateStockMovement[P]>
  }




  export type StockMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithAggregationInput | StockMovementOrderByWithAggregationInput[]
    by: StockMovementScalarFieldEnum[] | StockMovementScalarFieldEnum
    having?: StockMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockMovementCountAggregateInputType | true
    _avg?: StockMovementAvgAggregateInputType
    _sum?: StockMovementSumAggregateInputType
    _min?: StockMovementMinAggregateInputType
    _max?: StockMovementMaxAggregateInputType
  }

  export type StockMovementGroupByOutputType = {
    id: string
    storeId: string
    productId: string
    type: $Enums.StoreMovementType
    quantity: Decimal
    previousStock: Decimal
    newStock: Decimal
    reason: string | null
    referenceType: string | null
    referenceId: string | null
    performedBy: string | null
    createdAt: Date
    _count: StockMovementCountAggregateOutputType | null
    _avg: StockMovementAvgAggregateOutputType | null
    _sum: StockMovementSumAggregateOutputType | null
    _min: StockMovementMinAggregateOutputType | null
    _max: StockMovementMaxAggregateOutputType | null
  }

  type GetStockMovementGroupByPayload<T extends StockMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockMovementGroupByOutputType[P]>
            : GetScalarType<T[P], StockMovementGroupByOutputType[P]>
        }
      >
    >


  export type StockMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    productId?: boolean
    type?: boolean
    quantity?: boolean
    previousStock?: boolean
    newStock?: boolean
    reason?: boolean
    referenceType?: boolean
    referenceId?: boolean
    performedBy?: boolean
    createdAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockMovement"]>

  export type StockMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    productId?: boolean
    type?: boolean
    quantity?: boolean
    previousStock?: boolean
    newStock?: boolean
    reason?: boolean
    referenceType?: boolean
    referenceId?: boolean
    performedBy?: boolean
    createdAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockMovement"]>

  export type StockMovementSelectScalar = {
    id?: boolean
    storeId?: boolean
    productId?: boolean
    type?: boolean
    quantity?: boolean
    previousStock?: boolean
    newStock?: boolean
    reason?: boolean
    referenceType?: boolean
    referenceId?: boolean
    performedBy?: boolean
    createdAt?: boolean
  }

  export type StockMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }
  export type StockMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }

  export type $StockMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockMovement"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      product: Prisma.$StoreProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeId: string
      productId: string
      type: $Enums.StoreMovementType
      quantity: Prisma.Decimal
      previousStock: Prisma.Decimal
      newStock: Prisma.Decimal
      reason: string | null
      referenceType: string | null
      referenceId: string | null
      performedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["stockMovement"]>
    composites: {}
  }

  type StockMovementGetPayload<S extends boolean | null | undefined | StockMovementDefaultArgs> = $Result.GetResult<Prisma.$StockMovementPayload, S>

  type StockMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockMovementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockMovementCountAggregateInputType | true
    }

  export interface StockMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockMovement'], meta: { name: 'StockMovement' } }
    /**
     * Find zero or one StockMovement that matches the filter.
     * @param {StockMovementFindUniqueArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockMovementFindUniqueArgs>(args: SelectSubset<T, StockMovementFindUniqueArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StockMovement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StockMovementFindUniqueOrThrowArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, StockMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StockMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindFirstArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockMovementFindFirstArgs>(args?: SelectSubset<T, StockMovementFindFirstArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StockMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindFirstOrThrowArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, StockMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StockMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockMovements
     * const stockMovements = await prisma.stockMovement.findMany()
     * 
     * // Get first 10 StockMovements
     * const stockMovements = await prisma.stockMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockMovementWithIdOnly = await prisma.stockMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockMovementFindManyArgs>(args?: SelectSubset<T, StockMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StockMovement.
     * @param {StockMovementCreateArgs} args - Arguments to create a StockMovement.
     * @example
     * // Create one StockMovement
     * const StockMovement = await prisma.stockMovement.create({
     *   data: {
     *     // ... data to create a StockMovement
     *   }
     * })
     * 
     */
    create<T extends StockMovementCreateArgs>(args: SelectSubset<T, StockMovementCreateArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StockMovements.
     * @param {StockMovementCreateManyArgs} args - Arguments to create many StockMovements.
     * @example
     * // Create many StockMovements
     * const stockMovement = await prisma.stockMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockMovementCreateManyArgs>(args?: SelectSubset<T, StockMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockMovements and returns the data saved in the database.
     * @param {StockMovementCreateManyAndReturnArgs} args - Arguments to create many StockMovements.
     * @example
     * // Create many StockMovements
     * const stockMovement = await prisma.stockMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockMovements and only return the `id`
     * const stockMovementWithIdOnly = await prisma.stockMovement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, StockMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StockMovement.
     * @param {StockMovementDeleteArgs} args - Arguments to delete one StockMovement.
     * @example
     * // Delete one StockMovement
     * const StockMovement = await prisma.stockMovement.delete({
     *   where: {
     *     // ... filter to delete one StockMovement
     *   }
     * })
     * 
     */
    delete<T extends StockMovementDeleteArgs>(args: SelectSubset<T, StockMovementDeleteArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StockMovement.
     * @param {StockMovementUpdateArgs} args - Arguments to update one StockMovement.
     * @example
     * // Update one StockMovement
     * const stockMovement = await prisma.stockMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockMovementUpdateArgs>(args: SelectSubset<T, StockMovementUpdateArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StockMovements.
     * @param {StockMovementDeleteManyArgs} args - Arguments to filter StockMovements to delete.
     * @example
     * // Delete a few StockMovements
     * const { count } = await prisma.stockMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockMovementDeleteManyArgs>(args?: SelectSubset<T, StockMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockMovements
     * const stockMovement = await prisma.stockMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockMovementUpdateManyArgs>(args: SelectSubset<T, StockMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockMovement.
     * @param {StockMovementUpsertArgs} args - Arguments to update or create a StockMovement.
     * @example
     * // Update or create a StockMovement
     * const stockMovement = await prisma.stockMovement.upsert({
     *   create: {
     *     // ... data to create a StockMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockMovement we want to update
     *   }
     * })
     */
    upsert<T extends StockMovementUpsertArgs>(args: SelectSubset<T, StockMovementUpsertArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementCountArgs} args - Arguments to filter StockMovements to count.
     * @example
     * // Count the number of StockMovements
     * const count = await prisma.stockMovement.count({
     *   where: {
     *     // ... the filter for the StockMovements we want to count
     *   }
     * })
    **/
    count<T extends StockMovementCountArgs>(
      args?: Subset<T, StockMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockMovementAggregateArgs>(args: Subset<T, StockMovementAggregateArgs>): Prisma.PrismaPromise<GetStockMovementAggregateType<T>>

    /**
     * Group by StockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockMovementGroupByArgs['orderBy'] }
        : { orderBy?: StockMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockMovement model
   */
  readonly fields: StockMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends StoreProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreProductDefaultArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockMovement model
   */ 
  interface StockMovementFieldRefs {
    readonly id: FieldRef<"StockMovement", 'String'>
    readonly storeId: FieldRef<"StockMovement", 'String'>
    readonly productId: FieldRef<"StockMovement", 'String'>
    readonly type: FieldRef<"StockMovement", 'StoreMovementType'>
    readonly quantity: FieldRef<"StockMovement", 'Decimal'>
    readonly previousStock: FieldRef<"StockMovement", 'Decimal'>
    readonly newStock: FieldRef<"StockMovement", 'Decimal'>
    readonly reason: FieldRef<"StockMovement", 'String'>
    readonly referenceType: FieldRef<"StockMovement", 'String'>
    readonly referenceId: FieldRef<"StockMovement", 'String'>
    readonly performedBy: FieldRef<"StockMovement", 'String'>
    readonly createdAt: FieldRef<"StockMovement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockMovement findUnique
   */
  export type StockMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement findUniqueOrThrow
   */
  export type StockMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement findFirst
   */
  export type StockMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMovements.
     */
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement findFirstOrThrow
   */
  export type StockMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMovements.
     */
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement findMany
   */
  export type StockMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovements to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement create
   */
  export type StockMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a StockMovement.
     */
    data: XOR<StockMovementCreateInput, StockMovementUncheckedCreateInput>
  }

  /**
   * StockMovement createMany
   */
  export type StockMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockMovements.
     */
    data: StockMovementCreateManyInput | StockMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockMovement createManyAndReturn
   */
  export type StockMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StockMovements.
     */
    data: StockMovementCreateManyInput | StockMovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockMovement update
   */
  export type StockMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a StockMovement.
     */
    data: XOR<StockMovementUpdateInput, StockMovementUncheckedUpdateInput>
    /**
     * Choose, which StockMovement to update.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement updateMany
   */
  export type StockMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockMovements.
     */
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyInput>
    /**
     * Filter which StockMovements to update
     */
    where?: StockMovementWhereInput
  }

  /**
   * StockMovement upsert
   */
  export type StockMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the StockMovement to update in case it exists.
     */
    where: StockMovementWhereUniqueInput
    /**
     * In case the StockMovement found by the `where` argument doesn't exist, create a new StockMovement with this data.
     */
    create: XOR<StockMovementCreateInput, StockMovementUncheckedCreateInput>
    /**
     * In case the StockMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockMovementUpdateInput, StockMovementUncheckedUpdateInput>
  }

  /**
   * StockMovement delete
   */
  export type StockMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter which StockMovement to delete.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement deleteMany
   */
  export type StockMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMovements to delete
     */
    where?: StockMovementWhereInput
  }

  /**
   * StockMovement without action
   */
  export type StockMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
  }


  /**
   * Model TransferOrder
   */

  export type AggregateTransferOrder = {
    _count: TransferOrderCountAggregateOutputType | null
    _min: TransferOrderMinAggregateOutputType | null
    _max: TransferOrderMaxAggregateOutputType | null
  }

  export type TransferOrderMinAggregateOutputType = {
    id: string | null
    fromStoreId: string | null
    toStoreId: string | null
    transferNumber: string | null
    status: $Enums.TransferOrderStatus | null
    notes: string | null
    sentAt: Date | null
    receivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferOrderMaxAggregateOutputType = {
    id: string | null
    fromStoreId: string | null
    toStoreId: string | null
    transferNumber: string | null
    status: $Enums.TransferOrderStatus | null
    notes: string | null
    sentAt: Date | null
    receivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferOrderCountAggregateOutputType = {
    id: number
    fromStoreId: number
    toStoreId: number
    transferNumber: number
    status: number
    notes: number
    sentAt: number
    receivedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransferOrderMinAggregateInputType = {
    id?: true
    fromStoreId?: true
    toStoreId?: true
    transferNumber?: true
    status?: true
    notes?: true
    sentAt?: true
    receivedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferOrderMaxAggregateInputType = {
    id?: true
    fromStoreId?: true
    toStoreId?: true
    transferNumber?: true
    status?: true
    notes?: true
    sentAt?: true
    receivedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferOrderCountAggregateInputType = {
    id?: true
    fromStoreId?: true
    toStoreId?: true
    transferNumber?: true
    status?: true
    notes?: true
    sentAt?: true
    receivedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransferOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferOrder to aggregate.
     */
    where?: TransferOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferOrders to fetch.
     */
    orderBy?: TransferOrderOrderByWithRelationInput | TransferOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransferOrders
    **/
    _count?: true | TransferOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferOrderMaxAggregateInputType
  }

  export type GetTransferOrderAggregateType<T extends TransferOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateTransferOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransferOrder[P]>
      : GetScalarType<T[P], AggregateTransferOrder[P]>
  }




  export type TransferOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferOrderWhereInput
    orderBy?: TransferOrderOrderByWithAggregationInput | TransferOrderOrderByWithAggregationInput[]
    by: TransferOrderScalarFieldEnum[] | TransferOrderScalarFieldEnum
    having?: TransferOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferOrderCountAggregateInputType | true
    _min?: TransferOrderMinAggregateInputType
    _max?: TransferOrderMaxAggregateInputType
  }

  export type TransferOrderGroupByOutputType = {
    id: string
    fromStoreId: string
    toStoreId: string
    transferNumber: string
    status: $Enums.TransferOrderStatus
    notes: string | null
    sentAt: Date | null
    receivedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TransferOrderCountAggregateOutputType | null
    _min: TransferOrderMinAggregateOutputType | null
    _max: TransferOrderMaxAggregateOutputType | null
  }

  type GetTransferOrderGroupByPayload<T extends TransferOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferOrderGroupByOutputType[P]>
            : GetScalarType<T[P], TransferOrderGroupByOutputType[P]>
        }
      >
    >


  export type TransferOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromStoreId?: boolean
    toStoreId?: boolean
    transferNumber?: boolean
    status?: boolean
    notes?: boolean
    sentAt?: boolean
    receivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fromStore?: boolean | StoreDefaultArgs<ExtArgs>
    toStore?: boolean | StoreDefaultArgs<ExtArgs>
    items?: boolean | TransferOrder$itemsArgs<ExtArgs>
    _count?: boolean | TransferOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferOrder"]>

  export type TransferOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromStoreId?: boolean
    toStoreId?: boolean
    transferNumber?: boolean
    status?: boolean
    notes?: boolean
    sentAt?: boolean
    receivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fromStore?: boolean | StoreDefaultArgs<ExtArgs>
    toStore?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferOrder"]>

  export type TransferOrderSelectScalar = {
    id?: boolean
    fromStoreId?: boolean
    toStoreId?: boolean
    transferNumber?: boolean
    status?: boolean
    notes?: boolean
    sentAt?: boolean
    receivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransferOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromStore?: boolean | StoreDefaultArgs<ExtArgs>
    toStore?: boolean | StoreDefaultArgs<ExtArgs>
    items?: boolean | TransferOrder$itemsArgs<ExtArgs>
    _count?: boolean | TransferOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransferOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromStore?: boolean | StoreDefaultArgs<ExtArgs>
    toStore?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $TransferOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransferOrder"
    objects: {
      fromStore: Prisma.$StorePayload<ExtArgs>
      toStore: Prisma.$StorePayload<ExtArgs>
      items: Prisma.$TransferOrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fromStoreId: string
      toStoreId: string
      transferNumber: string
      status: $Enums.TransferOrderStatus
      notes: string | null
      sentAt: Date | null
      receivedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transferOrder"]>
    composites: {}
  }

  type TransferOrderGetPayload<S extends boolean | null | undefined | TransferOrderDefaultArgs> = $Result.GetResult<Prisma.$TransferOrderPayload, S>

  type TransferOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransferOrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransferOrderCountAggregateInputType | true
    }

  export interface TransferOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransferOrder'], meta: { name: 'TransferOrder' } }
    /**
     * Find zero or one TransferOrder that matches the filter.
     * @param {TransferOrderFindUniqueArgs} args - Arguments to find a TransferOrder
     * @example
     * // Get one TransferOrder
     * const transferOrder = await prisma.transferOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferOrderFindUniqueArgs>(args: SelectSubset<T, TransferOrderFindUniqueArgs<ExtArgs>>): Prisma__TransferOrderClient<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TransferOrder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransferOrderFindUniqueOrThrowArgs} args - Arguments to find a TransferOrder
     * @example
     * // Get one TransferOrder
     * const transferOrder = await prisma.transferOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferOrderClient<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TransferOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderFindFirstArgs} args - Arguments to find a TransferOrder
     * @example
     * // Get one TransferOrder
     * const transferOrder = await prisma.transferOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferOrderFindFirstArgs>(args?: SelectSubset<T, TransferOrderFindFirstArgs<ExtArgs>>): Prisma__TransferOrderClient<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TransferOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderFindFirstOrThrowArgs} args - Arguments to find a TransferOrder
     * @example
     * // Get one TransferOrder
     * const transferOrder = await prisma.transferOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferOrderClient<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TransferOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransferOrders
     * const transferOrders = await prisma.transferOrder.findMany()
     * 
     * // Get first 10 TransferOrders
     * const transferOrders = await prisma.transferOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferOrderWithIdOnly = await prisma.transferOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferOrderFindManyArgs>(args?: SelectSubset<T, TransferOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TransferOrder.
     * @param {TransferOrderCreateArgs} args - Arguments to create a TransferOrder.
     * @example
     * // Create one TransferOrder
     * const TransferOrder = await prisma.transferOrder.create({
     *   data: {
     *     // ... data to create a TransferOrder
     *   }
     * })
     * 
     */
    create<T extends TransferOrderCreateArgs>(args: SelectSubset<T, TransferOrderCreateArgs<ExtArgs>>): Prisma__TransferOrderClient<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TransferOrders.
     * @param {TransferOrderCreateManyArgs} args - Arguments to create many TransferOrders.
     * @example
     * // Create many TransferOrders
     * const transferOrder = await prisma.transferOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferOrderCreateManyArgs>(args?: SelectSubset<T, TransferOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransferOrders and returns the data saved in the database.
     * @param {TransferOrderCreateManyAndReturnArgs} args - Arguments to create many TransferOrders.
     * @example
     * // Create many TransferOrders
     * const transferOrder = await prisma.transferOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransferOrders and only return the `id`
     * const transferOrderWithIdOnly = await prisma.transferOrder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TransferOrder.
     * @param {TransferOrderDeleteArgs} args - Arguments to delete one TransferOrder.
     * @example
     * // Delete one TransferOrder
     * const TransferOrder = await prisma.transferOrder.delete({
     *   where: {
     *     // ... filter to delete one TransferOrder
     *   }
     * })
     * 
     */
    delete<T extends TransferOrderDeleteArgs>(args: SelectSubset<T, TransferOrderDeleteArgs<ExtArgs>>): Prisma__TransferOrderClient<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TransferOrder.
     * @param {TransferOrderUpdateArgs} args - Arguments to update one TransferOrder.
     * @example
     * // Update one TransferOrder
     * const transferOrder = await prisma.transferOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferOrderUpdateArgs>(args: SelectSubset<T, TransferOrderUpdateArgs<ExtArgs>>): Prisma__TransferOrderClient<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TransferOrders.
     * @param {TransferOrderDeleteManyArgs} args - Arguments to filter TransferOrders to delete.
     * @example
     * // Delete a few TransferOrders
     * const { count } = await prisma.transferOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferOrderDeleteManyArgs>(args?: SelectSubset<T, TransferOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransferOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransferOrders
     * const transferOrder = await prisma.transferOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferOrderUpdateManyArgs>(args: SelectSubset<T, TransferOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransferOrder.
     * @param {TransferOrderUpsertArgs} args - Arguments to update or create a TransferOrder.
     * @example
     * // Update or create a TransferOrder
     * const transferOrder = await prisma.transferOrder.upsert({
     *   create: {
     *     // ... data to create a TransferOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransferOrder we want to update
     *   }
     * })
     */
    upsert<T extends TransferOrderUpsertArgs>(args: SelectSubset<T, TransferOrderUpsertArgs<ExtArgs>>): Prisma__TransferOrderClient<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TransferOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderCountArgs} args - Arguments to filter TransferOrders to count.
     * @example
     * // Count the number of TransferOrders
     * const count = await prisma.transferOrder.count({
     *   where: {
     *     // ... the filter for the TransferOrders we want to count
     *   }
     * })
    **/
    count<T extends TransferOrderCountArgs>(
      args?: Subset<T, TransferOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransferOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferOrderAggregateArgs>(args: Subset<T, TransferOrderAggregateArgs>): Prisma.PrismaPromise<GetTransferOrderAggregateType<T>>

    /**
     * Group by TransferOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferOrderGroupByArgs['orderBy'] }
        : { orderBy?: TransferOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransferOrder model
   */
  readonly fields: TransferOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransferOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromStore<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    toStore<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends TransferOrder$itemsArgs<ExtArgs> = {}>(args?: Subset<T, TransferOrder$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransferOrder model
   */ 
  interface TransferOrderFieldRefs {
    readonly id: FieldRef<"TransferOrder", 'String'>
    readonly fromStoreId: FieldRef<"TransferOrder", 'String'>
    readonly toStoreId: FieldRef<"TransferOrder", 'String'>
    readonly transferNumber: FieldRef<"TransferOrder", 'String'>
    readonly status: FieldRef<"TransferOrder", 'TransferOrderStatus'>
    readonly notes: FieldRef<"TransferOrder", 'String'>
    readonly sentAt: FieldRef<"TransferOrder", 'DateTime'>
    readonly receivedAt: FieldRef<"TransferOrder", 'DateTime'>
    readonly createdAt: FieldRef<"TransferOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"TransferOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransferOrder findUnique
   */
  export type TransferOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrder to fetch.
     */
    where: TransferOrderWhereUniqueInput
  }

  /**
   * TransferOrder findUniqueOrThrow
   */
  export type TransferOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrder to fetch.
     */
    where: TransferOrderWhereUniqueInput
  }

  /**
   * TransferOrder findFirst
   */
  export type TransferOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrder to fetch.
     */
    where?: TransferOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferOrders to fetch.
     */
    orderBy?: TransferOrderOrderByWithRelationInput | TransferOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferOrders.
     */
    cursor?: TransferOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferOrders.
     */
    distinct?: TransferOrderScalarFieldEnum | TransferOrderScalarFieldEnum[]
  }

  /**
   * TransferOrder findFirstOrThrow
   */
  export type TransferOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrder to fetch.
     */
    where?: TransferOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferOrders to fetch.
     */
    orderBy?: TransferOrderOrderByWithRelationInput | TransferOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferOrders.
     */
    cursor?: TransferOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferOrders.
     */
    distinct?: TransferOrderScalarFieldEnum | TransferOrderScalarFieldEnum[]
  }

  /**
   * TransferOrder findMany
   */
  export type TransferOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrders to fetch.
     */
    where?: TransferOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferOrders to fetch.
     */
    orderBy?: TransferOrderOrderByWithRelationInput | TransferOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransferOrders.
     */
    cursor?: TransferOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferOrders.
     */
    skip?: number
    distinct?: TransferOrderScalarFieldEnum | TransferOrderScalarFieldEnum[]
  }

  /**
   * TransferOrder create
   */
  export type TransferOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a TransferOrder.
     */
    data: XOR<TransferOrderCreateInput, TransferOrderUncheckedCreateInput>
  }

  /**
   * TransferOrder createMany
   */
  export type TransferOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransferOrders.
     */
    data: TransferOrderCreateManyInput | TransferOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransferOrder createManyAndReturn
   */
  export type TransferOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TransferOrders.
     */
    data: TransferOrderCreateManyInput | TransferOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransferOrder update
   */
  export type TransferOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a TransferOrder.
     */
    data: XOR<TransferOrderUpdateInput, TransferOrderUncheckedUpdateInput>
    /**
     * Choose, which TransferOrder to update.
     */
    where: TransferOrderWhereUniqueInput
  }

  /**
   * TransferOrder updateMany
   */
  export type TransferOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransferOrders.
     */
    data: XOR<TransferOrderUpdateManyMutationInput, TransferOrderUncheckedUpdateManyInput>
    /**
     * Filter which TransferOrders to update
     */
    where?: TransferOrderWhereInput
  }

  /**
   * TransferOrder upsert
   */
  export type TransferOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the TransferOrder to update in case it exists.
     */
    where: TransferOrderWhereUniqueInput
    /**
     * In case the TransferOrder found by the `where` argument doesn't exist, create a new TransferOrder with this data.
     */
    create: XOR<TransferOrderCreateInput, TransferOrderUncheckedCreateInput>
    /**
     * In case the TransferOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferOrderUpdateInput, TransferOrderUncheckedUpdateInput>
  }

  /**
   * TransferOrder delete
   */
  export type TransferOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
    /**
     * Filter which TransferOrder to delete.
     */
    where: TransferOrderWhereUniqueInput
  }

  /**
   * TransferOrder deleteMany
   */
  export type TransferOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferOrders to delete
     */
    where?: TransferOrderWhereInput
  }

  /**
   * TransferOrder.items
   */
  export type TransferOrder$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    where?: TransferOrderItemWhereInput
    orderBy?: TransferOrderItemOrderByWithRelationInput | TransferOrderItemOrderByWithRelationInput[]
    cursor?: TransferOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferOrderItemScalarFieldEnum | TransferOrderItemScalarFieldEnum[]
  }

  /**
   * TransferOrder without action
   */
  export type TransferOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrder
     */
    select?: TransferOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderInclude<ExtArgs> | null
  }


  /**
   * Model TransferOrderItem
   */

  export type AggregateTransferOrderItem = {
    _count: TransferOrderItemCountAggregateOutputType | null
    _avg: TransferOrderItemAvgAggregateOutputType | null
    _sum: TransferOrderItemSumAggregateOutputType | null
    _min: TransferOrderItemMinAggregateOutputType | null
    _max: TransferOrderItemMaxAggregateOutputType | null
  }

  export type TransferOrderItemAvgAggregateOutputType = {
    quantity: Decimal | null
    unitCost: Decimal | null
  }

  export type TransferOrderItemSumAggregateOutputType = {
    quantity: Decimal | null
    unitCost: Decimal | null
  }

  export type TransferOrderItemMinAggregateOutputType = {
    id: string | null
    transferOrderId: string | null
    productId: string | null
    quantity: Decimal | null
    unitCost: Decimal | null
  }

  export type TransferOrderItemMaxAggregateOutputType = {
    id: string | null
    transferOrderId: string | null
    productId: string | null
    quantity: Decimal | null
    unitCost: Decimal | null
  }

  export type TransferOrderItemCountAggregateOutputType = {
    id: number
    transferOrderId: number
    productId: number
    quantity: number
    unitCost: number
    _all: number
  }


  export type TransferOrderItemAvgAggregateInputType = {
    quantity?: true
    unitCost?: true
  }

  export type TransferOrderItemSumAggregateInputType = {
    quantity?: true
    unitCost?: true
  }

  export type TransferOrderItemMinAggregateInputType = {
    id?: true
    transferOrderId?: true
    productId?: true
    quantity?: true
    unitCost?: true
  }

  export type TransferOrderItemMaxAggregateInputType = {
    id?: true
    transferOrderId?: true
    productId?: true
    quantity?: true
    unitCost?: true
  }

  export type TransferOrderItemCountAggregateInputType = {
    id?: true
    transferOrderId?: true
    productId?: true
    quantity?: true
    unitCost?: true
    _all?: true
  }

  export type TransferOrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferOrderItem to aggregate.
     */
    where?: TransferOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferOrderItems to fetch.
     */
    orderBy?: TransferOrderItemOrderByWithRelationInput | TransferOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransferOrderItems
    **/
    _count?: true | TransferOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransferOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransferOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferOrderItemMaxAggregateInputType
  }

  export type GetTransferOrderItemAggregateType<T extends TransferOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTransferOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransferOrderItem[P]>
      : GetScalarType<T[P], AggregateTransferOrderItem[P]>
  }




  export type TransferOrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferOrderItemWhereInput
    orderBy?: TransferOrderItemOrderByWithAggregationInput | TransferOrderItemOrderByWithAggregationInput[]
    by: TransferOrderItemScalarFieldEnum[] | TransferOrderItemScalarFieldEnum
    having?: TransferOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferOrderItemCountAggregateInputType | true
    _avg?: TransferOrderItemAvgAggregateInputType
    _sum?: TransferOrderItemSumAggregateInputType
    _min?: TransferOrderItemMinAggregateInputType
    _max?: TransferOrderItemMaxAggregateInputType
  }

  export type TransferOrderItemGroupByOutputType = {
    id: string
    transferOrderId: string
    productId: string
    quantity: Decimal
    unitCost: Decimal | null
    _count: TransferOrderItemCountAggregateOutputType | null
    _avg: TransferOrderItemAvgAggregateOutputType | null
    _sum: TransferOrderItemSumAggregateOutputType | null
    _min: TransferOrderItemMinAggregateOutputType | null
    _max: TransferOrderItemMaxAggregateOutputType | null
  }

  type GetTransferOrderItemGroupByPayload<T extends TransferOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], TransferOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type TransferOrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitCost?: boolean
    transferOrder?: boolean | TransferOrderDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferOrderItem"]>

  export type TransferOrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitCost?: boolean
    transferOrder?: boolean | TransferOrderDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transferOrderItem"]>

  export type TransferOrderItemSelectScalar = {
    id?: boolean
    transferOrderId?: boolean
    productId?: boolean
    quantity?: boolean
    unitCost?: boolean
  }

  export type TransferOrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transferOrder?: boolean | TransferOrderDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }
  export type TransferOrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transferOrder?: boolean | TransferOrderDefaultArgs<ExtArgs>
    product?: boolean | StoreProductDefaultArgs<ExtArgs>
  }

  export type $TransferOrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransferOrderItem"
    objects: {
      transferOrder: Prisma.$TransferOrderPayload<ExtArgs>
      product: Prisma.$StoreProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transferOrderId: string
      productId: string
      quantity: Prisma.Decimal
      unitCost: Prisma.Decimal | null
    }, ExtArgs["result"]["transferOrderItem"]>
    composites: {}
  }

  type TransferOrderItemGetPayload<S extends boolean | null | undefined | TransferOrderItemDefaultArgs> = $Result.GetResult<Prisma.$TransferOrderItemPayload, S>

  type TransferOrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransferOrderItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransferOrderItemCountAggregateInputType | true
    }

  export interface TransferOrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransferOrderItem'], meta: { name: 'TransferOrderItem' } }
    /**
     * Find zero or one TransferOrderItem that matches the filter.
     * @param {TransferOrderItemFindUniqueArgs} args - Arguments to find a TransferOrderItem
     * @example
     * // Get one TransferOrderItem
     * const transferOrderItem = await prisma.transferOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferOrderItemFindUniqueArgs>(args: SelectSubset<T, TransferOrderItemFindUniqueArgs<ExtArgs>>): Prisma__TransferOrderItemClient<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TransferOrderItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransferOrderItemFindUniqueOrThrowArgs} args - Arguments to find a TransferOrderItem
     * @example
     * // Get one TransferOrderItem
     * const transferOrderItem = await prisma.transferOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferOrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferOrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferOrderItemClient<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TransferOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderItemFindFirstArgs} args - Arguments to find a TransferOrderItem
     * @example
     * // Get one TransferOrderItem
     * const transferOrderItem = await prisma.transferOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferOrderItemFindFirstArgs>(args?: SelectSubset<T, TransferOrderItemFindFirstArgs<ExtArgs>>): Prisma__TransferOrderItemClient<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TransferOrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderItemFindFirstOrThrowArgs} args - Arguments to find a TransferOrderItem
     * @example
     * // Get one TransferOrderItem
     * const transferOrderItem = await prisma.transferOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferOrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferOrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferOrderItemClient<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TransferOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransferOrderItems
     * const transferOrderItems = await prisma.transferOrderItem.findMany()
     * 
     * // Get first 10 TransferOrderItems
     * const transferOrderItems = await prisma.transferOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferOrderItemWithIdOnly = await prisma.transferOrderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferOrderItemFindManyArgs>(args?: SelectSubset<T, TransferOrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TransferOrderItem.
     * @param {TransferOrderItemCreateArgs} args - Arguments to create a TransferOrderItem.
     * @example
     * // Create one TransferOrderItem
     * const TransferOrderItem = await prisma.transferOrderItem.create({
     *   data: {
     *     // ... data to create a TransferOrderItem
     *   }
     * })
     * 
     */
    create<T extends TransferOrderItemCreateArgs>(args: SelectSubset<T, TransferOrderItemCreateArgs<ExtArgs>>): Prisma__TransferOrderItemClient<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TransferOrderItems.
     * @param {TransferOrderItemCreateManyArgs} args - Arguments to create many TransferOrderItems.
     * @example
     * // Create many TransferOrderItems
     * const transferOrderItem = await prisma.transferOrderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferOrderItemCreateManyArgs>(args?: SelectSubset<T, TransferOrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransferOrderItems and returns the data saved in the database.
     * @param {TransferOrderItemCreateManyAndReturnArgs} args - Arguments to create many TransferOrderItems.
     * @example
     * // Create many TransferOrderItems
     * const transferOrderItem = await prisma.transferOrderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransferOrderItems and only return the `id`
     * const transferOrderItemWithIdOnly = await prisma.transferOrderItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferOrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferOrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TransferOrderItem.
     * @param {TransferOrderItemDeleteArgs} args - Arguments to delete one TransferOrderItem.
     * @example
     * // Delete one TransferOrderItem
     * const TransferOrderItem = await prisma.transferOrderItem.delete({
     *   where: {
     *     // ... filter to delete one TransferOrderItem
     *   }
     * })
     * 
     */
    delete<T extends TransferOrderItemDeleteArgs>(args: SelectSubset<T, TransferOrderItemDeleteArgs<ExtArgs>>): Prisma__TransferOrderItemClient<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TransferOrderItem.
     * @param {TransferOrderItemUpdateArgs} args - Arguments to update one TransferOrderItem.
     * @example
     * // Update one TransferOrderItem
     * const transferOrderItem = await prisma.transferOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferOrderItemUpdateArgs>(args: SelectSubset<T, TransferOrderItemUpdateArgs<ExtArgs>>): Prisma__TransferOrderItemClient<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TransferOrderItems.
     * @param {TransferOrderItemDeleteManyArgs} args - Arguments to filter TransferOrderItems to delete.
     * @example
     * // Delete a few TransferOrderItems
     * const { count } = await prisma.transferOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferOrderItemDeleteManyArgs>(args?: SelectSubset<T, TransferOrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransferOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransferOrderItems
     * const transferOrderItem = await prisma.transferOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferOrderItemUpdateManyArgs>(args: SelectSubset<T, TransferOrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransferOrderItem.
     * @param {TransferOrderItemUpsertArgs} args - Arguments to update or create a TransferOrderItem.
     * @example
     * // Update or create a TransferOrderItem
     * const transferOrderItem = await prisma.transferOrderItem.upsert({
     *   create: {
     *     // ... data to create a TransferOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransferOrderItem we want to update
     *   }
     * })
     */
    upsert<T extends TransferOrderItemUpsertArgs>(args: SelectSubset<T, TransferOrderItemUpsertArgs<ExtArgs>>): Prisma__TransferOrderItemClient<$Result.GetResult<Prisma.$TransferOrderItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TransferOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderItemCountArgs} args - Arguments to filter TransferOrderItems to count.
     * @example
     * // Count the number of TransferOrderItems
     * const count = await prisma.transferOrderItem.count({
     *   where: {
     *     // ... the filter for the TransferOrderItems we want to count
     *   }
     * })
    **/
    count<T extends TransferOrderItemCountArgs>(
      args?: Subset<T, TransferOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransferOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferOrderItemAggregateArgs>(args: Subset<T, TransferOrderItemAggregateArgs>): Prisma.PrismaPromise<GetTransferOrderItemAggregateType<T>>

    /**
     * Group by TransferOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: TransferOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransferOrderItem model
   */
  readonly fields: TransferOrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransferOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferOrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transferOrder<T extends TransferOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransferOrderDefaultArgs<ExtArgs>>): Prisma__TransferOrderClient<$Result.GetResult<Prisma.$TransferOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends StoreProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreProductDefaultArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransferOrderItem model
   */ 
  interface TransferOrderItemFieldRefs {
    readonly id: FieldRef<"TransferOrderItem", 'String'>
    readonly transferOrderId: FieldRef<"TransferOrderItem", 'String'>
    readonly productId: FieldRef<"TransferOrderItem", 'String'>
    readonly quantity: FieldRef<"TransferOrderItem", 'Decimal'>
    readonly unitCost: FieldRef<"TransferOrderItem", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * TransferOrderItem findUnique
   */
  export type TransferOrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrderItem to fetch.
     */
    where: TransferOrderItemWhereUniqueInput
  }

  /**
   * TransferOrderItem findUniqueOrThrow
   */
  export type TransferOrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrderItem to fetch.
     */
    where: TransferOrderItemWhereUniqueInput
  }

  /**
   * TransferOrderItem findFirst
   */
  export type TransferOrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrderItem to fetch.
     */
    where?: TransferOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferOrderItems to fetch.
     */
    orderBy?: TransferOrderItemOrderByWithRelationInput | TransferOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferOrderItems.
     */
    cursor?: TransferOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferOrderItems.
     */
    distinct?: TransferOrderItemScalarFieldEnum | TransferOrderItemScalarFieldEnum[]
  }

  /**
   * TransferOrderItem findFirstOrThrow
   */
  export type TransferOrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrderItem to fetch.
     */
    where?: TransferOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferOrderItems to fetch.
     */
    orderBy?: TransferOrderItemOrderByWithRelationInput | TransferOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransferOrderItems.
     */
    cursor?: TransferOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransferOrderItems.
     */
    distinct?: TransferOrderItemScalarFieldEnum | TransferOrderItemScalarFieldEnum[]
  }

  /**
   * TransferOrderItem findMany
   */
  export type TransferOrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which TransferOrderItems to fetch.
     */
    where?: TransferOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransferOrderItems to fetch.
     */
    orderBy?: TransferOrderItemOrderByWithRelationInput | TransferOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransferOrderItems.
     */
    cursor?: TransferOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransferOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransferOrderItems.
     */
    skip?: number
    distinct?: TransferOrderItemScalarFieldEnum | TransferOrderItemScalarFieldEnum[]
  }

  /**
   * TransferOrderItem create
   */
  export type TransferOrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a TransferOrderItem.
     */
    data: XOR<TransferOrderItemCreateInput, TransferOrderItemUncheckedCreateInput>
  }

  /**
   * TransferOrderItem createMany
   */
  export type TransferOrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransferOrderItems.
     */
    data: TransferOrderItemCreateManyInput | TransferOrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransferOrderItem createManyAndReturn
   */
  export type TransferOrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TransferOrderItems.
     */
    data: TransferOrderItemCreateManyInput | TransferOrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransferOrderItem update
   */
  export type TransferOrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a TransferOrderItem.
     */
    data: XOR<TransferOrderItemUpdateInput, TransferOrderItemUncheckedUpdateInput>
    /**
     * Choose, which TransferOrderItem to update.
     */
    where: TransferOrderItemWhereUniqueInput
  }

  /**
   * TransferOrderItem updateMany
   */
  export type TransferOrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransferOrderItems.
     */
    data: XOR<TransferOrderItemUpdateManyMutationInput, TransferOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which TransferOrderItems to update
     */
    where?: TransferOrderItemWhereInput
  }

  /**
   * TransferOrderItem upsert
   */
  export type TransferOrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the TransferOrderItem to update in case it exists.
     */
    where: TransferOrderItemWhereUniqueInput
    /**
     * In case the TransferOrderItem found by the `where` argument doesn't exist, create a new TransferOrderItem with this data.
     */
    create: XOR<TransferOrderItemCreateInput, TransferOrderItemUncheckedCreateInput>
    /**
     * In case the TransferOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferOrderItemUpdateInput, TransferOrderItemUncheckedUpdateInput>
  }

  /**
   * TransferOrderItem delete
   */
  export type TransferOrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
    /**
     * Filter which TransferOrderItem to delete.
     */
    where: TransferOrderItemWhereUniqueInput
  }

  /**
   * TransferOrderItem deleteMany
   */
  export type TransferOrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransferOrderItems to delete
     */
    where?: TransferOrderItemWhereInput
  }

  /**
   * TransferOrderItem without action
   */
  export type TransferOrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransferOrderItem
     */
    select?: TransferOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferOrderItemInclude<ExtArgs> | null
  }


  /**
   * Model StoreCustomer
   */

  export type AggregateStoreCustomer = {
    _count: StoreCustomerCountAggregateOutputType | null
    _avg: StoreCustomerAvgAggregateOutputType | null
    _sum: StoreCustomerSumAggregateOutputType | null
    _min: StoreCustomerMinAggregateOutputType | null
    _max: StoreCustomerMaxAggregateOutputType | null
  }

  export type StoreCustomerAvgAggregateOutputType = {
    totalPurchases: Decimal | null
    loyaltyPoints: number | null
    totalLifetimePurchases: Decimal | null
  }

  export type StoreCustomerSumAggregateOutputType = {
    totalPurchases: Decimal | null
    loyaltyPoints: number | null
    totalLifetimePurchases: Decimal | null
  }

  export type StoreCustomerMinAggregateOutputType = {
    id: string | null
    storeId: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    address: string | null
    taxId: string | null
    notes: string | null
    totalPurchases: Decimal | null
    loyaltyPoints: number | null
    loyaltyTier: $Enums.LoyaltyTier | null
    totalLifetimePurchases: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreCustomerMaxAggregateOutputType = {
    id: string | null
    storeId: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    address: string | null
    taxId: string | null
    notes: string | null
    totalPurchases: Decimal | null
    loyaltyPoints: number | null
    loyaltyTier: $Enums.LoyaltyTier | null
    totalLifetimePurchases: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreCustomerCountAggregateOutputType = {
    id: number
    storeId: number
    firstName: number
    lastName: number
    phone: number
    email: number
    address: number
    taxId: number
    notes: number
    totalPurchases: number
    loyaltyPoints: number
    loyaltyTier: number
    totalLifetimePurchases: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoreCustomerAvgAggregateInputType = {
    totalPurchases?: true
    loyaltyPoints?: true
    totalLifetimePurchases?: true
  }

  export type StoreCustomerSumAggregateInputType = {
    totalPurchases?: true
    loyaltyPoints?: true
    totalLifetimePurchases?: true
  }

  export type StoreCustomerMinAggregateInputType = {
    id?: true
    storeId?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    address?: true
    taxId?: true
    notes?: true
    totalPurchases?: true
    loyaltyPoints?: true
    loyaltyTier?: true
    totalLifetimePurchases?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreCustomerMaxAggregateInputType = {
    id?: true
    storeId?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    address?: true
    taxId?: true
    notes?: true
    totalPurchases?: true
    loyaltyPoints?: true
    loyaltyTier?: true
    totalLifetimePurchases?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreCustomerCountAggregateInputType = {
    id?: true
    storeId?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    address?: true
    taxId?: true
    notes?: true
    totalPurchases?: true
    loyaltyPoints?: true
    loyaltyTier?: true
    totalLifetimePurchases?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoreCustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreCustomer to aggregate.
     */
    where?: StoreCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreCustomers to fetch.
     */
    orderBy?: StoreCustomerOrderByWithRelationInput | StoreCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreCustomers
    **/
    _count?: true | StoreCustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreCustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreCustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreCustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreCustomerMaxAggregateInputType
  }

  export type GetStoreCustomerAggregateType<T extends StoreCustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreCustomer[P]>
      : GetScalarType<T[P], AggregateStoreCustomer[P]>
  }




  export type StoreCustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreCustomerWhereInput
    orderBy?: StoreCustomerOrderByWithAggregationInput | StoreCustomerOrderByWithAggregationInput[]
    by: StoreCustomerScalarFieldEnum[] | StoreCustomerScalarFieldEnum
    having?: StoreCustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreCustomerCountAggregateInputType | true
    _avg?: StoreCustomerAvgAggregateInputType
    _sum?: StoreCustomerSumAggregateInputType
    _min?: StoreCustomerMinAggregateInputType
    _max?: StoreCustomerMaxAggregateInputType
  }

  export type StoreCustomerGroupByOutputType = {
    id: string
    storeId: string
    firstName: string
    lastName: string | null
    phone: string | null
    email: string | null
    address: string | null
    taxId: string | null
    notes: string | null
    totalPurchases: Decimal
    loyaltyPoints: number
    loyaltyTier: $Enums.LoyaltyTier
    totalLifetimePurchases: Decimal
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StoreCustomerCountAggregateOutputType | null
    _avg: StoreCustomerAvgAggregateOutputType | null
    _sum: StoreCustomerSumAggregateOutputType | null
    _min: StoreCustomerMinAggregateOutputType | null
    _max: StoreCustomerMaxAggregateOutputType | null
  }

  type GetStoreCustomerGroupByPayload<T extends StoreCustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreCustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreCustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreCustomerGroupByOutputType[P]>
            : GetScalarType<T[P], StoreCustomerGroupByOutputType[P]>
        }
      >
    >


  export type StoreCustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    taxId?: boolean
    notes?: boolean
    totalPurchases?: boolean
    loyaltyPoints?: boolean
    loyaltyTier?: boolean
    totalLifetimePurchases?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    sales?: boolean | StoreCustomer$salesArgs<ExtArgs>
    loyaltyTransactions?: boolean | StoreCustomer$loyaltyTransactionsArgs<ExtArgs>
    _count?: boolean | StoreCustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeCustomer"]>

  export type StoreCustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    taxId?: boolean
    notes?: boolean
    totalPurchases?: boolean
    loyaltyPoints?: boolean
    loyaltyTier?: boolean
    totalLifetimePurchases?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeCustomer"]>

  export type StoreCustomerSelectScalar = {
    id?: boolean
    storeId?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    taxId?: boolean
    notes?: boolean
    totalPurchases?: boolean
    loyaltyPoints?: boolean
    loyaltyTier?: boolean
    totalLifetimePurchases?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoreCustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    sales?: boolean | StoreCustomer$salesArgs<ExtArgs>
    loyaltyTransactions?: boolean | StoreCustomer$loyaltyTransactionsArgs<ExtArgs>
    _count?: boolean | StoreCustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoreCustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $StoreCustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreCustomer"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      sales: Prisma.$SalePayload<ExtArgs>[]
      loyaltyTransactions: Prisma.$StoreLoyaltyTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeId: string
      firstName: string
      lastName: string | null
      phone: string | null
      email: string | null
      address: string | null
      taxId: string | null
      notes: string | null
      totalPurchases: Prisma.Decimal
      loyaltyPoints: number
      loyaltyTier: $Enums.LoyaltyTier
      totalLifetimePurchases: Prisma.Decimal
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storeCustomer"]>
    composites: {}
  }

  type StoreCustomerGetPayload<S extends boolean | null | undefined | StoreCustomerDefaultArgs> = $Result.GetResult<Prisma.$StoreCustomerPayload, S>

  type StoreCustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoreCustomerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoreCustomerCountAggregateInputType | true
    }

  export interface StoreCustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreCustomer'], meta: { name: 'StoreCustomer' } }
    /**
     * Find zero or one StoreCustomer that matches the filter.
     * @param {StoreCustomerFindUniqueArgs} args - Arguments to find a StoreCustomer
     * @example
     * // Get one StoreCustomer
     * const storeCustomer = await prisma.storeCustomer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreCustomerFindUniqueArgs>(args: SelectSubset<T, StoreCustomerFindUniqueArgs<ExtArgs>>): Prisma__StoreCustomerClient<$Result.GetResult<Prisma.$StoreCustomerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StoreCustomer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoreCustomerFindUniqueOrThrowArgs} args - Arguments to find a StoreCustomer
     * @example
     * // Get one StoreCustomer
     * const storeCustomer = await prisma.storeCustomer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreCustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreCustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreCustomerClient<$Result.GetResult<Prisma.$StoreCustomerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StoreCustomer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCustomerFindFirstArgs} args - Arguments to find a StoreCustomer
     * @example
     * // Get one StoreCustomer
     * const storeCustomer = await prisma.storeCustomer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreCustomerFindFirstArgs>(args?: SelectSubset<T, StoreCustomerFindFirstArgs<ExtArgs>>): Prisma__StoreCustomerClient<$Result.GetResult<Prisma.$StoreCustomerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StoreCustomer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCustomerFindFirstOrThrowArgs} args - Arguments to find a StoreCustomer
     * @example
     * // Get one StoreCustomer
     * const storeCustomer = await prisma.storeCustomer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreCustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreCustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreCustomerClient<$Result.GetResult<Prisma.$StoreCustomerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StoreCustomers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreCustomers
     * const storeCustomers = await prisma.storeCustomer.findMany()
     * 
     * // Get first 10 StoreCustomers
     * const storeCustomers = await prisma.storeCustomer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeCustomerWithIdOnly = await prisma.storeCustomer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreCustomerFindManyArgs>(args?: SelectSubset<T, StoreCustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreCustomerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StoreCustomer.
     * @param {StoreCustomerCreateArgs} args - Arguments to create a StoreCustomer.
     * @example
     * // Create one StoreCustomer
     * const StoreCustomer = await prisma.storeCustomer.create({
     *   data: {
     *     // ... data to create a StoreCustomer
     *   }
     * })
     * 
     */
    create<T extends StoreCustomerCreateArgs>(args: SelectSubset<T, StoreCustomerCreateArgs<ExtArgs>>): Prisma__StoreCustomerClient<$Result.GetResult<Prisma.$StoreCustomerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StoreCustomers.
     * @param {StoreCustomerCreateManyArgs} args - Arguments to create many StoreCustomers.
     * @example
     * // Create many StoreCustomers
     * const storeCustomer = await prisma.storeCustomer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreCustomerCreateManyArgs>(args?: SelectSubset<T, StoreCustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoreCustomers and returns the data saved in the database.
     * @param {StoreCustomerCreateManyAndReturnArgs} args - Arguments to create many StoreCustomers.
     * @example
     * // Create many StoreCustomers
     * const storeCustomer = await prisma.storeCustomer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoreCustomers and only return the `id`
     * const storeCustomerWithIdOnly = await prisma.storeCustomer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreCustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreCustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreCustomerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StoreCustomer.
     * @param {StoreCustomerDeleteArgs} args - Arguments to delete one StoreCustomer.
     * @example
     * // Delete one StoreCustomer
     * const StoreCustomer = await prisma.storeCustomer.delete({
     *   where: {
     *     // ... filter to delete one StoreCustomer
     *   }
     * })
     * 
     */
    delete<T extends StoreCustomerDeleteArgs>(args: SelectSubset<T, StoreCustomerDeleteArgs<ExtArgs>>): Prisma__StoreCustomerClient<$Result.GetResult<Prisma.$StoreCustomerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StoreCustomer.
     * @param {StoreCustomerUpdateArgs} args - Arguments to update one StoreCustomer.
     * @example
     * // Update one StoreCustomer
     * const storeCustomer = await prisma.storeCustomer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreCustomerUpdateArgs>(args: SelectSubset<T, StoreCustomerUpdateArgs<ExtArgs>>): Prisma__StoreCustomerClient<$Result.GetResult<Prisma.$StoreCustomerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StoreCustomers.
     * @param {StoreCustomerDeleteManyArgs} args - Arguments to filter StoreCustomers to delete.
     * @example
     * // Delete a few StoreCustomers
     * const { count } = await prisma.storeCustomer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreCustomerDeleteManyArgs>(args?: SelectSubset<T, StoreCustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreCustomers
     * const storeCustomer = await prisma.storeCustomer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreCustomerUpdateManyArgs>(args: SelectSubset<T, StoreCustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoreCustomer.
     * @param {StoreCustomerUpsertArgs} args - Arguments to update or create a StoreCustomer.
     * @example
     * // Update or create a StoreCustomer
     * const storeCustomer = await prisma.storeCustomer.upsert({
     *   create: {
     *     // ... data to create a StoreCustomer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreCustomer we want to update
     *   }
     * })
     */
    upsert<T extends StoreCustomerUpsertArgs>(args: SelectSubset<T, StoreCustomerUpsertArgs<ExtArgs>>): Prisma__StoreCustomerClient<$Result.GetResult<Prisma.$StoreCustomerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StoreCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCustomerCountArgs} args - Arguments to filter StoreCustomers to count.
     * @example
     * // Count the number of StoreCustomers
     * const count = await prisma.storeCustomer.count({
     *   where: {
     *     // ... the filter for the StoreCustomers we want to count
     *   }
     * })
    **/
    count<T extends StoreCustomerCountArgs>(
      args?: Subset<T, StoreCustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreCustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreCustomer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreCustomerAggregateArgs>(args: Subset<T, StoreCustomerAggregateArgs>): Prisma.PrismaPromise<GetStoreCustomerAggregateType<T>>

    /**
     * Group by StoreCustomer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreCustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreCustomerGroupByArgs['orderBy'] }
        : { orderBy?: StoreCustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreCustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreCustomer model
   */
  readonly fields: StoreCustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreCustomer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreCustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sales<T extends StoreCustomer$salesArgs<ExtArgs> = {}>(args?: Subset<T, StoreCustomer$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany"> | Null>
    loyaltyTransactions<T extends StoreCustomer$loyaltyTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, StoreCustomer$loyaltyTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreLoyaltyTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreCustomer model
   */ 
  interface StoreCustomerFieldRefs {
    readonly id: FieldRef<"StoreCustomer", 'String'>
    readonly storeId: FieldRef<"StoreCustomer", 'String'>
    readonly firstName: FieldRef<"StoreCustomer", 'String'>
    readonly lastName: FieldRef<"StoreCustomer", 'String'>
    readonly phone: FieldRef<"StoreCustomer", 'String'>
    readonly email: FieldRef<"StoreCustomer", 'String'>
    readonly address: FieldRef<"StoreCustomer", 'String'>
    readonly taxId: FieldRef<"StoreCustomer", 'String'>
    readonly notes: FieldRef<"StoreCustomer", 'String'>
    readonly totalPurchases: FieldRef<"StoreCustomer", 'Decimal'>
    readonly loyaltyPoints: FieldRef<"StoreCustomer", 'Int'>
    readonly loyaltyTier: FieldRef<"StoreCustomer", 'LoyaltyTier'>
    readonly totalLifetimePurchases: FieldRef<"StoreCustomer", 'Decimal'>
    readonly isActive: FieldRef<"StoreCustomer", 'Boolean'>
    readonly createdAt: FieldRef<"StoreCustomer", 'DateTime'>
    readonly updatedAt: FieldRef<"StoreCustomer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoreCustomer findUnique
   */
  export type StoreCustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCustomer
     */
    select?: StoreCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreCustomerInclude<ExtArgs> | null
    /**
     * Filter, which StoreCustomer to fetch.
     */
    where: StoreCustomerWhereUniqueInput
  }

  /**
   * StoreCustomer findUniqueOrThrow
   */
  export type StoreCustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCustomer
     */
    select?: StoreCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreCustomerInclude<ExtArgs> | null
    /**
     * Filter, which StoreCustomer to fetch.
     */
    where: StoreCustomerWhereUniqueInput
  }

  /**
   * StoreCustomer findFirst
   */
  export type StoreCustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCustomer
     */
    select?: StoreCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreCustomerInclude<ExtArgs> | null
    /**
     * Filter, which StoreCustomer to fetch.
     */
    where?: StoreCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreCustomers to fetch.
     */
    orderBy?: StoreCustomerOrderByWithRelationInput | StoreCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreCustomers.
     */
    cursor?: StoreCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreCustomers.
     */
    distinct?: StoreCustomerScalarFieldEnum | StoreCustomerScalarFieldEnum[]
  }

  /**
   * StoreCustomer findFirstOrThrow
   */
  export type StoreCustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCustomer
     */
    select?: StoreCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreCustomerInclude<ExtArgs> | null
    /**
     * Filter, which StoreCustomer to fetch.
     */
    where?: StoreCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreCustomers to fetch.
     */
    orderBy?: StoreCustomerOrderByWithRelationInput | StoreCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreCustomers.
     */
    cursor?: StoreCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreCustomers.
     */
    distinct?: StoreCustomerScalarFieldEnum | StoreCustomerScalarFieldEnum[]
  }

  /**
   * StoreCustomer findMany
   */
  export type StoreCustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCustomer
     */
    select?: StoreCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreCustomerInclude<ExtArgs> | null
    /**
     * Filter, which StoreCustomers to fetch.
     */
    where?: StoreCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreCustomers to fetch.
     */
    orderBy?: StoreCustomerOrderByWithRelationInput | StoreCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreCustomers.
     */
    cursor?: StoreCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreCustomers.
     */
    skip?: number
    distinct?: StoreCustomerScalarFieldEnum | StoreCustomerScalarFieldEnum[]
  }

  /**
   * StoreCustomer create
   */
  export type StoreCustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCustomer
     */
    select?: StoreCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreCustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a StoreCustomer.
     */
    data: XOR<StoreCustomerCreateInput, StoreCustomerUncheckedCreateInput>
  }

  /**
   * StoreCustomer createMany
   */
  export type StoreCustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreCustomers.
     */
    data: StoreCustomerCreateManyInput | StoreCustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreCustomer createManyAndReturn
   */
  export type StoreCustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCustomer
     */
    select?: StoreCustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StoreCustomers.
     */
    data: StoreCustomerCreateManyInput | StoreCustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreCustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoreCustomer update
   */
  export type StoreCustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCustomer
     */
    select?: StoreCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreCustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a StoreCustomer.
     */
    data: XOR<StoreCustomerUpdateInput, StoreCustomerUncheckedUpdateInput>
    /**
     * Choose, which StoreCustomer to update.
     */
    where: StoreCustomerWhereUniqueInput
  }

  /**
   * StoreCustomer updateMany
   */
  export type StoreCustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreCustomers.
     */
    data: XOR<StoreCustomerUpdateManyMutationInput, StoreCustomerUncheckedUpdateManyInput>
    /**
     * Filter which StoreCustomers to update
     */
    where?: StoreCustomerWhereInput
  }

  /**
   * StoreCustomer upsert
   */
  export type StoreCustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCustomer
     */
    select?: StoreCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreCustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the StoreCustomer to update in case it exists.
     */
    where: StoreCustomerWhereUniqueInput
    /**
     * In case the StoreCustomer found by the `where` argument doesn't exist, create a new StoreCustomer with this data.
     */
    create: XOR<StoreCustomerCreateInput, StoreCustomerUncheckedCreateInput>
    /**
     * In case the StoreCustomer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreCustomerUpdateInput, StoreCustomerUncheckedUpdateInput>
  }

  /**
   * StoreCustomer delete
   */
  export type StoreCustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCustomer
     */
    select?: StoreCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreCustomerInclude<ExtArgs> | null
    /**
     * Filter which StoreCustomer to delete.
     */
    where: StoreCustomerWhereUniqueInput
  }

  /**
   * StoreCustomer deleteMany
   */
  export type StoreCustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreCustomers to delete
     */
    where?: StoreCustomerWhereInput
  }

  /**
   * StoreCustomer.sales
   */
  export type StoreCustomer$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * StoreCustomer.loyaltyTransactions
   */
  export type StoreCustomer$loyaltyTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyTransaction
     */
    select?: StoreLoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyTransactionInclude<ExtArgs> | null
    where?: StoreLoyaltyTransactionWhereInput
    orderBy?: StoreLoyaltyTransactionOrderByWithRelationInput | StoreLoyaltyTransactionOrderByWithRelationInput[]
    cursor?: StoreLoyaltyTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreLoyaltyTransactionScalarFieldEnum | StoreLoyaltyTransactionScalarFieldEnum[]
  }

  /**
   * StoreCustomer without action
   */
  export type StoreCustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCustomer
     */
    select?: StoreCustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreCustomerInclude<ExtArgs> | null
  }


  /**
   * Model StoreLoyaltyConfig
   */

  export type AggregateStoreLoyaltyConfig = {
    _count: StoreLoyaltyConfigCountAggregateOutputType | null
    _avg: StoreLoyaltyConfigAvgAggregateOutputType | null
    _sum: StoreLoyaltyConfigSumAggregateOutputType | null
    _min: StoreLoyaltyConfigMinAggregateOutputType | null
    _max: StoreLoyaltyConfigMaxAggregateOutputType | null
  }

  export type StoreLoyaltyConfigAvgAggregateOutputType = {
    pointsPerGel: number | null
    redemptionRate: number | null
    minRedemptionPoints: number | null
    expirationDays: number | null
    bronzeMinSpend: Decimal | null
    silverMinSpend: Decimal | null
    goldMinSpend: Decimal | null
    platinumMinSpend: Decimal | null
    goldDiscountPercent: Decimal | null
    platinumDiscountPercent: Decimal | null
  }

  export type StoreLoyaltyConfigSumAggregateOutputType = {
    pointsPerGel: number | null
    redemptionRate: number | null
    minRedemptionPoints: number | null
    expirationDays: number | null
    bronzeMinSpend: Decimal | null
    silverMinSpend: Decimal | null
    goldMinSpend: Decimal | null
    platinumMinSpend: Decimal | null
    goldDiscountPercent: Decimal | null
    platinumDiscountPercent: Decimal | null
  }

  export type StoreLoyaltyConfigMinAggregateOutputType = {
    id: string | null
    storeId: string | null
    pointsPerGel: number | null
    redemptionRate: number | null
    minRedemptionPoints: number | null
    expirationDays: number | null
    bronzeMinSpend: Decimal | null
    silverMinSpend: Decimal | null
    goldMinSpend: Decimal | null
    platinumMinSpend: Decimal | null
    goldDiscountPercent: Decimal | null
    platinumDiscountPercent: Decimal | null
  }

  export type StoreLoyaltyConfigMaxAggregateOutputType = {
    id: string | null
    storeId: string | null
    pointsPerGel: number | null
    redemptionRate: number | null
    minRedemptionPoints: number | null
    expirationDays: number | null
    bronzeMinSpend: Decimal | null
    silverMinSpend: Decimal | null
    goldMinSpend: Decimal | null
    platinumMinSpend: Decimal | null
    goldDiscountPercent: Decimal | null
    platinumDiscountPercent: Decimal | null
  }

  export type StoreLoyaltyConfigCountAggregateOutputType = {
    id: number
    storeId: number
    pointsPerGel: number
    redemptionRate: number
    minRedemptionPoints: number
    expirationDays: number
    bronzeMinSpend: number
    silverMinSpend: number
    goldMinSpend: number
    platinumMinSpend: number
    goldDiscountPercent: number
    platinumDiscountPercent: number
    _all: number
  }


  export type StoreLoyaltyConfigAvgAggregateInputType = {
    pointsPerGel?: true
    redemptionRate?: true
    minRedemptionPoints?: true
    expirationDays?: true
    bronzeMinSpend?: true
    silverMinSpend?: true
    goldMinSpend?: true
    platinumMinSpend?: true
    goldDiscountPercent?: true
    platinumDiscountPercent?: true
  }

  export type StoreLoyaltyConfigSumAggregateInputType = {
    pointsPerGel?: true
    redemptionRate?: true
    minRedemptionPoints?: true
    expirationDays?: true
    bronzeMinSpend?: true
    silverMinSpend?: true
    goldMinSpend?: true
    platinumMinSpend?: true
    goldDiscountPercent?: true
    platinumDiscountPercent?: true
  }

  export type StoreLoyaltyConfigMinAggregateInputType = {
    id?: true
    storeId?: true
    pointsPerGel?: true
    redemptionRate?: true
    minRedemptionPoints?: true
    expirationDays?: true
    bronzeMinSpend?: true
    silverMinSpend?: true
    goldMinSpend?: true
    platinumMinSpend?: true
    goldDiscountPercent?: true
    platinumDiscountPercent?: true
  }

  export type StoreLoyaltyConfigMaxAggregateInputType = {
    id?: true
    storeId?: true
    pointsPerGel?: true
    redemptionRate?: true
    minRedemptionPoints?: true
    expirationDays?: true
    bronzeMinSpend?: true
    silverMinSpend?: true
    goldMinSpend?: true
    platinumMinSpend?: true
    goldDiscountPercent?: true
    platinumDiscountPercent?: true
  }

  export type StoreLoyaltyConfigCountAggregateInputType = {
    id?: true
    storeId?: true
    pointsPerGel?: true
    redemptionRate?: true
    minRedemptionPoints?: true
    expirationDays?: true
    bronzeMinSpend?: true
    silverMinSpend?: true
    goldMinSpend?: true
    platinumMinSpend?: true
    goldDiscountPercent?: true
    platinumDiscountPercent?: true
    _all?: true
  }

  export type StoreLoyaltyConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreLoyaltyConfig to aggregate.
     */
    where?: StoreLoyaltyConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreLoyaltyConfigs to fetch.
     */
    orderBy?: StoreLoyaltyConfigOrderByWithRelationInput | StoreLoyaltyConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreLoyaltyConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreLoyaltyConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreLoyaltyConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreLoyaltyConfigs
    **/
    _count?: true | StoreLoyaltyConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreLoyaltyConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreLoyaltyConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreLoyaltyConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreLoyaltyConfigMaxAggregateInputType
  }

  export type GetStoreLoyaltyConfigAggregateType<T extends StoreLoyaltyConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreLoyaltyConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreLoyaltyConfig[P]>
      : GetScalarType<T[P], AggregateStoreLoyaltyConfig[P]>
  }




  export type StoreLoyaltyConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreLoyaltyConfigWhereInput
    orderBy?: StoreLoyaltyConfigOrderByWithAggregationInput | StoreLoyaltyConfigOrderByWithAggregationInput[]
    by: StoreLoyaltyConfigScalarFieldEnum[] | StoreLoyaltyConfigScalarFieldEnum
    having?: StoreLoyaltyConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreLoyaltyConfigCountAggregateInputType | true
    _avg?: StoreLoyaltyConfigAvgAggregateInputType
    _sum?: StoreLoyaltyConfigSumAggregateInputType
    _min?: StoreLoyaltyConfigMinAggregateInputType
    _max?: StoreLoyaltyConfigMaxAggregateInputType
  }

  export type StoreLoyaltyConfigGroupByOutputType = {
    id: string
    storeId: string
    pointsPerGel: number
    redemptionRate: number
    minRedemptionPoints: number
    expirationDays: number | null
    bronzeMinSpend: Decimal | null
    silverMinSpend: Decimal | null
    goldMinSpend: Decimal | null
    platinumMinSpend: Decimal | null
    goldDiscountPercent: Decimal | null
    platinumDiscountPercent: Decimal | null
    _count: StoreLoyaltyConfigCountAggregateOutputType | null
    _avg: StoreLoyaltyConfigAvgAggregateOutputType | null
    _sum: StoreLoyaltyConfigSumAggregateOutputType | null
    _min: StoreLoyaltyConfigMinAggregateOutputType | null
    _max: StoreLoyaltyConfigMaxAggregateOutputType | null
  }

  type GetStoreLoyaltyConfigGroupByPayload<T extends StoreLoyaltyConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreLoyaltyConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreLoyaltyConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreLoyaltyConfigGroupByOutputType[P]>
            : GetScalarType<T[P], StoreLoyaltyConfigGroupByOutputType[P]>
        }
      >
    >


  export type StoreLoyaltyConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    pointsPerGel?: boolean
    redemptionRate?: boolean
    minRedemptionPoints?: boolean
    expirationDays?: boolean
    bronzeMinSpend?: boolean
    silverMinSpend?: boolean
    goldMinSpend?: boolean
    platinumMinSpend?: boolean
    goldDiscountPercent?: boolean
    platinumDiscountPercent?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeLoyaltyConfig"]>

  export type StoreLoyaltyConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    pointsPerGel?: boolean
    redemptionRate?: boolean
    minRedemptionPoints?: boolean
    expirationDays?: boolean
    bronzeMinSpend?: boolean
    silverMinSpend?: boolean
    goldMinSpend?: boolean
    platinumMinSpend?: boolean
    goldDiscountPercent?: boolean
    platinumDiscountPercent?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeLoyaltyConfig"]>

  export type StoreLoyaltyConfigSelectScalar = {
    id?: boolean
    storeId?: boolean
    pointsPerGel?: boolean
    redemptionRate?: boolean
    minRedemptionPoints?: boolean
    expirationDays?: boolean
    bronzeMinSpend?: boolean
    silverMinSpend?: boolean
    goldMinSpend?: boolean
    platinumMinSpend?: boolean
    goldDiscountPercent?: boolean
    platinumDiscountPercent?: boolean
  }

  export type StoreLoyaltyConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }
  export type StoreLoyaltyConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $StoreLoyaltyConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreLoyaltyConfig"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeId: string
      pointsPerGel: number
      redemptionRate: number
      minRedemptionPoints: number
      expirationDays: number | null
      bronzeMinSpend: Prisma.Decimal | null
      silverMinSpend: Prisma.Decimal | null
      goldMinSpend: Prisma.Decimal | null
      platinumMinSpend: Prisma.Decimal | null
      goldDiscountPercent: Prisma.Decimal | null
      platinumDiscountPercent: Prisma.Decimal | null
    }, ExtArgs["result"]["storeLoyaltyConfig"]>
    composites: {}
  }

  type StoreLoyaltyConfigGetPayload<S extends boolean | null | undefined | StoreLoyaltyConfigDefaultArgs> = $Result.GetResult<Prisma.$StoreLoyaltyConfigPayload, S>

  type StoreLoyaltyConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoreLoyaltyConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoreLoyaltyConfigCountAggregateInputType | true
    }

  export interface StoreLoyaltyConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreLoyaltyConfig'], meta: { name: 'StoreLoyaltyConfig' } }
    /**
     * Find zero or one StoreLoyaltyConfig that matches the filter.
     * @param {StoreLoyaltyConfigFindUniqueArgs} args - Arguments to find a StoreLoyaltyConfig
     * @example
     * // Get one StoreLoyaltyConfig
     * const storeLoyaltyConfig = await prisma.storeLoyaltyConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreLoyaltyConfigFindUniqueArgs>(args: SelectSubset<T, StoreLoyaltyConfigFindUniqueArgs<ExtArgs>>): Prisma__StoreLoyaltyConfigClient<$Result.GetResult<Prisma.$StoreLoyaltyConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StoreLoyaltyConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoreLoyaltyConfigFindUniqueOrThrowArgs} args - Arguments to find a StoreLoyaltyConfig
     * @example
     * // Get one StoreLoyaltyConfig
     * const storeLoyaltyConfig = await prisma.storeLoyaltyConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreLoyaltyConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreLoyaltyConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreLoyaltyConfigClient<$Result.GetResult<Prisma.$StoreLoyaltyConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StoreLoyaltyConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreLoyaltyConfigFindFirstArgs} args - Arguments to find a StoreLoyaltyConfig
     * @example
     * // Get one StoreLoyaltyConfig
     * const storeLoyaltyConfig = await prisma.storeLoyaltyConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreLoyaltyConfigFindFirstArgs>(args?: SelectSubset<T, StoreLoyaltyConfigFindFirstArgs<ExtArgs>>): Prisma__StoreLoyaltyConfigClient<$Result.GetResult<Prisma.$StoreLoyaltyConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StoreLoyaltyConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreLoyaltyConfigFindFirstOrThrowArgs} args - Arguments to find a StoreLoyaltyConfig
     * @example
     * // Get one StoreLoyaltyConfig
     * const storeLoyaltyConfig = await prisma.storeLoyaltyConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreLoyaltyConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreLoyaltyConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreLoyaltyConfigClient<$Result.GetResult<Prisma.$StoreLoyaltyConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StoreLoyaltyConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreLoyaltyConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreLoyaltyConfigs
     * const storeLoyaltyConfigs = await prisma.storeLoyaltyConfig.findMany()
     * 
     * // Get first 10 StoreLoyaltyConfigs
     * const storeLoyaltyConfigs = await prisma.storeLoyaltyConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeLoyaltyConfigWithIdOnly = await prisma.storeLoyaltyConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreLoyaltyConfigFindManyArgs>(args?: SelectSubset<T, StoreLoyaltyConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreLoyaltyConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StoreLoyaltyConfig.
     * @param {StoreLoyaltyConfigCreateArgs} args - Arguments to create a StoreLoyaltyConfig.
     * @example
     * // Create one StoreLoyaltyConfig
     * const StoreLoyaltyConfig = await prisma.storeLoyaltyConfig.create({
     *   data: {
     *     // ... data to create a StoreLoyaltyConfig
     *   }
     * })
     * 
     */
    create<T extends StoreLoyaltyConfigCreateArgs>(args: SelectSubset<T, StoreLoyaltyConfigCreateArgs<ExtArgs>>): Prisma__StoreLoyaltyConfigClient<$Result.GetResult<Prisma.$StoreLoyaltyConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StoreLoyaltyConfigs.
     * @param {StoreLoyaltyConfigCreateManyArgs} args - Arguments to create many StoreLoyaltyConfigs.
     * @example
     * // Create many StoreLoyaltyConfigs
     * const storeLoyaltyConfig = await prisma.storeLoyaltyConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreLoyaltyConfigCreateManyArgs>(args?: SelectSubset<T, StoreLoyaltyConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoreLoyaltyConfigs and returns the data saved in the database.
     * @param {StoreLoyaltyConfigCreateManyAndReturnArgs} args - Arguments to create many StoreLoyaltyConfigs.
     * @example
     * // Create many StoreLoyaltyConfigs
     * const storeLoyaltyConfig = await prisma.storeLoyaltyConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoreLoyaltyConfigs and only return the `id`
     * const storeLoyaltyConfigWithIdOnly = await prisma.storeLoyaltyConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreLoyaltyConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreLoyaltyConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreLoyaltyConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StoreLoyaltyConfig.
     * @param {StoreLoyaltyConfigDeleteArgs} args - Arguments to delete one StoreLoyaltyConfig.
     * @example
     * // Delete one StoreLoyaltyConfig
     * const StoreLoyaltyConfig = await prisma.storeLoyaltyConfig.delete({
     *   where: {
     *     // ... filter to delete one StoreLoyaltyConfig
     *   }
     * })
     * 
     */
    delete<T extends StoreLoyaltyConfigDeleteArgs>(args: SelectSubset<T, StoreLoyaltyConfigDeleteArgs<ExtArgs>>): Prisma__StoreLoyaltyConfigClient<$Result.GetResult<Prisma.$StoreLoyaltyConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StoreLoyaltyConfig.
     * @param {StoreLoyaltyConfigUpdateArgs} args - Arguments to update one StoreLoyaltyConfig.
     * @example
     * // Update one StoreLoyaltyConfig
     * const storeLoyaltyConfig = await prisma.storeLoyaltyConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreLoyaltyConfigUpdateArgs>(args: SelectSubset<T, StoreLoyaltyConfigUpdateArgs<ExtArgs>>): Prisma__StoreLoyaltyConfigClient<$Result.GetResult<Prisma.$StoreLoyaltyConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StoreLoyaltyConfigs.
     * @param {StoreLoyaltyConfigDeleteManyArgs} args - Arguments to filter StoreLoyaltyConfigs to delete.
     * @example
     * // Delete a few StoreLoyaltyConfigs
     * const { count } = await prisma.storeLoyaltyConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreLoyaltyConfigDeleteManyArgs>(args?: SelectSubset<T, StoreLoyaltyConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreLoyaltyConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreLoyaltyConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreLoyaltyConfigs
     * const storeLoyaltyConfig = await prisma.storeLoyaltyConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreLoyaltyConfigUpdateManyArgs>(args: SelectSubset<T, StoreLoyaltyConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoreLoyaltyConfig.
     * @param {StoreLoyaltyConfigUpsertArgs} args - Arguments to update or create a StoreLoyaltyConfig.
     * @example
     * // Update or create a StoreLoyaltyConfig
     * const storeLoyaltyConfig = await prisma.storeLoyaltyConfig.upsert({
     *   create: {
     *     // ... data to create a StoreLoyaltyConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreLoyaltyConfig we want to update
     *   }
     * })
     */
    upsert<T extends StoreLoyaltyConfigUpsertArgs>(args: SelectSubset<T, StoreLoyaltyConfigUpsertArgs<ExtArgs>>): Prisma__StoreLoyaltyConfigClient<$Result.GetResult<Prisma.$StoreLoyaltyConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StoreLoyaltyConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreLoyaltyConfigCountArgs} args - Arguments to filter StoreLoyaltyConfigs to count.
     * @example
     * // Count the number of StoreLoyaltyConfigs
     * const count = await prisma.storeLoyaltyConfig.count({
     *   where: {
     *     // ... the filter for the StoreLoyaltyConfigs we want to count
     *   }
     * })
    **/
    count<T extends StoreLoyaltyConfigCountArgs>(
      args?: Subset<T, StoreLoyaltyConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreLoyaltyConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreLoyaltyConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreLoyaltyConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreLoyaltyConfigAggregateArgs>(args: Subset<T, StoreLoyaltyConfigAggregateArgs>): Prisma.PrismaPromise<GetStoreLoyaltyConfigAggregateType<T>>

    /**
     * Group by StoreLoyaltyConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreLoyaltyConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreLoyaltyConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreLoyaltyConfigGroupByArgs['orderBy'] }
        : { orderBy?: StoreLoyaltyConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreLoyaltyConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreLoyaltyConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreLoyaltyConfig model
   */
  readonly fields: StoreLoyaltyConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreLoyaltyConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreLoyaltyConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreLoyaltyConfig model
   */ 
  interface StoreLoyaltyConfigFieldRefs {
    readonly id: FieldRef<"StoreLoyaltyConfig", 'String'>
    readonly storeId: FieldRef<"StoreLoyaltyConfig", 'String'>
    readonly pointsPerGel: FieldRef<"StoreLoyaltyConfig", 'Int'>
    readonly redemptionRate: FieldRef<"StoreLoyaltyConfig", 'Int'>
    readonly minRedemptionPoints: FieldRef<"StoreLoyaltyConfig", 'Int'>
    readonly expirationDays: FieldRef<"StoreLoyaltyConfig", 'Int'>
    readonly bronzeMinSpend: FieldRef<"StoreLoyaltyConfig", 'Decimal'>
    readonly silverMinSpend: FieldRef<"StoreLoyaltyConfig", 'Decimal'>
    readonly goldMinSpend: FieldRef<"StoreLoyaltyConfig", 'Decimal'>
    readonly platinumMinSpend: FieldRef<"StoreLoyaltyConfig", 'Decimal'>
    readonly goldDiscountPercent: FieldRef<"StoreLoyaltyConfig", 'Decimal'>
    readonly platinumDiscountPercent: FieldRef<"StoreLoyaltyConfig", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * StoreLoyaltyConfig findUnique
   */
  export type StoreLoyaltyConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyConfig
     */
    select?: StoreLoyaltyConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyConfigInclude<ExtArgs> | null
    /**
     * Filter, which StoreLoyaltyConfig to fetch.
     */
    where: StoreLoyaltyConfigWhereUniqueInput
  }

  /**
   * StoreLoyaltyConfig findUniqueOrThrow
   */
  export type StoreLoyaltyConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyConfig
     */
    select?: StoreLoyaltyConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyConfigInclude<ExtArgs> | null
    /**
     * Filter, which StoreLoyaltyConfig to fetch.
     */
    where: StoreLoyaltyConfigWhereUniqueInput
  }

  /**
   * StoreLoyaltyConfig findFirst
   */
  export type StoreLoyaltyConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyConfig
     */
    select?: StoreLoyaltyConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyConfigInclude<ExtArgs> | null
    /**
     * Filter, which StoreLoyaltyConfig to fetch.
     */
    where?: StoreLoyaltyConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreLoyaltyConfigs to fetch.
     */
    orderBy?: StoreLoyaltyConfigOrderByWithRelationInput | StoreLoyaltyConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreLoyaltyConfigs.
     */
    cursor?: StoreLoyaltyConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreLoyaltyConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreLoyaltyConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreLoyaltyConfigs.
     */
    distinct?: StoreLoyaltyConfigScalarFieldEnum | StoreLoyaltyConfigScalarFieldEnum[]
  }

  /**
   * StoreLoyaltyConfig findFirstOrThrow
   */
  export type StoreLoyaltyConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyConfig
     */
    select?: StoreLoyaltyConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyConfigInclude<ExtArgs> | null
    /**
     * Filter, which StoreLoyaltyConfig to fetch.
     */
    where?: StoreLoyaltyConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreLoyaltyConfigs to fetch.
     */
    orderBy?: StoreLoyaltyConfigOrderByWithRelationInput | StoreLoyaltyConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreLoyaltyConfigs.
     */
    cursor?: StoreLoyaltyConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreLoyaltyConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreLoyaltyConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreLoyaltyConfigs.
     */
    distinct?: StoreLoyaltyConfigScalarFieldEnum | StoreLoyaltyConfigScalarFieldEnum[]
  }

  /**
   * StoreLoyaltyConfig findMany
   */
  export type StoreLoyaltyConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyConfig
     */
    select?: StoreLoyaltyConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyConfigInclude<ExtArgs> | null
    /**
     * Filter, which StoreLoyaltyConfigs to fetch.
     */
    where?: StoreLoyaltyConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreLoyaltyConfigs to fetch.
     */
    orderBy?: StoreLoyaltyConfigOrderByWithRelationInput | StoreLoyaltyConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreLoyaltyConfigs.
     */
    cursor?: StoreLoyaltyConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreLoyaltyConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreLoyaltyConfigs.
     */
    skip?: number
    distinct?: StoreLoyaltyConfigScalarFieldEnum | StoreLoyaltyConfigScalarFieldEnum[]
  }

  /**
   * StoreLoyaltyConfig create
   */
  export type StoreLoyaltyConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyConfig
     */
    select?: StoreLoyaltyConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a StoreLoyaltyConfig.
     */
    data: XOR<StoreLoyaltyConfigCreateInput, StoreLoyaltyConfigUncheckedCreateInput>
  }

  /**
   * StoreLoyaltyConfig createMany
   */
  export type StoreLoyaltyConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreLoyaltyConfigs.
     */
    data: StoreLoyaltyConfigCreateManyInput | StoreLoyaltyConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreLoyaltyConfig createManyAndReturn
   */
  export type StoreLoyaltyConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyConfig
     */
    select?: StoreLoyaltyConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StoreLoyaltyConfigs.
     */
    data: StoreLoyaltyConfigCreateManyInput | StoreLoyaltyConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoreLoyaltyConfig update
   */
  export type StoreLoyaltyConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyConfig
     */
    select?: StoreLoyaltyConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a StoreLoyaltyConfig.
     */
    data: XOR<StoreLoyaltyConfigUpdateInput, StoreLoyaltyConfigUncheckedUpdateInput>
    /**
     * Choose, which StoreLoyaltyConfig to update.
     */
    where: StoreLoyaltyConfigWhereUniqueInput
  }

  /**
   * StoreLoyaltyConfig updateMany
   */
  export type StoreLoyaltyConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreLoyaltyConfigs.
     */
    data: XOR<StoreLoyaltyConfigUpdateManyMutationInput, StoreLoyaltyConfigUncheckedUpdateManyInput>
    /**
     * Filter which StoreLoyaltyConfigs to update
     */
    where?: StoreLoyaltyConfigWhereInput
  }

  /**
   * StoreLoyaltyConfig upsert
   */
  export type StoreLoyaltyConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyConfig
     */
    select?: StoreLoyaltyConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the StoreLoyaltyConfig to update in case it exists.
     */
    where: StoreLoyaltyConfigWhereUniqueInput
    /**
     * In case the StoreLoyaltyConfig found by the `where` argument doesn't exist, create a new StoreLoyaltyConfig with this data.
     */
    create: XOR<StoreLoyaltyConfigCreateInput, StoreLoyaltyConfigUncheckedCreateInput>
    /**
     * In case the StoreLoyaltyConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreLoyaltyConfigUpdateInput, StoreLoyaltyConfigUncheckedUpdateInput>
  }

  /**
   * StoreLoyaltyConfig delete
   */
  export type StoreLoyaltyConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyConfig
     */
    select?: StoreLoyaltyConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyConfigInclude<ExtArgs> | null
    /**
     * Filter which StoreLoyaltyConfig to delete.
     */
    where: StoreLoyaltyConfigWhereUniqueInput
  }

  /**
   * StoreLoyaltyConfig deleteMany
   */
  export type StoreLoyaltyConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreLoyaltyConfigs to delete
     */
    where?: StoreLoyaltyConfigWhereInput
  }

  /**
   * StoreLoyaltyConfig without action
   */
  export type StoreLoyaltyConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyConfig
     */
    select?: StoreLoyaltyConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyConfigInclude<ExtArgs> | null
  }


  /**
   * Model StoreLoyaltyTransaction
   */

  export type AggregateStoreLoyaltyTransaction = {
    _count: StoreLoyaltyTransactionCountAggregateOutputType | null
    _avg: StoreLoyaltyTransactionAvgAggregateOutputType | null
    _sum: StoreLoyaltyTransactionSumAggregateOutputType | null
    _min: StoreLoyaltyTransactionMinAggregateOutputType | null
    _max: StoreLoyaltyTransactionMaxAggregateOutputType | null
  }

  export type StoreLoyaltyTransactionAvgAggregateOutputType = {
    points: number | null
  }

  export type StoreLoyaltyTransactionSumAggregateOutputType = {
    points: number | null
  }

  export type StoreLoyaltyTransactionMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    type: $Enums.LoyaltyTransactionType | null
    points: number | null
    saleId: string | null
    description: string | null
    createdAt: Date | null
  }

  export type StoreLoyaltyTransactionMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    type: $Enums.LoyaltyTransactionType | null
    points: number | null
    saleId: string | null
    description: string | null
    createdAt: Date | null
  }

  export type StoreLoyaltyTransactionCountAggregateOutputType = {
    id: number
    customerId: number
    type: number
    points: number
    saleId: number
    description: number
    createdAt: number
    _all: number
  }


  export type StoreLoyaltyTransactionAvgAggregateInputType = {
    points?: true
  }

  export type StoreLoyaltyTransactionSumAggregateInputType = {
    points?: true
  }

  export type StoreLoyaltyTransactionMinAggregateInputType = {
    id?: true
    customerId?: true
    type?: true
    points?: true
    saleId?: true
    description?: true
    createdAt?: true
  }

  export type StoreLoyaltyTransactionMaxAggregateInputType = {
    id?: true
    customerId?: true
    type?: true
    points?: true
    saleId?: true
    description?: true
    createdAt?: true
  }

  export type StoreLoyaltyTransactionCountAggregateInputType = {
    id?: true
    customerId?: true
    type?: true
    points?: true
    saleId?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type StoreLoyaltyTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreLoyaltyTransaction to aggregate.
     */
    where?: StoreLoyaltyTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreLoyaltyTransactions to fetch.
     */
    orderBy?: StoreLoyaltyTransactionOrderByWithRelationInput | StoreLoyaltyTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreLoyaltyTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreLoyaltyTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreLoyaltyTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreLoyaltyTransactions
    **/
    _count?: true | StoreLoyaltyTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreLoyaltyTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreLoyaltyTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreLoyaltyTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreLoyaltyTransactionMaxAggregateInputType
  }

  export type GetStoreLoyaltyTransactionAggregateType<T extends StoreLoyaltyTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreLoyaltyTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreLoyaltyTransaction[P]>
      : GetScalarType<T[P], AggregateStoreLoyaltyTransaction[P]>
  }




  export type StoreLoyaltyTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreLoyaltyTransactionWhereInput
    orderBy?: StoreLoyaltyTransactionOrderByWithAggregationInput | StoreLoyaltyTransactionOrderByWithAggregationInput[]
    by: StoreLoyaltyTransactionScalarFieldEnum[] | StoreLoyaltyTransactionScalarFieldEnum
    having?: StoreLoyaltyTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreLoyaltyTransactionCountAggregateInputType | true
    _avg?: StoreLoyaltyTransactionAvgAggregateInputType
    _sum?: StoreLoyaltyTransactionSumAggregateInputType
    _min?: StoreLoyaltyTransactionMinAggregateInputType
    _max?: StoreLoyaltyTransactionMaxAggregateInputType
  }

  export type StoreLoyaltyTransactionGroupByOutputType = {
    id: string
    customerId: string
    type: $Enums.LoyaltyTransactionType
    points: number
    saleId: string | null
    description: string | null
    createdAt: Date
    _count: StoreLoyaltyTransactionCountAggregateOutputType | null
    _avg: StoreLoyaltyTransactionAvgAggregateOutputType | null
    _sum: StoreLoyaltyTransactionSumAggregateOutputType | null
    _min: StoreLoyaltyTransactionMinAggregateOutputType | null
    _max: StoreLoyaltyTransactionMaxAggregateOutputType | null
  }

  type GetStoreLoyaltyTransactionGroupByPayload<T extends StoreLoyaltyTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreLoyaltyTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreLoyaltyTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreLoyaltyTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], StoreLoyaltyTransactionGroupByOutputType[P]>
        }
      >
    >


  export type StoreLoyaltyTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    type?: boolean
    points?: boolean
    saleId?: boolean
    description?: boolean
    createdAt?: boolean
    customer?: boolean | StoreCustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeLoyaltyTransaction"]>

  export type StoreLoyaltyTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    type?: boolean
    points?: boolean
    saleId?: boolean
    description?: boolean
    createdAt?: boolean
    customer?: boolean | StoreCustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeLoyaltyTransaction"]>

  export type StoreLoyaltyTransactionSelectScalar = {
    id?: boolean
    customerId?: boolean
    type?: boolean
    points?: boolean
    saleId?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type StoreLoyaltyTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | StoreCustomerDefaultArgs<ExtArgs>
  }
  export type StoreLoyaltyTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | StoreCustomerDefaultArgs<ExtArgs>
  }

  export type $StoreLoyaltyTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreLoyaltyTransaction"
    objects: {
      customer: Prisma.$StoreCustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      type: $Enums.LoyaltyTransactionType
      points: number
      saleId: string | null
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["storeLoyaltyTransaction"]>
    composites: {}
  }

  type StoreLoyaltyTransactionGetPayload<S extends boolean | null | undefined | StoreLoyaltyTransactionDefaultArgs> = $Result.GetResult<Prisma.$StoreLoyaltyTransactionPayload, S>

  type StoreLoyaltyTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoreLoyaltyTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoreLoyaltyTransactionCountAggregateInputType | true
    }

  export interface StoreLoyaltyTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreLoyaltyTransaction'], meta: { name: 'StoreLoyaltyTransaction' } }
    /**
     * Find zero or one StoreLoyaltyTransaction that matches the filter.
     * @param {StoreLoyaltyTransactionFindUniqueArgs} args - Arguments to find a StoreLoyaltyTransaction
     * @example
     * // Get one StoreLoyaltyTransaction
     * const storeLoyaltyTransaction = await prisma.storeLoyaltyTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreLoyaltyTransactionFindUniqueArgs>(args: SelectSubset<T, StoreLoyaltyTransactionFindUniqueArgs<ExtArgs>>): Prisma__StoreLoyaltyTransactionClient<$Result.GetResult<Prisma.$StoreLoyaltyTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StoreLoyaltyTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoreLoyaltyTransactionFindUniqueOrThrowArgs} args - Arguments to find a StoreLoyaltyTransaction
     * @example
     * // Get one StoreLoyaltyTransaction
     * const storeLoyaltyTransaction = await prisma.storeLoyaltyTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreLoyaltyTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreLoyaltyTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreLoyaltyTransactionClient<$Result.GetResult<Prisma.$StoreLoyaltyTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StoreLoyaltyTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreLoyaltyTransactionFindFirstArgs} args - Arguments to find a StoreLoyaltyTransaction
     * @example
     * // Get one StoreLoyaltyTransaction
     * const storeLoyaltyTransaction = await prisma.storeLoyaltyTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreLoyaltyTransactionFindFirstArgs>(args?: SelectSubset<T, StoreLoyaltyTransactionFindFirstArgs<ExtArgs>>): Prisma__StoreLoyaltyTransactionClient<$Result.GetResult<Prisma.$StoreLoyaltyTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StoreLoyaltyTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreLoyaltyTransactionFindFirstOrThrowArgs} args - Arguments to find a StoreLoyaltyTransaction
     * @example
     * // Get one StoreLoyaltyTransaction
     * const storeLoyaltyTransaction = await prisma.storeLoyaltyTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreLoyaltyTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreLoyaltyTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreLoyaltyTransactionClient<$Result.GetResult<Prisma.$StoreLoyaltyTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StoreLoyaltyTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreLoyaltyTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreLoyaltyTransactions
     * const storeLoyaltyTransactions = await prisma.storeLoyaltyTransaction.findMany()
     * 
     * // Get first 10 StoreLoyaltyTransactions
     * const storeLoyaltyTransactions = await prisma.storeLoyaltyTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeLoyaltyTransactionWithIdOnly = await prisma.storeLoyaltyTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreLoyaltyTransactionFindManyArgs>(args?: SelectSubset<T, StoreLoyaltyTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreLoyaltyTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StoreLoyaltyTransaction.
     * @param {StoreLoyaltyTransactionCreateArgs} args - Arguments to create a StoreLoyaltyTransaction.
     * @example
     * // Create one StoreLoyaltyTransaction
     * const StoreLoyaltyTransaction = await prisma.storeLoyaltyTransaction.create({
     *   data: {
     *     // ... data to create a StoreLoyaltyTransaction
     *   }
     * })
     * 
     */
    create<T extends StoreLoyaltyTransactionCreateArgs>(args: SelectSubset<T, StoreLoyaltyTransactionCreateArgs<ExtArgs>>): Prisma__StoreLoyaltyTransactionClient<$Result.GetResult<Prisma.$StoreLoyaltyTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StoreLoyaltyTransactions.
     * @param {StoreLoyaltyTransactionCreateManyArgs} args - Arguments to create many StoreLoyaltyTransactions.
     * @example
     * // Create many StoreLoyaltyTransactions
     * const storeLoyaltyTransaction = await prisma.storeLoyaltyTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreLoyaltyTransactionCreateManyArgs>(args?: SelectSubset<T, StoreLoyaltyTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoreLoyaltyTransactions and returns the data saved in the database.
     * @param {StoreLoyaltyTransactionCreateManyAndReturnArgs} args - Arguments to create many StoreLoyaltyTransactions.
     * @example
     * // Create many StoreLoyaltyTransactions
     * const storeLoyaltyTransaction = await prisma.storeLoyaltyTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoreLoyaltyTransactions and only return the `id`
     * const storeLoyaltyTransactionWithIdOnly = await prisma.storeLoyaltyTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreLoyaltyTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreLoyaltyTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreLoyaltyTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StoreLoyaltyTransaction.
     * @param {StoreLoyaltyTransactionDeleteArgs} args - Arguments to delete one StoreLoyaltyTransaction.
     * @example
     * // Delete one StoreLoyaltyTransaction
     * const StoreLoyaltyTransaction = await prisma.storeLoyaltyTransaction.delete({
     *   where: {
     *     // ... filter to delete one StoreLoyaltyTransaction
     *   }
     * })
     * 
     */
    delete<T extends StoreLoyaltyTransactionDeleteArgs>(args: SelectSubset<T, StoreLoyaltyTransactionDeleteArgs<ExtArgs>>): Prisma__StoreLoyaltyTransactionClient<$Result.GetResult<Prisma.$StoreLoyaltyTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StoreLoyaltyTransaction.
     * @param {StoreLoyaltyTransactionUpdateArgs} args - Arguments to update one StoreLoyaltyTransaction.
     * @example
     * // Update one StoreLoyaltyTransaction
     * const storeLoyaltyTransaction = await prisma.storeLoyaltyTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreLoyaltyTransactionUpdateArgs>(args: SelectSubset<T, StoreLoyaltyTransactionUpdateArgs<ExtArgs>>): Prisma__StoreLoyaltyTransactionClient<$Result.GetResult<Prisma.$StoreLoyaltyTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StoreLoyaltyTransactions.
     * @param {StoreLoyaltyTransactionDeleteManyArgs} args - Arguments to filter StoreLoyaltyTransactions to delete.
     * @example
     * // Delete a few StoreLoyaltyTransactions
     * const { count } = await prisma.storeLoyaltyTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreLoyaltyTransactionDeleteManyArgs>(args?: SelectSubset<T, StoreLoyaltyTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreLoyaltyTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreLoyaltyTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreLoyaltyTransactions
     * const storeLoyaltyTransaction = await prisma.storeLoyaltyTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreLoyaltyTransactionUpdateManyArgs>(args: SelectSubset<T, StoreLoyaltyTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoreLoyaltyTransaction.
     * @param {StoreLoyaltyTransactionUpsertArgs} args - Arguments to update or create a StoreLoyaltyTransaction.
     * @example
     * // Update or create a StoreLoyaltyTransaction
     * const storeLoyaltyTransaction = await prisma.storeLoyaltyTransaction.upsert({
     *   create: {
     *     // ... data to create a StoreLoyaltyTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreLoyaltyTransaction we want to update
     *   }
     * })
     */
    upsert<T extends StoreLoyaltyTransactionUpsertArgs>(args: SelectSubset<T, StoreLoyaltyTransactionUpsertArgs<ExtArgs>>): Prisma__StoreLoyaltyTransactionClient<$Result.GetResult<Prisma.$StoreLoyaltyTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StoreLoyaltyTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreLoyaltyTransactionCountArgs} args - Arguments to filter StoreLoyaltyTransactions to count.
     * @example
     * // Count the number of StoreLoyaltyTransactions
     * const count = await prisma.storeLoyaltyTransaction.count({
     *   where: {
     *     // ... the filter for the StoreLoyaltyTransactions we want to count
     *   }
     * })
    **/
    count<T extends StoreLoyaltyTransactionCountArgs>(
      args?: Subset<T, StoreLoyaltyTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreLoyaltyTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreLoyaltyTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreLoyaltyTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreLoyaltyTransactionAggregateArgs>(args: Subset<T, StoreLoyaltyTransactionAggregateArgs>): Prisma.PrismaPromise<GetStoreLoyaltyTransactionAggregateType<T>>

    /**
     * Group by StoreLoyaltyTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreLoyaltyTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreLoyaltyTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreLoyaltyTransactionGroupByArgs['orderBy'] }
        : { orderBy?: StoreLoyaltyTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreLoyaltyTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreLoyaltyTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreLoyaltyTransaction model
   */
  readonly fields: StoreLoyaltyTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreLoyaltyTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreLoyaltyTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends StoreCustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreCustomerDefaultArgs<ExtArgs>>): Prisma__StoreCustomerClient<$Result.GetResult<Prisma.$StoreCustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreLoyaltyTransaction model
   */ 
  interface StoreLoyaltyTransactionFieldRefs {
    readonly id: FieldRef<"StoreLoyaltyTransaction", 'String'>
    readonly customerId: FieldRef<"StoreLoyaltyTransaction", 'String'>
    readonly type: FieldRef<"StoreLoyaltyTransaction", 'LoyaltyTransactionType'>
    readonly points: FieldRef<"StoreLoyaltyTransaction", 'Int'>
    readonly saleId: FieldRef<"StoreLoyaltyTransaction", 'String'>
    readonly description: FieldRef<"StoreLoyaltyTransaction", 'String'>
    readonly createdAt: FieldRef<"StoreLoyaltyTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoreLoyaltyTransaction findUnique
   */
  export type StoreLoyaltyTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyTransaction
     */
    select?: StoreLoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StoreLoyaltyTransaction to fetch.
     */
    where: StoreLoyaltyTransactionWhereUniqueInput
  }

  /**
   * StoreLoyaltyTransaction findUniqueOrThrow
   */
  export type StoreLoyaltyTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyTransaction
     */
    select?: StoreLoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StoreLoyaltyTransaction to fetch.
     */
    where: StoreLoyaltyTransactionWhereUniqueInput
  }

  /**
   * StoreLoyaltyTransaction findFirst
   */
  export type StoreLoyaltyTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyTransaction
     */
    select?: StoreLoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StoreLoyaltyTransaction to fetch.
     */
    where?: StoreLoyaltyTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreLoyaltyTransactions to fetch.
     */
    orderBy?: StoreLoyaltyTransactionOrderByWithRelationInput | StoreLoyaltyTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreLoyaltyTransactions.
     */
    cursor?: StoreLoyaltyTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreLoyaltyTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreLoyaltyTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreLoyaltyTransactions.
     */
    distinct?: StoreLoyaltyTransactionScalarFieldEnum | StoreLoyaltyTransactionScalarFieldEnum[]
  }

  /**
   * StoreLoyaltyTransaction findFirstOrThrow
   */
  export type StoreLoyaltyTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyTransaction
     */
    select?: StoreLoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StoreLoyaltyTransaction to fetch.
     */
    where?: StoreLoyaltyTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreLoyaltyTransactions to fetch.
     */
    orderBy?: StoreLoyaltyTransactionOrderByWithRelationInput | StoreLoyaltyTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreLoyaltyTransactions.
     */
    cursor?: StoreLoyaltyTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreLoyaltyTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreLoyaltyTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreLoyaltyTransactions.
     */
    distinct?: StoreLoyaltyTransactionScalarFieldEnum | StoreLoyaltyTransactionScalarFieldEnum[]
  }

  /**
   * StoreLoyaltyTransaction findMany
   */
  export type StoreLoyaltyTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyTransaction
     */
    select?: StoreLoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter, which StoreLoyaltyTransactions to fetch.
     */
    where?: StoreLoyaltyTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreLoyaltyTransactions to fetch.
     */
    orderBy?: StoreLoyaltyTransactionOrderByWithRelationInput | StoreLoyaltyTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreLoyaltyTransactions.
     */
    cursor?: StoreLoyaltyTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreLoyaltyTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreLoyaltyTransactions.
     */
    skip?: number
    distinct?: StoreLoyaltyTransactionScalarFieldEnum | StoreLoyaltyTransactionScalarFieldEnum[]
  }

  /**
   * StoreLoyaltyTransaction create
   */
  export type StoreLoyaltyTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyTransaction
     */
    select?: StoreLoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a StoreLoyaltyTransaction.
     */
    data: XOR<StoreLoyaltyTransactionCreateInput, StoreLoyaltyTransactionUncheckedCreateInput>
  }

  /**
   * StoreLoyaltyTransaction createMany
   */
  export type StoreLoyaltyTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreLoyaltyTransactions.
     */
    data: StoreLoyaltyTransactionCreateManyInput | StoreLoyaltyTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreLoyaltyTransaction createManyAndReturn
   */
  export type StoreLoyaltyTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyTransaction
     */
    select?: StoreLoyaltyTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StoreLoyaltyTransactions.
     */
    data: StoreLoyaltyTransactionCreateManyInput | StoreLoyaltyTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoreLoyaltyTransaction update
   */
  export type StoreLoyaltyTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyTransaction
     */
    select?: StoreLoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a StoreLoyaltyTransaction.
     */
    data: XOR<StoreLoyaltyTransactionUpdateInput, StoreLoyaltyTransactionUncheckedUpdateInput>
    /**
     * Choose, which StoreLoyaltyTransaction to update.
     */
    where: StoreLoyaltyTransactionWhereUniqueInput
  }

  /**
   * StoreLoyaltyTransaction updateMany
   */
  export type StoreLoyaltyTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreLoyaltyTransactions.
     */
    data: XOR<StoreLoyaltyTransactionUpdateManyMutationInput, StoreLoyaltyTransactionUncheckedUpdateManyInput>
    /**
     * Filter which StoreLoyaltyTransactions to update
     */
    where?: StoreLoyaltyTransactionWhereInput
  }

  /**
   * StoreLoyaltyTransaction upsert
   */
  export type StoreLoyaltyTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyTransaction
     */
    select?: StoreLoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the StoreLoyaltyTransaction to update in case it exists.
     */
    where: StoreLoyaltyTransactionWhereUniqueInput
    /**
     * In case the StoreLoyaltyTransaction found by the `where` argument doesn't exist, create a new StoreLoyaltyTransaction with this data.
     */
    create: XOR<StoreLoyaltyTransactionCreateInput, StoreLoyaltyTransactionUncheckedCreateInput>
    /**
     * In case the StoreLoyaltyTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreLoyaltyTransactionUpdateInput, StoreLoyaltyTransactionUncheckedUpdateInput>
  }

  /**
   * StoreLoyaltyTransaction delete
   */
  export type StoreLoyaltyTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyTransaction
     */
    select?: StoreLoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyTransactionInclude<ExtArgs> | null
    /**
     * Filter which StoreLoyaltyTransaction to delete.
     */
    where: StoreLoyaltyTransactionWhereUniqueInput
  }

  /**
   * StoreLoyaltyTransaction deleteMany
   */
  export type StoreLoyaltyTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreLoyaltyTransactions to delete
     */
    where?: StoreLoyaltyTransactionWhereInput
  }

  /**
   * StoreLoyaltyTransaction without action
   */
  export type StoreLoyaltyTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreLoyaltyTransaction
     */
    select?: StoreLoyaltyTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreLoyaltyTransactionInclude<ExtArgs> | null
  }


  /**
   * Model StoreTaxRule
   */

  export type AggregateStoreTaxRule = {
    _count: StoreTaxRuleCountAggregateOutputType | null
    _avg: StoreTaxRuleAvgAggregateOutputType | null
    _sum: StoreTaxRuleSumAggregateOutputType | null
    _min: StoreTaxRuleMinAggregateOutputType | null
    _max: StoreTaxRuleMaxAggregateOutputType | null
  }

  export type StoreTaxRuleAvgAggregateOutputType = {
    rate: Decimal | null
  }

  export type StoreTaxRuleSumAggregateOutputType = {
    rate: Decimal | null
  }

  export type StoreTaxRuleMinAggregateOutputType = {
    id: string | null
    storeId: string | null
    name: string | null
    rate: Decimal | null
    isDefault: boolean | null
    isActive: boolean | null
  }

  export type StoreTaxRuleMaxAggregateOutputType = {
    id: string | null
    storeId: string | null
    name: string | null
    rate: Decimal | null
    isDefault: boolean | null
    isActive: boolean | null
  }

  export type StoreTaxRuleCountAggregateOutputType = {
    id: number
    storeId: number
    name: number
    rate: number
    isDefault: number
    isActive: number
    _all: number
  }


  export type StoreTaxRuleAvgAggregateInputType = {
    rate?: true
  }

  export type StoreTaxRuleSumAggregateInputType = {
    rate?: true
  }

  export type StoreTaxRuleMinAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    rate?: true
    isDefault?: true
    isActive?: true
  }

  export type StoreTaxRuleMaxAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    rate?: true
    isDefault?: true
    isActive?: true
  }

  export type StoreTaxRuleCountAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    rate?: true
    isDefault?: true
    isActive?: true
    _all?: true
  }

  export type StoreTaxRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreTaxRule to aggregate.
     */
    where?: StoreTaxRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreTaxRules to fetch.
     */
    orderBy?: StoreTaxRuleOrderByWithRelationInput | StoreTaxRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreTaxRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreTaxRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreTaxRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreTaxRules
    **/
    _count?: true | StoreTaxRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreTaxRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreTaxRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreTaxRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreTaxRuleMaxAggregateInputType
  }

  export type GetStoreTaxRuleAggregateType<T extends StoreTaxRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreTaxRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreTaxRule[P]>
      : GetScalarType<T[P], AggregateStoreTaxRule[P]>
  }




  export type StoreTaxRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreTaxRuleWhereInput
    orderBy?: StoreTaxRuleOrderByWithAggregationInput | StoreTaxRuleOrderByWithAggregationInput[]
    by: StoreTaxRuleScalarFieldEnum[] | StoreTaxRuleScalarFieldEnum
    having?: StoreTaxRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreTaxRuleCountAggregateInputType | true
    _avg?: StoreTaxRuleAvgAggregateInputType
    _sum?: StoreTaxRuleSumAggregateInputType
    _min?: StoreTaxRuleMinAggregateInputType
    _max?: StoreTaxRuleMaxAggregateInputType
  }

  export type StoreTaxRuleGroupByOutputType = {
    id: string
    storeId: string
    name: string
    rate: Decimal
    isDefault: boolean
    isActive: boolean
    _count: StoreTaxRuleCountAggregateOutputType | null
    _avg: StoreTaxRuleAvgAggregateOutputType | null
    _sum: StoreTaxRuleSumAggregateOutputType | null
    _min: StoreTaxRuleMinAggregateOutputType | null
    _max: StoreTaxRuleMaxAggregateOutputType | null
  }

  type GetStoreTaxRuleGroupByPayload<T extends StoreTaxRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreTaxRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreTaxRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreTaxRuleGroupByOutputType[P]>
            : GetScalarType<T[P], StoreTaxRuleGroupByOutputType[P]>
        }
      >
    >


  export type StoreTaxRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    name?: boolean
    rate?: boolean
    isDefault?: boolean
    isActive?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
    products?: boolean | StoreTaxRule$productsArgs<ExtArgs>
    _count?: boolean | StoreTaxRuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeTaxRule"]>

  export type StoreTaxRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    name?: boolean
    rate?: boolean
    isDefault?: boolean
    isActive?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeTaxRule"]>

  export type StoreTaxRuleSelectScalar = {
    id?: boolean
    storeId?: boolean
    name?: boolean
    rate?: boolean
    isDefault?: boolean
    isActive?: boolean
  }

  export type StoreTaxRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
    products?: boolean | StoreTaxRule$productsArgs<ExtArgs>
    _count?: boolean | StoreTaxRuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoreTaxRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $StoreTaxRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreTaxRule"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
      products: Prisma.$StoreProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeId: string
      name: string
      rate: Prisma.Decimal
      isDefault: boolean
      isActive: boolean
    }, ExtArgs["result"]["storeTaxRule"]>
    composites: {}
  }

  type StoreTaxRuleGetPayload<S extends boolean | null | undefined | StoreTaxRuleDefaultArgs> = $Result.GetResult<Prisma.$StoreTaxRulePayload, S>

  type StoreTaxRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoreTaxRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoreTaxRuleCountAggregateInputType | true
    }

  export interface StoreTaxRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreTaxRule'], meta: { name: 'StoreTaxRule' } }
    /**
     * Find zero or one StoreTaxRule that matches the filter.
     * @param {StoreTaxRuleFindUniqueArgs} args - Arguments to find a StoreTaxRule
     * @example
     * // Get one StoreTaxRule
     * const storeTaxRule = await prisma.storeTaxRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreTaxRuleFindUniqueArgs>(args: SelectSubset<T, StoreTaxRuleFindUniqueArgs<ExtArgs>>): Prisma__StoreTaxRuleClient<$Result.GetResult<Prisma.$StoreTaxRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StoreTaxRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoreTaxRuleFindUniqueOrThrowArgs} args - Arguments to find a StoreTaxRule
     * @example
     * // Get one StoreTaxRule
     * const storeTaxRule = await prisma.storeTaxRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreTaxRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreTaxRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreTaxRuleClient<$Result.GetResult<Prisma.$StoreTaxRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StoreTaxRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreTaxRuleFindFirstArgs} args - Arguments to find a StoreTaxRule
     * @example
     * // Get one StoreTaxRule
     * const storeTaxRule = await prisma.storeTaxRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreTaxRuleFindFirstArgs>(args?: SelectSubset<T, StoreTaxRuleFindFirstArgs<ExtArgs>>): Prisma__StoreTaxRuleClient<$Result.GetResult<Prisma.$StoreTaxRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StoreTaxRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreTaxRuleFindFirstOrThrowArgs} args - Arguments to find a StoreTaxRule
     * @example
     * // Get one StoreTaxRule
     * const storeTaxRule = await prisma.storeTaxRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreTaxRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreTaxRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreTaxRuleClient<$Result.GetResult<Prisma.$StoreTaxRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StoreTaxRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreTaxRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreTaxRules
     * const storeTaxRules = await prisma.storeTaxRule.findMany()
     * 
     * // Get first 10 StoreTaxRules
     * const storeTaxRules = await prisma.storeTaxRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeTaxRuleWithIdOnly = await prisma.storeTaxRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreTaxRuleFindManyArgs>(args?: SelectSubset<T, StoreTaxRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreTaxRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StoreTaxRule.
     * @param {StoreTaxRuleCreateArgs} args - Arguments to create a StoreTaxRule.
     * @example
     * // Create one StoreTaxRule
     * const StoreTaxRule = await prisma.storeTaxRule.create({
     *   data: {
     *     // ... data to create a StoreTaxRule
     *   }
     * })
     * 
     */
    create<T extends StoreTaxRuleCreateArgs>(args: SelectSubset<T, StoreTaxRuleCreateArgs<ExtArgs>>): Prisma__StoreTaxRuleClient<$Result.GetResult<Prisma.$StoreTaxRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StoreTaxRules.
     * @param {StoreTaxRuleCreateManyArgs} args - Arguments to create many StoreTaxRules.
     * @example
     * // Create many StoreTaxRules
     * const storeTaxRule = await prisma.storeTaxRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreTaxRuleCreateManyArgs>(args?: SelectSubset<T, StoreTaxRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoreTaxRules and returns the data saved in the database.
     * @param {StoreTaxRuleCreateManyAndReturnArgs} args - Arguments to create many StoreTaxRules.
     * @example
     * // Create many StoreTaxRules
     * const storeTaxRule = await prisma.storeTaxRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoreTaxRules and only return the `id`
     * const storeTaxRuleWithIdOnly = await prisma.storeTaxRule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreTaxRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreTaxRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreTaxRulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StoreTaxRule.
     * @param {StoreTaxRuleDeleteArgs} args - Arguments to delete one StoreTaxRule.
     * @example
     * // Delete one StoreTaxRule
     * const StoreTaxRule = await prisma.storeTaxRule.delete({
     *   where: {
     *     // ... filter to delete one StoreTaxRule
     *   }
     * })
     * 
     */
    delete<T extends StoreTaxRuleDeleteArgs>(args: SelectSubset<T, StoreTaxRuleDeleteArgs<ExtArgs>>): Prisma__StoreTaxRuleClient<$Result.GetResult<Prisma.$StoreTaxRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StoreTaxRule.
     * @param {StoreTaxRuleUpdateArgs} args - Arguments to update one StoreTaxRule.
     * @example
     * // Update one StoreTaxRule
     * const storeTaxRule = await prisma.storeTaxRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreTaxRuleUpdateArgs>(args: SelectSubset<T, StoreTaxRuleUpdateArgs<ExtArgs>>): Prisma__StoreTaxRuleClient<$Result.GetResult<Prisma.$StoreTaxRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StoreTaxRules.
     * @param {StoreTaxRuleDeleteManyArgs} args - Arguments to filter StoreTaxRules to delete.
     * @example
     * // Delete a few StoreTaxRules
     * const { count } = await prisma.storeTaxRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreTaxRuleDeleteManyArgs>(args?: SelectSubset<T, StoreTaxRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreTaxRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreTaxRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreTaxRules
     * const storeTaxRule = await prisma.storeTaxRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreTaxRuleUpdateManyArgs>(args: SelectSubset<T, StoreTaxRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoreTaxRule.
     * @param {StoreTaxRuleUpsertArgs} args - Arguments to update or create a StoreTaxRule.
     * @example
     * // Update or create a StoreTaxRule
     * const storeTaxRule = await prisma.storeTaxRule.upsert({
     *   create: {
     *     // ... data to create a StoreTaxRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreTaxRule we want to update
     *   }
     * })
     */
    upsert<T extends StoreTaxRuleUpsertArgs>(args: SelectSubset<T, StoreTaxRuleUpsertArgs<ExtArgs>>): Prisma__StoreTaxRuleClient<$Result.GetResult<Prisma.$StoreTaxRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StoreTaxRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreTaxRuleCountArgs} args - Arguments to filter StoreTaxRules to count.
     * @example
     * // Count the number of StoreTaxRules
     * const count = await prisma.storeTaxRule.count({
     *   where: {
     *     // ... the filter for the StoreTaxRules we want to count
     *   }
     * })
    **/
    count<T extends StoreTaxRuleCountArgs>(
      args?: Subset<T, StoreTaxRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreTaxRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreTaxRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreTaxRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreTaxRuleAggregateArgs>(args: Subset<T, StoreTaxRuleAggregateArgs>): Prisma.PrismaPromise<GetStoreTaxRuleAggregateType<T>>

    /**
     * Group by StoreTaxRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreTaxRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreTaxRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreTaxRuleGroupByArgs['orderBy'] }
        : { orderBy?: StoreTaxRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreTaxRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreTaxRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreTaxRule model
   */
  readonly fields: StoreTaxRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreTaxRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreTaxRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    products<T extends StoreTaxRule$productsArgs<ExtArgs> = {}>(args?: Subset<T, StoreTaxRule$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreTaxRule model
   */ 
  interface StoreTaxRuleFieldRefs {
    readonly id: FieldRef<"StoreTaxRule", 'String'>
    readonly storeId: FieldRef<"StoreTaxRule", 'String'>
    readonly name: FieldRef<"StoreTaxRule", 'String'>
    readonly rate: FieldRef<"StoreTaxRule", 'Decimal'>
    readonly isDefault: FieldRef<"StoreTaxRule", 'Boolean'>
    readonly isActive: FieldRef<"StoreTaxRule", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * StoreTaxRule findUnique
   */
  export type StoreTaxRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreTaxRule
     */
    select?: StoreTaxRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreTaxRuleInclude<ExtArgs> | null
    /**
     * Filter, which StoreTaxRule to fetch.
     */
    where: StoreTaxRuleWhereUniqueInput
  }

  /**
   * StoreTaxRule findUniqueOrThrow
   */
  export type StoreTaxRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreTaxRule
     */
    select?: StoreTaxRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreTaxRuleInclude<ExtArgs> | null
    /**
     * Filter, which StoreTaxRule to fetch.
     */
    where: StoreTaxRuleWhereUniqueInput
  }

  /**
   * StoreTaxRule findFirst
   */
  export type StoreTaxRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreTaxRule
     */
    select?: StoreTaxRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreTaxRuleInclude<ExtArgs> | null
    /**
     * Filter, which StoreTaxRule to fetch.
     */
    where?: StoreTaxRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreTaxRules to fetch.
     */
    orderBy?: StoreTaxRuleOrderByWithRelationInput | StoreTaxRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreTaxRules.
     */
    cursor?: StoreTaxRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreTaxRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreTaxRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreTaxRules.
     */
    distinct?: StoreTaxRuleScalarFieldEnum | StoreTaxRuleScalarFieldEnum[]
  }

  /**
   * StoreTaxRule findFirstOrThrow
   */
  export type StoreTaxRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreTaxRule
     */
    select?: StoreTaxRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreTaxRuleInclude<ExtArgs> | null
    /**
     * Filter, which StoreTaxRule to fetch.
     */
    where?: StoreTaxRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreTaxRules to fetch.
     */
    orderBy?: StoreTaxRuleOrderByWithRelationInput | StoreTaxRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreTaxRules.
     */
    cursor?: StoreTaxRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreTaxRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreTaxRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreTaxRules.
     */
    distinct?: StoreTaxRuleScalarFieldEnum | StoreTaxRuleScalarFieldEnum[]
  }

  /**
   * StoreTaxRule findMany
   */
  export type StoreTaxRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreTaxRule
     */
    select?: StoreTaxRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreTaxRuleInclude<ExtArgs> | null
    /**
     * Filter, which StoreTaxRules to fetch.
     */
    where?: StoreTaxRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreTaxRules to fetch.
     */
    orderBy?: StoreTaxRuleOrderByWithRelationInput | StoreTaxRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreTaxRules.
     */
    cursor?: StoreTaxRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreTaxRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreTaxRules.
     */
    skip?: number
    distinct?: StoreTaxRuleScalarFieldEnum | StoreTaxRuleScalarFieldEnum[]
  }

  /**
   * StoreTaxRule create
   */
  export type StoreTaxRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreTaxRule
     */
    select?: StoreTaxRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreTaxRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a StoreTaxRule.
     */
    data: XOR<StoreTaxRuleCreateInput, StoreTaxRuleUncheckedCreateInput>
  }

  /**
   * StoreTaxRule createMany
   */
  export type StoreTaxRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreTaxRules.
     */
    data: StoreTaxRuleCreateManyInput | StoreTaxRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreTaxRule createManyAndReturn
   */
  export type StoreTaxRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreTaxRule
     */
    select?: StoreTaxRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StoreTaxRules.
     */
    data: StoreTaxRuleCreateManyInput | StoreTaxRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreTaxRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoreTaxRule update
   */
  export type StoreTaxRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreTaxRule
     */
    select?: StoreTaxRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreTaxRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a StoreTaxRule.
     */
    data: XOR<StoreTaxRuleUpdateInput, StoreTaxRuleUncheckedUpdateInput>
    /**
     * Choose, which StoreTaxRule to update.
     */
    where: StoreTaxRuleWhereUniqueInput
  }

  /**
   * StoreTaxRule updateMany
   */
  export type StoreTaxRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreTaxRules.
     */
    data: XOR<StoreTaxRuleUpdateManyMutationInput, StoreTaxRuleUncheckedUpdateManyInput>
    /**
     * Filter which StoreTaxRules to update
     */
    where?: StoreTaxRuleWhereInput
  }

  /**
   * StoreTaxRule upsert
   */
  export type StoreTaxRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreTaxRule
     */
    select?: StoreTaxRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreTaxRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the StoreTaxRule to update in case it exists.
     */
    where: StoreTaxRuleWhereUniqueInput
    /**
     * In case the StoreTaxRule found by the `where` argument doesn't exist, create a new StoreTaxRule with this data.
     */
    create: XOR<StoreTaxRuleCreateInput, StoreTaxRuleUncheckedCreateInput>
    /**
     * In case the StoreTaxRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreTaxRuleUpdateInput, StoreTaxRuleUncheckedUpdateInput>
  }

  /**
   * StoreTaxRule delete
   */
  export type StoreTaxRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreTaxRule
     */
    select?: StoreTaxRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreTaxRuleInclude<ExtArgs> | null
    /**
     * Filter which StoreTaxRule to delete.
     */
    where: StoreTaxRuleWhereUniqueInput
  }

  /**
   * StoreTaxRule deleteMany
   */
  export type StoreTaxRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreTaxRules to delete
     */
    where?: StoreTaxRuleWhereInput
  }

  /**
   * StoreTaxRule.products
   */
  export type StoreTaxRule$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreProductInclude<ExtArgs> | null
    where?: StoreProductWhereInput
    orderBy?: StoreProductOrderByWithRelationInput | StoreProductOrderByWithRelationInput[]
    cursor?: StoreProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreProductScalarFieldEnum | StoreProductScalarFieldEnum[]
  }

  /**
   * StoreTaxRule without action
   */
  export type StoreTaxRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreTaxRule
     */
    select?: StoreTaxRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreTaxRuleInclude<ExtArgs> | null
  }


  /**
   * Model StorePaymentConfig
   */

  export type AggregateStorePaymentConfig = {
    _count: StorePaymentConfigCountAggregateOutputType | null
    _avg: StorePaymentConfigAvgAggregateOutputType | null
    _sum: StorePaymentConfigSumAggregateOutputType | null
    _min: StorePaymentConfigMinAggregateOutputType | null
    _max: StorePaymentConfigMaxAggregateOutputType | null
  }

  export type StorePaymentConfigAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type StorePaymentConfigSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type StorePaymentConfigMinAggregateOutputType = {
    id: string | null
    storeId: string | null
    name: string | null
    type: $Enums.PaymentMethod | null
    isActive: boolean | null
    sortOrder: number | null
  }

  export type StorePaymentConfigMaxAggregateOutputType = {
    id: string | null
    storeId: string | null
    name: string | null
    type: $Enums.PaymentMethod | null
    isActive: boolean | null
    sortOrder: number | null
  }

  export type StorePaymentConfigCountAggregateOutputType = {
    id: number
    storeId: number
    name: number
    type: number
    isActive: number
    sortOrder: number
    _all: number
  }


  export type StorePaymentConfigAvgAggregateInputType = {
    sortOrder?: true
  }

  export type StorePaymentConfigSumAggregateInputType = {
    sortOrder?: true
  }

  export type StorePaymentConfigMinAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    type?: true
    isActive?: true
    sortOrder?: true
  }

  export type StorePaymentConfigMaxAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    type?: true
    isActive?: true
    sortOrder?: true
  }

  export type StorePaymentConfigCountAggregateInputType = {
    id?: true
    storeId?: true
    name?: true
    type?: true
    isActive?: true
    sortOrder?: true
    _all?: true
  }

  export type StorePaymentConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorePaymentConfig to aggregate.
     */
    where?: StorePaymentConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePaymentConfigs to fetch.
     */
    orderBy?: StorePaymentConfigOrderByWithRelationInput | StorePaymentConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StorePaymentConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePaymentConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePaymentConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StorePaymentConfigs
    **/
    _count?: true | StorePaymentConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StorePaymentConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StorePaymentConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorePaymentConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorePaymentConfigMaxAggregateInputType
  }

  export type GetStorePaymentConfigAggregateType<T extends StorePaymentConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateStorePaymentConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorePaymentConfig[P]>
      : GetScalarType<T[P], AggregateStorePaymentConfig[P]>
  }




  export type StorePaymentConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorePaymentConfigWhereInput
    orderBy?: StorePaymentConfigOrderByWithAggregationInput | StorePaymentConfigOrderByWithAggregationInput[]
    by: StorePaymentConfigScalarFieldEnum[] | StorePaymentConfigScalarFieldEnum
    having?: StorePaymentConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorePaymentConfigCountAggregateInputType | true
    _avg?: StorePaymentConfigAvgAggregateInputType
    _sum?: StorePaymentConfigSumAggregateInputType
    _min?: StorePaymentConfigMinAggregateInputType
    _max?: StorePaymentConfigMaxAggregateInputType
  }

  export type StorePaymentConfigGroupByOutputType = {
    id: string
    storeId: string
    name: string
    type: $Enums.PaymentMethod
    isActive: boolean
    sortOrder: number
    _count: StorePaymentConfigCountAggregateOutputType | null
    _avg: StorePaymentConfigAvgAggregateOutputType | null
    _sum: StorePaymentConfigSumAggregateOutputType | null
    _min: StorePaymentConfigMinAggregateOutputType | null
    _max: StorePaymentConfigMaxAggregateOutputType | null
  }

  type GetStorePaymentConfigGroupByPayload<T extends StorePaymentConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StorePaymentConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorePaymentConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorePaymentConfigGroupByOutputType[P]>
            : GetScalarType<T[P], StorePaymentConfigGroupByOutputType[P]>
        }
      >
    >


  export type StorePaymentConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    name?: boolean
    type?: boolean
    isActive?: boolean
    sortOrder?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storePaymentConfig"]>

  export type StorePaymentConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    name?: boolean
    type?: boolean
    isActive?: boolean
    sortOrder?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storePaymentConfig"]>

  export type StorePaymentConfigSelectScalar = {
    id?: boolean
    storeId?: boolean
    name?: boolean
    type?: boolean
    isActive?: boolean
    sortOrder?: boolean
  }

  export type StorePaymentConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }
  export type StorePaymentConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $StorePaymentConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StorePaymentConfig"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeId: string
      name: string
      type: $Enums.PaymentMethod
      isActive: boolean
      sortOrder: number
    }, ExtArgs["result"]["storePaymentConfig"]>
    composites: {}
  }

  type StorePaymentConfigGetPayload<S extends boolean | null | undefined | StorePaymentConfigDefaultArgs> = $Result.GetResult<Prisma.$StorePaymentConfigPayload, S>

  type StorePaymentConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StorePaymentConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StorePaymentConfigCountAggregateInputType | true
    }

  export interface StorePaymentConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StorePaymentConfig'], meta: { name: 'StorePaymentConfig' } }
    /**
     * Find zero or one StorePaymentConfig that matches the filter.
     * @param {StorePaymentConfigFindUniqueArgs} args - Arguments to find a StorePaymentConfig
     * @example
     * // Get one StorePaymentConfig
     * const storePaymentConfig = await prisma.storePaymentConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StorePaymentConfigFindUniqueArgs>(args: SelectSubset<T, StorePaymentConfigFindUniqueArgs<ExtArgs>>): Prisma__StorePaymentConfigClient<$Result.GetResult<Prisma.$StorePaymentConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StorePaymentConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StorePaymentConfigFindUniqueOrThrowArgs} args - Arguments to find a StorePaymentConfig
     * @example
     * // Get one StorePaymentConfig
     * const storePaymentConfig = await prisma.storePaymentConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StorePaymentConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, StorePaymentConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StorePaymentConfigClient<$Result.GetResult<Prisma.$StorePaymentConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StorePaymentConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePaymentConfigFindFirstArgs} args - Arguments to find a StorePaymentConfig
     * @example
     * // Get one StorePaymentConfig
     * const storePaymentConfig = await prisma.storePaymentConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StorePaymentConfigFindFirstArgs>(args?: SelectSubset<T, StorePaymentConfigFindFirstArgs<ExtArgs>>): Prisma__StorePaymentConfigClient<$Result.GetResult<Prisma.$StorePaymentConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StorePaymentConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePaymentConfigFindFirstOrThrowArgs} args - Arguments to find a StorePaymentConfig
     * @example
     * // Get one StorePaymentConfig
     * const storePaymentConfig = await prisma.storePaymentConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StorePaymentConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, StorePaymentConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__StorePaymentConfigClient<$Result.GetResult<Prisma.$StorePaymentConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StorePaymentConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePaymentConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StorePaymentConfigs
     * const storePaymentConfigs = await prisma.storePaymentConfig.findMany()
     * 
     * // Get first 10 StorePaymentConfigs
     * const storePaymentConfigs = await prisma.storePaymentConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storePaymentConfigWithIdOnly = await prisma.storePaymentConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StorePaymentConfigFindManyArgs>(args?: SelectSubset<T, StorePaymentConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePaymentConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StorePaymentConfig.
     * @param {StorePaymentConfigCreateArgs} args - Arguments to create a StorePaymentConfig.
     * @example
     * // Create one StorePaymentConfig
     * const StorePaymentConfig = await prisma.storePaymentConfig.create({
     *   data: {
     *     // ... data to create a StorePaymentConfig
     *   }
     * })
     * 
     */
    create<T extends StorePaymentConfigCreateArgs>(args: SelectSubset<T, StorePaymentConfigCreateArgs<ExtArgs>>): Prisma__StorePaymentConfigClient<$Result.GetResult<Prisma.$StorePaymentConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StorePaymentConfigs.
     * @param {StorePaymentConfigCreateManyArgs} args - Arguments to create many StorePaymentConfigs.
     * @example
     * // Create many StorePaymentConfigs
     * const storePaymentConfig = await prisma.storePaymentConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StorePaymentConfigCreateManyArgs>(args?: SelectSubset<T, StorePaymentConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StorePaymentConfigs and returns the data saved in the database.
     * @param {StorePaymentConfigCreateManyAndReturnArgs} args - Arguments to create many StorePaymentConfigs.
     * @example
     * // Create many StorePaymentConfigs
     * const storePaymentConfig = await prisma.storePaymentConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StorePaymentConfigs and only return the `id`
     * const storePaymentConfigWithIdOnly = await prisma.storePaymentConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StorePaymentConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, StorePaymentConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePaymentConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StorePaymentConfig.
     * @param {StorePaymentConfigDeleteArgs} args - Arguments to delete one StorePaymentConfig.
     * @example
     * // Delete one StorePaymentConfig
     * const StorePaymentConfig = await prisma.storePaymentConfig.delete({
     *   where: {
     *     // ... filter to delete one StorePaymentConfig
     *   }
     * })
     * 
     */
    delete<T extends StorePaymentConfigDeleteArgs>(args: SelectSubset<T, StorePaymentConfigDeleteArgs<ExtArgs>>): Prisma__StorePaymentConfigClient<$Result.GetResult<Prisma.$StorePaymentConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StorePaymentConfig.
     * @param {StorePaymentConfigUpdateArgs} args - Arguments to update one StorePaymentConfig.
     * @example
     * // Update one StorePaymentConfig
     * const storePaymentConfig = await prisma.storePaymentConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StorePaymentConfigUpdateArgs>(args: SelectSubset<T, StorePaymentConfigUpdateArgs<ExtArgs>>): Prisma__StorePaymentConfigClient<$Result.GetResult<Prisma.$StorePaymentConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StorePaymentConfigs.
     * @param {StorePaymentConfigDeleteManyArgs} args - Arguments to filter StorePaymentConfigs to delete.
     * @example
     * // Delete a few StorePaymentConfigs
     * const { count } = await prisma.storePaymentConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StorePaymentConfigDeleteManyArgs>(args?: SelectSubset<T, StorePaymentConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorePaymentConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePaymentConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StorePaymentConfigs
     * const storePaymentConfig = await prisma.storePaymentConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StorePaymentConfigUpdateManyArgs>(args: SelectSubset<T, StorePaymentConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StorePaymentConfig.
     * @param {StorePaymentConfigUpsertArgs} args - Arguments to update or create a StorePaymentConfig.
     * @example
     * // Update or create a StorePaymentConfig
     * const storePaymentConfig = await prisma.storePaymentConfig.upsert({
     *   create: {
     *     // ... data to create a StorePaymentConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StorePaymentConfig we want to update
     *   }
     * })
     */
    upsert<T extends StorePaymentConfigUpsertArgs>(args: SelectSubset<T, StorePaymentConfigUpsertArgs<ExtArgs>>): Prisma__StorePaymentConfigClient<$Result.GetResult<Prisma.$StorePaymentConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StorePaymentConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePaymentConfigCountArgs} args - Arguments to filter StorePaymentConfigs to count.
     * @example
     * // Count the number of StorePaymentConfigs
     * const count = await prisma.storePaymentConfig.count({
     *   where: {
     *     // ... the filter for the StorePaymentConfigs we want to count
     *   }
     * })
    **/
    count<T extends StorePaymentConfigCountArgs>(
      args?: Subset<T, StorePaymentConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorePaymentConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StorePaymentConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePaymentConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorePaymentConfigAggregateArgs>(args: Subset<T, StorePaymentConfigAggregateArgs>): Prisma.PrismaPromise<GetStorePaymentConfigAggregateType<T>>

    /**
     * Group by StorePaymentConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorePaymentConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorePaymentConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorePaymentConfigGroupByArgs['orderBy'] }
        : { orderBy?: StorePaymentConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorePaymentConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorePaymentConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StorePaymentConfig model
   */
  readonly fields: StorePaymentConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StorePaymentConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StorePaymentConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StorePaymentConfig model
   */ 
  interface StorePaymentConfigFieldRefs {
    readonly id: FieldRef<"StorePaymentConfig", 'String'>
    readonly storeId: FieldRef<"StorePaymentConfig", 'String'>
    readonly name: FieldRef<"StorePaymentConfig", 'String'>
    readonly type: FieldRef<"StorePaymentConfig", 'PaymentMethod'>
    readonly isActive: FieldRef<"StorePaymentConfig", 'Boolean'>
    readonly sortOrder: FieldRef<"StorePaymentConfig", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StorePaymentConfig findUnique
   */
  export type StorePaymentConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePaymentConfig
     */
    select?: StorePaymentConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePaymentConfigInclude<ExtArgs> | null
    /**
     * Filter, which StorePaymentConfig to fetch.
     */
    where: StorePaymentConfigWhereUniqueInput
  }

  /**
   * StorePaymentConfig findUniqueOrThrow
   */
  export type StorePaymentConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePaymentConfig
     */
    select?: StorePaymentConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePaymentConfigInclude<ExtArgs> | null
    /**
     * Filter, which StorePaymentConfig to fetch.
     */
    where: StorePaymentConfigWhereUniqueInput
  }

  /**
   * StorePaymentConfig findFirst
   */
  export type StorePaymentConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePaymentConfig
     */
    select?: StorePaymentConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePaymentConfigInclude<ExtArgs> | null
    /**
     * Filter, which StorePaymentConfig to fetch.
     */
    where?: StorePaymentConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePaymentConfigs to fetch.
     */
    orderBy?: StorePaymentConfigOrderByWithRelationInput | StorePaymentConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorePaymentConfigs.
     */
    cursor?: StorePaymentConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePaymentConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePaymentConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorePaymentConfigs.
     */
    distinct?: StorePaymentConfigScalarFieldEnum | StorePaymentConfigScalarFieldEnum[]
  }

  /**
   * StorePaymentConfig findFirstOrThrow
   */
  export type StorePaymentConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePaymentConfig
     */
    select?: StorePaymentConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePaymentConfigInclude<ExtArgs> | null
    /**
     * Filter, which StorePaymentConfig to fetch.
     */
    where?: StorePaymentConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePaymentConfigs to fetch.
     */
    orderBy?: StorePaymentConfigOrderByWithRelationInput | StorePaymentConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorePaymentConfigs.
     */
    cursor?: StorePaymentConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePaymentConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePaymentConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorePaymentConfigs.
     */
    distinct?: StorePaymentConfigScalarFieldEnum | StorePaymentConfigScalarFieldEnum[]
  }

  /**
   * StorePaymentConfig findMany
   */
  export type StorePaymentConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePaymentConfig
     */
    select?: StorePaymentConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePaymentConfigInclude<ExtArgs> | null
    /**
     * Filter, which StorePaymentConfigs to fetch.
     */
    where?: StorePaymentConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorePaymentConfigs to fetch.
     */
    orderBy?: StorePaymentConfigOrderByWithRelationInput | StorePaymentConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StorePaymentConfigs.
     */
    cursor?: StorePaymentConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorePaymentConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorePaymentConfigs.
     */
    skip?: number
    distinct?: StorePaymentConfigScalarFieldEnum | StorePaymentConfigScalarFieldEnum[]
  }

  /**
   * StorePaymentConfig create
   */
  export type StorePaymentConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePaymentConfig
     */
    select?: StorePaymentConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePaymentConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a StorePaymentConfig.
     */
    data: XOR<StorePaymentConfigCreateInput, StorePaymentConfigUncheckedCreateInput>
  }

  /**
   * StorePaymentConfig createMany
   */
  export type StorePaymentConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StorePaymentConfigs.
     */
    data: StorePaymentConfigCreateManyInput | StorePaymentConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StorePaymentConfig createManyAndReturn
   */
  export type StorePaymentConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePaymentConfig
     */
    select?: StorePaymentConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StorePaymentConfigs.
     */
    data: StorePaymentConfigCreateManyInput | StorePaymentConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePaymentConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StorePaymentConfig update
   */
  export type StorePaymentConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePaymentConfig
     */
    select?: StorePaymentConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePaymentConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a StorePaymentConfig.
     */
    data: XOR<StorePaymentConfigUpdateInput, StorePaymentConfigUncheckedUpdateInput>
    /**
     * Choose, which StorePaymentConfig to update.
     */
    where: StorePaymentConfigWhereUniqueInput
  }

  /**
   * StorePaymentConfig updateMany
   */
  export type StorePaymentConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StorePaymentConfigs.
     */
    data: XOR<StorePaymentConfigUpdateManyMutationInput, StorePaymentConfigUncheckedUpdateManyInput>
    /**
     * Filter which StorePaymentConfigs to update
     */
    where?: StorePaymentConfigWhereInput
  }

  /**
   * StorePaymentConfig upsert
   */
  export type StorePaymentConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePaymentConfig
     */
    select?: StorePaymentConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePaymentConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the StorePaymentConfig to update in case it exists.
     */
    where: StorePaymentConfigWhereUniqueInput
    /**
     * In case the StorePaymentConfig found by the `where` argument doesn't exist, create a new StorePaymentConfig with this data.
     */
    create: XOR<StorePaymentConfigCreateInput, StorePaymentConfigUncheckedCreateInput>
    /**
     * In case the StorePaymentConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StorePaymentConfigUpdateInput, StorePaymentConfigUncheckedUpdateInput>
  }

  /**
   * StorePaymentConfig delete
   */
  export type StorePaymentConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePaymentConfig
     */
    select?: StorePaymentConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePaymentConfigInclude<ExtArgs> | null
    /**
     * Filter which StorePaymentConfig to delete.
     */
    where: StorePaymentConfigWhereUniqueInput
  }

  /**
   * StorePaymentConfig deleteMany
   */
  export type StorePaymentConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorePaymentConfigs to delete
     */
    where?: StorePaymentConfigWhereInput
  }

  /**
   * StorePaymentConfig without action
   */
  export type StorePaymentConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorePaymentConfig
     */
    select?: StorePaymentConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorePaymentConfigInclude<ExtArgs> | null
  }


  /**
   * Model StoreReceiptConfig
   */

  export type AggregateStoreReceiptConfig = {
    _count: StoreReceiptConfigCountAggregateOutputType | null
    _avg: StoreReceiptConfigAvgAggregateOutputType | null
    _sum: StoreReceiptConfigSumAggregateOutputType | null
    _min: StoreReceiptConfigMinAggregateOutputType | null
    _max: StoreReceiptConfigMaxAggregateOutputType | null
  }

  export type StoreReceiptConfigAvgAggregateOutputType = {
    paperWidth: number | null
  }

  export type StoreReceiptConfigSumAggregateOutputType = {
    paperWidth: number | null
  }

  export type StoreReceiptConfigMinAggregateOutputType = {
    id: string | null
    storeId: string | null
    headerText: string | null
    footerText: string | null
    showLogo: boolean | null
    showTaxId: boolean | null
    showBarcode: boolean | null
    paperWidth: number | null
  }

  export type StoreReceiptConfigMaxAggregateOutputType = {
    id: string | null
    storeId: string | null
    headerText: string | null
    footerText: string | null
    showLogo: boolean | null
    showTaxId: boolean | null
    showBarcode: boolean | null
    paperWidth: number | null
  }

  export type StoreReceiptConfigCountAggregateOutputType = {
    id: number
    storeId: number
    headerText: number
    footerText: number
    showLogo: number
    showTaxId: number
    showBarcode: number
    paperWidth: number
    _all: number
  }


  export type StoreReceiptConfigAvgAggregateInputType = {
    paperWidth?: true
  }

  export type StoreReceiptConfigSumAggregateInputType = {
    paperWidth?: true
  }

  export type StoreReceiptConfigMinAggregateInputType = {
    id?: true
    storeId?: true
    headerText?: true
    footerText?: true
    showLogo?: true
    showTaxId?: true
    showBarcode?: true
    paperWidth?: true
  }

  export type StoreReceiptConfigMaxAggregateInputType = {
    id?: true
    storeId?: true
    headerText?: true
    footerText?: true
    showLogo?: true
    showTaxId?: true
    showBarcode?: true
    paperWidth?: true
  }

  export type StoreReceiptConfigCountAggregateInputType = {
    id?: true
    storeId?: true
    headerText?: true
    footerText?: true
    showLogo?: true
    showTaxId?: true
    showBarcode?: true
    paperWidth?: true
    _all?: true
  }

  export type StoreReceiptConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreReceiptConfig to aggregate.
     */
    where?: StoreReceiptConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreReceiptConfigs to fetch.
     */
    orderBy?: StoreReceiptConfigOrderByWithRelationInput | StoreReceiptConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreReceiptConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreReceiptConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreReceiptConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreReceiptConfigs
    **/
    _count?: true | StoreReceiptConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreReceiptConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreReceiptConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreReceiptConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreReceiptConfigMaxAggregateInputType
  }

  export type GetStoreReceiptConfigAggregateType<T extends StoreReceiptConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreReceiptConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreReceiptConfig[P]>
      : GetScalarType<T[P], AggregateStoreReceiptConfig[P]>
  }




  export type StoreReceiptConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreReceiptConfigWhereInput
    orderBy?: StoreReceiptConfigOrderByWithAggregationInput | StoreReceiptConfigOrderByWithAggregationInput[]
    by: StoreReceiptConfigScalarFieldEnum[] | StoreReceiptConfigScalarFieldEnum
    having?: StoreReceiptConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreReceiptConfigCountAggregateInputType | true
    _avg?: StoreReceiptConfigAvgAggregateInputType
    _sum?: StoreReceiptConfigSumAggregateInputType
    _min?: StoreReceiptConfigMinAggregateInputType
    _max?: StoreReceiptConfigMaxAggregateInputType
  }

  export type StoreReceiptConfigGroupByOutputType = {
    id: string
    storeId: string
    headerText: string | null
    footerText: string | null
    showLogo: boolean
    showTaxId: boolean
    showBarcode: boolean
    paperWidth: number
    _count: StoreReceiptConfigCountAggregateOutputType | null
    _avg: StoreReceiptConfigAvgAggregateOutputType | null
    _sum: StoreReceiptConfigSumAggregateOutputType | null
    _min: StoreReceiptConfigMinAggregateOutputType | null
    _max: StoreReceiptConfigMaxAggregateOutputType | null
  }

  type GetStoreReceiptConfigGroupByPayload<T extends StoreReceiptConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreReceiptConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreReceiptConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreReceiptConfigGroupByOutputType[P]>
            : GetScalarType<T[P], StoreReceiptConfigGroupByOutputType[P]>
        }
      >
    >


  export type StoreReceiptConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    headerText?: boolean
    footerText?: boolean
    showLogo?: boolean
    showTaxId?: boolean
    showBarcode?: boolean
    paperWidth?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeReceiptConfig"]>

  export type StoreReceiptConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    headerText?: boolean
    footerText?: boolean
    showLogo?: boolean
    showTaxId?: boolean
    showBarcode?: boolean
    paperWidth?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeReceiptConfig"]>

  export type StoreReceiptConfigSelectScalar = {
    id?: boolean
    storeId?: boolean
    headerText?: boolean
    footerText?: boolean
    showLogo?: boolean
    showTaxId?: boolean
    showBarcode?: boolean
    paperWidth?: boolean
  }

  export type StoreReceiptConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }
  export type StoreReceiptConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $StoreReceiptConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreReceiptConfig"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeId: string
      headerText: string | null
      footerText: string | null
      showLogo: boolean
      showTaxId: boolean
      showBarcode: boolean
      paperWidth: number
    }, ExtArgs["result"]["storeReceiptConfig"]>
    composites: {}
  }

  type StoreReceiptConfigGetPayload<S extends boolean | null | undefined | StoreReceiptConfigDefaultArgs> = $Result.GetResult<Prisma.$StoreReceiptConfigPayload, S>

  type StoreReceiptConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoreReceiptConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoreReceiptConfigCountAggregateInputType | true
    }

  export interface StoreReceiptConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreReceiptConfig'], meta: { name: 'StoreReceiptConfig' } }
    /**
     * Find zero or one StoreReceiptConfig that matches the filter.
     * @param {StoreReceiptConfigFindUniqueArgs} args - Arguments to find a StoreReceiptConfig
     * @example
     * // Get one StoreReceiptConfig
     * const storeReceiptConfig = await prisma.storeReceiptConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreReceiptConfigFindUniqueArgs>(args: SelectSubset<T, StoreReceiptConfigFindUniqueArgs<ExtArgs>>): Prisma__StoreReceiptConfigClient<$Result.GetResult<Prisma.$StoreReceiptConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StoreReceiptConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoreReceiptConfigFindUniqueOrThrowArgs} args - Arguments to find a StoreReceiptConfig
     * @example
     * // Get one StoreReceiptConfig
     * const storeReceiptConfig = await prisma.storeReceiptConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreReceiptConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreReceiptConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreReceiptConfigClient<$Result.GetResult<Prisma.$StoreReceiptConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StoreReceiptConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreReceiptConfigFindFirstArgs} args - Arguments to find a StoreReceiptConfig
     * @example
     * // Get one StoreReceiptConfig
     * const storeReceiptConfig = await prisma.storeReceiptConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreReceiptConfigFindFirstArgs>(args?: SelectSubset<T, StoreReceiptConfigFindFirstArgs<ExtArgs>>): Prisma__StoreReceiptConfigClient<$Result.GetResult<Prisma.$StoreReceiptConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StoreReceiptConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreReceiptConfigFindFirstOrThrowArgs} args - Arguments to find a StoreReceiptConfig
     * @example
     * // Get one StoreReceiptConfig
     * const storeReceiptConfig = await prisma.storeReceiptConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreReceiptConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreReceiptConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreReceiptConfigClient<$Result.GetResult<Prisma.$StoreReceiptConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StoreReceiptConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreReceiptConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreReceiptConfigs
     * const storeReceiptConfigs = await prisma.storeReceiptConfig.findMany()
     * 
     * // Get first 10 StoreReceiptConfigs
     * const storeReceiptConfigs = await prisma.storeReceiptConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeReceiptConfigWithIdOnly = await prisma.storeReceiptConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreReceiptConfigFindManyArgs>(args?: SelectSubset<T, StoreReceiptConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreReceiptConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StoreReceiptConfig.
     * @param {StoreReceiptConfigCreateArgs} args - Arguments to create a StoreReceiptConfig.
     * @example
     * // Create one StoreReceiptConfig
     * const StoreReceiptConfig = await prisma.storeReceiptConfig.create({
     *   data: {
     *     // ... data to create a StoreReceiptConfig
     *   }
     * })
     * 
     */
    create<T extends StoreReceiptConfigCreateArgs>(args: SelectSubset<T, StoreReceiptConfigCreateArgs<ExtArgs>>): Prisma__StoreReceiptConfigClient<$Result.GetResult<Prisma.$StoreReceiptConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StoreReceiptConfigs.
     * @param {StoreReceiptConfigCreateManyArgs} args - Arguments to create many StoreReceiptConfigs.
     * @example
     * // Create many StoreReceiptConfigs
     * const storeReceiptConfig = await prisma.storeReceiptConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreReceiptConfigCreateManyArgs>(args?: SelectSubset<T, StoreReceiptConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoreReceiptConfigs and returns the data saved in the database.
     * @param {StoreReceiptConfigCreateManyAndReturnArgs} args - Arguments to create many StoreReceiptConfigs.
     * @example
     * // Create many StoreReceiptConfigs
     * const storeReceiptConfig = await prisma.storeReceiptConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoreReceiptConfigs and only return the `id`
     * const storeReceiptConfigWithIdOnly = await prisma.storeReceiptConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreReceiptConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreReceiptConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreReceiptConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StoreReceiptConfig.
     * @param {StoreReceiptConfigDeleteArgs} args - Arguments to delete one StoreReceiptConfig.
     * @example
     * // Delete one StoreReceiptConfig
     * const StoreReceiptConfig = await prisma.storeReceiptConfig.delete({
     *   where: {
     *     // ... filter to delete one StoreReceiptConfig
     *   }
     * })
     * 
     */
    delete<T extends StoreReceiptConfigDeleteArgs>(args: SelectSubset<T, StoreReceiptConfigDeleteArgs<ExtArgs>>): Prisma__StoreReceiptConfigClient<$Result.GetResult<Prisma.$StoreReceiptConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StoreReceiptConfig.
     * @param {StoreReceiptConfigUpdateArgs} args - Arguments to update one StoreReceiptConfig.
     * @example
     * // Update one StoreReceiptConfig
     * const storeReceiptConfig = await prisma.storeReceiptConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreReceiptConfigUpdateArgs>(args: SelectSubset<T, StoreReceiptConfigUpdateArgs<ExtArgs>>): Prisma__StoreReceiptConfigClient<$Result.GetResult<Prisma.$StoreReceiptConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StoreReceiptConfigs.
     * @param {StoreReceiptConfigDeleteManyArgs} args - Arguments to filter StoreReceiptConfigs to delete.
     * @example
     * // Delete a few StoreReceiptConfigs
     * const { count } = await prisma.storeReceiptConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreReceiptConfigDeleteManyArgs>(args?: SelectSubset<T, StoreReceiptConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreReceiptConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreReceiptConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreReceiptConfigs
     * const storeReceiptConfig = await prisma.storeReceiptConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreReceiptConfigUpdateManyArgs>(args: SelectSubset<T, StoreReceiptConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoreReceiptConfig.
     * @param {StoreReceiptConfigUpsertArgs} args - Arguments to update or create a StoreReceiptConfig.
     * @example
     * // Update or create a StoreReceiptConfig
     * const storeReceiptConfig = await prisma.storeReceiptConfig.upsert({
     *   create: {
     *     // ... data to create a StoreReceiptConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreReceiptConfig we want to update
     *   }
     * })
     */
    upsert<T extends StoreReceiptConfigUpsertArgs>(args: SelectSubset<T, StoreReceiptConfigUpsertArgs<ExtArgs>>): Prisma__StoreReceiptConfigClient<$Result.GetResult<Prisma.$StoreReceiptConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StoreReceiptConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreReceiptConfigCountArgs} args - Arguments to filter StoreReceiptConfigs to count.
     * @example
     * // Count the number of StoreReceiptConfigs
     * const count = await prisma.storeReceiptConfig.count({
     *   where: {
     *     // ... the filter for the StoreReceiptConfigs we want to count
     *   }
     * })
    **/
    count<T extends StoreReceiptConfigCountArgs>(
      args?: Subset<T, StoreReceiptConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreReceiptConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreReceiptConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreReceiptConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreReceiptConfigAggregateArgs>(args: Subset<T, StoreReceiptConfigAggregateArgs>): Prisma.PrismaPromise<GetStoreReceiptConfigAggregateType<T>>

    /**
     * Group by StoreReceiptConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreReceiptConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreReceiptConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreReceiptConfigGroupByArgs['orderBy'] }
        : { orderBy?: StoreReceiptConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreReceiptConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreReceiptConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreReceiptConfig model
   */
  readonly fields: StoreReceiptConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreReceiptConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreReceiptConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreReceiptConfig model
   */ 
  interface StoreReceiptConfigFieldRefs {
    readonly id: FieldRef<"StoreReceiptConfig", 'String'>
    readonly storeId: FieldRef<"StoreReceiptConfig", 'String'>
    readonly headerText: FieldRef<"StoreReceiptConfig", 'String'>
    readonly footerText: FieldRef<"StoreReceiptConfig", 'String'>
    readonly showLogo: FieldRef<"StoreReceiptConfig", 'Boolean'>
    readonly showTaxId: FieldRef<"StoreReceiptConfig", 'Boolean'>
    readonly showBarcode: FieldRef<"StoreReceiptConfig", 'Boolean'>
    readonly paperWidth: FieldRef<"StoreReceiptConfig", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StoreReceiptConfig findUnique
   */
  export type StoreReceiptConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreReceiptConfig
     */
    select?: StoreReceiptConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreReceiptConfigInclude<ExtArgs> | null
    /**
     * Filter, which StoreReceiptConfig to fetch.
     */
    where: StoreReceiptConfigWhereUniqueInput
  }

  /**
   * StoreReceiptConfig findUniqueOrThrow
   */
  export type StoreReceiptConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreReceiptConfig
     */
    select?: StoreReceiptConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreReceiptConfigInclude<ExtArgs> | null
    /**
     * Filter, which StoreReceiptConfig to fetch.
     */
    where: StoreReceiptConfigWhereUniqueInput
  }

  /**
   * StoreReceiptConfig findFirst
   */
  export type StoreReceiptConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreReceiptConfig
     */
    select?: StoreReceiptConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreReceiptConfigInclude<ExtArgs> | null
    /**
     * Filter, which StoreReceiptConfig to fetch.
     */
    where?: StoreReceiptConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreReceiptConfigs to fetch.
     */
    orderBy?: StoreReceiptConfigOrderByWithRelationInput | StoreReceiptConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreReceiptConfigs.
     */
    cursor?: StoreReceiptConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreReceiptConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreReceiptConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreReceiptConfigs.
     */
    distinct?: StoreReceiptConfigScalarFieldEnum | StoreReceiptConfigScalarFieldEnum[]
  }

  /**
   * StoreReceiptConfig findFirstOrThrow
   */
  export type StoreReceiptConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreReceiptConfig
     */
    select?: StoreReceiptConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreReceiptConfigInclude<ExtArgs> | null
    /**
     * Filter, which StoreReceiptConfig to fetch.
     */
    where?: StoreReceiptConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreReceiptConfigs to fetch.
     */
    orderBy?: StoreReceiptConfigOrderByWithRelationInput | StoreReceiptConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreReceiptConfigs.
     */
    cursor?: StoreReceiptConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreReceiptConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreReceiptConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreReceiptConfigs.
     */
    distinct?: StoreReceiptConfigScalarFieldEnum | StoreReceiptConfigScalarFieldEnum[]
  }

  /**
   * StoreReceiptConfig findMany
   */
  export type StoreReceiptConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreReceiptConfig
     */
    select?: StoreReceiptConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreReceiptConfigInclude<ExtArgs> | null
    /**
     * Filter, which StoreReceiptConfigs to fetch.
     */
    where?: StoreReceiptConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreReceiptConfigs to fetch.
     */
    orderBy?: StoreReceiptConfigOrderByWithRelationInput | StoreReceiptConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreReceiptConfigs.
     */
    cursor?: StoreReceiptConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreReceiptConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreReceiptConfigs.
     */
    skip?: number
    distinct?: StoreReceiptConfigScalarFieldEnum | StoreReceiptConfigScalarFieldEnum[]
  }

  /**
   * StoreReceiptConfig create
   */
  export type StoreReceiptConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreReceiptConfig
     */
    select?: StoreReceiptConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreReceiptConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a StoreReceiptConfig.
     */
    data: XOR<StoreReceiptConfigCreateInput, StoreReceiptConfigUncheckedCreateInput>
  }

  /**
   * StoreReceiptConfig createMany
   */
  export type StoreReceiptConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreReceiptConfigs.
     */
    data: StoreReceiptConfigCreateManyInput | StoreReceiptConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreReceiptConfig createManyAndReturn
   */
  export type StoreReceiptConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreReceiptConfig
     */
    select?: StoreReceiptConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StoreReceiptConfigs.
     */
    data: StoreReceiptConfigCreateManyInput | StoreReceiptConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreReceiptConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoreReceiptConfig update
   */
  export type StoreReceiptConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreReceiptConfig
     */
    select?: StoreReceiptConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreReceiptConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a StoreReceiptConfig.
     */
    data: XOR<StoreReceiptConfigUpdateInput, StoreReceiptConfigUncheckedUpdateInput>
    /**
     * Choose, which StoreReceiptConfig to update.
     */
    where: StoreReceiptConfigWhereUniqueInput
  }

  /**
   * StoreReceiptConfig updateMany
   */
  export type StoreReceiptConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreReceiptConfigs.
     */
    data: XOR<StoreReceiptConfigUpdateManyMutationInput, StoreReceiptConfigUncheckedUpdateManyInput>
    /**
     * Filter which StoreReceiptConfigs to update
     */
    where?: StoreReceiptConfigWhereInput
  }

  /**
   * StoreReceiptConfig upsert
   */
  export type StoreReceiptConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreReceiptConfig
     */
    select?: StoreReceiptConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreReceiptConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the StoreReceiptConfig to update in case it exists.
     */
    where: StoreReceiptConfigWhereUniqueInput
    /**
     * In case the StoreReceiptConfig found by the `where` argument doesn't exist, create a new StoreReceiptConfig with this data.
     */
    create: XOR<StoreReceiptConfigCreateInput, StoreReceiptConfigUncheckedCreateInput>
    /**
     * In case the StoreReceiptConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreReceiptConfigUpdateInput, StoreReceiptConfigUncheckedUpdateInput>
  }

  /**
   * StoreReceiptConfig delete
   */
  export type StoreReceiptConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreReceiptConfig
     */
    select?: StoreReceiptConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreReceiptConfigInclude<ExtArgs> | null
    /**
     * Filter which StoreReceiptConfig to delete.
     */
    where: StoreReceiptConfigWhereUniqueInput
  }

  /**
   * StoreReceiptConfig deleteMany
   */
  export type StoreReceiptConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreReceiptConfigs to delete
     */
    where?: StoreReceiptConfigWhereInput
  }

  /**
   * StoreReceiptConfig without action
   */
  export type StoreReceiptConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreReceiptConfig
     */
    select?: StoreReceiptConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreReceiptConfigInclude<ExtArgs> | null
  }


  /**
   * Model StoreDeviceConfig
   */

  export type AggregateStoreDeviceConfig = {
    _count: StoreDeviceConfigCountAggregateOutputType | null
    _min: StoreDeviceConfigMinAggregateOutputType | null
    _max: StoreDeviceConfigMaxAggregateOutputType | null
  }

  export type StoreDeviceConfigMinAggregateOutputType = {
    id: string | null
    storeId: string | null
    deviceType: $Enums.StoreDeviceType | null
    name: string | null
    connectionType: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreDeviceConfigMaxAggregateOutputType = {
    id: string | null
    storeId: string | null
    deviceType: $Enums.StoreDeviceType | null
    name: string | null
    connectionType: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreDeviceConfigCountAggregateOutputType = {
    id: number
    storeId: number
    deviceType: number
    name: number
    connectionType: number
    settings: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoreDeviceConfigMinAggregateInputType = {
    id?: true
    storeId?: true
    deviceType?: true
    name?: true
    connectionType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreDeviceConfigMaxAggregateInputType = {
    id?: true
    storeId?: true
    deviceType?: true
    name?: true
    connectionType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreDeviceConfigCountAggregateInputType = {
    id?: true
    storeId?: true
    deviceType?: true
    name?: true
    connectionType?: true
    settings?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoreDeviceConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreDeviceConfig to aggregate.
     */
    where?: StoreDeviceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreDeviceConfigs to fetch.
     */
    orderBy?: StoreDeviceConfigOrderByWithRelationInput | StoreDeviceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreDeviceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreDeviceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreDeviceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreDeviceConfigs
    **/
    _count?: true | StoreDeviceConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreDeviceConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreDeviceConfigMaxAggregateInputType
  }

  export type GetStoreDeviceConfigAggregateType<T extends StoreDeviceConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreDeviceConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreDeviceConfig[P]>
      : GetScalarType<T[P], AggregateStoreDeviceConfig[P]>
  }




  export type StoreDeviceConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreDeviceConfigWhereInput
    orderBy?: StoreDeviceConfigOrderByWithAggregationInput | StoreDeviceConfigOrderByWithAggregationInput[]
    by: StoreDeviceConfigScalarFieldEnum[] | StoreDeviceConfigScalarFieldEnum
    having?: StoreDeviceConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreDeviceConfigCountAggregateInputType | true
    _min?: StoreDeviceConfigMinAggregateInputType
    _max?: StoreDeviceConfigMaxAggregateInputType
  }

  export type StoreDeviceConfigGroupByOutputType = {
    id: string
    storeId: string
    deviceType: $Enums.StoreDeviceType
    name: string
    connectionType: string
    settings: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StoreDeviceConfigCountAggregateOutputType | null
    _min: StoreDeviceConfigMinAggregateOutputType | null
    _max: StoreDeviceConfigMaxAggregateOutputType | null
  }

  type GetStoreDeviceConfigGroupByPayload<T extends StoreDeviceConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreDeviceConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreDeviceConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreDeviceConfigGroupByOutputType[P]>
            : GetScalarType<T[P], StoreDeviceConfigGroupByOutputType[P]>
        }
      >
    >


  export type StoreDeviceConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    deviceType?: boolean
    name?: boolean
    connectionType?: boolean
    settings?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeDeviceConfig"]>

  export type StoreDeviceConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    deviceType?: boolean
    name?: boolean
    connectionType?: boolean
    settings?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeDeviceConfig"]>

  export type StoreDeviceConfigSelectScalar = {
    id?: boolean
    storeId?: boolean
    deviceType?: boolean
    name?: boolean
    connectionType?: boolean
    settings?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoreDeviceConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }
  export type StoreDeviceConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $StoreDeviceConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreDeviceConfig"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeId: string
      deviceType: $Enums.StoreDeviceType
      name: string
      connectionType: string
      settings: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storeDeviceConfig"]>
    composites: {}
  }

  type StoreDeviceConfigGetPayload<S extends boolean | null | undefined | StoreDeviceConfigDefaultArgs> = $Result.GetResult<Prisma.$StoreDeviceConfigPayload, S>

  type StoreDeviceConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoreDeviceConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoreDeviceConfigCountAggregateInputType | true
    }

  export interface StoreDeviceConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreDeviceConfig'], meta: { name: 'StoreDeviceConfig' } }
    /**
     * Find zero or one StoreDeviceConfig that matches the filter.
     * @param {StoreDeviceConfigFindUniqueArgs} args - Arguments to find a StoreDeviceConfig
     * @example
     * // Get one StoreDeviceConfig
     * const storeDeviceConfig = await prisma.storeDeviceConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreDeviceConfigFindUniqueArgs>(args: SelectSubset<T, StoreDeviceConfigFindUniqueArgs<ExtArgs>>): Prisma__StoreDeviceConfigClient<$Result.GetResult<Prisma.$StoreDeviceConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StoreDeviceConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoreDeviceConfigFindUniqueOrThrowArgs} args - Arguments to find a StoreDeviceConfig
     * @example
     * // Get one StoreDeviceConfig
     * const storeDeviceConfig = await prisma.storeDeviceConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreDeviceConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreDeviceConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreDeviceConfigClient<$Result.GetResult<Prisma.$StoreDeviceConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StoreDeviceConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreDeviceConfigFindFirstArgs} args - Arguments to find a StoreDeviceConfig
     * @example
     * // Get one StoreDeviceConfig
     * const storeDeviceConfig = await prisma.storeDeviceConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreDeviceConfigFindFirstArgs>(args?: SelectSubset<T, StoreDeviceConfigFindFirstArgs<ExtArgs>>): Prisma__StoreDeviceConfigClient<$Result.GetResult<Prisma.$StoreDeviceConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StoreDeviceConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreDeviceConfigFindFirstOrThrowArgs} args - Arguments to find a StoreDeviceConfig
     * @example
     * // Get one StoreDeviceConfig
     * const storeDeviceConfig = await prisma.storeDeviceConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreDeviceConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreDeviceConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreDeviceConfigClient<$Result.GetResult<Prisma.$StoreDeviceConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StoreDeviceConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreDeviceConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreDeviceConfigs
     * const storeDeviceConfigs = await prisma.storeDeviceConfig.findMany()
     * 
     * // Get first 10 StoreDeviceConfigs
     * const storeDeviceConfigs = await prisma.storeDeviceConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeDeviceConfigWithIdOnly = await prisma.storeDeviceConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreDeviceConfigFindManyArgs>(args?: SelectSubset<T, StoreDeviceConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreDeviceConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StoreDeviceConfig.
     * @param {StoreDeviceConfigCreateArgs} args - Arguments to create a StoreDeviceConfig.
     * @example
     * // Create one StoreDeviceConfig
     * const StoreDeviceConfig = await prisma.storeDeviceConfig.create({
     *   data: {
     *     // ... data to create a StoreDeviceConfig
     *   }
     * })
     * 
     */
    create<T extends StoreDeviceConfigCreateArgs>(args: SelectSubset<T, StoreDeviceConfigCreateArgs<ExtArgs>>): Prisma__StoreDeviceConfigClient<$Result.GetResult<Prisma.$StoreDeviceConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StoreDeviceConfigs.
     * @param {StoreDeviceConfigCreateManyArgs} args - Arguments to create many StoreDeviceConfigs.
     * @example
     * // Create many StoreDeviceConfigs
     * const storeDeviceConfig = await prisma.storeDeviceConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreDeviceConfigCreateManyArgs>(args?: SelectSubset<T, StoreDeviceConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoreDeviceConfigs and returns the data saved in the database.
     * @param {StoreDeviceConfigCreateManyAndReturnArgs} args - Arguments to create many StoreDeviceConfigs.
     * @example
     * // Create many StoreDeviceConfigs
     * const storeDeviceConfig = await prisma.storeDeviceConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoreDeviceConfigs and only return the `id`
     * const storeDeviceConfigWithIdOnly = await prisma.storeDeviceConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreDeviceConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreDeviceConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreDeviceConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StoreDeviceConfig.
     * @param {StoreDeviceConfigDeleteArgs} args - Arguments to delete one StoreDeviceConfig.
     * @example
     * // Delete one StoreDeviceConfig
     * const StoreDeviceConfig = await prisma.storeDeviceConfig.delete({
     *   where: {
     *     // ... filter to delete one StoreDeviceConfig
     *   }
     * })
     * 
     */
    delete<T extends StoreDeviceConfigDeleteArgs>(args: SelectSubset<T, StoreDeviceConfigDeleteArgs<ExtArgs>>): Prisma__StoreDeviceConfigClient<$Result.GetResult<Prisma.$StoreDeviceConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StoreDeviceConfig.
     * @param {StoreDeviceConfigUpdateArgs} args - Arguments to update one StoreDeviceConfig.
     * @example
     * // Update one StoreDeviceConfig
     * const storeDeviceConfig = await prisma.storeDeviceConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreDeviceConfigUpdateArgs>(args: SelectSubset<T, StoreDeviceConfigUpdateArgs<ExtArgs>>): Prisma__StoreDeviceConfigClient<$Result.GetResult<Prisma.$StoreDeviceConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StoreDeviceConfigs.
     * @param {StoreDeviceConfigDeleteManyArgs} args - Arguments to filter StoreDeviceConfigs to delete.
     * @example
     * // Delete a few StoreDeviceConfigs
     * const { count } = await prisma.storeDeviceConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreDeviceConfigDeleteManyArgs>(args?: SelectSubset<T, StoreDeviceConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreDeviceConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreDeviceConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreDeviceConfigs
     * const storeDeviceConfig = await prisma.storeDeviceConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreDeviceConfigUpdateManyArgs>(args: SelectSubset<T, StoreDeviceConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoreDeviceConfig.
     * @param {StoreDeviceConfigUpsertArgs} args - Arguments to update or create a StoreDeviceConfig.
     * @example
     * // Update or create a StoreDeviceConfig
     * const storeDeviceConfig = await prisma.storeDeviceConfig.upsert({
     *   create: {
     *     // ... data to create a StoreDeviceConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreDeviceConfig we want to update
     *   }
     * })
     */
    upsert<T extends StoreDeviceConfigUpsertArgs>(args: SelectSubset<T, StoreDeviceConfigUpsertArgs<ExtArgs>>): Prisma__StoreDeviceConfigClient<$Result.GetResult<Prisma.$StoreDeviceConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StoreDeviceConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreDeviceConfigCountArgs} args - Arguments to filter StoreDeviceConfigs to count.
     * @example
     * // Count the number of StoreDeviceConfigs
     * const count = await prisma.storeDeviceConfig.count({
     *   where: {
     *     // ... the filter for the StoreDeviceConfigs we want to count
     *   }
     * })
    **/
    count<T extends StoreDeviceConfigCountArgs>(
      args?: Subset<T, StoreDeviceConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreDeviceConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreDeviceConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreDeviceConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreDeviceConfigAggregateArgs>(args: Subset<T, StoreDeviceConfigAggregateArgs>): Prisma.PrismaPromise<GetStoreDeviceConfigAggregateType<T>>

    /**
     * Group by StoreDeviceConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreDeviceConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreDeviceConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreDeviceConfigGroupByArgs['orderBy'] }
        : { orderBy?: StoreDeviceConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreDeviceConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreDeviceConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreDeviceConfig model
   */
  readonly fields: StoreDeviceConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreDeviceConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreDeviceConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreDeviceConfig model
   */ 
  interface StoreDeviceConfigFieldRefs {
    readonly id: FieldRef<"StoreDeviceConfig", 'String'>
    readonly storeId: FieldRef<"StoreDeviceConfig", 'String'>
    readonly deviceType: FieldRef<"StoreDeviceConfig", 'StoreDeviceType'>
    readonly name: FieldRef<"StoreDeviceConfig", 'String'>
    readonly connectionType: FieldRef<"StoreDeviceConfig", 'String'>
    readonly settings: FieldRef<"StoreDeviceConfig", 'Json'>
    readonly isActive: FieldRef<"StoreDeviceConfig", 'Boolean'>
    readonly createdAt: FieldRef<"StoreDeviceConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"StoreDeviceConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoreDeviceConfig findUnique
   */
  export type StoreDeviceConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreDeviceConfig
     */
    select?: StoreDeviceConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreDeviceConfigInclude<ExtArgs> | null
    /**
     * Filter, which StoreDeviceConfig to fetch.
     */
    where: StoreDeviceConfigWhereUniqueInput
  }

  /**
   * StoreDeviceConfig findUniqueOrThrow
   */
  export type StoreDeviceConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreDeviceConfig
     */
    select?: StoreDeviceConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreDeviceConfigInclude<ExtArgs> | null
    /**
     * Filter, which StoreDeviceConfig to fetch.
     */
    where: StoreDeviceConfigWhereUniqueInput
  }

  /**
   * StoreDeviceConfig findFirst
   */
  export type StoreDeviceConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreDeviceConfig
     */
    select?: StoreDeviceConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreDeviceConfigInclude<ExtArgs> | null
    /**
     * Filter, which StoreDeviceConfig to fetch.
     */
    where?: StoreDeviceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreDeviceConfigs to fetch.
     */
    orderBy?: StoreDeviceConfigOrderByWithRelationInput | StoreDeviceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreDeviceConfigs.
     */
    cursor?: StoreDeviceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreDeviceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreDeviceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreDeviceConfigs.
     */
    distinct?: StoreDeviceConfigScalarFieldEnum | StoreDeviceConfigScalarFieldEnum[]
  }

  /**
   * StoreDeviceConfig findFirstOrThrow
   */
  export type StoreDeviceConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreDeviceConfig
     */
    select?: StoreDeviceConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreDeviceConfigInclude<ExtArgs> | null
    /**
     * Filter, which StoreDeviceConfig to fetch.
     */
    where?: StoreDeviceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreDeviceConfigs to fetch.
     */
    orderBy?: StoreDeviceConfigOrderByWithRelationInput | StoreDeviceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreDeviceConfigs.
     */
    cursor?: StoreDeviceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreDeviceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreDeviceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreDeviceConfigs.
     */
    distinct?: StoreDeviceConfigScalarFieldEnum | StoreDeviceConfigScalarFieldEnum[]
  }

  /**
   * StoreDeviceConfig findMany
   */
  export type StoreDeviceConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreDeviceConfig
     */
    select?: StoreDeviceConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreDeviceConfigInclude<ExtArgs> | null
    /**
     * Filter, which StoreDeviceConfigs to fetch.
     */
    where?: StoreDeviceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreDeviceConfigs to fetch.
     */
    orderBy?: StoreDeviceConfigOrderByWithRelationInput | StoreDeviceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreDeviceConfigs.
     */
    cursor?: StoreDeviceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreDeviceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreDeviceConfigs.
     */
    skip?: number
    distinct?: StoreDeviceConfigScalarFieldEnum | StoreDeviceConfigScalarFieldEnum[]
  }

  /**
   * StoreDeviceConfig create
   */
  export type StoreDeviceConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreDeviceConfig
     */
    select?: StoreDeviceConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreDeviceConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a StoreDeviceConfig.
     */
    data: XOR<StoreDeviceConfigCreateInput, StoreDeviceConfigUncheckedCreateInput>
  }

  /**
   * StoreDeviceConfig createMany
   */
  export type StoreDeviceConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreDeviceConfigs.
     */
    data: StoreDeviceConfigCreateManyInput | StoreDeviceConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreDeviceConfig createManyAndReturn
   */
  export type StoreDeviceConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreDeviceConfig
     */
    select?: StoreDeviceConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StoreDeviceConfigs.
     */
    data: StoreDeviceConfigCreateManyInput | StoreDeviceConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreDeviceConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoreDeviceConfig update
   */
  export type StoreDeviceConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreDeviceConfig
     */
    select?: StoreDeviceConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreDeviceConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a StoreDeviceConfig.
     */
    data: XOR<StoreDeviceConfigUpdateInput, StoreDeviceConfigUncheckedUpdateInput>
    /**
     * Choose, which StoreDeviceConfig to update.
     */
    where: StoreDeviceConfigWhereUniqueInput
  }

  /**
   * StoreDeviceConfig updateMany
   */
  export type StoreDeviceConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreDeviceConfigs.
     */
    data: XOR<StoreDeviceConfigUpdateManyMutationInput, StoreDeviceConfigUncheckedUpdateManyInput>
    /**
     * Filter which StoreDeviceConfigs to update
     */
    where?: StoreDeviceConfigWhereInput
  }

  /**
   * StoreDeviceConfig upsert
   */
  export type StoreDeviceConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreDeviceConfig
     */
    select?: StoreDeviceConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreDeviceConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the StoreDeviceConfig to update in case it exists.
     */
    where: StoreDeviceConfigWhereUniqueInput
    /**
     * In case the StoreDeviceConfig found by the `where` argument doesn't exist, create a new StoreDeviceConfig with this data.
     */
    create: XOR<StoreDeviceConfigCreateInput, StoreDeviceConfigUncheckedCreateInput>
    /**
     * In case the StoreDeviceConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreDeviceConfigUpdateInput, StoreDeviceConfigUncheckedUpdateInput>
  }

  /**
   * StoreDeviceConfig delete
   */
  export type StoreDeviceConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreDeviceConfig
     */
    select?: StoreDeviceConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreDeviceConfigInclude<ExtArgs> | null
    /**
     * Filter which StoreDeviceConfig to delete.
     */
    where: StoreDeviceConfigWhereUniqueInput
  }

  /**
   * StoreDeviceConfig deleteMany
   */
  export type StoreDeviceConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreDeviceConfigs to delete
     */
    where?: StoreDeviceConfigWhereInput
  }

  /**
   * StoreDeviceConfig without action
   */
  export type StoreDeviceConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreDeviceConfig
     */
    select?: StoreDeviceConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreDeviceConfigInclude<ExtArgs> | null
  }


  /**
   * Model StoreIntegration
   */

  export type AggregateStoreIntegration = {
    _count: StoreIntegrationCountAggregateOutputType | null
    _min: StoreIntegrationMinAggregateOutputType | null
    _max: StoreIntegrationMaxAggregateOutputType | null
  }

  export type StoreIntegrationMinAggregateOutputType = {
    id: string | null
    storeId: string | null
    type: $Enums.StoreIntegrationType | null
    name: string | null
    lastSyncAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreIntegrationMaxAggregateOutputType = {
    id: string | null
    storeId: string | null
    type: $Enums.StoreIntegrationType | null
    name: string | null
    lastSyncAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreIntegrationCountAggregateOutputType = {
    id: number
    storeId: number
    type: number
    name: number
    credentials: number
    settings: number
    lastSyncAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoreIntegrationMinAggregateInputType = {
    id?: true
    storeId?: true
    type?: true
    name?: true
    lastSyncAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreIntegrationMaxAggregateInputType = {
    id?: true
    storeId?: true
    type?: true
    name?: true
    lastSyncAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreIntegrationCountAggregateInputType = {
    id?: true
    storeId?: true
    type?: true
    name?: true
    credentials?: true
    settings?: true
    lastSyncAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoreIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreIntegration to aggregate.
     */
    where?: StoreIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreIntegrations to fetch.
     */
    orderBy?: StoreIntegrationOrderByWithRelationInput | StoreIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreIntegrations
    **/
    _count?: true | StoreIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreIntegrationMaxAggregateInputType
  }

  export type GetStoreIntegrationAggregateType<T extends StoreIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreIntegration[P]>
      : GetScalarType<T[P], AggregateStoreIntegration[P]>
  }




  export type StoreIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreIntegrationWhereInput
    orderBy?: StoreIntegrationOrderByWithAggregationInput | StoreIntegrationOrderByWithAggregationInput[]
    by: StoreIntegrationScalarFieldEnum[] | StoreIntegrationScalarFieldEnum
    having?: StoreIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreIntegrationCountAggregateInputType | true
    _min?: StoreIntegrationMinAggregateInputType
    _max?: StoreIntegrationMaxAggregateInputType
  }

  export type StoreIntegrationGroupByOutputType = {
    id: string
    storeId: string
    type: $Enums.StoreIntegrationType
    name: string
    credentials: JsonValue | null
    settings: JsonValue | null
    lastSyncAt: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StoreIntegrationCountAggregateOutputType | null
    _min: StoreIntegrationMinAggregateOutputType | null
    _max: StoreIntegrationMaxAggregateOutputType | null
  }

  type GetStoreIntegrationGroupByPayload<T extends StoreIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], StoreIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type StoreIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    type?: boolean
    name?: boolean
    credentials?: boolean
    settings?: boolean
    lastSyncAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeIntegration"]>

  export type StoreIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    type?: boolean
    name?: boolean
    credentials?: boolean
    settings?: boolean
    lastSyncAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeIntegration"]>

  export type StoreIntegrationSelectScalar = {
    id?: boolean
    storeId?: boolean
    type?: boolean
    name?: boolean
    credentials?: boolean
    settings?: boolean
    lastSyncAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoreIntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }
  export type StoreIntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $StoreIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreIntegration"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeId: string
      type: $Enums.StoreIntegrationType
      name: string
      credentials: Prisma.JsonValue | null
      settings: Prisma.JsonValue | null
      lastSyncAt: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storeIntegration"]>
    composites: {}
  }

  type StoreIntegrationGetPayload<S extends boolean | null | undefined | StoreIntegrationDefaultArgs> = $Result.GetResult<Prisma.$StoreIntegrationPayload, S>

  type StoreIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoreIntegrationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoreIntegrationCountAggregateInputType | true
    }

  export interface StoreIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreIntegration'], meta: { name: 'StoreIntegration' } }
    /**
     * Find zero or one StoreIntegration that matches the filter.
     * @param {StoreIntegrationFindUniqueArgs} args - Arguments to find a StoreIntegration
     * @example
     * // Get one StoreIntegration
     * const storeIntegration = await prisma.storeIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreIntegrationFindUniqueArgs>(args: SelectSubset<T, StoreIntegrationFindUniqueArgs<ExtArgs>>): Prisma__StoreIntegrationClient<$Result.GetResult<Prisma.$StoreIntegrationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StoreIntegration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoreIntegrationFindUniqueOrThrowArgs} args - Arguments to find a StoreIntegration
     * @example
     * // Get one StoreIntegration
     * const storeIntegration = await prisma.storeIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreIntegrationClient<$Result.GetResult<Prisma.$StoreIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StoreIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreIntegrationFindFirstArgs} args - Arguments to find a StoreIntegration
     * @example
     * // Get one StoreIntegration
     * const storeIntegration = await prisma.storeIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreIntegrationFindFirstArgs>(args?: SelectSubset<T, StoreIntegrationFindFirstArgs<ExtArgs>>): Prisma__StoreIntegrationClient<$Result.GetResult<Prisma.$StoreIntegrationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StoreIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreIntegrationFindFirstOrThrowArgs} args - Arguments to find a StoreIntegration
     * @example
     * // Get one StoreIntegration
     * const storeIntegration = await prisma.storeIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreIntegrationClient<$Result.GetResult<Prisma.$StoreIntegrationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StoreIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreIntegrations
     * const storeIntegrations = await prisma.storeIntegration.findMany()
     * 
     * // Get first 10 StoreIntegrations
     * const storeIntegrations = await prisma.storeIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeIntegrationWithIdOnly = await prisma.storeIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreIntegrationFindManyArgs>(args?: SelectSubset<T, StoreIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreIntegrationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StoreIntegration.
     * @param {StoreIntegrationCreateArgs} args - Arguments to create a StoreIntegration.
     * @example
     * // Create one StoreIntegration
     * const StoreIntegration = await prisma.storeIntegration.create({
     *   data: {
     *     // ... data to create a StoreIntegration
     *   }
     * })
     * 
     */
    create<T extends StoreIntegrationCreateArgs>(args: SelectSubset<T, StoreIntegrationCreateArgs<ExtArgs>>): Prisma__StoreIntegrationClient<$Result.GetResult<Prisma.$StoreIntegrationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StoreIntegrations.
     * @param {StoreIntegrationCreateManyArgs} args - Arguments to create many StoreIntegrations.
     * @example
     * // Create many StoreIntegrations
     * const storeIntegration = await prisma.storeIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreIntegrationCreateManyArgs>(args?: SelectSubset<T, StoreIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoreIntegrations and returns the data saved in the database.
     * @param {StoreIntegrationCreateManyAndReturnArgs} args - Arguments to create many StoreIntegrations.
     * @example
     * // Create many StoreIntegrations
     * const storeIntegration = await prisma.storeIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoreIntegrations and only return the `id`
     * const storeIntegrationWithIdOnly = await prisma.storeIntegration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreIntegrationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StoreIntegration.
     * @param {StoreIntegrationDeleteArgs} args - Arguments to delete one StoreIntegration.
     * @example
     * // Delete one StoreIntegration
     * const StoreIntegration = await prisma.storeIntegration.delete({
     *   where: {
     *     // ... filter to delete one StoreIntegration
     *   }
     * })
     * 
     */
    delete<T extends StoreIntegrationDeleteArgs>(args: SelectSubset<T, StoreIntegrationDeleteArgs<ExtArgs>>): Prisma__StoreIntegrationClient<$Result.GetResult<Prisma.$StoreIntegrationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StoreIntegration.
     * @param {StoreIntegrationUpdateArgs} args - Arguments to update one StoreIntegration.
     * @example
     * // Update one StoreIntegration
     * const storeIntegration = await prisma.storeIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreIntegrationUpdateArgs>(args: SelectSubset<T, StoreIntegrationUpdateArgs<ExtArgs>>): Prisma__StoreIntegrationClient<$Result.GetResult<Prisma.$StoreIntegrationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StoreIntegrations.
     * @param {StoreIntegrationDeleteManyArgs} args - Arguments to filter StoreIntegrations to delete.
     * @example
     * // Delete a few StoreIntegrations
     * const { count } = await prisma.storeIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreIntegrationDeleteManyArgs>(args?: SelectSubset<T, StoreIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreIntegrations
     * const storeIntegration = await prisma.storeIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreIntegrationUpdateManyArgs>(args: SelectSubset<T, StoreIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoreIntegration.
     * @param {StoreIntegrationUpsertArgs} args - Arguments to update or create a StoreIntegration.
     * @example
     * // Update or create a StoreIntegration
     * const storeIntegration = await prisma.storeIntegration.upsert({
     *   create: {
     *     // ... data to create a StoreIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreIntegration we want to update
     *   }
     * })
     */
    upsert<T extends StoreIntegrationUpsertArgs>(args: SelectSubset<T, StoreIntegrationUpsertArgs<ExtArgs>>): Prisma__StoreIntegrationClient<$Result.GetResult<Prisma.$StoreIntegrationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StoreIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreIntegrationCountArgs} args - Arguments to filter StoreIntegrations to count.
     * @example
     * // Count the number of StoreIntegrations
     * const count = await prisma.storeIntegration.count({
     *   where: {
     *     // ... the filter for the StoreIntegrations we want to count
     *   }
     * })
    **/
    count<T extends StoreIntegrationCountArgs>(
      args?: Subset<T, StoreIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreIntegrationAggregateArgs>(args: Subset<T, StoreIntegrationAggregateArgs>): Prisma.PrismaPromise<GetStoreIntegrationAggregateType<T>>

    /**
     * Group by StoreIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: StoreIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreIntegration model
   */
  readonly fields: StoreIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreIntegration model
   */ 
  interface StoreIntegrationFieldRefs {
    readonly id: FieldRef<"StoreIntegration", 'String'>
    readonly storeId: FieldRef<"StoreIntegration", 'String'>
    readonly type: FieldRef<"StoreIntegration", 'StoreIntegrationType'>
    readonly name: FieldRef<"StoreIntegration", 'String'>
    readonly credentials: FieldRef<"StoreIntegration", 'Json'>
    readonly settings: FieldRef<"StoreIntegration", 'Json'>
    readonly lastSyncAt: FieldRef<"StoreIntegration", 'DateTime'>
    readonly isActive: FieldRef<"StoreIntegration", 'Boolean'>
    readonly createdAt: FieldRef<"StoreIntegration", 'DateTime'>
    readonly updatedAt: FieldRef<"StoreIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoreIntegration findUnique
   */
  export type StoreIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreIntegration
     */
    select?: StoreIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which StoreIntegration to fetch.
     */
    where: StoreIntegrationWhereUniqueInput
  }

  /**
   * StoreIntegration findUniqueOrThrow
   */
  export type StoreIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreIntegration
     */
    select?: StoreIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which StoreIntegration to fetch.
     */
    where: StoreIntegrationWhereUniqueInput
  }

  /**
   * StoreIntegration findFirst
   */
  export type StoreIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreIntegration
     */
    select?: StoreIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which StoreIntegration to fetch.
     */
    where?: StoreIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreIntegrations to fetch.
     */
    orderBy?: StoreIntegrationOrderByWithRelationInput | StoreIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreIntegrations.
     */
    cursor?: StoreIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreIntegrations.
     */
    distinct?: StoreIntegrationScalarFieldEnum | StoreIntegrationScalarFieldEnum[]
  }

  /**
   * StoreIntegration findFirstOrThrow
   */
  export type StoreIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreIntegration
     */
    select?: StoreIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which StoreIntegration to fetch.
     */
    where?: StoreIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreIntegrations to fetch.
     */
    orderBy?: StoreIntegrationOrderByWithRelationInput | StoreIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreIntegrations.
     */
    cursor?: StoreIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreIntegrations.
     */
    distinct?: StoreIntegrationScalarFieldEnum | StoreIntegrationScalarFieldEnum[]
  }

  /**
   * StoreIntegration findMany
   */
  export type StoreIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreIntegration
     */
    select?: StoreIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which StoreIntegrations to fetch.
     */
    where?: StoreIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreIntegrations to fetch.
     */
    orderBy?: StoreIntegrationOrderByWithRelationInput | StoreIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreIntegrations.
     */
    cursor?: StoreIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreIntegrations.
     */
    skip?: number
    distinct?: StoreIntegrationScalarFieldEnum | StoreIntegrationScalarFieldEnum[]
  }

  /**
   * StoreIntegration create
   */
  export type StoreIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreIntegration
     */
    select?: StoreIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a StoreIntegration.
     */
    data: XOR<StoreIntegrationCreateInput, StoreIntegrationUncheckedCreateInput>
  }

  /**
   * StoreIntegration createMany
   */
  export type StoreIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreIntegrations.
     */
    data: StoreIntegrationCreateManyInput | StoreIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreIntegration createManyAndReturn
   */
  export type StoreIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreIntegration
     */
    select?: StoreIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StoreIntegrations.
     */
    data: StoreIntegrationCreateManyInput | StoreIntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreIntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoreIntegration update
   */
  export type StoreIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreIntegration
     */
    select?: StoreIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a StoreIntegration.
     */
    data: XOR<StoreIntegrationUpdateInput, StoreIntegrationUncheckedUpdateInput>
    /**
     * Choose, which StoreIntegration to update.
     */
    where: StoreIntegrationWhereUniqueInput
  }

  /**
   * StoreIntegration updateMany
   */
  export type StoreIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreIntegrations.
     */
    data: XOR<StoreIntegrationUpdateManyMutationInput, StoreIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which StoreIntegrations to update
     */
    where?: StoreIntegrationWhereInput
  }

  /**
   * StoreIntegration upsert
   */
  export type StoreIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreIntegration
     */
    select?: StoreIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreIntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the StoreIntegration to update in case it exists.
     */
    where: StoreIntegrationWhereUniqueInput
    /**
     * In case the StoreIntegration found by the `where` argument doesn't exist, create a new StoreIntegration with this data.
     */
    create: XOR<StoreIntegrationCreateInput, StoreIntegrationUncheckedCreateInput>
    /**
     * In case the StoreIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreIntegrationUpdateInput, StoreIntegrationUncheckedUpdateInput>
  }

  /**
   * StoreIntegration delete
   */
  export type StoreIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreIntegration
     */
    select?: StoreIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreIntegrationInclude<ExtArgs> | null
    /**
     * Filter which StoreIntegration to delete.
     */
    where: StoreIntegrationWhereUniqueInput
  }

  /**
   * StoreIntegration deleteMany
   */
  export type StoreIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreIntegrations to delete
     */
    where?: StoreIntegrationWhereInput
  }

  /**
   * StoreIntegration without action
   */
  export type StoreIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreIntegration
     */
    select?: StoreIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreIntegrationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    email: 'email',
    phone: 'phone',
    address: 'address',
    logo: 'logo',
    company: 'company',
    taxId: 'taxId',
    city: 'city',
    country: 'country',
    website: 'website',
    bankName: 'bankName',
    bankAccount: 'bankAccount',
    tenantId: 'tenantId',
    hotelCode: 'hotelCode',
    storeCode: 'storeCode',
    databaseUrl: 'databaseUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    avatar: 'avatar',
    emailVerified: 'emailVerified',
    lastLoginAt: 'lastLoginAt',
    organizationId: 'organizationId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const StoreScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    slug: 'slug',
    address: 'address',
    phone: 'phone',
    email: 'email',
    taxId: 'taxId',
    currency: 'currency',
    timezone: 'timezone',
    logoUrl: 'logoUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoreScalarFieldEnum = (typeof StoreScalarFieldEnum)[keyof typeof StoreScalarFieldEnum]


  export const StoreEmployeeScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    email: 'email',
    role: 'role',
    pin: 'pin',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoreEmployeeScalarFieldEnum = (typeof StoreEmployeeScalarFieldEnum)[keyof typeof StoreEmployeeScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    name: 'name',
    nameKa: 'nameKa',
    slug: 'slug',
    description: 'description',
    color: 'color',
    icon: 'icon',
    sortOrder: 'sortOrder',
    parentId: 'parentId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const StoreProductScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    categoryId: 'categoryId',
    sku: 'sku',
    barcode: 'barcode',
    name: 'name',
    nameKa: 'nameKa',
    description: 'description',
    imageUrl: 'imageUrl',
    costPrice: 'costPrice',
    sellingPrice: 'sellingPrice',
    wholesalePrice: 'wholesalePrice',
    currentStock: 'currentStock',
    minStock: 'minStock',
    maxStock: 'maxStock',
    unit: 'unit',
    taxRuleId: 'taxRuleId',
    isActive: 'isActive',
    isFavorite: 'isFavorite',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoreProductScalarFieldEnum = (typeof StoreProductScalarFieldEnum)[keyof typeof StoreProductScalarFieldEnum]


  export const StorePriceHistoryScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    costPrice: 'costPrice',
    sellingPrice: 'sellingPrice',
    changedBy: 'changedBy',
    changedAt: 'changedAt'
  };

  export type StorePriceHistoryScalarFieldEnum = (typeof StorePriceHistoryScalarFieldEnum)[keyof typeof StorePriceHistoryScalarFieldEnum]


  export const SaleScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    saleNumber: 'saleNumber',
    customerId: 'customerId',
    employeeId: 'employeeId',
    subtotal: 'subtotal',
    taxAmount: 'taxAmount',
    discountAmount: 'discountAmount',
    discountType: 'discountType',
    total: 'total',
    paidAmount: 'paidAmount',
    changeAmount: 'changeAmount',
    status: 'status',
    notes: 'notes',
    receiptPrinted: 'receiptPrinted',
    fiscalPrinted: 'fiscalPrinted',
    fiscalNumber: 'fiscalNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SaleScalarFieldEnum = (typeof SaleScalarFieldEnum)[keyof typeof SaleScalarFieldEnum]


  export const SaleItemScalarFieldEnum: {
    id: 'id',
    saleId: 'saleId',
    productId: 'productId',
    productName: 'productName',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    costPrice: 'costPrice',
    discount: 'discount',
    taxAmount: 'taxAmount',
    total: 'total'
  };

  export type SaleItemScalarFieldEnum = (typeof SaleItemScalarFieldEnum)[keyof typeof SaleItemScalarFieldEnum]


  export const SalePaymentScalarFieldEnum: {
    id: 'id',
    saleId: 'saleId',
    method: 'method',
    amount: 'amount',
    reference: 'reference',
    createdAt: 'createdAt'
  };

  export type SalePaymentScalarFieldEnum = (typeof SalePaymentScalarFieldEnum)[keyof typeof SalePaymentScalarFieldEnum]


  export const SaleReturnScalarFieldEnum: {
    id: 'id',
    saleId: 'saleId',
    reason: 'reason',
    refundAmount: 'refundAmount',
    refundMethod: 'refundMethod',
    status: 'status',
    createdAt: 'createdAt',
    processedAt: 'processedAt'
  };

  export type SaleReturnScalarFieldEnum = (typeof SaleReturnScalarFieldEnum)[keyof typeof SaleReturnScalarFieldEnum]


  export const SaleReturnItemScalarFieldEnum: {
    id: 'id',
    returnId: 'returnId',
    productId: 'productId',
    quantity: 'quantity',
    refundAmount: 'refundAmount'
  };

  export type SaleReturnItemScalarFieldEnum = (typeof SaleReturnItemScalarFieldEnum)[keyof typeof SaleReturnItemScalarFieldEnum]


  export const StoreSupplierScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    name: 'name',
    contactPerson: 'contactPerson',
    phone: 'phone',
    email: 'email',
    address: 'address',
    taxId: 'taxId',
    bankAccount: 'bankAccount',
    notes: 'notes',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoreSupplierScalarFieldEnum = (typeof StoreSupplierScalarFieldEnum)[keyof typeof StoreSupplierScalarFieldEnum]


  export const StorePurchaseOrderScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    supplierId: 'supplierId',
    orderNumber: 'orderNumber',
    subtotal: 'subtotal',
    taxAmount: 'taxAmount',
    total: 'total',
    status: 'status',
    notes: 'notes',
    expectedDate: 'expectedDate',
    receivedDate: 'receivedDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StorePurchaseOrderScalarFieldEnum = (typeof StorePurchaseOrderScalarFieldEnum)[keyof typeof StorePurchaseOrderScalarFieldEnum]


  export const StorePurchaseItemScalarFieldEnum: {
    id: 'id',
    purchaseOrderId: 'purchaseOrderId',
    productId: 'productId',
    quantity: 'quantity',
    unitCost: 'unitCost',
    receivedQty: 'receivedQty',
    total: 'total'
  };

  export type StorePurchaseItemScalarFieldEnum = (typeof StorePurchaseItemScalarFieldEnum)[keyof typeof StorePurchaseItemScalarFieldEnum]


  export const StockMovementScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    productId: 'productId',
    type: 'type',
    quantity: 'quantity',
    previousStock: 'previousStock',
    newStock: 'newStock',
    reason: 'reason',
    referenceType: 'referenceType',
    referenceId: 'referenceId',
    performedBy: 'performedBy',
    createdAt: 'createdAt'
  };

  export type StockMovementScalarFieldEnum = (typeof StockMovementScalarFieldEnum)[keyof typeof StockMovementScalarFieldEnum]


  export const TransferOrderScalarFieldEnum: {
    id: 'id',
    fromStoreId: 'fromStoreId',
    toStoreId: 'toStoreId',
    transferNumber: 'transferNumber',
    status: 'status',
    notes: 'notes',
    sentAt: 'sentAt',
    receivedAt: 'receivedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransferOrderScalarFieldEnum = (typeof TransferOrderScalarFieldEnum)[keyof typeof TransferOrderScalarFieldEnum]


  export const TransferOrderItemScalarFieldEnum: {
    id: 'id',
    transferOrderId: 'transferOrderId',
    productId: 'productId',
    quantity: 'quantity',
    unitCost: 'unitCost'
  };

  export type TransferOrderItemScalarFieldEnum = (typeof TransferOrderItemScalarFieldEnum)[keyof typeof TransferOrderItemScalarFieldEnum]


  export const StoreCustomerScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    email: 'email',
    address: 'address',
    taxId: 'taxId',
    notes: 'notes',
    totalPurchases: 'totalPurchases',
    loyaltyPoints: 'loyaltyPoints',
    loyaltyTier: 'loyaltyTier',
    totalLifetimePurchases: 'totalLifetimePurchases',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoreCustomerScalarFieldEnum = (typeof StoreCustomerScalarFieldEnum)[keyof typeof StoreCustomerScalarFieldEnum]


  export const StoreLoyaltyConfigScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    pointsPerGel: 'pointsPerGel',
    redemptionRate: 'redemptionRate',
    minRedemptionPoints: 'minRedemptionPoints',
    expirationDays: 'expirationDays',
    bronzeMinSpend: 'bronzeMinSpend',
    silverMinSpend: 'silverMinSpend',
    goldMinSpend: 'goldMinSpend',
    platinumMinSpend: 'platinumMinSpend',
    goldDiscountPercent: 'goldDiscountPercent',
    platinumDiscountPercent: 'platinumDiscountPercent'
  };

  export type StoreLoyaltyConfigScalarFieldEnum = (typeof StoreLoyaltyConfigScalarFieldEnum)[keyof typeof StoreLoyaltyConfigScalarFieldEnum]


  export const StoreLoyaltyTransactionScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    type: 'type',
    points: 'points',
    saleId: 'saleId',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type StoreLoyaltyTransactionScalarFieldEnum = (typeof StoreLoyaltyTransactionScalarFieldEnum)[keyof typeof StoreLoyaltyTransactionScalarFieldEnum]


  export const StoreTaxRuleScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    name: 'name',
    rate: 'rate',
    isDefault: 'isDefault',
    isActive: 'isActive'
  };

  export type StoreTaxRuleScalarFieldEnum = (typeof StoreTaxRuleScalarFieldEnum)[keyof typeof StoreTaxRuleScalarFieldEnum]


  export const StorePaymentConfigScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    name: 'name',
    type: 'type',
    isActive: 'isActive',
    sortOrder: 'sortOrder'
  };

  export type StorePaymentConfigScalarFieldEnum = (typeof StorePaymentConfigScalarFieldEnum)[keyof typeof StorePaymentConfigScalarFieldEnum]


  export const StoreReceiptConfigScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    headerText: 'headerText',
    footerText: 'footerText',
    showLogo: 'showLogo',
    showTaxId: 'showTaxId',
    showBarcode: 'showBarcode',
    paperWidth: 'paperWidth'
  };

  export type StoreReceiptConfigScalarFieldEnum = (typeof StoreReceiptConfigScalarFieldEnum)[keyof typeof StoreReceiptConfigScalarFieldEnum]


  export const StoreDeviceConfigScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    deviceType: 'deviceType',
    name: 'name',
    connectionType: 'connectionType',
    settings: 'settings',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoreDeviceConfigScalarFieldEnum = (typeof StoreDeviceConfigScalarFieldEnum)[keyof typeof StoreDeviceConfigScalarFieldEnum]


  export const StoreIntegrationScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    type: 'type',
    name: 'name',
    credentials: 'credentials',
    settings: 'settings',
    lastSyncAt: 'lastSyncAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoreIntegrationScalarFieldEnum = (typeof StoreIntegrationScalarFieldEnum)[keyof typeof StoreIntegrationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'StoreDiscountType'
   */
  export type EnumStoreDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoreDiscountType'>
    


  /**
   * Reference to a field of type 'StoreDiscountType[]'
   */
  export type ListEnumStoreDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoreDiscountType[]'>
    


  /**
   * Reference to a field of type 'StoreSaleStatus'
   */
  export type EnumStoreSaleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoreSaleStatus'>
    


  /**
   * Reference to a field of type 'StoreSaleStatus[]'
   */
  export type ListEnumStoreSaleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoreSaleStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'StoreReturnStatus'
   */
  export type EnumStoreReturnStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoreReturnStatus'>
    


  /**
   * Reference to a field of type 'StoreReturnStatus[]'
   */
  export type ListEnumStoreReturnStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoreReturnStatus[]'>
    


  /**
   * Reference to a field of type 'StorePurchaseStatus'
   */
  export type EnumStorePurchaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StorePurchaseStatus'>
    


  /**
   * Reference to a field of type 'StorePurchaseStatus[]'
   */
  export type ListEnumStorePurchaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StorePurchaseStatus[]'>
    


  /**
   * Reference to a field of type 'StoreMovementType'
   */
  export type EnumStoreMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoreMovementType'>
    


  /**
   * Reference to a field of type 'StoreMovementType[]'
   */
  export type ListEnumStoreMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoreMovementType[]'>
    


  /**
   * Reference to a field of type 'TransferOrderStatus'
   */
  export type EnumTransferOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferOrderStatus'>
    


  /**
   * Reference to a field of type 'TransferOrderStatus[]'
   */
  export type ListEnumTransferOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferOrderStatus[]'>
    


  /**
   * Reference to a field of type 'LoyaltyTier'
   */
  export type EnumLoyaltyTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoyaltyTier'>
    


  /**
   * Reference to a field of type 'LoyaltyTier[]'
   */
  export type ListEnumLoyaltyTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoyaltyTier[]'>
    


  /**
   * Reference to a field of type 'LoyaltyTransactionType'
   */
  export type EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoyaltyTransactionType'>
    


  /**
   * Reference to a field of type 'LoyaltyTransactionType[]'
   */
  export type ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoyaltyTransactionType[]'>
    


  /**
   * Reference to a field of type 'StoreDeviceType'
   */
  export type EnumStoreDeviceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoreDeviceType'>
    


  /**
   * Reference to a field of type 'StoreDeviceType[]'
   */
  export type ListEnumStoreDeviceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoreDeviceType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'StoreIntegrationType'
   */
  export type EnumStoreIntegrationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoreIntegrationType'>
    


  /**
   * Reference to a field of type 'StoreIntegrationType[]'
   */
  export type ListEnumStoreIntegrationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoreIntegrationType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    slug?: StringFilter<"Organization"> | string
    email?: StringFilter<"Organization"> | string
    phone?: StringNullableFilter<"Organization"> | string | null
    address?: StringNullableFilter<"Organization"> | string | null
    logo?: StringNullableFilter<"Organization"> | string | null
    company?: StringNullableFilter<"Organization"> | string | null
    taxId?: StringNullableFilter<"Organization"> | string | null
    city?: StringNullableFilter<"Organization"> | string | null
    country?: StringNullableFilter<"Organization"> | string | null
    website?: StringNullableFilter<"Organization"> | string | null
    bankName?: StringNullableFilter<"Organization"> | string | null
    bankAccount?: StringNullableFilter<"Organization"> | string | null
    tenantId?: StringFilter<"Organization"> | string
    hotelCode?: StringFilter<"Organization"> | string
    storeCode?: StringNullableFilter<"Organization"> | string | null
    databaseUrl?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    users?: UserListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    hotelCode?: SortOrder
    storeCode?: SortOrderInput | SortOrder
    databaseUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    tenantId?: string
    hotelCode?: string
    storeCode?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    email?: StringFilter<"Organization"> | string
    phone?: StringNullableFilter<"Organization"> | string | null
    address?: StringNullableFilter<"Organization"> | string | null
    logo?: StringNullableFilter<"Organization"> | string | null
    company?: StringNullableFilter<"Organization"> | string | null
    taxId?: StringNullableFilter<"Organization"> | string | null
    city?: StringNullableFilter<"Organization"> | string | null
    country?: StringNullableFilter<"Organization"> | string | null
    website?: StringNullableFilter<"Organization"> | string | null
    bankName?: StringNullableFilter<"Organization"> | string | null
    bankAccount?: StringNullableFilter<"Organization"> | string | null
    databaseUrl?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    users?: UserListRelationFilter
  }, "id" | "slug" | "tenantId" | "hotelCode" | "storeCode">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    hotelCode?: SortOrder
    storeCode?: SortOrderInput | SortOrder
    databaseUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    slug?: StringWithAggregatesFilter<"Organization"> | string
    email?: StringWithAggregatesFilter<"Organization"> | string
    phone?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    address?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    company?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    city?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    country?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    website?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    bankAccount?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    tenantId?: StringWithAggregatesFilter<"Organization"> | string
    hotelCode?: StringWithAggregatesFilter<"Organization"> | string
    storeCode?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    databaseUrl?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    organizationId?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrder
    avatar?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    organizationId?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    organizationId?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrder
    avatar?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    organizationId?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    organizationId?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type StoreWhereInput = {
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    id?: StringFilter<"Store"> | string
    tenantId?: StringFilter<"Store"> | string
    name?: StringFilter<"Store"> | string
    slug?: StringFilter<"Store"> | string
    address?: StringNullableFilter<"Store"> | string | null
    phone?: StringNullableFilter<"Store"> | string | null
    email?: StringNullableFilter<"Store"> | string | null
    taxId?: StringNullableFilter<"Store"> | string | null
    currency?: StringFilter<"Store"> | string
    timezone?: StringFilter<"Store"> | string
    logoUrl?: StringNullableFilter<"Store"> | string | null
    isActive?: BoolFilter<"Store"> | boolean
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
    employees?: StoreEmployeeListRelationFilter
    products?: StoreProductListRelationFilter
    categories?: ProductCategoryListRelationFilter
    sales?: SaleListRelationFilter
    purchases?: StorePurchaseOrderListRelationFilter
    suppliers?: StoreSupplierListRelationFilter
    customers?: StoreCustomerListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    taxRules?: StoreTaxRuleListRelationFilter
    loyaltyConfig?: XOR<StoreLoyaltyConfigNullableRelationFilter, StoreLoyaltyConfigWhereInput> | null
    transferOrdersOut?: TransferOrderListRelationFilter
    transferOrdersIn?: TransferOrderListRelationFilter
    paymentMethods?: StorePaymentConfigListRelationFilter
    receiptConfig?: XOR<StoreReceiptConfigNullableRelationFilter, StoreReceiptConfigWhereInput> | null
    devices?: StoreDeviceConfigListRelationFilter
    integrations?: StoreIntegrationListRelationFilter
  }

  export type StoreOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employees?: StoreEmployeeOrderByRelationAggregateInput
    products?: StoreProductOrderByRelationAggregateInput
    categories?: ProductCategoryOrderByRelationAggregateInput
    sales?: SaleOrderByRelationAggregateInput
    purchases?: StorePurchaseOrderOrderByRelationAggregateInput
    suppliers?: StoreSupplierOrderByRelationAggregateInput
    customers?: StoreCustomerOrderByRelationAggregateInput
    stockMovements?: StockMovementOrderByRelationAggregateInput
    taxRules?: StoreTaxRuleOrderByRelationAggregateInput
    loyaltyConfig?: StoreLoyaltyConfigOrderByWithRelationInput
    transferOrdersOut?: TransferOrderOrderByRelationAggregateInput
    transferOrdersIn?: TransferOrderOrderByRelationAggregateInput
    paymentMethods?: StorePaymentConfigOrderByRelationAggregateInput
    receiptConfig?: StoreReceiptConfigOrderByWithRelationInput
    devices?: StoreDeviceConfigOrderByRelationAggregateInput
    integrations?: StoreIntegrationOrderByRelationAggregateInput
  }

  export type StoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    tenantId?: StringFilter<"Store"> | string
    name?: StringFilter<"Store"> | string
    address?: StringNullableFilter<"Store"> | string | null
    phone?: StringNullableFilter<"Store"> | string | null
    email?: StringNullableFilter<"Store"> | string | null
    taxId?: StringNullableFilter<"Store"> | string | null
    currency?: StringFilter<"Store"> | string
    timezone?: StringFilter<"Store"> | string
    logoUrl?: StringNullableFilter<"Store"> | string | null
    isActive?: BoolFilter<"Store"> | boolean
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
    employees?: StoreEmployeeListRelationFilter
    products?: StoreProductListRelationFilter
    categories?: ProductCategoryListRelationFilter
    sales?: SaleListRelationFilter
    purchases?: StorePurchaseOrderListRelationFilter
    suppliers?: StoreSupplierListRelationFilter
    customers?: StoreCustomerListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    taxRules?: StoreTaxRuleListRelationFilter
    loyaltyConfig?: XOR<StoreLoyaltyConfigNullableRelationFilter, StoreLoyaltyConfigWhereInput> | null
    transferOrdersOut?: TransferOrderListRelationFilter
    transferOrdersIn?: TransferOrderListRelationFilter
    paymentMethods?: StorePaymentConfigListRelationFilter
    receiptConfig?: XOR<StoreReceiptConfigNullableRelationFilter, StoreReceiptConfigWhereInput> | null
    devices?: StoreDeviceConfigListRelationFilter
    integrations?: StoreIntegrationListRelationFilter
  }, "id" | "slug">

  export type StoreOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoreCountOrderByAggregateInput
    _max?: StoreMaxOrderByAggregateInput
    _min?: StoreMinOrderByAggregateInput
  }

  export type StoreScalarWhereWithAggregatesInput = {
    AND?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    OR?: StoreScalarWhereWithAggregatesInput[]
    NOT?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Store"> | string
    tenantId?: StringWithAggregatesFilter<"Store"> | string
    name?: StringWithAggregatesFilter<"Store"> | string
    slug?: StringWithAggregatesFilter<"Store"> | string
    address?: StringNullableWithAggregatesFilter<"Store"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Store"> | string | null
    email?: StringNullableWithAggregatesFilter<"Store"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"Store"> | string | null
    currency?: StringWithAggregatesFilter<"Store"> | string
    timezone?: StringWithAggregatesFilter<"Store"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"Store"> | string | null
    isActive?: BoolWithAggregatesFilter<"Store"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
  }

  export type StoreEmployeeWhereInput = {
    AND?: StoreEmployeeWhereInput | StoreEmployeeWhereInput[]
    OR?: StoreEmployeeWhereInput[]
    NOT?: StoreEmployeeWhereInput | StoreEmployeeWhereInput[]
    id?: StringFilter<"StoreEmployee"> | string
    storeId?: StringFilter<"StoreEmployee"> | string
    userId?: StringNullableFilter<"StoreEmployee"> | string | null
    firstName?: StringFilter<"StoreEmployee"> | string
    lastName?: StringFilter<"StoreEmployee"> | string
    phone?: StringNullableFilter<"StoreEmployee"> | string | null
    email?: StringNullableFilter<"StoreEmployee"> | string | null
    role?: StringFilter<"StoreEmployee"> | string
    pin?: StringNullableFilter<"StoreEmployee"> | string | null
    isActive?: BoolFilter<"StoreEmployee"> | boolean
    createdAt?: DateTimeFilter<"StoreEmployee"> | Date | string
    updatedAt?: DateTimeFilter<"StoreEmployee"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    sales?: SaleListRelationFilter
  }

  export type StoreEmployeeOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    userId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    pin?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoreOrderByWithRelationInput
    sales?: SaleOrderByRelationAggregateInput
  }

  export type StoreEmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoreEmployeeWhereInput | StoreEmployeeWhereInput[]
    OR?: StoreEmployeeWhereInput[]
    NOT?: StoreEmployeeWhereInput | StoreEmployeeWhereInput[]
    storeId?: StringFilter<"StoreEmployee"> | string
    userId?: StringNullableFilter<"StoreEmployee"> | string | null
    firstName?: StringFilter<"StoreEmployee"> | string
    lastName?: StringFilter<"StoreEmployee"> | string
    phone?: StringNullableFilter<"StoreEmployee"> | string | null
    email?: StringNullableFilter<"StoreEmployee"> | string | null
    role?: StringFilter<"StoreEmployee"> | string
    pin?: StringNullableFilter<"StoreEmployee"> | string | null
    isActive?: BoolFilter<"StoreEmployee"> | boolean
    createdAt?: DateTimeFilter<"StoreEmployee"> | Date | string
    updatedAt?: DateTimeFilter<"StoreEmployee"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    sales?: SaleListRelationFilter
  }, "id">

  export type StoreEmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    userId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    pin?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoreEmployeeCountOrderByAggregateInput
    _max?: StoreEmployeeMaxOrderByAggregateInput
    _min?: StoreEmployeeMinOrderByAggregateInput
  }

  export type StoreEmployeeScalarWhereWithAggregatesInput = {
    AND?: StoreEmployeeScalarWhereWithAggregatesInput | StoreEmployeeScalarWhereWithAggregatesInput[]
    OR?: StoreEmployeeScalarWhereWithAggregatesInput[]
    NOT?: StoreEmployeeScalarWhereWithAggregatesInput | StoreEmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoreEmployee"> | string
    storeId?: StringWithAggregatesFilter<"StoreEmployee"> | string
    userId?: StringNullableWithAggregatesFilter<"StoreEmployee"> | string | null
    firstName?: StringWithAggregatesFilter<"StoreEmployee"> | string
    lastName?: StringWithAggregatesFilter<"StoreEmployee"> | string
    phone?: StringNullableWithAggregatesFilter<"StoreEmployee"> | string | null
    email?: StringNullableWithAggregatesFilter<"StoreEmployee"> | string | null
    role?: StringWithAggregatesFilter<"StoreEmployee"> | string
    pin?: StringNullableWithAggregatesFilter<"StoreEmployee"> | string | null
    isActive?: BoolWithAggregatesFilter<"StoreEmployee"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StoreEmployee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StoreEmployee"> | Date | string
  }

  export type ProductCategoryWhereInput = {
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    id?: StringFilter<"ProductCategory"> | string
    storeId?: StringFilter<"ProductCategory"> | string
    name?: StringFilter<"ProductCategory"> | string
    nameKa?: StringNullableFilter<"ProductCategory"> | string | null
    slug?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    color?: StringNullableFilter<"ProductCategory"> | string | null
    icon?: StringNullableFilter<"ProductCategory"> | string | null
    sortOrder?: IntFilter<"ProductCategory"> | number
    parentId?: StringNullableFilter<"ProductCategory"> | string | null
    isActive?: BoolFilter<"ProductCategory"> | boolean
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    parent?: XOR<ProductCategoryNullableRelationFilter, ProductCategoryWhereInput> | null
    children?: ProductCategoryListRelationFilter
    products?: StoreProductListRelationFilter
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    nameKa?: SortOrderInput | SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoreOrderByWithRelationInput
    parent?: ProductCategoryOrderByWithRelationInput
    children?: ProductCategoryOrderByRelationAggregateInput
    products?: StoreProductOrderByRelationAggregateInput
  }

  export type ProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storeId_slug?: ProductCategoryStoreIdSlugCompoundUniqueInput
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    storeId?: StringFilter<"ProductCategory"> | string
    name?: StringFilter<"ProductCategory"> | string
    nameKa?: StringNullableFilter<"ProductCategory"> | string | null
    slug?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    color?: StringNullableFilter<"ProductCategory"> | string | null
    icon?: StringNullableFilter<"ProductCategory"> | string | null
    sortOrder?: IntFilter<"ProductCategory"> | number
    parentId?: StringNullableFilter<"ProductCategory"> | string | null
    isActive?: BoolFilter<"ProductCategory"> | boolean
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    parent?: XOR<ProductCategoryNullableRelationFilter, ProductCategoryWhereInput> | null
    children?: ProductCategoryListRelationFilter
    products?: StoreProductListRelationFilter
  }, "id" | "storeId_slug">

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    nameKa?: SortOrderInput | SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _avg?: ProductCategoryAvgOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
    _sum?: ProductCategorySumOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductCategory"> | string
    storeId?: StringWithAggregatesFilter<"ProductCategory"> | string
    name?: StringWithAggregatesFilter<"ProductCategory"> | string
    nameKa?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    slug?: StringWithAggregatesFilter<"ProductCategory"> | string
    description?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    color?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    icon?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    sortOrder?: IntWithAggregatesFilter<"ProductCategory"> | number
    parentId?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    isActive?: BoolWithAggregatesFilter<"ProductCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
  }

  export type StoreProductWhereInput = {
    AND?: StoreProductWhereInput | StoreProductWhereInput[]
    OR?: StoreProductWhereInput[]
    NOT?: StoreProductWhereInput | StoreProductWhereInput[]
    id?: StringFilter<"StoreProduct"> | string
    storeId?: StringFilter<"StoreProduct"> | string
    categoryId?: StringNullableFilter<"StoreProduct"> | string | null
    sku?: StringFilter<"StoreProduct"> | string
    barcode?: StringNullableFilter<"StoreProduct"> | string | null
    name?: StringFilter<"StoreProduct"> | string
    nameKa?: StringNullableFilter<"StoreProduct"> | string | null
    description?: StringNullableFilter<"StoreProduct"> | string | null
    imageUrl?: StringNullableFilter<"StoreProduct"> | string | null
    costPrice?: DecimalFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalNullableFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalNullableFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringFilter<"StoreProduct"> | string
    taxRuleId?: StringNullableFilter<"StoreProduct"> | string | null
    isActive?: BoolFilter<"StoreProduct"> | boolean
    isFavorite?: BoolFilter<"StoreProduct"> | boolean
    sortOrder?: IntFilter<"StoreProduct"> | number
    createdAt?: DateTimeFilter<"StoreProduct"> | Date | string
    updatedAt?: DateTimeFilter<"StoreProduct"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    category?: XOR<ProductCategoryNullableRelationFilter, ProductCategoryWhereInput> | null
    taxRule?: XOR<StoreTaxRuleNullableRelationFilter, StoreTaxRuleWhereInput> | null
    saleItems?: SaleItemListRelationFilter
    saleReturnItems?: SaleReturnItemListRelationFilter
    purchaseItems?: StorePurchaseItemListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    priceHistory?: StorePriceHistoryListRelationFilter
    transferOrderItems?: TransferOrderItemListRelationFilter
  }

  export type StoreProductOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    sku?: SortOrder
    barcode?: SortOrderInput | SortOrder
    name?: SortOrder
    nameKa?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    wholesalePrice?: SortOrderInput | SortOrder
    currentStock?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrderInput | SortOrder
    unit?: SortOrder
    taxRuleId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isFavorite?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoreOrderByWithRelationInput
    category?: ProductCategoryOrderByWithRelationInput
    taxRule?: StoreTaxRuleOrderByWithRelationInput
    saleItems?: SaleItemOrderByRelationAggregateInput
    saleReturnItems?: SaleReturnItemOrderByRelationAggregateInput
    purchaseItems?: StorePurchaseItemOrderByRelationAggregateInput
    stockMovements?: StockMovementOrderByRelationAggregateInput
    priceHistory?: StorePriceHistoryOrderByRelationAggregateInput
    transferOrderItems?: TransferOrderItemOrderByRelationAggregateInput
  }

  export type StoreProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storeId_sku?: StoreProductStoreIdSkuCompoundUniqueInput
    AND?: StoreProductWhereInput | StoreProductWhereInput[]
    OR?: StoreProductWhereInput[]
    NOT?: StoreProductWhereInput | StoreProductWhereInput[]
    storeId?: StringFilter<"StoreProduct"> | string
    categoryId?: StringNullableFilter<"StoreProduct"> | string | null
    sku?: StringFilter<"StoreProduct"> | string
    barcode?: StringNullableFilter<"StoreProduct"> | string | null
    name?: StringFilter<"StoreProduct"> | string
    nameKa?: StringNullableFilter<"StoreProduct"> | string | null
    description?: StringNullableFilter<"StoreProduct"> | string | null
    imageUrl?: StringNullableFilter<"StoreProduct"> | string | null
    costPrice?: DecimalFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalNullableFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalNullableFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringFilter<"StoreProduct"> | string
    taxRuleId?: StringNullableFilter<"StoreProduct"> | string | null
    isActive?: BoolFilter<"StoreProduct"> | boolean
    isFavorite?: BoolFilter<"StoreProduct"> | boolean
    sortOrder?: IntFilter<"StoreProduct"> | number
    createdAt?: DateTimeFilter<"StoreProduct"> | Date | string
    updatedAt?: DateTimeFilter<"StoreProduct"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    category?: XOR<ProductCategoryNullableRelationFilter, ProductCategoryWhereInput> | null
    taxRule?: XOR<StoreTaxRuleNullableRelationFilter, StoreTaxRuleWhereInput> | null
    saleItems?: SaleItemListRelationFilter
    saleReturnItems?: SaleReturnItemListRelationFilter
    purchaseItems?: StorePurchaseItemListRelationFilter
    stockMovements?: StockMovementListRelationFilter
    priceHistory?: StorePriceHistoryListRelationFilter
    transferOrderItems?: TransferOrderItemListRelationFilter
  }, "id" | "storeId_sku">

  export type StoreProductOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    sku?: SortOrder
    barcode?: SortOrderInput | SortOrder
    name?: SortOrder
    nameKa?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    wholesalePrice?: SortOrderInput | SortOrder
    currentStock?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrderInput | SortOrder
    unit?: SortOrder
    taxRuleId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isFavorite?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoreProductCountOrderByAggregateInput
    _avg?: StoreProductAvgOrderByAggregateInput
    _max?: StoreProductMaxOrderByAggregateInput
    _min?: StoreProductMinOrderByAggregateInput
    _sum?: StoreProductSumOrderByAggregateInput
  }

  export type StoreProductScalarWhereWithAggregatesInput = {
    AND?: StoreProductScalarWhereWithAggregatesInput | StoreProductScalarWhereWithAggregatesInput[]
    OR?: StoreProductScalarWhereWithAggregatesInput[]
    NOT?: StoreProductScalarWhereWithAggregatesInput | StoreProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoreProduct"> | string
    storeId?: StringWithAggregatesFilter<"StoreProduct"> | string
    categoryId?: StringNullableWithAggregatesFilter<"StoreProduct"> | string | null
    sku?: StringWithAggregatesFilter<"StoreProduct"> | string
    barcode?: StringNullableWithAggregatesFilter<"StoreProduct"> | string | null
    name?: StringWithAggregatesFilter<"StoreProduct"> | string
    nameKa?: StringNullableWithAggregatesFilter<"StoreProduct"> | string | null
    description?: StringNullableWithAggregatesFilter<"StoreProduct"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"StoreProduct"> | string | null
    costPrice?: DecimalWithAggregatesFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalWithAggregatesFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalNullableWithAggregatesFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalWithAggregatesFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string
    minStock?: DecimalWithAggregatesFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalNullableWithAggregatesFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringWithAggregatesFilter<"StoreProduct"> | string
    taxRuleId?: StringNullableWithAggregatesFilter<"StoreProduct"> | string | null
    isActive?: BoolWithAggregatesFilter<"StoreProduct"> | boolean
    isFavorite?: BoolWithAggregatesFilter<"StoreProduct"> | boolean
    sortOrder?: IntWithAggregatesFilter<"StoreProduct"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StoreProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StoreProduct"> | Date | string
  }

  export type StorePriceHistoryWhereInput = {
    AND?: StorePriceHistoryWhereInput | StorePriceHistoryWhereInput[]
    OR?: StorePriceHistoryWhereInput[]
    NOT?: StorePriceHistoryWhereInput | StorePriceHistoryWhereInput[]
    id?: StringFilter<"StorePriceHistory"> | string
    productId?: StringFilter<"StorePriceHistory"> | string
    costPrice?: DecimalFilter<"StorePriceHistory"> | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFilter<"StorePriceHistory"> | Decimal | DecimalJsLike | number | string
    changedBy?: StringNullableFilter<"StorePriceHistory"> | string | null
    changedAt?: DateTimeFilter<"StorePriceHistory"> | Date | string
    product?: XOR<StoreProductRelationFilter, StoreProductWhereInput>
  }

  export type StorePriceHistoryOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    changedBy?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    product?: StoreProductOrderByWithRelationInput
  }

  export type StorePriceHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StorePriceHistoryWhereInput | StorePriceHistoryWhereInput[]
    OR?: StorePriceHistoryWhereInput[]
    NOT?: StorePriceHistoryWhereInput | StorePriceHistoryWhereInput[]
    productId?: StringFilter<"StorePriceHistory"> | string
    costPrice?: DecimalFilter<"StorePriceHistory"> | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFilter<"StorePriceHistory"> | Decimal | DecimalJsLike | number | string
    changedBy?: StringNullableFilter<"StorePriceHistory"> | string | null
    changedAt?: DateTimeFilter<"StorePriceHistory"> | Date | string
    product?: XOR<StoreProductRelationFilter, StoreProductWhereInput>
  }, "id">

  export type StorePriceHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    changedBy?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    _count?: StorePriceHistoryCountOrderByAggregateInput
    _avg?: StorePriceHistoryAvgOrderByAggregateInput
    _max?: StorePriceHistoryMaxOrderByAggregateInput
    _min?: StorePriceHistoryMinOrderByAggregateInput
    _sum?: StorePriceHistorySumOrderByAggregateInput
  }

  export type StorePriceHistoryScalarWhereWithAggregatesInput = {
    AND?: StorePriceHistoryScalarWhereWithAggregatesInput | StorePriceHistoryScalarWhereWithAggregatesInput[]
    OR?: StorePriceHistoryScalarWhereWithAggregatesInput[]
    NOT?: StorePriceHistoryScalarWhereWithAggregatesInput | StorePriceHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StorePriceHistory"> | string
    productId?: StringWithAggregatesFilter<"StorePriceHistory"> | string
    costPrice?: DecimalWithAggregatesFilter<"StorePriceHistory"> | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalWithAggregatesFilter<"StorePriceHistory"> | Decimal | DecimalJsLike | number | string
    changedBy?: StringNullableWithAggregatesFilter<"StorePriceHistory"> | string | null
    changedAt?: DateTimeWithAggregatesFilter<"StorePriceHistory"> | Date | string
  }

  export type SaleWhereInput = {
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    id?: StringFilter<"Sale"> | string
    storeId?: StringFilter<"Sale"> | string
    saleNumber?: StringFilter<"Sale"> | string
    customerId?: StringNullableFilter<"Sale"> | string | null
    employeeId?: StringNullableFilter<"Sale"> | string | null
    subtotal?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discountType?: EnumStoreDiscountTypeNullableFilter<"Sale"> | $Enums.StoreDiscountType | null
    total?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFilter<"Sale"> | $Enums.StoreSaleStatus
    notes?: StringNullableFilter<"Sale"> | string | null
    receiptPrinted?: BoolFilter<"Sale"> | boolean
    fiscalPrinted?: BoolFilter<"Sale"> | boolean
    fiscalNumber?: StringNullableFilter<"Sale"> | string | null
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    customer?: XOR<StoreCustomerNullableRelationFilter, StoreCustomerWhereInput> | null
    employee?: XOR<StoreEmployeeNullableRelationFilter, StoreEmployeeWhereInput> | null
    items?: SaleItemListRelationFilter
    payments?: SalePaymentListRelationFilter
    returns?: SaleReturnListRelationFilter
  }

  export type SaleOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    saleNumber?: SortOrder
    customerId?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    discountType?: SortOrderInput | SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    changeAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    receiptPrinted?: SortOrder
    fiscalPrinted?: SortOrder
    fiscalNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoreOrderByWithRelationInput
    customer?: StoreCustomerOrderByWithRelationInput
    employee?: StoreEmployeeOrderByWithRelationInput
    items?: SaleItemOrderByRelationAggregateInput
    payments?: SalePaymentOrderByRelationAggregateInput
    returns?: SaleReturnOrderByRelationAggregateInput
  }

  export type SaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storeId_saleNumber?: SaleStoreIdSaleNumberCompoundUniqueInput
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    storeId?: StringFilter<"Sale"> | string
    saleNumber?: StringFilter<"Sale"> | string
    customerId?: StringNullableFilter<"Sale"> | string | null
    employeeId?: StringNullableFilter<"Sale"> | string | null
    subtotal?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discountType?: EnumStoreDiscountTypeNullableFilter<"Sale"> | $Enums.StoreDiscountType | null
    total?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFilter<"Sale"> | $Enums.StoreSaleStatus
    notes?: StringNullableFilter<"Sale"> | string | null
    receiptPrinted?: BoolFilter<"Sale"> | boolean
    fiscalPrinted?: BoolFilter<"Sale"> | boolean
    fiscalNumber?: StringNullableFilter<"Sale"> | string | null
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    customer?: XOR<StoreCustomerNullableRelationFilter, StoreCustomerWhereInput> | null
    employee?: XOR<StoreEmployeeNullableRelationFilter, StoreEmployeeWhereInput> | null
    items?: SaleItemListRelationFilter
    payments?: SalePaymentListRelationFilter
    returns?: SaleReturnListRelationFilter
  }, "id" | "storeId_saleNumber">

  export type SaleOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    saleNumber?: SortOrder
    customerId?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    discountType?: SortOrderInput | SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    changeAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    receiptPrinted?: SortOrder
    fiscalPrinted?: SortOrder
    fiscalNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SaleCountOrderByAggregateInput
    _avg?: SaleAvgOrderByAggregateInput
    _max?: SaleMaxOrderByAggregateInput
    _min?: SaleMinOrderByAggregateInput
    _sum?: SaleSumOrderByAggregateInput
  }

  export type SaleScalarWhereWithAggregatesInput = {
    AND?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    OR?: SaleScalarWhereWithAggregatesInput[]
    NOT?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sale"> | string
    storeId?: StringWithAggregatesFilter<"Sale"> | string
    saleNumber?: StringWithAggregatesFilter<"Sale"> | string
    customerId?: StringNullableWithAggregatesFilter<"Sale"> | string | null
    employeeId?: StringNullableWithAggregatesFilter<"Sale"> | string | null
    subtotal?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discountType?: EnumStoreDiscountTypeNullableWithAggregatesFilter<"Sale"> | $Enums.StoreDiscountType | null
    total?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusWithAggregatesFilter<"Sale"> | $Enums.StoreSaleStatus
    notes?: StringNullableWithAggregatesFilter<"Sale"> | string | null
    receiptPrinted?: BoolWithAggregatesFilter<"Sale"> | boolean
    fiscalPrinted?: BoolWithAggregatesFilter<"Sale"> | boolean
    fiscalNumber?: StringNullableWithAggregatesFilter<"Sale"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
  }

  export type SaleItemWhereInput = {
    AND?: SaleItemWhereInput | SaleItemWhereInput[]
    OR?: SaleItemWhereInput[]
    NOT?: SaleItemWhereInput | SaleItemWhereInput[]
    id?: StringFilter<"SaleItem"> | string
    saleId?: StringFilter<"SaleItem"> | string
    productId?: StringFilter<"SaleItem"> | string
    productName?: StringFilter<"SaleItem"> | string
    quantity?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    sale?: XOR<SaleRelationFilter, SaleWhereInput>
    product?: XOR<StoreProductRelationFilter, StoreProductWhereInput>
  }

  export type SaleItemOrderByWithRelationInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    productName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    costPrice?: SortOrder
    discount?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    sale?: SaleOrderByWithRelationInput
    product?: StoreProductOrderByWithRelationInput
  }

  export type SaleItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleItemWhereInput | SaleItemWhereInput[]
    OR?: SaleItemWhereInput[]
    NOT?: SaleItemWhereInput | SaleItemWhereInput[]
    saleId?: StringFilter<"SaleItem"> | string
    productId?: StringFilter<"SaleItem"> | string
    productName?: StringFilter<"SaleItem"> | string
    quantity?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    sale?: XOR<SaleRelationFilter, SaleWhereInput>
    product?: XOR<StoreProductRelationFilter, StoreProductWhereInput>
  }, "id">

  export type SaleItemOrderByWithAggregationInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    productName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    costPrice?: SortOrder
    discount?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    _count?: SaleItemCountOrderByAggregateInput
    _avg?: SaleItemAvgOrderByAggregateInput
    _max?: SaleItemMaxOrderByAggregateInput
    _min?: SaleItemMinOrderByAggregateInput
    _sum?: SaleItemSumOrderByAggregateInput
  }

  export type SaleItemScalarWhereWithAggregatesInput = {
    AND?: SaleItemScalarWhereWithAggregatesInput | SaleItemScalarWhereWithAggregatesInput[]
    OR?: SaleItemScalarWhereWithAggregatesInput[]
    NOT?: SaleItemScalarWhereWithAggregatesInput | SaleItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SaleItem"> | string
    saleId?: StringWithAggregatesFilter<"SaleItem"> | string
    productId?: StringWithAggregatesFilter<"SaleItem"> | string
    productName?: StringWithAggregatesFilter<"SaleItem"> | string
    quantity?: DecimalWithAggregatesFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalWithAggregatesFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
  }

  export type SalePaymentWhereInput = {
    AND?: SalePaymentWhereInput | SalePaymentWhereInput[]
    OR?: SalePaymentWhereInput[]
    NOT?: SalePaymentWhereInput | SalePaymentWhereInput[]
    id?: StringFilter<"SalePayment"> | string
    saleId?: StringFilter<"SalePayment"> | string
    method?: EnumPaymentMethodFilter<"SalePayment"> | $Enums.PaymentMethod
    amount?: DecimalFilter<"SalePayment"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"SalePayment"> | string | null
    createdAt?: DateTimeFilter<"SalePayment"> | Date | string
    sale?: XOR<SaleRelationFilter, SaleWhereInput>
  }

  export type SalePaymentOrderByWithRelationInput = {
    id?: SortOrder
    saleId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    sale?: SaleOrderByWithRelationInput
  }

  export type SalePaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SalePaymentWhereInput | SalePaymentWhereInput[]
    OR?: SalePaymentWhereInput[]
    NOT?: SalePaymentWhereInput | SalePaymentWhereInput[]
    saleId?: StringFilter<"SalePayment"> | string
    method?: EnumPaymentMethodFilter<"SalePayment"> | $Enums.PaymentMethod
    amount?: DecimalFilter<"SalePayment"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"SalePayment"> | string | null
    createdAt?: DateTimeFilter<"SalePayment"> | Date | string
    sale?: XOR<SaleRelationFilter, SaleWhereInput>
  }, "id">

  export type SalePaymentOrderByWithAggregationInput = {
    id?: SortOrder
    saleId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    reference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SalePaymentCountOrderByAggregateInput
    _avg?: SalePaymentAvgOrderByAggregateInput
    _max?: SalePaymentMaxOrderByAggregateInput
    _min?: SalePaymentMinOrderByAggregateInput
    _sum?: SalePaymentSumOrderByAggregateInput
  }

  export type SalePaymentScalarWhereWithAggregatesInput = {
    AND?: SalePaymentScalarWhereWithAggregatesInput | SalePaymentScalarWhereWithAggregatesInput[]
    OR?: SalePaymentScalarWhereWithAggregatesInput[]
    NOT?: SalePaymentScalarWhereWithAggregatesInput | SalePaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalePayment"> | string
    saleId?: StringWithAggregatesFilter<"SalePayment"> | string
    method?: EnumPaymentMethodWithAggregatesFilter<"SalePayment"> | $Enums.PaymentMethod
    amount?: DecimalWithAggregatesFilter<"SalePayment"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableWithAggregatesFilter<"SalePayment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SalePayment"> | Date | string
  }

  export type SaleReturnWhereInput = {
    AND?: SaleReturnWhereInput | SaleReturnWhereInput[]
    OR?: SaleReturnWhereInput[]
    NOT?: SaleReturnWhereInput | SaleReturnWhereInput[]
    id?: StringFilter<"SaleReturn"> | string
    saleId?: StringFilter<"SaleReturn"> | string
    reason?: StringFilter<"SaleReturn"> | string
    refundAmount?: DecimalFilter<"SaleReturn"> | Decimal | DecimalJsLike | number | string
    refundMethod?: EnumPaymentMethodFilter<"SaleReturn"> | $Enums.PaymentMethod
    status?: EnumStoreReturnStatusFilter<"SaleReturn"> | $Enums.StoreReturnStatus
    createdAt?: DateTimeFilter<"SaleReturn"> | Date | string
    processedAt?: DateTimeNullableFilter<"SaleReturn"> | Date | string | null
    sale?: XOR<SaleRelationFilter, SaleWhereInput>
    items?: SaleReturnItemListRelationFilter
  }

  export type SaleReturnOrderByWithRelationInput = {
    id?: SortOrder
    saleId?: SortOrder
    reason?: SortOrder
    refundAmount?: SortOrder
    refundMethod?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    sale?: SaleOrderByWithRelationInput
    items?: SaleReturnItemOrderByRelationAggregateInput
  }

  export type SaleReturnWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleReturnWhereInput | SaleReturnWhereInput[]
    OR?: SaleReturnWhereInput[]
    NOT?: SaleReturnWhereInput | SaleReturnWhereInput[]
    saleId?: StringFilter<"SaleReturn"> | string
    reason?: StringFilter<"SaleReturn"> | string
    refundAmount?: DecimalFilter<"SaleReturn"> | Decimal | DecimalJsLike | number | string
    refundMethod?: EnumPaymentMethodFilter<"SaleReturn"> | $Enums.PaymentMethod
    status?: EnumStoreReturnStatusFilter<"SaleReturn"> | $Enums.StoreReturnStatus
    createdAt?: DateTimeFilter<"SaleReturn"> | Date | string
    processedAt?: DateTimeNullableFilter<"SaleReturn"> | Date | string | null
    sale?: XOR<SaleRelationFilter, SaleWhereInput>
    items?: SaleReturnItemListRelationFilter
  }, "id">

  export type SaleReturnOrderByWithAggregationInput = {
    id?: SortOrder
    saleId?: SortOrder
    reason?: SortOrder
    refundAmount?: SortOrder
    refundMethod?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    _count?: SaleReturnCountOrderByAggregateInput
    _avg?: SaleReturnAvgOrderByAggregateInput
    _max?: SaleReturnMaxOrderByAggregateInput
    _min?: SaleReturnMinOrderByAggregateInput
    _sum?: SaleReturnSumOrderByAggregateInput
  }

  export type SaleReturnScalarWhereWithAggregatesInput = {
    AND?: SaleReturnScalarWhereWithAggregatesInput | SaleReturnScalarWhereWithAggregatesInput[]
    OR?: SaleReturnScalarWhereWithAggregatesInput[]
    NOT?: SaleReturnScalarWhereWithAggregatesInput | SaleReturnScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SaleReturn"> | string
    saleId?: StringWithAggregatesFilter<"SaleReturn"> | string
    reason?: StringWithAggregatesFilter<"SaleReturn"> | string
    refundAmount?: DecimalWithAggregatesFilter<"SaleReturn"> | Decimal | DecimalJsLike | number | string
    refundMethod?: EnumPaymentMethodWithAggregatesFilter<"SaleReturn"> | $Enums.PaymentMethod
    status?: EnumStoreReturnStatusWithAggregatesFilter<"SaleReturn"> | $Enums.StoreReturnStatus
    createdAt?: DateTimeWithAggregatesFilter<"SaleReturn"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"SaleReturn"> | Date | string | null
  }

  export type SaleReturnItemWhereInput = {
    AND?: SaleReturnItemWhereInput | SaleReturnItemWhereInput[]
    OR?: SaleReturnItemWhereInput[]
    NOT?: SaleReturnItemWhereInput | SaleReturnItemWhereInput[]
    id?: StringFilter<"SaleReturnItem"> | string
    returnId?: StringFilter<"SaleReturnItem"> | string
    productId?: StringFilter<"SaleReturnItem"> | string
    quantity?: DecimalFilter<"SaleReturnItem"> | Decimal | DecimalJsLike | number | string
    refundAmount?: DecimalFilter<"SaleReturnItem"> | Decimal | DecimalJsLike | number | string
    saleReturn?: XOR<SaleReturnRelationFilter, SaleReturnWhereInput>
    product?: XOR<StoreProductRelationFilter, StoreProductWhereInput>
  }

  export type SaleReturnItemOrderByWithRelationInput = {
    id?: SortOrder
    returnId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    refundAmount?: SortOrder
    saleReturn?: SaleReturnOrderByWithRelationInput
    product?: StoreProductOrderByWithRelationInput
  }

  export type SaleReturnItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleReturnItemWhereInput | SaleReturnItemWhereInput[]
    OR?: SaleReturnItemWhereInput[]
    NOT?: SaleReturnItemWhereInput | SaleReturnItemWhereInput[]
    returnId?: StringFilter<"SaleReturnItem"> | string
    productId?: StringFilter<"SaleReturnItem"> | string
    quantity?: DecimalFilter<"SaleReturnItem"> | Decimal | DecimalJsLike | number | string
    refundAmount?: DecimalFilter<"SaleReturnItem"> | Decimal | DecimalJsLike | number | string
    saleReturn?: XOR<SaleReturnRelationFilter, SaleReturnWhereInput>
    product?: XOR<StoreProductRelationFilter, StoreProductWhereInput>
  }, "id">

  export type SaleReturnItemOrderByWithAggregationInput = {
    id?: SortOrder
    returnId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    refundAmount?: SortOrder
    _count?: SaleReturnItemCountOrderByAggregateInput
    _avg?: SaleReturnItemAvgOrderByAggregateInput
    _max?: SaleReturnItemMaxOrderByAggregateInput
    _min?: SaleReturnItemMinOrderByAggregateInput
    _sum?: SaleReturnItemSumOrderByAggregateInput
  }

  export type SaleReturnItemScalarWhereWithAggregatesInput = {
    AND?: SaleReturnItemScalarWhereWithAggregatesInput | SaleReturnItemScalarWhereWithAggregatesInput[]
    OR?: SaleReturnItemScalarWhereWithAggregatesInput[]
    NOT?: SaleReturnItemScalarWhereWithAggregatesInput | SaleReturnItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SaleReturnItem"> | string
    returnId?: StringWithAggregatesFilter<"SaleReturnItem"> | string
    productId?: StringWithAggregatesFilter<"SaleReturnItem"> | string
    quantity?: DecimalWithAggregatesFilter<"SaleReturnItem"> | Decimal | DecimalJsLike | number | string
    refundAmount?: DecimalWithAggregatesFilter<"SaleReturnItem"> | Decimal | DecimalJsLike | number | string
  }

  export type StoreSupplierWhereInput = {
    AND?: StoreSupplierWhereInput | StoreSupplierWhereInput[]
    OR?: StoreSupplierWhereInput[]
    NOT?: StoreSupplierWhereInput | StoreSupplierWhereInput[]
    id?: StringFilter<"StoreSupplier"> | string
    storeId?: StringFilter<"StoreSupplier"> | string
    name?: StringFilter<"StoreSupplier"> | string
    contactPerson?: StringNullableFilter<"StoreSupplier"> | string | null
    phone?: StringNullableFilter<"StoreSupplier"> | string | null
    email?: StringNullableFilter<"StoreSupplier"> | string | null
    address?: StringNullableFilter<"StoreSupplier"> | string | null
    taxId?: StringNullableFilter<"StoreSupplier"> | string | null
    bankAccount?: StringNullableFilter<"StoreSupplier"> | string | null
    notes?: StringNullableFilter<"StoreSupplier"> | string | null
    isActive?: BoolFilter<"StoreSupplier"> | boolean
    createdAt?: DateTimeFilter<"StoreSupplier"> | Date | string
    updatedAt?: DateTimeFilter<"StoreSupplier"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    purchaseOrders?: StorePurchaseOrderListRelationFilter
  }

  export type StoreSupplierOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoreOrderByWithRelationInput
    purchaseOrders?: StorePurchaseOrderOrderByRelationAggregateInput
  }

  export type StoreSupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storeId_name?: StoreSupplierStoreIdNameCompoundUniqueInput
    AND?: StoreSupplierWhereInput | StoreSupplierWhereInput[]
    OR?: StoreSupplierWhereInput[]
    NOT?: StoreSupplierWhereInput | StoreSupplierWhereInput[]
    storeId?: StringFilter<"StoreSupplier"> | string
    name?: StringFilter<"StoreSupplier"> | string
    contactPerson?: StringNullableFilter<"StoreSupplier"> | string | null
    phone?: StringNullableFilter<"StoreSupplier"> | string | null
    email?: StringNullableFilter<"StoreSupplier"> | string | null
    address?: StringNullableFilter<"StoreSupplier"> | string | null
    taxId?: StringNullableFilter<"StoreSupplier"> | string | null
    bankAccount?: StringNullableFilter<"StoreSupplier"> | string | null
    notes?: StringNullableFilter<"StoreSupplier"> | string | null
    isActive?: BoolFilter<"StoreSupplier"> | boolean
    createdAt?: DateTimeFilter<"StoreSupplier"> | Date | string
    updatedAt?: DateTimeFilter<"StoreSupplier"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    purchaseOrders?: StorePurchaseOrderListRelationFilter
  }, "id" | "storeId_name">

  export type StoreSupplierOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoreSupplierCountOrderByAggregateInput
    _max?: StoreSupplierMaxOrderByAggregateInput
    _min?: StoreSupplierMinOrderByAggregateInput
  }

  export type StoreSupplierScalarWhereWithAggregatesInput = {
    AND?: StoreSupplierScalarWhereWithAggregatesInput | StoreSupplierScalarWhereWithAggregatesInput[]
    OR?: StoreSupplierScalarWhereWithAggregatesInput[]
    NOT?: StoreSupplierScalarWhereWithAggregatesInput | StoreSupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoreSupplier"> | string
    storeId?: StringWithAggregatesFilter<"StoreSupplier"> | string
    name?: StringWithAggregatesFilter<"StoreSupplier"> | string
    contactPerson?: StringNullableWithAggregatesFilter<"StoreSupplier"> | string | null
    phone?: StringNullableWithAggregatesFilter<"StoreSupplier"> | string | null
    email?: StringNullableWithAggregatesFilter<"StoreSupplier"> | string | null
    address?: StringNullableWithAggregatesFilter<"StoreSupplier"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"StoreSupplier"> | string | null
    bankAccount?: StringNullableWithAggregatesFilter<"StoreSupplier"> | string | null
    notes?: StringNullableWithAggregatesFilter<"StoreSupplier"> | string | null
    isActive?: BoolWithAggregatesFilter<"StoreSupplier"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StoreSupplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StoreSupplier"> | Date | string
  }

  export type StorePurchaseOrderWhereInput = {
    AND?: StorePurchaseOrderWhereInput | StorePurchaseOrderWhereInput[]
    OR?: StorePurchaseOrderWhereInput[]
    NOT?: StorePurchaseOrderWhereInput | StorePurchaseOrderWhereInput[]
    id?: StringFilter<"StorePurchaseOrder"> | string
    storeId?: StringFilter<"StorePurchaseOrder"> | string
    supplierId?: StringFilter<"StorePurchaseOrder"> | string
    orderNumber?: StringFilter<"StorePurchaseOrder"> | string
    subtotal?: DecimalFilter<"StorePurchaseOrder"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"StorePurchaseOrder"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"StorePurchaseOrder"> | Decimal | DecimalJsLike | number | string
    status?: EnumStorePurchaseStatusFilter<"StorePurchaseOrder"> | $Enums.StorePurchaseStatus
    notes?: StringNullableFilter<"StorePurchaseOrder"> | string | null
    expectedDate?: DateTimeNullableFilter<"StorePurchaseOrder"> | Date | string | null
    receivedDate?: DateTimeNullableFilter<"StorePurchaseOrder"> | Date | string | null
    createdAt?: DateTimeFilter<"StorePurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"StorePurchaseOrder"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    supplier?: XOR<StoreSupplierRelationFilter, StoreSupplierWhereInput>
    items?: StorePurchaseItemListRelationFilter
  }

  export type StorePurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    supplierId?: SortOrder
    orderNumber?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    expectedDate?: SortOrderInput | SortOrder
    receivedDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoreOrderByWithRelationInput
    supplier?: StoreSupplierOrderByWithRelationInput
    items?: StorePurchaseItemOrderByRelationAggregateInput
  }

  export type StorePurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storeId_orderNumber?: StorePurchaseOrderStoreIdOrderNumberCompoundUniqueInput
    AND?: StorePurchaseOrderWhereInput | StorePurchaseOrderWhereInput[]
    OR?: StorePurchaseOrderWhereInput[]
    NOT?: StorePurchaseOrderWhereInput | StorePurchaseOrderWhereInput[]
    storeId?: StringFilter<"StorePurchaseOrder"> | string
    supplierId?: StringFilter<"StorePurchaseOrder"> | string
    orderNumber?: StringFilter<"StorePurchaseOrder"> | string
    subtotal?: DecimalFilter<"StorePurchaseOrder"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"StorePurchaseOrder"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"StorePurchaseOrder"> | Decimal | DecimalJsLike | number | string
    status?: EnumStorePurchaseStatusFilter<"StorePurchaseOrder"> | $Enums.StorePurchaseStatus
    notes?: StringNullableFilter<"StorePurchaseOrder"> | string | null
    expectedDate?: DateTimeNullableFilter<"StorePurchaseOrder"> | Date | string | null
    receivedDate?: DateTimeNullableFilter<"StorePurchaseOrder"> | Date | string | null
    createdAt?: DateTimeFilter<"StorePurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"StorePurchaseOrder"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    supplier?: XOR<StoreSupplierRelationFilter, StoreSupplierWhereInput>
    items?: StorePurchaseItemListRelationFilter
  }, "id" | "storeId_orderNumber">

  export type StorePurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    supplierId?: SortOrder
    orderNumber?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    expectedDate?: SortOrderInput | SortOrder
    receivedDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StorePurchaseOrderCountOrderByAggregateInput
    _avg?: StorePurchaseOrderAvgOrderByAggregateInput
    _max?: StorePurchaseOrderMaxOrderByAggregateInput
    _min?: StorePurchaseOrderMinOrderByAggregateInput
    _sum?: StorePurchaseOrderSumOrderByAggregateInput
  }

  export type StorePurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: StorePurchaseOrderScalarWhereWithAggregatesInput | StorePurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: StorePurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: StorePurchaseOrderScalarWhereWithAggregatesInput | StorePurchaseOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StorePurchaseOrder"> | string
    storeId?: StringWithAggregatesFilter<"StorePurchaseOrder"> | string
    supplierId?: StringWithAggregatesFilter<"StorePurchaseOrder"> | string
    orderNumber?: StringWithAggregatesFilter<"StorePurchaseOrder"> | string
    subtotal?: DecimalWithAggregatesFilter<"StorePurchaseOrder"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"StorePurchaseOrder"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"StorePurchaseOrder"> | Decimal | DecimalJsLike | number | string
    status?: EnumStorePurchaseStatusWithAggregatesFilter<"StorePurchaseOrder"> | $Enums.StorePurchaseStatus
    notes?: StringNullableWithAggregatesFilter<"StorePurchaseOrder"> | string | null
    expectedDate?: DateTimeNullableWithAggregatesFilter<"StorePurchaseOrder"> | Date | string | null
    receivedDate?: DateTimeNullableWithAggregatesFilter<"StorePurchaseOrder"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StorePurchaseOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StorePurchaseOrder"> | Date | string
  }

  export type StorePurchaseItemWhereInput = {
    AND?: StorePurchaseItemWhereInput | StorePurchaseItemWhereInput[]
    OR?: StorePurchaseItemWhereInput[]
    NOT?: StorePurchaseItemWhereInput | StorePurchaseItemWhereInput[]
    id?: StringFilter<"StorePurchaseItem"> | string
    purchaseOrderId?: StringFilter<"StorePurchaseItem"> | string
    productId?: StringFilter<"StorePurchaseItem"> | string
    quantity?: DecimalFilter<"StorePurchaseItem"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFilter<"StorePurchaseItem"> | Decimal | DecimalJsLike | number | string
    receivedQty?: DecimalFilter<"StorePurchaseItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"StorePurchaseItem"> | Decimal | DecimalJsLike | number | string
    purchaseOrder?: XOR<StorePurchaseOrderRelationFilter, StorePurchaseOrderWhereInput>
    product?: XOR<StoreProductRelationFilter, StoreProductWhereInput>
  }

  export type StorePurchaseItemOrderByWithRelationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    receivedQty?: SortOrder
    total?: SortOrder
    purchaseOrder?: StorePurchaseOrderOrderByWithRelationInput
    product?: StoreProductOrderByWithRelationInput
  }

  export type StorePurchaseItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StorePurchaseItemWhereInput | StorePurchaseItemWhereInput[]
    OR?: StorePurchaseItemWhereInput[]
    NOT?: StorePurchaseItemWhereInput | StorePurchaseItemWhereInput[]
    purchaseOrderId?: StringFilter<"StorePurchaseItem"> | string
    productId?: StringFilter<"StorePurchaseItem"> | string
    quantity?: DecimalFilter<"StorePurchaseItem"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFilter<"StorePurchaseItem"> | Decimal | DecimalJsLike | number | string
    receivedQty?: DecimalFilter<"StorePurchaseItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"StorePurchaseItem"> | Decimal | DecimalJsLike | number | string
    purchaseOrder?: XOR<StorePurchaseOrderRelationFilter, StorePurchaseOrderWhereInput>
    product?: XOR<StoreProductRelationFilter, StoreProductWhereInput>
  }, "id">

  export type StorePurchaseItemOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    receivedQty?: SortOrder
    total?: SortOrder
    _count?: StorePurchaseItemCountOrderByAggregateInput
    _avg?: StorePurchaseItemAvgOrderByAggregateInput
    _max?: StorePurchaseItemMaxOrderByAggregateInput
    _min?: StorePurchaseItemMinOrderByAggregateInput
    _sum?: StorePurchaseItemSumOrderByAggregateInput
  }

  export type StorePurchaseItemScalarWhereWithAggregatesInput = {
    AND?: StorePurchaseItemScalarWhereWithAggregatesInput | StorePurchaseItemScalarWhereWithAggregatesInput[]
    OR?: StorePurchaseItemScalarWhereWithAggregatesInput[]
    NOT?: StorePurchaseItemScalarWhereWithAggregatesInput | StorePurchaseItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StorePurchaseItem"> | string
    purchaseOrderId?: StringWithAggregatesFilter<"StorePurchaseItem"> | string
    productId?: StringWithAggregatesFilter<"StorePurchaseItem"> | string
    quantity?: DecimalWithAggregatesFilter<"StorePurchaseItem"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalWithAggregatesFilter<"StorePurchaseItem"> | Decimal | DecimalJsLike | number | string
    receivedQty?: DecimalWithAggregatesFilter<"StorePurchaseItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"StorePurchaseItem"> | Decimal | DecimalJsLike | number | string
  }

  export type StockMovementWhereInput = {
    AND?: StockMovementWhereInput | StockMovementWhereInput[]
    OR?: StockMovementWhereInput[]
    NOT?: StockMovementWhereInput | StockMovementWhereInput[]
    id?: StringFilter<"StockMovement"> | string
    storeId?: StringFilter<"StockMovement"> | string
    productId?: StringFilter<"StockMovement"> | string
    type?: EnumStoreMovementTypeFilter<"StockMovement"> | $Enums.StoreMovementType
    quantity?: DecimalFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    previousStock?: DecimalFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    newStock?: DecimalFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    reason?: StringNullableFilter<"StockMovement"> | string | null
    referenceType?: StringNullableFilter<"StockMovement"> | string | null
    referenceId?: StringNullableFilter<"StockMovement"> | string | null
    performedBy?: StringNullableFilter<"StockMovement"> | string | null
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    product?: XOR<StoreProductRelationFilter, StoreProductWhereInput>
  }

  export type StockMovementOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    previousStock?: SortOrder
    newStock?: SortOrder
    reason?: SortOrderInput | SortOrder
    referenceType?: SortOrderInput | SortOrder
    referenceId?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    store?: StoreOrderByWithRelationInput
    product?: StoreProductOrderByWithRelationInput
  }

  export type StockMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockMovementWhereInput | StockMovementWhereInput[]
    OR?: StockMovementWhereInput[]
    NOT?: StockMovementWhereInput | StockMovementWhereInput[]
    storeId?: StringFilter<"StockMovement"> | string
    productId?: StringFilter<"StockMovement"> | string
    type?: EnumStoreMovementTypeFilter<"StockMovement"> | $Enums.StoreMovementType
    quantity?: DecimalFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    previousStock?: DecimalFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    newStock?: DecimalFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    reason?: StringNullableFilter<"StockMovement"> | string | null
    referenceType?: StringNullableFilter<"StockMovement"> | string | null
    referenceId?: StringNullableFilter<"StockMovement"> | string | null
    performedBy?: StringNullableFilter<"StockMovement"> | string | null
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    product?: XOR<StoreProductRelationFilter, StoreProductWhereInput>
  }, "id">

  export type StockMovementOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    previousStock?: SortOrder
    newStock?: SortOrder
    reason?: SortOrderInput | SortOrder
    referenceType?: SortOrderInput | SortOrder
    referenceId?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StockMovementCountOrderByAggregateInput
    _avg?: StockMovementAvgOrderByAggregateInput
    _max?: StockMovementMaxOrderByAggregateInput
    _min?: StockMovementMinOrderByAggregateInput
    _sum?: StockMovementSumOrderByAggregateInput
  }

  export type StockMovementScalarWhereWithAggregatesInput = {
    AND?: StockMovementScalarWhereWithAggregatesInput | StockMovementScalarWhereWithAggregatesInput[]
    OR?: StockMovementScalarWhereWithAggregatesInput[]
    NOT?: StockMovementScalarWhereWithAggregatesInput | StockMovementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockMovement"> | string
    storeId?: StringWithAggregatesFilter<"StockMovement"> | string
    productId?: StringWithAggregatesFilter<"StockMovement"> | string
    type?: EnumStoreMovementTypeWithAggregatesFilter<"StockMovement"> | $Enums.StoreMovementType
    quantity?: DecimalWithAggregatesFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    previousStock?: DecimalWithAggregatesFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    newStock?: DecimalWithAggregatesFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    reason?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    referenceType?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    referenceId?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    performedBy?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StockMovement"> | Date | string
  }

  export type TransferOrderWhereInput = {
    AND?: TransferOrderWhereInput | TransferOrderWhereInput[]
    OR?: TransferOrderWhereInput[]
    NOT?: TransferOrderWhereInput | TransferOrderWhereInput[]
    id?: StringFilter<"TransferOrder"> | string
    fromStoreId?: StringFilter<"TransferOrder"> | string
    toStoreId?: StringFilter<"TransferOrder"> | string
    transferNumber?: StringFilter<"TransferOrder"> | string
    status?: EnumTransferOrderStatusFilter<"TransferOrder"> | $Enums.TransferOrderStatus
    notes?: StringNullableFilter<"TransferOrder"> | string | null
    sentAt?: DateTimeNullableFilter<"TransferOrder"> | Date | string | null
    receivedAt?: DateTimeNullableFilter<"TransferOrder"> | Date | string | null
    createdAt?: DateTimeFilter<"TransferOrder"> | Date | string
    updatedAt?: DateTimeFilter<"TransferOrder"> | Date | string
    fromStore?: XOR<StoreRelationFilter, StoreWhereInput>
    toStore?: XOR<StoreRelationFilter, StoreWhereInput>
    items?: TransferOrderItemListRelationFilter
  }

  export type TransferOrderOrderByWithRelationInput = {
    id?: SortOrder
    fromStoreId?: SortOrder
    toStoreId?: SortOrder
    transferNumber?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    receivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromStore?: StoreOrderByWithRelationInput
    toStore?: StoreOrderByWithRelationInput
    items?: TransferOrderItemOrderByRelationAggregateInput
  }

  export type TransferOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransferOrderWhereInput | TransferOrderWhereInput[]
    OR?: TransferOrderWhereInput[]
    NOT?: TransferOrderWhereInput | TransferOrderWhereInput[]
    fromStoreId?: StringFilter<"TransferOrder"> | string
    toStoreId?: StringFilter<"TransferOrder"> | string
    transferNumber?: StringFilter<"TransferOrder"> | string
    status?: EnumTransferOrderStatusFilter<"TransferOrder"> | $Enums.TransferOrderStatus
    notes?: StringNullableFilter<"TransferOrder"> | string | null
    sentAt?: DateTimeNullableFilter<"TransferOrder"> | Date | string | null
    receivedAt?: DateTimeNullableFilter<"TransferOrder"> | Date | string | null
    createdAt?: DateTimeFilter<"TransferOrder"> | Date | string
    updatedAt?: DateTimeFilter<"TransferOrder"> | Date | string
    fromStore?: XOR<StoreRelationFilter, StoreWhereInput>
    toStore?: XOR<StoreRelationFilter, StoreWhereInput>
    items?: TransferOrderItemListRelationFilter
  }, "id">

  export type TransferOrderOrderByWithAggregationInput = {
    id?: SortOrder
    fromStoreId?: SortOrder
    toStoreId?: SortOrder
    transferNumber?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    receivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransferOrderCountOrderByAggregateInput
    _max?: TransferOrderMaxOrderByAggregateInput
    _min?: TransferOrderMinOrderByAggregateInput
  }

  export type TransferOrderScalarWhereWithAggregatesInput = {
    AND?: TransferOrderScalarWhereWithAggregatesInput | TransferOrderScalarWhereWithAggregatesInput[]
    OR?: TransferOrderScalarWhereWithAggregatesInput[]
    NOT?: TransferOrderScalarWhereWithAggregatesInput | TransferOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransferOrder"> | string
    fromStoreId?: StringWithAggregatesFilter<"TransferOrder"> | string
    toStoreId?: StringWithAggregatesFilter<"TransferOrder"> | string
    transferNumber?: StringWithAggregatesFilter<"TransferOrder"> | string
    status?: EnumTransferOrderStatusWithAggregatesFilter<"TransferOrder"> | $Enums.TransferOrderStatus
    notes?: StringNullableWithAggregatesFilter<"TransferOrder"> | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"TransferOrder"> | Date | string | null
    receivedAt?: DateTimeNullableWithAggregatesFilter<"TransferOrder"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TransferOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransferOrder"> | Date | string
  }

  export type TransferOrderItemWhereInput = {
    AND?: TransferOrderItemWhereInput | TransferOrderItemWhereInput[]
    OR?: TransferOrderItemWhereInput[]
    NOT?: TransferOrderItemWhereInput | TransferOrderItemWhereInput[]
    id?: StringFilter<"TransferOrderItem"> | string
    transferOrderId?: StringFilter<"TransferOrderItem"> | string
    productId?: StringFilter<"TransferOrderItem"> | string
    quantity?: DecimalFilter<"TransferOrderItem"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalNullableFilter<"TransferOrderItem"> | Decimal | DecimalJsLike | number | string | null
    transferOrder?: XOR<TransferOrderRelationFilter, TransferOrderWhereInput>
    product?: XOR<StoreProductRelationFilter, StoreProductWhereInput>
  }

  export type TransferOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    transferOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrderInput | SortOrder
    transferOrder?: TransferOrderOrderByWithRelationInput
    product?: StoreProductOrderByWithRelationInput
  }

  export type TransferOrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransferOrderItemWhereInput | TransferOrderItemWhereInput[]
    OR?: TransferOrderItemWhereInput[]
    NOT?: TransferOrderItemWhereInput | TransferOrderItemWhereInput[]
    transferOrderId?: StringFilter<"TransferOrderItem"> | string
    productId?: StringFilter<"TransferOrderItem"> | string
    quantity?: DecimalFilter<"TransferOrderItem"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalNullableFilter<"TransferOrderItem"> | Decimal | DecimalJsLike | number | string | null
    transferOrder?: XOR<TransferOrderRelationFilter, TransferOrderWhereInput>
    product?: XOR<StoreProductRelationFilter, StoreProductWhereInput>
  }, "id">

  export type TransferOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    transferOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrderInput | SortOrder
    _count?: TransferOrderItemCountOrderByAggregateInput
    _avg?: TransferOrderItemAvgOrderByAggregateInput
    _max?: TransferOrderItemMaxOrderByAggregateInput
    _min?: TransferOrderItemMinOrderByAggregateInput
    _sum?: TransferOrderItemSumOrderByAggregateInput
  }

  export type TransferOrderItemScalarWhereWithAggregatesInput = {
    AND?: TransferOrderItemScalarWhereWithAggregatesInput | TransferOrderItemScalarWhereWithAggregatesInput[]
    OR?: TransferOrderItemScalarWhereWithAggregatesInput[]
    NOT?: TransferOrderItemScalarWhereWithAggregatesInput | TransferOrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransferOrderItem"> | string
    transferOrderId?: StringWithAggregatesFilter<"TransferOrderItem"> | string
    productId?: StringWithAggregatesFilter<"TransferOrderItem"> | string
    quantity?: DecimalWithAggregatesFilter<"TransferOrderItem"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalNullableWithAggregatesFilter<"TransferOrderItem"> | Decimal | DecimalJsLike | number | string | null
  }

  export type StoreCustomerWhereInput = {
    AND?: StoreCustomerWhereInput | StoreCustomerWhereInput[]
    OR?: StoreCustomerWhereInput[]
    NOT?: StoreCustomerWhereInput | StoreCustomerWhereInput[]
    id?: StringFilter<"StoreCustomer"> | string
    storeId?: StringFilter<"StoreCustomer"> | string
    firstName?: StringFilter<"StoreCustomer"> | string
    lastName?: StringNullableFilter<"StoreCustomer"> | string | null
    phone?: StringNullableFilter<"StoreCustomer"> | string | null
    email?: StringNullableFilter<"StoreCustomer"> | string | null
    address?: StringNullableFilter<"StoreCustomer"> | string | null
    taxId?: StringNullableFilter<"StoreCustomer"> | string | null
    notes?: StringNullableFilter<"StoreCustomer"> | string | null
    totalPurchases?: DecimalFilter<"StoreCustomer"> | Decimal | DecimalJsLike | number | string
    loyaltyPoints?: IntFilter<"StoreCustomer"> | number
    loyaltyTier?: EnumLoyaltyTierFilter<"StoreCustomer"> | $Enums.LoyaltyTier
    totalLifetimePurchases?: DecimalFilter<"StoreCustomer"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"StoreCustomer"> | boolean
    createdAt?: DateTimeFilter<"StoreCustomer"> | Date | string
    updatedAt?: DateTimeFilter<"StoreCustomer"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    sales?: SaleListRelationFilter
    loyaltyTransactions?: StoreLoyaltyTransactionListRelationFilter
  }

  export type StoreCustomerOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    totalPurchases?: SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    totalLifetimePurchases?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoreOrderByWithRelationInput
    sales?: SaleOrderByRelationAggregateInput
    loyaltyTransactions?: StoreLoyaltyTransactionOrderByRelationAggregateInput
  }

  export type StoreCustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoreCustomerWhereInput | StoreCustomerWhereInput[]
    OR?: StoreCustomerWhereInput[]
    NOT?: StoreCustomerWhereInput | StoreCustomerWhereInput[]
    storeId?: StringFilter<"StoreCustomer"> | string
    firstName?: StringFilter<"StoreCustomer"> | string
    lastName?: StringNullableFilter<"StoreCustomer"> | string | null
    phone?: StringNullableFilter<"StoreCustomer"> | string | null
    email?: StringNullableFilter<"StoreCustomer"> | string | null
    address?: StringNullableFilter<"StoreCustomer"> | string | null
    taxId?: StringNullableFilter<"StoreCustomer"> | string | null
    notes?: StringNullableFilter<"StoreCustomer"> | string | null
    totalPurchases?: DecimalFilter<"StoreCustomer"> | Decimal | DecimalJsLike | number | string
    loyaltyPoints?: IntFilter<"StoreCustomer"> | number
    loyaltyTier?: EnumLoyaltyTierFilter<"StoreCustomer"> | $Enums.LoyaltyTier
    totalLifetimePurchases?: DecimalFilter<"StoreCustomer"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"StoreCustomer"> | boolean
    createdAt?: DateTimeFilter<"StoreCustomer"> | Date | string
    updatedAt?: DateTimeFilter<"StoreCustomer"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    sales?: SaleListRelationFilter
    loyaltyTransactions?: StoreLoyaltyTransactionListRelationFilter
  }, "id">

  export type StoreCustomerOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    totalPurchases?: SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    totalLifetimePurchases?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoreCustomerCountOrderByAggregateInput
    _avg?: StoreCustomerAvgOrderByAggregateInput
    _max?: StoreCustomerMaxOrderByAggregateInput
    _min?: StoreCustomerMinOrderByAggregateInput
    _sum?: StoreCustomerSumOrderByAggregateInput
  }

  export type StoreCustomerScalarWhereWithAggregatesInput = {
    AND?: StoreCustomerScalarWhereWithAggregatesInput | StoreCustomerScalarWhereWithAggregatesInput[]
    OR?: StoreCustomerScalarWhereWithAggregatesInput[]
    NOT?: StoreCustomerScalarWhereWithAggregatesInput | StoreCustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoreCustomer"> | string
    storeId?: StringWithAggregatesFilter<"StoreCustomer"> | string
    firstName?: StringWithAggregatesFilter<"StoreCustomer"> | string
    lastName?: StringNullableWithAggregatesFilter<"StoreCustomer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"StoreCustomer"> | string | null
    email?: StringNullableWithAggregatesFilter<"StoreCustomer"> | string | null
    address?: StringNullableWithAggregatesFilter<"StoreCustomer"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"StoreCustomer"> | string | null
    notes?: StringNullableWithAggregatesFilter<"StoreCustomer"> | string | null
    totalPurchases?: DecimalWithAggregatesFilter<"StoreCustomer"> | Decimal | DecimalJsLike | number | string
    loyaltyPoints?: IntWithAggregatesFilter<"StoreCustomer"> | number
    loyaltyTier?: EnumLoyaltyTierWithAggregatesFilter<"StoreCustomer"> | $Enums.LoyaltyTier
    totalLifetimePurchases?: DecimalWithAggregatesFilter<"StoreCustomer"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolWithAggregatesFilter<"StoreCustomer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StoreCustomer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StoreCustomer"> | Date | string
  }

  export type StoreLoyaltyConfigWhereInput = {
    AND?: StoreLoyaltyConfigWhereInput | StoreLoyaltyConfigWhereInput[]
    OR?: StoreLoyaltyConfigWhereInput[]
    NOT?: StoreLoyaltyConfigWhereInput | StoreLoyaltyConfigWhereInput[]
    id?: StringFilter<"StoreLoyaltyConfig"> | string
    storeId?: StringFilter<"StoreLoyaltyConfig"> | string
    pointsPerGel?: IntFilter<"StoreLoyaltyConfig"> | number
    redemptionRate?: IntFilter<"StoreLoyaltyConfig"> | number
    minRedemptionPoints?: IntFilter<"StoreLoyaltyConfig"> | number
    expirationDays?: IntNullableFilter<"StoreLoyaltyConfig"> | number | null
    bronzeMinSpend?: DecimalNullableFilter<"StoreLoyaltyConfig"> | Decimal | DecimalJsLike | number | string | null
    silverMinSpend?: DecimalNullableFilter<"StoreLoyaltyConfig"> | Decimal | DecimalJsLike | number | string | null
    goldMinSpend?: DecimalNullableFilter<"StoreLoyaltyConfig"> | Decimal | DecimalJsLike | number | string | null
    platinumMinSpend?: DecimalNullableFilter<"StoreLoyaltyConfig"> | Decimal | DecimalJsLike | number | string | null
    goldDiscountPercent?: DecimalNullableFilter<"StoreLoyaltyConfig"> | Decimal | DecimalJsLike | number | string | null
    platinumDiscountPercent?: DecimalNullableFilter<"StoreLoyaltyConfig"> | Decimal | DecimalJsLike | number | string | null
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }

  export type StoreLoyaltyConfigOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    pointsPerGel?: SortOrder
    redemptionRate?: SortOrder
    minRedemptionPoints?: SortOrder
    expirationDays?: SortOrderInput | SortOrder
    bronzeMinSpend?: SortOrderInput | SortOrder
    silverMinSpend?: SortOrderInput | SortOrder
    goldMinSpend?: SortOrderInput | SortOrder
    platinumMinSpend?: SortOrderInput | SortOrder
    goldDiscountPercent?: SortOrderInput | SortOrder
    platinumDiscountPercent?: SortOrderInput | SortOrder
    store?: StoreOrderByWithRelationInput
  }

  export type StoreLoyaltyConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storeId?: string
    AND?: StoreLoyaltyConfigWhereInput | StoreLoyaltyConfigWhereInput[]
    OR?: StoreLoyaltyConfigWhereInput[]
    NOT?: StoreLoyaltyConfigWhereInput | StoreLoyaltyConfigWhereInput[]
    pointsPerGel?: IntFilter<"StoreLoyaltyConfig"> | number
    redemptionRate?: IntFilter<"StoreLoyaltyConfig"> | number
    minRedemptionPoints?: IntFilter<"StoreLoyaltyConfig"> | number
    expirationDays?: IntNullableFilter<"StoreLoyaltyConfig"> | number | null
    bronzeMinSpend?: DecimalNullableFilter<"StoreLoyaltyConfig"> | Decimal | DecimalJsLike | number | string | null
    silverMinSpend?: DecimalNullableFilter<"StoreLoyaltyConfig"> | Decimal | DecimalJsLike | number | string | null
    goldMinSpend?: DecimalNullableFilter<"StoreLoyaltyConfig"> | Decimal | DecimalJsLike | number | string | null
    platinumMinSpend?: DecimalNullableFilter<"StoreLoyaltyConfig"> | Decimal | DecimalJsLike | number | string | null
    goldDiscountPercent?: DecimalNullableFilter<"StoreLoyaltyConfig"> | Decimal | DecimalJsLike | number | string | null
    platinumDiscountPercent?: DecimalNullableFilter<"StoreLoyaltyConfig"> | Decimal | DecimalJsLike | number | string | null
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }, "id" | "storeId">

  export type StoreLoyaltyConfigOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    pointsPerGel?: SortOrder
    redemptionRate?: SortOrder
    minRedemptionPoints?: SortOrder
    expirationDays?: SortOrderInput | SortOrder
    bronzeMinSpend?: SortOrderInput | SortOrder
    silverMinSpend?: SortOrderInput | SortOrder
    goldMinSpend?: SortOrderInput | SortOrder
    platinumMinSpend?: SortOrderInput | SortOrder
    goldDiscountPercent?: SortOrderInput | SortOrder
    platinumDiscountPercent?: SortOrderInput | SortOrder
    _count?: StoreLoyaltyConfigCountOrderByAggregateInput
    _avg?: StoreLoyaltyConfigAvgOrderByAggregateInput
    _max?: StoreLoyaltyConfigMaxOrderByAggregateInput
    _min?: StoreLoyaltyConfigMinOrderByAggregateInput
    _sum?: StoreLoyaltyConfigSumOrderByAggregateInput
  }

  export type StoreLoyaltyConfigScalarWhereWithAggregatesInput = {
    AND?: StoreLoyaltyConfigScalarWhereWithAggregatesInput | StoreLoyaltyConfigScalarWhereWithAggregatesInput[]
    OR?: StoreLoyaltyConfigScalarWhereWithAggregatesInput[]
    NOT?: StoreLoyaltyConfigScalarWhereWithAggregatesInput | StoreLoyaltyConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoreLoyaltyConfig"> | string
    storeId?: StringWithAggregatesFilter<"StoreLoyaltyConfig"> | string
    pointsPerGel?: IntWithAggregatesFilter<"StoreLoyaltyConfig"> | number
    redemptionRate?: IntWithAggregatesFilter<"StoreLoyaltyConfig"> | number
    minRedemptionPoints?: IntWithAggregatesFilter<"StoreLoyaltyConfig"> | number
    expirationDays?: IntNullableWithAggregatesFilter<"StoreLoyaltyConfig"> | number | null
    bronzeMinSpend?: DecimalNullableWithAggregatesFilter<"StoreLoyaltyConfig"> | Decimal | DecimalJsLike | number | string | null
    silverMinSpend?: DecimalNullableWithAggregatesFilter<"StoreLoyaltyConfig"> | Decimal | DecimalJsLike | number | string | null
    goldMinSpend?: DecimalNullableWithAggregatesFilter<"StoreLoyaltyConfig"> | Decimal | DecimalJsLike | number | string | null
    platinumMinSpend?: DecimalNullableWithAggregatesFilter<"StoreLoyaltyConfig"> | Decimal | DecimalJsLike | number | string | null
    goldDiscountPercent?: DecimalNullableWithAggregatesFilter<"StoreLoyaltyConfig"> | Decimal | DecimalJsLike | number | string | null
    platinumDiscountPercent?: DecimalNullableWithAggregatesFilter<"StoreLoyaltyConfig"> | Decimal | DecimalJsLike | number | string | null
  }

  export type StoreLoyaltyTransactionWhereInput = {
    AND?: StoreLoyaltyTransactionWhereInput | StoreLoyaltyTransactionWhereInput[]
    OR?: StoreLoyaltyTransactionWhereInput[]
    NOT?: StoreLoyaltyTransactionWhereInput | StoreLoyaltyTransactionWhereInput[]
    id?: StringFilter<"StoreLoyaltyTransaction"> | string
    customerId?: StringFilter<"StoreLoyaltyTransaction"> | string
    type?: EnumLoyaltyTransactionTypeFilter<"StoreLoyaltyTransaction"> | $Enums.LoyaltyTransactionType
    points?: IntFilter<"StoreLoyaltyTransaction"> | number
    saleId?: StringNullableFilter<"StoreLoyaltyTransaction"> | string | null
    description?: StringNullableFilter<"StoreLoyaltyTransaction"> | string | null
    createdAt?: DateTimeFilter<"StoreLoyaltyTransaction"> | Date | string
    customer?: XOR<StoreCustomerRelationFilter, StoreCustomerWhereInput>
  }

  export type StoreLoyaltyTransactionOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    points?: SortOrder
    saleId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    customer?: StoreCustomerOrderByWithRelationInput
  }

  export type StoreLoyaltyTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoreLoyaltyTransactionWhereInput | StoreLoyaltyTransactionWhereInput[]
    OR?: StoreLoyaltyTransactionWhereInput[]
    NOT?: StoreLoyaltyTransactionWhereInput | StoreLoyaltyTransactionWhereInput[]
    customerId?: StringFilter<"StoreLoyaltyTransaction"> | string
    type?: EnumLoyaltyTransactionTypeFilter<"StoreLoyaltyTransaction"> | $Enums.LoyaltyTransactionType
    points?: IntFilter<"StoreLoyaltyTransaction"> | number
    saleId?: StringNullableFilter<"StoreLoyaltyTransaction"> | string | null
    description?: StringNullableFilter<"StoreLoyaltyTransaction"> | string | null
    createdAt?: DateTimeFilter<"StoreLoyaltyTransaction"> | Date | string
    customer?: XOR<StoreCustomerRelationFilter, StoreCustomerWhereInput>
  }, "id">

  export type StoreLoyaltyTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    points?: SortOrder
    saleId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StoreLoyaltyTransactionCountOrderByAggregateInput
    _avg?: StoreLoyaltyTransactionAvgOrderByAggregateInput
    _max?: StoreLoyaltyTransactionMaxOrderByAggregateInput
    _min?: StoreLoyaltyTransactionMinOrderByAggregateInput
    _sum?: StoreLoyaltyTransactionSumOrderByAggregateInput
  }

  export type StoreLoyaltyTransactionScalarWhereWithAggregatesInput = {
    AND?: StoreLoyaltyTransactionScalarWhereWithAggregatesInput | StoreLoyaltyTransactionScalarWhereWithAggregatesInput[]
    OR?: StoreLoyaltyTransactionScalarWhereWithAggregatesInput[]
    NOT?: StoreLoyaltyTransactionScalarWhereWithAggregatesInput | StoreLoyaltyTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoreLoyaltyTransaction"> | string
    customerId?: StringWithAggregatesFilter<"StoreLoyaltyTransaction"> | string
    type?: EnumLoyaltyTransactionTypeWithAggregatesFilter<"StoreLoyaltyTransaction"> | $Enums.LoyaltyTransactionType
    points?: IntWithAggregatesFilter<"StoreLoyaltyTransaction"> | number
    saleId?: StringNullableWithAggregatesFilter<"StoreLoyaltyTransaction"> | string | null
    description?: StringNullableWithAggregatesFilter<"StoreLoyaltyTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StoreLoyaltyTransaction"> | Date | string
  }

  export type StoreTaxRuleWhereInput = {
    AND?: StoreTaxRuleWhereInput | StoreTaxRuleWhereInput[]
    OR?: StoreTaxRuleWhereInput[]
    NOT?: StoreTaxRuleWhereInput | StoreTaxRuleWhereInput[]
    id?: StringFilter<"StoreTaxRule"> | string
    storeId?: StringFilter<"StoreTaxRule"> | string
    name?: StringFilter<"StoreTaxRule"> | string
    rate?: DecimalFilter<"StoreTaxRule"> | Decimal | DecimalJsLike | number | string
    isDefault?: BoolFilter<"StoreTaxRule"> | boolean
    isActive?: BoolFilter<"StoreTaxRule"> | boolean
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    products?: StoreProductListRelationFilter
  }

  export type StoreTaxRuleOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    store?: StoreOrderByWithRelationInput
    products?: StoreProductOrderByRelationAggregateInput
  }

  export type StoreTaxRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoreTaxRuleWhereInput | StoreTaxRuleWhereInput[]
    OR?: StoreTaxRuleWhereInput[]
    NOT?: StoreTaxRuleWhereInput | StoreTaxRuleWhereInput[]
    storeId?: StringFilter<"StoreTaxRule"> | string
    name?: StringFilter<"StoreTaxRule"> | string
    rate?: DecimalFilter<"StoreTaxRule"> | Decimal | DecimalJsLike | number | string
    isDefault?: BoolFilter<"StoreTaxRule"> | boolean
    isActive?: BoolFilter<"StoreTaxRule"> | boolean
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    products?: StoreProductListRelationFilter
  }, "id">

  export type StoreTaxRuleOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    _count?: StoreTaxRuleCountOrderByAggregateInput
    _avg?: StoreTaxRuleAvgOrderByAggregateInput
    _max?: StoreTaxRuleMaxOrderByAggregateInput
    _min?: StoreTaxRuleMinOrderByAggregateInput
    _sum?: StoreTaxRuleSumOrderByAggregateInput
  }

  export type StoreTaxRuleScalarWhereWithAggregatesInput = {
    AND?: StoreTaxRuleScalarWhereWithAggregatesInput | StoreTaxRuleScalarWhereWithAggregatesInput[]
    OR?: StoreTaxRuleScalarWhereWithAggregatesInput[]
    NOT?: StoreTaxRuleScalarWhereWithAggregatesInput | StoreTaxRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoreTaxRule"> | string
    storeId?: StringWithAggregatesFilter<"StoreTaxRule"> | string
    name?: StringWithAggregatesFilter<"StoreTaxRule"> | string
    rate?: DecimalWithAggregatesFilter<"StoreTaxRule"> | Decimal | DecimalJsLike | number | string
    isDefault?: BoolWithAggregatesFilter<"StoreTaxRule"> | boolean
    isActive?: BoolWithAggregatesFilter<"StoreTaxRule"> | boolean
  }

  export type StorePaymentConfigWhereInput = {
    AND?: StorePaymentConfigWhereInput | StorePaymentConfigWhereInput[]
    OR?: StorePaymentConfigWhereInput[]
    NOT?: StorePaymentConfigWhereInput | StorePaymentConfigWhereInput[]
    id?: StringFilter<"StorePaymentConfig"> | string
    storeId?: StringFilter<"StorePaymentConfig"> | string
    name?: StringFilter<"StorePaymentConfig"> | string
    type?: EnumPaymentMethodFilter<"StorePaymentConfig"> | $Enums.PaymentMethod
    isActive?: BoolFilter<"StorePaymentConfig"> | boolean
    sortOrder?: IntFilter<"StorePaymentConfig"> | number
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }

  export type StorePaymentConfigOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    store?: StoreOrderByWithRelationInput
  }

  export type StorePaymentConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StorePaymentConfigWhereInput | StorePaymentConfigWhereInput[]
    OR?: StorePaymentConfigWhereInput[]
    NOT?: StorePaymentConfigWhereInput | StorePaymentConfigWhereInput[]
    storeId?: StringFilter<"StorePaymentConfig"> | string
    name?: StringFilter<"StorePaymentConfig"> | string
    type?: EnumPaymentMethodFilter<"StorePaymentConfig"> | $Enums.PaymentMethod
    isActive?: BoolFilter<"StorePaymentConfig"> | boolean
    sortOrder?: IntFilter<"StorePaymentConfig"> | number
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }, "id">

  export type StorePaymentConfigOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    _count?: StorePaymentConfigCountOrderByAggregateInput
    _avg?: StorePaymentConfigAvgOrderByAggregateInput
    _max?: StorePaymentConfigMaxOrderByAggregateInput
    _min?: StorePaymentConfigMinOrderByAggregateInput
    _sum?: StorePaymentConfigSumOrderByAggregateInput
  }

  export type StorePaymentConfigScalarWhereWithAggregatesInput = {
    AND?: StorePaymentConfigScalarWhereWithAggregatesInput | StorePaymentConfigScalarWhereWithAggregatesInput[]
    OR?: StorePaymentConfigScalarWhereWithAggregatesInput[]
    NOT?: StorePaymentConfigScalarWhereWithAggregatesInput | StorePaymentConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StorePaymentConfig"> | string
    storeId?: StringWithAggregatesFilter<"StorePaymentConfig"> | string
    name?: StringWithAggregatesFilter<"StorePaymentConfig"> | string
    type?: EnumPaymentMethodWithAggregatesFilter<"StorePaymentConfig"> | $Enums.PaymentMethod
    isActive?: BoolWithAggregatesFilter<"StorePaymentConfig"> | boolean
    sortOrder?: IntWithAggregatesFilter<"StorePaymentConfig"> | number
  }

  export type StoreReceiptConfigWhereInput = {
    AND?: StoreReceiptConfigWhereInput | StoreReceiptConfigWhereInput[]
    OR?: StoreReceiptConfigWhereInput[]
    NOT?: StoreReceiptConfigWhereInput | StoreReceiptConfigWhereInput[]
    id?: StringFilter<"StoreReceiptConfig"> | string
    storeId?: StringFilter<"StoreReceiptConfig"> | string
    headerText?: StringNullableFilter<"StoreReceiptConfig"> | string | null
    footerText?: StringNullableFilter<"StoreReceiptConfig"> | string | null
    showLogo?: BoolFilter<"StoreReceiptConfig"> | boolean
    showTaxId?: BoolFilter<"StoreReceiptConfig"> | boolean
    showBarcode?: BoolFilter<"StoreReceiptConfig"> | boolean
    paperWidth?: IntFilter<"StoreReceiptConfig"> | number
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }

  export type StoreReceiptConfigOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    headerText?: SortOrderInput | SortOrder
    footerText?: SortOrderInput | SortOrder
    showLogo?: SortOrder
    showTaxId?: SortOrder
    showBarcode?: SortOrder
    paperWidth?: SortOrder
    store?: StoreOrderByWithRelationInput
  }

  export type StoreReceiptConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storeId?: string
    AND?: StoreReceiptConfigWhereInput | StoreReceiptConfigWhereInput[]
    OR?: StoreReceiptConfigWhereInput[]
    NOT?: StoreReceiptConfigWhereInput | StoreReceiptConfigWhereInput[]
    headerText?: StringNullableFilter<"StoreReceiptConfig"> | string | null
    footerText?: StringNullableFilter<"StoreReceiptConfig"> | string | null
    showLogo?: BoolFilter<"StoreReceiptConfig"> | boolean
    showTaxId?: BoolFilter<"StoreReceiptConfig"> | boolean
    showBarcode?: BoolFilter<"StoreReceiptConfig"> | boolean
    paperWidth?: IntFilter<"StoreReceiptConfig"> | number
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }, "id" | "storeId">

  export type StoreReceiptConfigOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    headerText?: SortOrderInput | SortOrder
    footerText?: SortOrderInput | SortOrder
    showLogo?: SortOrder
    showTaxId?: SortOrder
    showBarcode?: SortOrder
    paperWidth?: SortOrder
    _count?: StoreReceiptConfigCountOrderByAggregateInput
    _avg?: StoreReceiptConfigAvgOrderByAggregateInput
    _max?: StoreReceiptConfigMaxOrderByAggregateInput
    _min?: StoreReceiptConfigMinOrderByAggregateInput
    _sum?: StoreReceiptConfigSumOrderByAggregateInput
  }

  export type StoreReceiptConfigScalarWhereWithAggregatesInput = {
    AND?: StoreReceiptConfigScalarWhereWithAggregatesInput | StoreReceiptConfigScalarWhereWithAggregatesInput[]
    OR?: StoreReceiptConfigScalarWhereWithAggregatesInput[]
    NOT?: StoreReceiptConfigScalarWhereWithAggregatesInput | StoreReceiptConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoreReceiptConfig"> | string
    storeId?: StringWithAggregatesFilter<"StoreReceiptConfig"> | string
    headerText?: StringNullableWithAggregatesFilter<"StoreReceiptConfig"> | string | null
    footerText?: StringNullableWithAggregatesFilter<"StoreReceiptConfig"> | string | null
    showLogo?: BoolWithAggregatesFilter<"StoreReceiptConfig"> | boolean
    showTaxId?: BoolWithAggregatesFilter<"StoreReceiptConfig"> | boolean
    showBarcode?: BoolWithAggregatesFilter<"StoreReceiptConfig"> | boolean
    paperWidth?: IntWithAggregatesFilter<"StoreReceiptConfig"> | number
  }

  export type StoreDeviceConfigWhereInput = {
    AND?: StoreDeviceConfigWhereInput | StoreDeviceConfigWhereInput[]
    OR?: StoreDeviceConfigWhereInput[]
    NOT?: StoreDeviceConfigWhereInput | StoreDeviceConfigWhereInput[]
    id?: StringFilter<"StoreDeviceConfig"> | string
    storeId?: StringFilter<"StoreDeviceConfig"> | string
    deviceType?: EnumStoreDeviceTypeFilter<"StoreDeviceConfig"> | $Enums.StoreDeviceType
    name?: StringFilter<"StoreDeviceConfig"> | string
    connectionType?: StringFilter<"StoreDeviceConfig"> | string
    settings?: JsonFilter<"StoreDeviceConfig">
    isActive?: BoolFilter<"StoreDeviceConfig"> | boolean
    createdAt?: DateTimeFilter<"StoreDeviceConfig"> | Date | string
    updatedAt?: DateTimeFilter<"StoreDeviceConfig"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }

  export type StoreDeviceConfigOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    deviceType?: SortOrder
    name?: SortOrder
    connectionType?: SortOrder
    settings?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoreOrderByWithRelationInput
  }

  export type StoreDeviceConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoreDeviceConfigWhereInput | StoreDeviceConfigWhereInput[]
    OR?: StoreDeviceConfigWhereInput[]
    NOT?: StoreDeviceConfigWhereInput | StoreDeviceConfigWhereInput[]
    storeId?: StringFilter<"StoreDeviceConfig"> | string
    deviceType?: EnumStoreDeviceTypeFilter<"StoreDeviceConfig"> | $Enums.StoreDeviceType
    name?: StringFilter<"StoreDeviceConfig"> | string
    connectionType?: StringFilter<"StoreDeviceConfig"> | string
    settings?: JsonFilter<"StoreDeviceConfig">
    isActive?: BoolFilter<"StoreDeviceConfig"> | boolean
    createdAt?: DateTimeFilter<"StoreDeviceConfig"> | Date | string
    updatedAt?: DateTimeFilter<"StoreDeviceConfig"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }, "id">

  export type StoreDeviceConfigOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    deviceType?: SortOrder
    name?: SortOrder
    connectionType?: SortOrder
    settings?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoreDeviceConfigCountOrderByAggregateInput
    _max?: StoreDeviceConfigMaxOrderByAggregateInput
    _min?: StoreDeviceConfigMinOrderByAggregateInput
  }

  export type StoreDeviceConfigScalarWhereWithAggregatesInput = {
    AND?: StoreDeviceConfigScalarWhereWithAggregatesInput | StoreDeviceConfigScalarWhereWithAggregatesInput[]
    OR?: StoreDeviceConfigScalarWhereWithAggregatesInput[]
    NOT?: StoreDeviceConfigScalarWhereWithAggregatesInput | StoreDeviceConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoreDeviceConfig"> | string
    storeId?: StringWithAggregatesFilter<"StoreDeviceConfig"> | string
    deviceType?: EnumStoreDeviceTypeWithAggregatesFilter<"StoreDeviceConfig"> | $Enums.StoreDeviceType
    name?: StringWithAggregatesFilter<"StoreDeviceConfig"> | string
    connectionType?: StringWithAggregatesFilter<"StoreDeviceConfig"> | string
    settings?: JsonWithAggregatesFilter<"StoreDeviceConfig">
    isActive?: BoolWithAggregatesFilter<"StoreDeviceConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StoreDeviceConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StoreDeviceConfig"> | Date | string
  }

  export type StoreIntegrationWhereInput = {
    AND?: StoreIntegrationWhereInput | StoreIntegrationWhereInput[]
    OR?: StoreIntegrationWhereInput[]
    NOT?: StoreIntegrationWhereInput | StoreIntegrationWhereInput[]
    id?: StringFilter<"StoreIntegration"> | string
    storeId?: StringFilter<"StoreIntegration"> | string
    type?: EnumStoreIntegrationTypeFilter<"StoreIntegration"> | $Enums.StoreIntegrationType
    name?: StringFilter<"StoreIntegration"> | string
    credentials?: JsonNullableFilter<"StoreIntegration">
    settings?: JsonNullableFilter<"StoreIntegration">
    lastSyncAt?: DateTimeNullableFilter<"StoreIntegration"> | Date | string | null
    isActive?: BoolFilter<"StoreIntegration"> | boolean
    createdAt?: DateTimeFilter<"StoreIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"StoreIntegration"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }

  export type StoreIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    credentials?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    store?: StoreOrderByWithRelationInput
  }

  export type StoreIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoreIntegrationWhereInput | StoreIntegrationWhereInput[]
    OR?: StoreIntegrationWhereInput[]
    NOT?: StoreIntegrationWhereInput | StoreIntegrationWhereInput[]
    storeId?: StringFilter<"StoreIntegration"> | string
    type?: EnumStoreIntegrationTypeFilter<"StoreIntegration"> | $Enums.StoreIntegrationType
    name?: StringFilter<"StoreIntegration"> | string
    credentials?: JsonNullableFilter<"StoreIntegration">
    settings?: JsonNullableFilter<"StoreIntegration">
    lastSyncAt?: DateTimeNullableFilter<"StoreIntegration"> | Date | string | null
    isActive?: BoolFilter<"StoreIntegration"> | boolean
    createdAt?: DateTimeFilter<"StoreIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"StoreIntegration"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }, "id">

  export type StoreIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    credentials?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoreIntegrationCountOrderByAggregateInput
    _max?: StoreIntegrationMaxOrderByAggregateInput
    _min?: StoreIntegrationMinOrderByAggregateInput
  }

  export type StoreIntegrationScalarWhereWithAggregatesInput = {
    AND?: StoreIntegrationScalarWhereWithAggregatesInput | StoreIntegrationScalarWhereWithAggregatesInput[]
    OR?: StoreIntegrationScalarWhereWithAggregatesInput[]
    NOT?: StoreIntegrationScalarWhereWithAggregatesInput | StoreIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoreIntegration"> | string
    storeId?: StringWithAggregatesFilter<"StoreIntegration"> | string
    type?: EnumStoreIntegrationTypeWithAggregatesFilter<"StoreIntegration"> | $Enums.StoreIntegrationType
    name?: StringWithAggregatesFilter<"StoreIntegration"> | string
    credentials?: JsonNullableWithAggregatesFilter<"StoreIntegration">
    settings?: JsonNullableWithAggregatesFilter<"StoreIntegration">
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"StoreIntegration"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"StoreIntegration"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StoreIntegration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StoreIntegration"> | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    logo?: string | null
    company?: string | null
    taxId?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    tenantId?: string
    hotelCode: string
    storeCode?: string | null
    databaseUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    logo?: string | null
    company?: string | null
    taxId?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    tenantId?: string
    hotelCode: string
    storeCode?: string | null
    databaseUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    hotelCode?: StringFieldUpdateOperationsInput | string
    storeCode?: NullableStringFieldUpdateOperationsInput | string | null
    databaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    hotelCode?: StringFieldUpdateOperationsInput | string
    storeCode?: NullableStringFieldUpdateOperationsInput | string | null
    databaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    logo?: string | null
    company?: string | null
    taxId?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    tenantId?: string
    hotelCode: string
    storeCode?: string | null
    databaseUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    hotelCode?: StringFieldUpdateOperationsInput | string
    storeCode?: NullableStringFieldUpdateOperationsInput | string | null
    databaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    hotelCode?: StringFieldUpdateOperationsInput | string
    storeCode?: NullableStringFieldUpdateOperationsInput | string | null
    databaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    avatar?: string | null
    emailVerified?: Date | string | null
    lastLoginAt?: Date | string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    avatar?: string | null
    emailVerified?: Date | string | null
    lastLoginAt?: Date | string | null
    organizationId?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    avatar?: string | null
    emailVerified?: Date | string | null
    lastLoginAt?: Date | string | null
    organizationId?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreCreateInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeCreateNestedManyWithoutStoreInput
    products?: StoreProductCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeUncheckedCreateNestedManyWithoutStoreInput
    products?: StoreProductUncheckedCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderUncheckedCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierUncheckedCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerUncheckedCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleUncheckedCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderUncheckedCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderUncheckedCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigUncheckedCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigUncheckedCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigUncheckedCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUpdateManyWithoutStoreNestedInput
    products?: StoreProductUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUncheckedUpdateManyWithoutStoreNestedInput
    products?: StoreProductUncheckedUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUncheckedUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUncheckedUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUncheckedUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUncheckedUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUncheckedUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUncheckedUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUncheckedUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUncheckedUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUncheckedUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreEmployeeCreateInput = {
    id?: string
    userId?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    role?: string
    pin?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutEmployeesInput
    sales?: SaleCreateNestedManyWithoutEmployeeInput
  }

  export type StoreEmployeeUncheckedCreateInput = {
    id?: string
    storeId: string
    userId?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    role?: string
    pin?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type StoreEmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutEmployeesNestedInput
    sales?: SaleUpdateManyWithoutEmployeeNestedInput
  }

  export type StoreEmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type StoreEmployeeCreateManyInput = {
    id?: string
    storeId: string
    userId?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    role?: string
    pin?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreEmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreEmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryCreateInput = {
    id?: string
    name: string
    nameKa?: string | null
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutCategoriesInput
    parent?: ProductCategoryCreateNestedOneWithoutChildrenInput
    children?: ProductCategoryCreateNestedManyWithoutParentInput
    products?: StoreProductCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id?: string
    storeId: string
    name: string
    nameKa?: string | null
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    sortOrder?: number
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ProductCategoryUncheckedCreateNestedManyWithoutParentInput
    products?: StoreProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutCategoriesNestedInput
    parent?: ProductCategoryUpdateOneWithoutChildrenNestedInput
    children?: ProductCategoryUpdateManyWithoutParentNestedInput
    products?: StoreProductUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ProductCategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: StoreProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryCreateManyInput = {
    id?: string
    storeId: string
    name: string
    nameKa?: string | null
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    sortOrder?: number
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreProductCreateInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutProductsInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    taxRule?: StoreTaxRuleCreateNestedOneWithoutProductsInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    saleReturnItems?: SaleReturnItemCreateNestedManyWithoutProductInput
    purchaseItems?: StorePurchaseItemCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    priceHistory?: StorePriceHistoryCreateNestedManyWithoutProductInput
    transferOrderItems?: TransferOrderItemCreateNestedManyWithoutProductInput
  }

  export type StoreProductUncheckedCreateInput = {
    id?: string
    storeId: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    taxRuleId?: string | null
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    saleReturnItems?: SaleReturnItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: StorePurchaseItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: StorePriceHistoryUncheckedCreateNestedManyWithoutProductInput
    transferOrderItems?: TransferOrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type StoreProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    taxRule?: StoreTaxRuleUpdateOneWithoutProductsNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    saleReturnItems?: SaleReturnItemUpdateManyWithoutProductNestedInput
    purchaseItems?: StorePurchaseItemUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    priceHistory?: StorePriceHistoryUpdateManyWithoutProductNestedInput
    transferOrderItems?: TransferOrderItemUpdateManyWithoutProductNestedInput
  }

  export type StoreProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    taxRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    saleReturnItems?: SaleReturnItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: StorePurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: StorePriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    transferOrderItems?: TransferOrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StoreProductCreateManyInput = {
    id?: string
    storeId: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    taxRuleId?: string | null
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    taxRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorePriceHistoryCreateInput = {
    id?: string
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    changedBy?: string | null
    changedAt?: Date | string
    product: StoreProductCreateNestedOneWithoutPriceHistoryInput
  }

  export type StorePriceHistoryUncheckedCreateInput = {
    id?: string
    productId: string
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    changedBy?: string | null
    changedAt?: Date | string
  }

  export type StorePriceHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: StoreProductUpdateOneRequiredWithoutPriceHistoryNestedInput
  }

  export type StorePriceHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorePriceHistoryCreateManyInput = {
    id?: string
    productId: string
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    changedBy?: string | null
    changedAt?: Date | string
  }

  export type StorePriceHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorePriceHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateInput = {
    id?: string
    saleNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.StoreDiscountType | null
    total: Decimal | DecimalJsLike | number | string
    paidAmount: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.StoreSaleStatus
    notes?: string | null
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSalesInput
    customer?: StoreCustomerCreateNestedOneWithoutSalesInput
    employee?: StoreEmployeeCreateNestedOneWithoutSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
    payments?: SalePaymentCreateNestedManyWithoutSaleInput
    returns?: SaleReturnCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateInput = {
    id?: string
    storeId: string
    saleNumber: string
    customerId?: string | null
    employeeId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.StoreDiscountType | null
    total: Decimal | DecimalJsLike | number | string
    paidAmount: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.StoreSaleStatus
    notes?: string | null
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
    payments?: SalePaymentUncheckedCreateNestedManyWithoutSaleInput
    returns?: SaleReturnUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumStoreDiscountTypeFieldUpdateOperationsInput | $Enums.StoreDiscountType | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFieldUpdateOperationsInput | $Enums.StoreSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSalesNestedInput
    customer?: StoreCustomerUpdateOneWithoutSalesNestedInput
    employee?: StoreEmployeeUpdateOneWithoutSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUpdateManyWithoutSaleNestedInput
    returns?: SaleReturnUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumStoreDiscountTypeFieldUpdateOperationsInput | $Enums.StoreDiscountType | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFieldUpdateOperationsInput | $Enums.StoreSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUncheckedUpdateManyWithoutSaleNestedInput
    returns?: SaleReturnUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleCreateManyInput = {
    id?: string
    storeId: string
    saleNumber: string
    customerId?: string | null
    employeeId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.StoreDiscountType | null
    total: Decimal | DecimalJsLike | number | string
    paidAmount: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.StoreSaleStatus
    notes?: string | null
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumStoreDiscountTypeFieldUpdateOperationsInput | $Enums.StoreDiscountType | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFieldUpdateOperationsInput | $Enums.StoreSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumStoreDiscountTypeFieldUpdateOperationsInput | $Enums.StoreDiscountType | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFieldUpdateOperationsInput | $Enums.StoreSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemCreateInput = {
    id?: string
    productName: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    sale: SaleCreateNestedOneWithoutItemsInput
    product: StoreProductCreateNestedOneWithoutSaleItemsInput
  }

  export type SaleItemUncheckedCreateInput = {
    id?: string
    saleId: string
    productId: string
    productName: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type SaleItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale?: SaleUpdateOneRequiredWithoutItemsNestedInput
    product?: StoreProductUpdateOneRequiredWithoutSaleItemsNestedInput
  }

  export type SaleItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleItemCreateManyInput = {
    id?: string
    saleId: string
    productId: string
    productName: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type SaleItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalePaymentCreateInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdAt?: Date | string
    sale: SaleCreateNestedOneWithoutPaymentsInput
  }

  export type SalePaymentUncheckedCreateInput = {
    id?: string
    saleId: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdAt?: Date | string
  }

  export type SalePaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type SalePaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalePaymentCreateManyInput = {
    id?: string
    saleId: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdAt?: Date | string
  }

  export type SalePaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalePaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleReturnCreateInput = {
    id?: string
    reason: string
    refundAmount: Decimal | DecimalJsLike | number | string
    refundMethod: $Enums.PaymentMethod
    status?: $Enums.StoreReturnStatus
    createdAt?: Date | string
    processedAt?: Date | string | null
    sale: SaleCreateNestedOneWithoutReturnsInput
    items?: SaleReturnItemCreateNestedManyWithoutSaleReturnInput
  }

  export type SaleReturnUncheckedCreateInput = {
    id?: string
    saleId: string
    reason: string
    refundAmount: Decimal | DecimalJsLike | number | string
    refundMethod: $Enums.PaymentMethod
    status?: $Enums.StoreReturnStatus
    createdAt?: Date | string
    processedAt?: Date | string | null
    items?: SaleReturnItemUncheckedCreateNestedManyWithoutSaleReturnInput
  }

  export type SaleReturnUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumStoreReturnStatusFieldUpdateOperationsInput | $Enums.StoreReturnStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale?: SaleUpdateOneRequiredWithoutReturnsNestedInput
    items?: SaleReturnItemUpdateManyWithoutSaleReturnNestedInput
  }

  export type SaleReturnUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumStoreReturnStatusFieldUpdateOperationsInput | $Enums.StoreReturnStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: SaleReturnItemUncheckedUpdateManyWithoutSaleReturnNestedInput
  }

  export type SaleReturnCreateManyInput = {
    id?: string
    saleId: string
    reason: string
    refundAmount: Decimal | DecimalJsLike | number | string
    refundMethod: $Enums.PaymentMethod
    status?: $Enums.StoreReturnStatus
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type SaleReturnUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumStoreReturnStatusFieldUpdateOperationsInput | $Enums.StoreReturnStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SaleReturnUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumStoreReturnStatusFieldUpdateOperationsInput | $Enums.StoreReturnStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SaleReturnItemCreateInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    refundAmount: Decimal | DecimalJsLike | number | string
    saleReturn: SaleReturnCreateNestedOneWithoutItemsInput
    product: StoreProductCreateNestedOneWithoutSaleReturnItemsInput
  }

  export type SaleReturnItemUncheckedCreateInput = {
    id?: string
    returnId: string
    productId: string
    quantity: Decimal | DecimalJsLike | number | string
    refundAmount: Decimal | DecimalJsLike | number | string
  }

  export type SaleReturnItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    saleReturn?: SaleReturnUpdateOneRequiredWithoutItemsNestedInput
    product?: StoreProductUpdateOneRequiredWithoutSaleReturnItemsNestedInput
  }

  export type SaleReturnItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleReturnItemCreateManyInput = {
    id?: string
    returnId: string
    productId: string
    quantity: Decimal | DecimalJsLike | number | string
    refundAmount: Decimal | DecimalJsLike | number | string
  }

  export type SaleReturnItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleReturnItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type StoreSupplierCreateInput = {
    id?: string
    name: string
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSuppliersInput
    purchaseOrders?: StorePurchaseOrderCreateNestedManyWithoutSupplierInput
  }

  export type StoreSupplierUncheckedCreateInput = {
    id?: string
    storeId: string
    name: string
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: StorePurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type StoreSupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSuppliersNestedInput
    purchaseOrders?: StorePurchaseOrderUpdateManyWithoutSupplierNestedInput
  }

  export type StoreSupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: StorePurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type StoreSupplierCreateManyInput = {
    id?: string
    storeId: string
    name: string
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreSupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreSupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorePurchaseOrderCreateInput = {
    id?: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.StorePurchaseStatus
    notes?: string | null
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutPurchasesInput
    supplier: StoreSupplierCreateNestedOneWithoutPurchaseOrdersInput
    items?: StorePurchaseItemCreateNestedManyWithoutPurchaseOrderInput
  }

  export type StorePurchaseOrderUncheckedCreateInput = {
    id?: string
    storeId: string
    supplierId: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.StorePurchaseStatus
    notes?: string | null
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: StorePurchaseItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type StorePurchaseOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStorePurchaseStatusFieldUpdateOperationsInput | $Enums.StorePurchaseStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutPurchasesNestedInput
    supplier?: StoreSupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: StorePurchaseItemUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type StorePurchaseOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStorePurchaseStatusFieldUpdateOperationsInput | $Enums.StorePurchaseStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: StorePurchaseItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type StorePurchaseOrderCreateManyInput = {
    id?: string
    storeId: string
    supplierId: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.StorePurchaseStatus
    notes?: string | null
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorePurchaseOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStorePurchaseStatusFieldUpdateOperationsInput | $Enums.StorePurchaseStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorePurchaseOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStorePurchaseStatusFieldUpdateOperationsInput | $Enums.StorePurchaseStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorePurchaseItemCreateInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedQty?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    purchaseOrder: StorePurchaseOrderCreateNestedOneWithoutItemsInput
    product: StoreProductCreateNestedOneWithoutPurchaseItemsInput
  }

  export type StorePurchaseItemUncheckedCreateInput = {
    id?: string
    purchaseOrderId: string
    productId: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedQty?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type StorePurchaseItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseOrder?: StorePurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
    product?: StoreProductUpdateOneRequiredWithoutPurchaseItemsNestedInput
  }

  export type StorePurchaseItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type StorePurchaseItemCreateManyInput = {
    id?: string
    purchaseOrderId: string
    productId: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedQty?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type StorePurchaseItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type StorePurchaseItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type StockMovementCreateInput = {
    id?: string
    type: $Enums.StoreMovementType
    quantity: Decimal | DecimalJsLike | number | string
    previousStock: Decimal | DecimalJsLike | number | string
    newStock: Decimal | DecimalJsLike | number | string
    reason?: string | null
    referenceType?: string | null
    referenceId?: string | null
    performedBy?: string | null
    createdAt?: Date | string
    store: StoreCreateNestedOneWithoutStockMovementsInput
    product: StoreProductCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateInput = {
    id?: string
    storeId: string
    productId: string
    type: $Enums.StoreMovementType
    quantity: Decimal | DecimalJsLike | number | string
    previousStock: Decimal | DecimalJsLike | number | string
    newStock: Decimal | DecimalJsLike | number | string
    reason?: string | null
    referenceType?: string | null
    referenceId?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type StockMovementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStoreMovementTypeFieldUpdateOperationsInput | $Enums.StoreMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    previousStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutStockMovementsNestedInput
    product?: StoreProductUpdateOneRequiredWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    type?: EnumStoreMovementTypeFieldUpdateOperationsInput | $Enums.StoreMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    previousStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementCreateManyInput = {
    id?: string
    storeId: string
    productId: string
    type: $Enums.StoreMovementType
    quantity: Decimal | DecimalJsLike | number | string
    previousStock: Decimal | DecimalJsLike | number | string
    newStock: Decimal | DecimalJsLike | number | string
    reason?: string | null
    referenceType?: string | null
    referenceId?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type StockMovementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStoreMovementTypeFieldUpdateOperationsInput | $Enums.StoreMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    previousStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    type?: EnumStoreMovementTypeFieldUpdateOperationsInput | $Enums.StoreMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    previousStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferOrderCreateInput = {
    id?: string
    transferNumber: string
    status?: $Enums.TransferOrderStatus
    notes?: string | null
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fromStore: StoreCreateNestedOneWithoutTransferOrdersOutInput
    toStore: StoreCreateNestedOneWithoutTransferOrdersInInput
    items?: TransferOrderItemCreateNestedManyWithoutTransferOrderInput
  }

  export type TransferOrderUncheckedCreateInput = {
    id?: string
    fromStoreId: string
    toStoreId: string
    transferNumber: string
    status?: $Enums.TransferOrderStatus
    notes?: string | null
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferOrderItemUncheckedCreateNestedManyWithoutTransferOrderInput
  }

  export type TransferOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferOrderStatusFieldUpdateOperationsInput | $Enums.TransferOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromStore?: StoreUpdateOneRequiredWithoutTransferOrdersOutNestedInput
    toStore?: StoreUpdateOneRequiredWithoutTransferOrdersInNestedInput
    items?: TransferOrderItemUpdateManyWithoutTransferOrderNestedInput
  }

  export type TransferOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromStoreId?: StringFieldUpdateOperationsInput | string
    toStoreId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferOrderStatusFieldUpdateOperationsInput | $Enums.TransferOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferOrderItemUncheckedUpdateManyWithoutTransferOrderNestedInput
  }

  export type TransferOrderCreateManyInput = {
    id?: string
    fromStoreId: string
    toStoreId: string
    transferNumber: string
    status?: $Enums.TransferOrderStatus
    notes?: string | null
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferOrderStatusFieldUpdateOperationsInput | $Enums.TransferOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromStoreId?: StringFieldUpdateOperationsInput | string
    toStoreId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferOrderStatusFieldUpdateOperationsInput | $Enums.TransferOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferOrderItemCreateInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    transferOrder: TransferOrderCreateNestedOneWithoutItemsInput
    product: StoreProductCreateNestedOneWithoutTransferOrderItemsInput
  }

  export type TransferOrderItemUncheckedCreateInput = {
    id?: string
    transferOrderId: string
    productId: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type TransferOrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transferOrder?: TransferOrderUpdateOneRequiredWithoutItemsNestedInput
    product?: StoreProductUpdateOneRequiredWithoutTransferOrderItemsNestedInput
  }

  export type TransferOrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type TransferOrderItemCreateManyInput = {
    id?: string
    transferOrderId: string
    productId: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type TransferOrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type TransferOrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferOrderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type StoreCustomerCreateInput = {
    id?: string
    firstName: string
    lastName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    taxId?: string | null
    notes?: string | null
    totalPurchases?: Decimal | DecimalJsLike | number | string
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    totalLifetimePurchases?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutCustomersInput
    sales?: SaleCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: StoreLoyaltyTransactionCreateNestedManyWithoutCustomerInput
  }

  export type StoreCustomerUncheckedCreateInput = {
    id?: string
    storeId: string
    firstName: string
    lastName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    taxId?: string | null
    notes?: string | null
    totalPurchases?: Decimal | DecimalJsLike | number | string
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    totalLifetimePurchases?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: StoreLoyaltyTransactionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type StoreCustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    totalLifetimePurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutCustomersNestedInput
    sales?: SaleUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: StoreLoyaltyTransactionUpdateManyWithoutCustomerNestedInput
  }

  export type StoreCustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    totalLifetimePurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: StoreLoyaltyTransactionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type StoreCustomerCreateManyInput = {
    id?: string
    storeId: string
    firstName: string
    lastName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    taxId?: string | null
    notes?: string | null
    totalPurchases?: Decimal | DecimalJsLike | number | string
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    totalLifetimePurchases?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreCustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    totalLifetimePurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreCustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    totalLifetimePurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreLoyaltyConfigCreateInput = {
    id?: string
    pointsPerGel?: number
    redemptionRate?: number
    minRedemptionPoints?: number
    expirationDays?: number | null
    bronzeMinSpend?: Decimal | DecimalJsLike | number | string | null
    silverMinSpend?: Decimal | DecimalJsLike | number | string | null
    goldMinSpend?: Decimal | DecimalJsLike | number | string | null
    platinumMinSpend?: Decimal | DecimalJsLike | number | string | null
    goldDiscountPercent?: Decimal | DecimalJsLike | number | string | null
    platinumDiscountPercent?: Decimal | DecimalJsLike | number | string | null
    store: StoreCreateNestedOneWithoutLoyaltyConfigInput
  }

  export type StoreLoyaltyConfigUncheckedCreateInput = {
    id?: string
    storeId: string
    pointsPerGel?: number
    redemptionRate?: number
    minRedemptionPoints?: number
    expirationDays?: number | null
    bronzeMinSpend?: Decimal | DecimalJsLike | number | string | null
    silverMinSpend?: Decimal | DecimalJsLike | number | string | null
    goldMinSpend?: Decimal | DecimalJsLike | number | string | null
    platinumMinSpend?: Decimal | DecimalJsLike | number | string | null
    goldDiscountPercent?: Decimal | DecimalJsLike | number | string | null
    platinumDiscountPercent?: Decimal | DecimalJsLike | number | string | null
  }

  export type StoreLoyaltyConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsPerGel?: IntFieldUpdateOperationsInput | number
    redemptionRate?: IntFieldUpdateOperationsInput | number
    minRedemptionPoints?: IntFieldUpdateOperationsInput | number
    expirationDays?: NullableIntFieldUpdateOperationsInput | number | null
    bronzeMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    silverMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    goldMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platinumMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    goldDiscountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platinumDiscountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    store?: StoreUpdateOneRequiredWithoutLoyaltyConfigNestedInput
  }

  export type StoreLoyaltyConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    pointsPerGel?: IntFieldUpdateOperationsInput | number
    redemptionRate?: IntFieldUpdateOperationsInput | number
    minRedemptionPoints?: IntFieldUpdateOperationsInput | number
    expirationDays?: NullableIntFieldUpdateOperationsInput | number | null
    bronzeMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    silverMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    goldMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platinumMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    goldDiscountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platinumDiscountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type StoreLoyaltyConfigCreateManyInput = {
    id?: string
    storeId: string
    pointsPerGel?: number
    redemptionRate?: number
    minRedemptionPoints?: number
    expirationDays?: number | null
    bronzeMinSpend?: Decimal | DecimalJsLike | number | string | null
    silverMinSpend?: Decimal | DecimalJsLike | number | string | null
    goldMinSpend?: Decimal | DecimalJsLike | number | string | null
    platinumMinSpend?: Decimal | DecimalJsLike | number | string | null
    goldDiscountPercent?: Decimal | DecimalJsLike | number | string | null
    platinumDiscountPercent?: Decimal | DecimalJsLike | number | string | null
  }

  export type StoreLoyaltyConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsPerGel?: IntFieldUpdateOperationsInput | number
    redemptionRate?: IntFieldUpdateOperationsInput | number
    minRedemptionPoints?: IntFieldUpdateOperationsInput | number
    expirationDays?: NullableIntFieldUpdateOperationsInput | number | null
    bronzeMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    silverMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    goldMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platinumMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    goldDiscountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platinumDiscountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type StoreLoyaltyConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    pointsPerGel?: IntFieldUpdateOperationsInput | number
    redemptionRate?: IntFieldUpdateOperationsInput | number
    minRedemptionPoints?: IntFieldUpdateOperationsInput | number
    expirationDays?: NullableIntFieldUpdateOperationsInput | number | null
    bronzeMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    silverMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    goldMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platinumMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    goldDiscountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platinumDiscountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type StoreLoyaltyTransactionCreateInput = {
    id?: string
    type: $Enums.LoyaltyTransactionType
    points: number
    saleId?: string | null
    description?: string | null
    createdAt?: Date | string
    customer: StoreCustomerCreateNestedOneWithoutLoyaltyTransactionsInput
  }

  export type StoreLoyaltyTransactionUncheckedCreateInput = {
    id?: string
    customerId: string
    type: $Enums.LoyaltyTransactionType
    points: number
    saleId?: string | null
    description?: string | null
    createdAt?: Date | string
  }

  export type StoreLoyaltyTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    points?: IntFieldUpdateOperationsInput | number
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: StoreCustomerUpdateOneRequiredWithoutLoyaltyTransactionsNestedInput
  }

  export type StoreLoyaltyTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    points?: IntFieldUpdateOperationsInput | number
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreLoyaltyTransactionCreateManyInput = {
    id?: string
    customerId: string
    type: $Enums.LoyaltyTransactionType
    points: number
    saleId?: string | null
    description?: string | null
    createdAt?: Date | string
  }

  export type StoreLoyaltyTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    points?: IntFieldUpdateOperationsInput | number
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreLoyaltyTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    points?: IntFieldUpdateOperationsInput | number
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreTaxRuleCreateInput = {
    id?: string
    name: string
    rate: Decimal | DecimalJsLike | number | string
    isDefault?: boolean
    isActive?: boolean
    store: StoreCreateNestedOneWithoutTaxRulesInput
    products?: StoreProductCreateNestedManyWithoutTaxRuleInput
  }

  export type StoreTaxRuleUncheckedCreateInput = {
    id?: string
    storeId: string
    name: string
    rate: Decimal | DecimalJsLike | number | string
    isDefault?: boolean
    isActive?: boolean
    products?: StoreProductUncheckedCreateNestedManyWithoutTaxRuleInput
  }

  export type StoreTaxRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    store?: StoreUpdateOneRequiredWithoutTaxRulesNestedInput
    products?: StoreProductUpdateManyWithoutTaxRuleNestedInput
  }

  export type StoreTaxRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    products?: StoreProductUncheckedUpdateManyWithoutTaxRuleNestedInput
  }

  export type StoreTaxRuleCreateManyInput = {
    id?: string
    storeId: string
    name: string
    rate: Decimal | DecimalJsLike | number | string
    isDefault?: boolean
    isActive?: boolean
  }

  export type StoreTaxRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StoreTaxRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StorePaymentConfigCreateInput = {
    id?: string
    name: string
    type: $Enums.PaymentMethod
    isActive?: boolean
    sortOrder?: number
    store: StoreCreateNestedOneWithoutPaymentMethodsInput
  }

  export type StorePaymentConfigUncheckedCreateInput = {
    id?: string
    storeId: string
    name: string
    type: $Enums.PaymentMethod
    isActive?: boolean
    sortOrder?: number
  }

  export type StorePaymentConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    store?: StoreUpdateOneRequiredWithoutPaymentMethodsNestedInput
  }

  export type StorePaymentConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type StorePaymentConfigCreateManyInput = {
    id?: string
    storeId: string
    name: string
    type: $Enums.PaymentMethod
    isActive?: boolean
    sortOrder?: number
  }

  export type StorePaymentConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type StorePaymentConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type StoreReceiptConfigCreateInput = {
    id?: string
    headerText?: string | null
    footerText?: string | null
    showLogo?: boolean
    showTaxId?: boolean
    showBarcode?: boolean
    paperWidth?: number
    store: StoreCreateNestedOneWithoutReceiptConfigInput
  }

  export type StoreReceiptConfigUncheckedCreateInput = {
    id?: string
    storeId: string
    headerText?: string | null
    footerText?: string | null
    showLogo?: boolean
    showTaxId?: boolean
    showBarcode?: boolean
    paperWidth?: number
  }

  export type StoreReceiptConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    headerText?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    showLogo?: BoolFieldUpdateOperationsInput | boolean
    showTaxId?: BoolFieldUpdateOperationsInput | boolean
    showBarcode?: BoolFieldUpdateOperationsInput | boolean
    paperWidth?: IntFieldUpdateOperationsInput | number
    store?: StoreUpdateOneRequiredWithoutReceiptConfigNestedInput
  }

  export type StoreReceiptConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    headerText?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    showLogo?: BoolFieldUpdateOperationsInput | boolean
    showTaxId?: BoolFieldUpdateOperationsInput | boolean
    showBarcode?: BoolFieldUpdateOperationsInput | boolean
    paperWidth?: IntFieldUpdateOperationsInput | number
  }

  export type StoreReceiptConfigCreateManyInput = {
    id?: string
    storeId: string
    headerText?: string | null
    footerText?: string | null
    showLogo?: boolean
    showTaxId?: boolean
    showBarcode?: boolean
    paperWidth?: number
  }

  export type StoreReceiptConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    headerText?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    showLogo?: BoolFieldUpdateOperationsInput | boolean
    showTaxId?: BoolFieldUpdateOperationsInput | boolean
    showBarcode?: BoolFieldUpdateOperationsInput | boolean
    paperWidth?: IntFieldUpdateOperationsInput | number
  }

  export type StoreReceiptConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    headerText?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    showLogo?: BoolFieldUpdateOperationsInput | boolean
    showTaxId?: BoolFieldUpdateOperationsInput | boolean
    showBarcode?: BoolFieldUpdateOperationsInput | boolean
    paperWidth?: IntFieldUpdateOperationsInput | number
  }

  export type StoreDeviceConfigCreateInput = {
    id?: string
    deviceType: $Enums.StoreDeviceType
    name: string
    connectionType: string
    settings: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutDevicesInput
  }

  export type StoreDeviceConfigUncheckedCreateInput = {
    id?: string
    storeId: string
    deviceType: $Enums.StoreDeviceType
    name: string
    connectionType: string
    settings: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreDeviceConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumStoreDeviceTypeFieldUpdateOperationsInput | $Enums.StoreDeviceType
    name?: StringFieldUpdateOperationsInput | string
    connectionType?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutDevicesNestedInput
  }

  export type StoreDeviceConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumStoreDeviceTypeFieldUpdateOperationsInput | $Enums.StoreDeviceType
    name?: StringFieldUpdateOperationsInput | string
    connectionType?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreDeviceConfigCreateManyInput = {
    id?: string
    storeId: string
    deviceType: $Enums.StoreDeviceType
    name: string
    connectionType: string
    settings: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreDeviceConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumStoreDeviceTypeFieldUpdateOperationsInput | $Enums.StoreDeviceType
    name?: StringFieldUpdateOperationsInput | string
    connectionType?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreDeviceConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumStoreDeviceTypeFieldUpdateOperationsInput | $Enums.StoreDeviceType
    name?: StringFieldUpdateOperationsInput | string
    connectionType?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreIntegrationCreateInput = {
    id?: string
    type: $Enums.StoreIntegrationType
    name: string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutIntegrationsInput
  }

  export type StoreIntegrationUncheckedCreateInput = {
    id?: string
    storeId: string
    type: $Enums.StoreIntegrationType
    name: string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStoreIntegrationTypeFieldUpdateOperationsInput | $Enums.StoreIntegrationType
    name?: StringFieldUpdateOperationsInput | string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutIntegrationsNestedInput
  }

  export type StoreIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    type?: EnumStoreIntegrationTypeFieldUpdateOperationsInput | $Enums.StoreIntegrationType
    name?: StringFieldUpdateOperationsInput | string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreIntegrationCreateManyInput = {
    id?: string
    storeId: string
    type: $Enums.StoreIntegrationType
    name: string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStoreIntegrationTypeFieldUpdateOperationsInput | $Enums.StoreIntegrationType
    name?: StringFieldUpdateOperationsInput | string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    type?: EnumStoreIntegrationTypeFieldUpdateOperationsInput | $Enums.StoreIntegrationType
    name?: StringFieldUpdateOperationsInput | string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    logo?: SortOrder
    company?: SortOrder
    taxId?: SortOrder
    city?: SortOrder
    country?: SortOrder
    website?: SortOrder
    bankName?: SortOrder
    bankAccount?: SortOrder
    tenantId?: SortOrder
    hotelCode?: SortOrder
    storeCode?: SortOrder
    databaseUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    logo?: SortOrder
    company?: SortOrder
    taxId?: SortOrder
    city?: SortOrder
    country?: SortOrder
    website?: SortOrder
    bankName?: SortOrder
    bankAccount?: SortOrder
    tenantId?: SortOrder
    hotelCode?: SortOrder
    storeCode?: SortOrder
    databaseUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    logo?: SortOrder
    company?: SortOrder
    taxId?: SortOrder
    city?: SortOrder
    country?: SortOrder
    website?: SortOrder
    bankName?: SortOrder
    bankAccount?: SortOrder
    tenantId?: SortOrder
    hotelCode?: SortOrder
    storeCode?: SortOrder
    databaseUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type OrganizationNullableRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    emailVerified?: SortOrder
    lastLoginAt?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    emailVerified?: SortOrder
    lastLoginAt?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    emailVerified?: SortOrder
    lastLoginAt?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StoreEmployeeListRelationFilter = {
    every?: StoreEmployeeWhereInput
    some?: StoreEmployeeWhereInput
    none?: StoreEmployeeWhereInput
  }

  export type StoreProductListRelationFilter = {
    every?: StoreProductWhereInput
    some?: StoreProductWhereInput
    none?: StoreProductWhereInput
  }

  export type ProductCategoryListRelationFilter = {
    every?: ProductCategoryWhereInput
    some?: ProductCategoryWhereInput
    none?: ProductCategoryWhereInput
  }

  export type SaleListRelationFilter = {
    every?: SaleWhereInput
    some?: SaleWhereInput
    none?: SaleWhereInput
  }

  export type StorePurchaseOrderListRelationFilter = {
    every?: StorePurchaseOrderWhereInput
    some?: StorePurchaseOrderWhereInput
    none?: StorePurchaseOrderWhereInput
  }

  export type StoreSupplierListRelationFilter = {
    every?: StoreSupplierWhereInput
    some?: StoreSupplierWhereInput
    none?: StoreSupplierWhereInput
  }

  export type StoreCustomerListRelationFilter = {
    every?: StoreCustomerWhereInput
    some?: StoreCustomerWhereInput
    none?: StoreCustomerWhereInput
  }

  export type StockMovementListRelationFilter = {
    every?: StockMovementWhereInput
    some?: StockMovementWhereInput
    none?: StockMovementWhereInput
  }

  export type StoreTaxRuleListRelationFilter = {
    every?: StoreTaxRuleWhereInput
    some?: StoreTaxRuleWhereInput
    none?: StoreTaxRuleWhereInput
  }

  export type StoreLoyaltyConfigNullableRelationFilter = {
    is?: StoreLoyaltyConfigWhereInput | null
    isNot?: StoreLoyaltyConfigWhereInput | null
  }

  export type TransferOrderListRelationFilter = {
    every?: TransferOrderWhereInput
    some?: TransferOrderWhereInput
    none?: TransferOrderWhereInput
  }

  export type StorePaymentConfigListRelationFilter = {
    every?: StorePaymentConfigWhereInput
    some?: StorePaymentConfigWhereInput
    none?: StorePaymentConfigWhereInput
  }

  export type StoreReceiptConfigNullableRelationFilter = {
    is?: StoreReceiptConfigWhereInput | null
    isNot?: StoreReceiptConfigWhereInput | null
  }

  export type StoreDeviceConfigListRelationFilter = {
    every?: StoreDeviceConfigWhereInput
    some?: StoreDeviceConfigWhereInput
    none?: StoreDeviceConfigWhereInput
  }

  export type StoreIntegrationListRelationFilter = {
    every?: StoreIntegrationWhereInput
    some?: StoreIntegrationWhereInput
    none?: StoreIntegrationWhereInput
  }

  export type StoreEmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StorePurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreSupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreCustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreTaxRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StorePaymentConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreDeviceConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreIntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    taxId?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    taxId?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    taxId?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StoreRelationFilter = {
    is?: StoreWhereInput
    isNot?: StoreWhereInput
  }

  export type StoreEmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    role?: SortOrder
    pin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreEmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    role?: SortOrder
    pin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreEmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    role?: SortOrder
    pin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ProductCategoryNullableRelationFilter = {
    is?: ProductCategoryWhereInput | null
    isNot?: ProductCategoryWhereInput | null
  }

  export type ProductCategoryStoreIdSlugCompoundUniqueInput = {
    storeId: string
    slug: string
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    nameKa?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    nameKa?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    nameKa?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategorySumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type StoreTaxRuleNullableRelationFilter = {
    is?: StoreTaxRuleWhereInput | null
    isNot?: StoreTaxRuleWhereInput | null
  }

  export type SaleItemListRelationFilter = {
    every?: SaleItemWhereInput
    some?: SaleItemWhereInput
    none?: SaleItemWhereInput
  }

  export type SaleReturnItemListRelationFilter = {
    every?: SaleReturnItemWhereInput
    some?: SaleReturnItemWhereInput
    none?: SaleReturnItemWhereInput
  }

  export type StorePurchaseItemListRelationFilter = {
    every?: StorePurchaseItemWhereInput
    some?: StorePurchaseItemWhereInput
    none?: StorePurchaseItemWhereInput
  }

  export type StorePriceHistoryListRelationFilter = {
    every?: StorePriceHistoryWhereInput
    some?: StorePriceHistoryWhereInput
    none?: StorePriceHistoryWhereInput
  }

  export type TransferOrderItemListRelationFilter = {
    every?: TransferOrderItemWhereInput
    some?: TransferOrderItemWhereInput
    none?: TransferOrderItemWhereInput
  }

  export type SaleItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleReturnItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StorePurchaseItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StorePriceHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreProductStoreIdSkuCompoundUniqueInput = {
    storeId: string
    sku: string
  }

  export type StoreProductCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    categoryId?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    name?: SortOrder
    nameKa?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    wholesalePrice?: SortOrder
    currentStock?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    unit?: SortOrder
    taxRuleId?: SortOrder
    isActive?: SortOrder
    isFavorite?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreProductAvgOrderByAggregateInput = {
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    wholesalePrice?: SortOrder
    currentStock?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    sortOrder?: SortOrder
  }

  export type StoreProductMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    categoryId?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    name?: SortOrder
    nameKa?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    wholesalePrice?: SortOrder
    currentStock?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    unit?: SortOrder
    taxRuleId?: SortOrder
    isActive?: SortOrder
    isFavorite?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreProductMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    categoryId?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    name?: SortOrder
    nameKa?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    wholesalePrice?: SortOrder
    currentStock?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    unit?: SortOrder
    taxRuleId?: SortOrder
    isActive?: SortOrder
    isFavorite?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreProductSumOrderByAggregateInput = {
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    wholesalePrice?: SortOrder
    currentStock?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    sortOrder?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type StoreProductRelationFilter = {
    is?: StoreProductWhereInput
    isNot?: StoreProductWhereInput
  }

  export type StorePriceHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    changedBy?: SortOrder
    changedAt?: SortOrder
  }

  export type StorePriceHistoryAvgOrderByAggregateInput = {
    costPrice?: SortOrder
    sellingPrice?: SortOrder
  }

  export type StorePriceHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    changedBy?: SortOrder
    changedAt?: SortOrder
  }

  export type StorePriceHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    costPrice?: SortOrder
    sellingPrice?: SortOrder
    changedBy?: SortOrder
    changedAt?: SortOrder
  }

  export type StorePriceHistorySumOrderByAggregateInput = {
    costPrice?: SortOrder
    sellingPrice?: SortOrder
  }

  export type EnumStoreDiscountTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreDiscountType | EnumStoreDiscountTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.StoreDiscountType[] | ListEnumStoreDiscountTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StoreDiscountType[] | ListEnumStoreDiscountTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStoreDiscountTypeNullableFilter<$PrismaModel> | $Enums.StoreDiscountType | null
  }

  export type EnumStoreSaleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreSaleStatus | EnumStoreSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoreSaleStatus[] | ListEnumStoreSaleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreSaleStatus[] | ListEnumStoreSaleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreSaleStatusFilter<$PrismaModel> | $Enums.StoreSaleStatus
  }

  export type StoreCustomerNullableRelationFilter = {
    is?: StoreCustomerWhereInput | null
    isNot?: StoreCustomerWhereInput | null
  }

  export type StoreEmployeeNullableRelationFilter = {
    is?: StoreEmployeeWhereInput | null
    isNot?: StoreEmployeeWhereInput | null
  }

  export type SalePaymentListRelationFilter = {
    every?: SalePaymentWhereInput
    some?: SalePaymentWhereInput
    none?: SalePaymentWhereInput
  }

  export type SaleReturnListRelationFilter = {
    every?: SaleReturnWhereInput
    some?: SaleReturnWhereInput
    none?: SaleReturnWhereInput
  }

  export type SalePaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleReturnOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleStoreIdSaleNumberCompoundUniqueInput = {
    storeId: string
    saleNumber: string
  }

  export type SaleCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    saleNumber?: SortOrder
    customerId?: SortOrder
    employeeId?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    discountType?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    changeAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    receiptPrinted?: SortOrder
    fiscalPrinted?: SortOrder
    fiscalNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    changeAmount?: SortOrder
  }

  export type SaleMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    saleNumber?: SortOrder
    customerId?: SortOrder
    employeeId?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    discountType?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    changeAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    receiptPrinted?: SortOrder
    fiscalPrinted?: SortOrder
    fiscalNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    saleNumber?: SortOrder
    customerId?: SortOrder
    employeeId?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    discountType?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    changeAmount?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    receiptPrinted?: SortOrder
    fiscalPrinted?: SortOrder
    fiscalNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    changeAmount?: SortOrder
  }

  export type EnumStoreDiscountTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreDiscountType | EnumStoreDiscountTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.StoreDiscountType[] | ListEnumStoreDiscountTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StoreDiscountType[] | ListEnumStoreDiscountTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStoreDiscountTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.StoreDiscountType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStoreDiscountTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumStoreDiscountTypeNullableFilter<$PrismaModel>
  }

  export type EnumStoreSaleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreSaleStatus | EnumStoreSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoreSaleStatus[] | ListEnumStoreSaleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreSaleStatus[] | ListEnumStoreSaleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreSaleStatusWithAggregatesFilter<$PrismaModel> | $Enums.StoreSaleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoreSaleStatusFilter<$PrismaModel>
    _max?: NestedEnumStoreSaleStatusFilter<$PrismaModel>
  }

  export type SaleRelationFilter = {
    is?: SaleWhereInput
    isNot?: SaleWhereInput
  }

  export type SaleItemCountOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    productName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    costPrice?: SortOrder
    discount?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
  }

  export type SaleItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    costPrice?: SortOrder
    discount?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
  }

  export type SaleItemMaxOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    productName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    costPrice?: SortOrder
    discount?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
  }

  export type SaleItemMinOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    productName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    costPrice?: SortOrder
    discount?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
  }

  export type SaleItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    costPrice?: SortOrder
    discount?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type SalePaymentCountOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type SalePaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SalePaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type SalePaymentMinOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type SalePaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumStoreReturnStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreReturnStatus | EnumStoreReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoreReturnStatus[] | ListEnumStoreReturnStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreReturnStatus[] | ListEnumStoreReturnStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreReturnStatusFilter<$PrismaModel> | $Enums.StoreReturnStatus
  }

  export type SaleReturnCountOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    reason?: SortOrder
    refundAmount?: SortOrder
    refundMethod?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type SaleReturnAvgOrderByAggregateInput = {
    refundAmount?: SortOrder
  }

  export type SaleReturnMaxOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    reason?: SortOrder
    refundAmount?: SortOrder
    refundMethod?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type SaleReturnMinOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    reason?: SortOrder
    refundAmount?: SortOrder
    refundMethod?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type SaleReturnSumOrderByAggregateInput = {
    refundAmount?: SortOrder
  }

  export type EnumStoreReturnStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreReturnStatus | EnumStoreReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoreReturnStatus[] | ListEnumStoreReturnStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreReturnStatus[] | ListEnumStoreReturnStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreReturnStatusWithAggregatesFilter<$PrismaModel> | $Enums.StoreReturnStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoreReturnStatusFilter<$PrismaModel>
    _max?: NestedEnumStoreReturnStatusFilter<$PrismaModel>
  }

  export type SaleReturnRelationFilter = {
    is?: SaleReturnWhereInput
    isNot?: SaleReturnWhereInput
  }

  export type SaleReturnItemCountOrderByAggregateInput = {
    id?: SortOrder
    returnId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    refundAmount?: SortOrder
  }

  export type SaleReturnItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    refundAmount?: SortOrder
  }

  export type SaleReturnItemMaxOrderByAggregateInput = {
    id?: SortOrder
    returnId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    refundAmount?: SortOrder
  }

  export type SaleReturnItemMinOrderByAggregateInput = {
    id?: SortOrder
    returnId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    refundAmount?: SortOrder
  }

  export type SaleReturnItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    refundAmount?: SortOrder
  }

  export type StoreSupplierStoreIdNameCompoundUniqueInput = {
    storeId: string
    name: string
  }

  export type StoreSupplierCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    taxId?: SortOrder
    bankAccount?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreSupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    taxId?: SortOrder
    bankAccount?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreSupplierMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    taxId?: SortOrder
    bankAccount?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStorePurchaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StorePurchaseStatus | EnumStorePurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StorePurchaseStatus[] | ListEnumStorePurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StorePurchaseStatus[] | ListEnumStorePurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStorePurchaseStatusFilter<$PrismaModel> | $Enums.StorePurchaseStatus
  }

  export type StoreSupplierRelationFilter = {
    is?: StoreSupplierWhereInput
    isNot?: StoreSupplierWhereInput
  }

  export type StorePurchaseOrderStoreIdOrderNumberCompoundUniqueInput = {
    storeId: string
    orderNumber: string
  }

  export type StorePurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    supplierId?: SortOrder
    orderNumber?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    expectedDate?: SortOrder
    receivedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorePurchaseOrderAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
  }

  export type StorePurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    supplierId?: SortOrder
    orderNumber?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    expectedDate?: SortOrder
    receivedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorePurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    supplierId?: SortOrder
    orderNumber?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    expectedDate?: SortOrder
    receivedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorePurchaseOrderSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
  }

  export type EnumStorePurchaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StorePurchaseStatus | EnumStorePurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StorePurchaseStatus[] | ListEnumStorePurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StorePurchaseStatus[] | ListEnumStorePurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStorePurchaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.StorePurchaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStorePurchaseStatusFilter<$PrismaModel>
    _max?: NestedEnumStorePurchaseStatusFilter<$PrismaModel>
  }

  export type StorePurchaseOrderRelationFilter = {
    is?: StorePurchaseOrderWhereInput
    isNot?: StorePurchaseOrderWhereInput
  }

  export type StorePurchaseItemCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    receivedQty?: SortOrder
    total?: SortOrder
  }

  export type StorePurchaseItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitCost?: SortOrder
    receivedQty?: SortOrder
    total?: SortOrder
  }

  export type StorePurchaseItemMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    receivedQty?: SortOrder
    total?: SortOrder
  }

  export type StorePurchaseItemMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    receivedQty?: SortOrder
    total?: SortOrder
  }

  export type StorePurchaseItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitCost?: SortOrder
    receivedQty?: SortOrder
    total?: SortOrder
  }

  export type EnumStoreMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreMovementType | EnumStoreMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoreMovementType[] | ListEnumStoreMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreMovementType[] | ListEnumStoreMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreMovementTypeFilter<$PrismaModel> | $Enums.StoreMovementType
  }

  export type StockMovementCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    previousStock?: SortOrder
    newStock?: SortOrder
    reason?: SortOrder
    referenceType?: SortOrder
    referenceId?: SortOrder
    performedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementAvgOrderByAggregateInput = {
    quantity?: SortOrder
    previousStock?: SortOrder
    newStock?: SortOrder
  }

  export type StockMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    previousStock?: SortOrder
    newStock?: SortOrder
    reason?: SortOrder
    referenceType?: SortOrder
    referenceId?: SortOrder
    performedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    previousStock?: SortOrder
    newStock?: SortOrder
    reason?: SortOrder
    referenceType?: SortOrder
    referenceId?: SortOrder
    performedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementSumOrderByAggregateInput = {
    quantity?: SortOrder
    previousStock?: SortOrder
    newStock?: SortOrder
  }

  export type EnumStoreMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreMovementType | EnumStoreMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoreMovementType[] | ListEnumStoreMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreMovementType[] | ListEnumStoreMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.StoreMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoreMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumStoreMovementTypeFilter<$PrismaModel>
  }

  export type EnumTransferOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferOrderStatus | EnumTransferOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferOrderStatus[] | ListEnumTransferOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferOrderStatus[] | ListEnumTransferOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferOrderStatusFilter<$PrismaModel> | $Enums.TransferOrderStatus
  }

  export type TransferOrderCountOrderByAggregateInput = {
    id?: SortOrder
    fromStoreId?: SortOrder
    toStoreId?: SortOrder
    transferNumber?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    sentAt?: SortOrder
    receivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    fromStoreId?: SortOrder
    toStoreId?: SortOrder
    transferNumber?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    sentAt?: SortOrder
    receivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferOrderMinOrderByAggregateInput = {
    id?: SortOrder
    fromStoreId?: SortOrder
    toStoreId?: SortOrder
    transferNumber?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    sentAt?: SortOrder
    receivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTransferOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferOrderStatus | EnumTransferOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferOrderStatus[] | ListEnumTransferOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferOrderStatus[] | ListEnumTransferOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferOrderStatusFilter<$PrismaModel>
  }

  export type TransferOrderRelationFilter = {
    is?: TransferOrderWhereInput
    isNot?: TransferOrderWhereInput
  }

  export type TransferOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    transferOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
  }

  export type TransferOrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitCost?: SortOrder
  }

  export type TransferOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    transferOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
  }

  export type TransferOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    transferOrderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
  }

  export type TransferOrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitCost?: SortOrder
  }

  export type EnumLoyaltyTierFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTier | EnumLoyaltyTierFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTierFilter<$PrismaModel> | $Enums.LoyaltyTier
  }

  export type StoreLoyaltyTransactionListRelationFilter = {
    every?: StoreLoyaltyTransactionWhereInput
    some?: StoreLoyaltyTransactionWhereInput
    none?: StoreLoyaltyTransactionWhereInput
  }

  export type StoreLoyaltyTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreCustomerCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    taxId?: SortOrder
    notes?: SortOrder
    totalPurchases?: SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    totalLifetimePurchases?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreCustomerAvgOrderByAggregateInput = {
    totalPurchases?: SortOrder
    loyaltyPoints?: SortOrder
    totalLifetimePurchases?: SortOrder
  }

  export type StoreCustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    taxId?: SortOrder
    notes?: SortOrder
    totalPurchases?: SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    totalLifetimePurchases?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreCustomerMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    taxId?: SortOrder
    notes?: SortOrder
    totalPurchases?: SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    totalLifetimePurchases?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreCustomerSumOrderByAggregateInput = {
    totalPurchases?: SortOrder
    loyaltyPoints?: SortOrder
    totalLifetimePurchases?: SortOrder
  }

  export type EnumLoyaltyTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTier | EnumLoyaltyTierFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTierWithAggregatesFilter<$PrismaModel> | $Enums.LoyaltyTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoyaltyTierFilter<$PrismaModel>
    _max?: NestedEnumLoyaltyTierFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StoreLoyaltyConfigCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    pointsPerGel?: SortOrder
    redemptionRate?: SortOrder
    minRedemptionPoints?: SortOrder
    expirationDays?: SortOrder
    bronzeMinSpend?: SortOrder
    silverMinSpend?: SortOrder
    goldMinSpend?: SortOrder
    platinumMinSpend?: SortOrder
    goldDiscountPercent?: SortOrder
    platinumDiscountPercent?: SortOrder
  }

  export type StoreLoyaltyConfigAvgOrderByAggregateInput = {
    pointsPerGel?: SortOrder
    redemptionRate?: SortOrder
    minRedemptionPoints?: SortOrder
    expirationDays?: SortOrder
    bronzeMinSpend?: SortOrder
    silverMinSpend?: SortOrder
    goldMinSpend?: SortOrder
    platinumMinSpend?: SortOrder
    goldDiscountPercent?: SortOrder
    platinumDiscountPercent?: SortOrder
  }

  export type StoreLoyaltyConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    pointsPerGel?: SortOrder
    redemptionRate?: SortOrder
    minRedemptionPoints?: SortOrder
    expirationDays?: SortOrder
    bronzeMinSpend?: SortOrder
    silverMinSpend?: SortOrder
    goldMinSpend?: SortOrder
    platinumMinSpend?: SortOrder
    goldDiscountPercent?: SortOrder
    platinumDiscountPercent?: SortOrder
  }

  export type StoreLoyaltyConfigMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    pointsPerGel?: SortOrder
    redemptionRate?: SortOrder
    minRedemptionPoints?: SortOrder
    expirationDays?: SortOrder
    bronzeMinSpend?: SortOrder
    silverMinSpend?: SortOrder
    goldMinSpend?: SortOrder
    platinumMinSpend?: SortOrder
    goldDiscountPercent?: SortOrder
    platinumDiscountPercent?: SortOrder
  }

  export type StoreLoyaltyConfigSumOrderByAggregateInput = {
    pointsPerGel?: SortOrder
    redemptionRate?: SortOrder
    minRedemptionPoints?: SortOrder
    expirationDays?: SortOrder
    bronzeMinSpend?: SortOrder
    silverMinSpend?: SortOrder
    goldMinSpend?: SortOrder
    platinumMinSpend?: SortOrder
    goldDiscountPercent?: SortOrder
    platinumDiscountPercent?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumLoyaltyTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTransactionType | EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel> | $Enums.LoyaltyTransactionType
  }

  export type StoreCustomerRelationFilter = {
    is?: StoreCustomerWhereInput
    isNot?: StoreCustomerWhereInput
  }

  export type StoreLoyaltyTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    points?: SortOrder
    saleId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type StoreLoyaltyTransactionAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type StoreLoyaltyTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    points?: SortOrder
    saleId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type StoreLoyaltyTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    points?: SortOrder
    saleId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type StoreLoyaltyTransactionSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type EnumLoyaltyTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTransactionType | EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.LoyaltyTransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel>
  }

  export type StoreTaxRuleCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
  }

  export type StoreTaxRuleAvgOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type StoreTaxRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
  }

  export type StoreTaxRuleMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
  }

  export type StoreTaxRuleSumOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type StorePaymentConfigCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
  }

  export type StorePaymentConfigAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type StorePaymentConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
  }

  export type StorePaymentConfigMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
  }

  export type StorePaymentConfigSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type StoreReceiptConfigCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    headerText?: SortOrder
    footerText?: SortOrder
    showLogo?: SortOrder
    showTaxId?: SortOrder
    showBarcode?: SortOrder
    paperWidth?: SortOrder
  }

  export type StoreReceiptConfigAvgOrderByAggregateInput = {
    paperWidth?: SortOrder
  }

  export type StoreReceiptConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    headerText?: SortOrder
    footerText?: SortOrder
    showLogo?: SortOrder
    showTaxId?: SortOrder
    showBarcode?: SortOrder
    paperWidth?: SortOrder
  }

  export type StoreReceiptConfigMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    headerText?: SortOrder
    footerText?: SortOrder
    showLogo?: SortOrder
    showTaxId?: SortOrder
    showBarcode?: SortOrder
    paperWidth?: SortOrder
  }

  export type StoreReceiptConfigSumOrderByAggregateInput = {
    paperWidth?: SortOrder
  }

  export type EnumStoreDeviceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreDeviceType | EnumStoreDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoreDeviceType[] | ListEnumStoreDeviceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreDeviceType[] | ListEnumStoreDeviceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreDeviceTypeFilter<$PrismaModel> | $Enums.StoreDeviceType
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StoreDeviceConfigCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    deviceType?: SortOrder
    name?: SortOrder
    connectionType?: SortOrder
    settings?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreDeviceConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    deviceType?: SortOrder
    name?: SortOrder
    connectionType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreDeviceConfigMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    deviceType?: SortOrder
    name?: SortOrder
    connectionType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStoreDeviceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreDeviceType | EnumStoreDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoreDeviceType[] | ListEnumStoreDeviceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreDeviceType[] | ListEnumStoreDeviceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreDeviceTypeWithAggregatesFilter<$PrismaModel> | $Enums.StoreDeviceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoreDeviceTypeFilter<$PrismaModel>
    _max?: NestedEnumStoreDeviceTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumStoreIntegrationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreIntegrationType | EnumStoreIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoreIntegrationType[] | ListEnumStoreIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreIntegrationType[] | ListEnumStoreIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreIntegrationTypeFilter<$PrismaModel> | $Enums.StoreIntegrationType
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StoreIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    credentials?: SortOrder
    settings?: SortOrder
    lastSyncAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    lastSyncAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    lastSyncAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStoreIntegrationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreIntegrationType | EnumStoreIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoreIntegrationType[] | ListEnumStoreIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreIntegrationType[] | ListEnumStoreIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreIntegrationTypeWithAggregatesFilter<$PrismaModel> | $Enums.StoreIntegrationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoreIntegrationTypeFilter<$PrismaModel>
    _max?: NestedEnumStoreIntegrationTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UserCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutUsersInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type OrganizationUpdateOneWithoutUsersNestedInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    upsert?: OrganizationUpsertWithoutUsersInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUsersInput, OrganizationUpdateWithoutUsersInput>, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type StoreEmployeeCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreEmployeeCreateWithoutStoreInput, StoreEmployeeUncheckedCreateWithoutStoreInput> | StoreEmployeeCreateWithoutStoreInput[] | StoreEmployeeUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreEmployeeCreateOrConnectWithoutStoreInput | StoreEmployeeCreateOrConnectWithoutStoreInput[]
    createMany?: StoreEmployeeCreateManyStoreInputEnvelope
    connect?: StoreEmployeeWhereUniqueInput | StoreEmployeeWhereUniqueInput[]
  }

  export type StoreProductCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreProductCreateWithoutStoreInput, StoreProductUncheckedCreateWithoutStoreInput> | StoreProductCreateWithoutStoreInput[] | StoreProductUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreProductCreateOrConnectWithoutStoreInput | StoreProductCreateOrConnectWithoutStoreInput[]
    createMany?: StoreProductCreateManyStoreInputEnvelope
    connect?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
  }

  export type ProductCategoryCreateNestedManyWithoutStoreInput = {
    create?: XOR<ProductCategoryCreateWithoutStoreInput, ProductCategoryUncheckedCreateWithoutStoreInput> | ProductCategoryCreateWithoutStoreInput[] | ProductCategoryUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutStoreInput | ProductCategoryCreateOrConnectWithoutStoreInput[]
    createMany?: ProductCategoryCreateManyStoreInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type SaleCreateNestedManyWithoutStoreInput = {
    create?: XOR<SaleCreateWithoutStoreInput, SaleUncheckedCreateWithoutStoreInput> | SaleCreateWithoutStoreInput[] | SaleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutStoreInput | SaleCreateOrConnectWithoutStoreInput[]
    createMany?: SaleCreateManyStoreInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type StorePurchaseOrderCreateNestedManyWithoutStoreInput = {
    create?: XOR<StorePurchaseOrderCreateWithoutStoreInput, StorePurchaseOrderUncheckedCreateWithoutStoreInput> | StorePurchaseOrderCreateWithoutStoreInput[] | StorePurchaseOrderUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StorePurchaseOrderCreateOrConnectWithoutStoreInput | StorePurchaseOrderCreateOrConnectWithoutStoreInput[]
    createMany?: StorePurchaseOrderCreateManyStoreInputEnvelope
    connect?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
  }

  export type StoreSupplierCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreSupplierCreateWithoutStoreInput, StoreSupplierUncheckedCreateWithoutStoreInput> | StoreSupplierCreateWithoutStoreInput[] | StoreSupplierUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreSupplierCreateOrConnectWithoutStoreInput | StoreSupplierCreateOrConnectWithoutStoreInput[]
    createMany?: StoreSupplierCreateManyStoreInputEnvelope
    connect?: StoreSupplierWhereUniqueInput | StoreSupplierWhereUniqueInput[]
  }

  export type StoreCustomerCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreCustomerCreateWithoutStoreInput, StoreCustomerUncheckedCreateWithoutStoreInput> | StoreCustomerCreateWithoutStoreInput[] | StoreCustomerUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreCustomerCreateOrConnectWithoutStoreInput | StoreCustomerCreateOrConnectWithoutStoreInput[]
    createMany?: StoreCustomerCreateManyStoreInputEnvelope
    connect?: StoreCustomerWhereUniqueInput | StoreCustomerWhereUniqueInput[]
  }

  export type StockMovementCreateNestedManyWithoutStoreInput = {
    create?: XOR<StockMovementCreateWithoutStoreInput, StockMovementUncheckedCreateWithoutStoreInput> | StockMovementCreateWithoutStoreInput[] | StockMovementUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutStoreInput | StockMovementCreateOrConnectWithoutStoreInput[]
    createMany?: StockMovementCreateManyStoreInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type StoreTaxRuleCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreTaxRuleCreateWithoutStoreInput, StoreTaxRuleUncheckedCreateWithoutStoreInput> | StoreTaxRuleCreateWithoutStoreInput[] | StoreTaxRuleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreTaxRuleCreateOrConnectWithoutStoreInput | StoreTaxRuleCreateOrConnectWithoutStoreInput[]
    createMany?: StoreTaxRuleCreateManyStoreInputEnvelope
    connect?: StoreTaxRuleWhereUniqueInput | StoreTaxRuleWhereUniqueInput[]
  }

  export type StoreLoyaltyConfigCreateNestedOneWithoutStoreInput = {
    create?: XOR<StoreLoyaltyConfigCreateWithoutStoreInput, StoreLoyaltyConfigUncheckedCreateWithoutStoreInput>
    connectOrCreate?: StoreLoyaltyConfigCreateOrConnectWithoutStoreInput
    connect?: StoreLoyaltyConfigWhereUniqueInput
  }

  export type TransferOrderCreateNestedManyWithoutFromStoreInput = {
    create?: XOR<TransferOrderCreateWithoutFromStoreInput, TransferOrderUncheckedCreateWithoutFromStoreInput> | TransferOrderCreateWithoutFromStoreInput[] | TransferOrderUncheckedCreateWithoutFromStoreInput[]
    connectOrCreate?: TransferOrderCreateOrConnectWithoutFromStoreInput | TransferOrderCreateOrConnectWithoutFromStoreInput[]
    createMany?: TransferOrderCreateManyFromStoreInputEnvelope
    connect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
  }

  export type TransferOrderCreateNestedManyWithoutToStoreInput = {
    create?: XOR<TransferOrderCreateWithoutToStoreInput, TransferOrderUncheckedCreateWithoutToStoreInput> | TransferOrderCreateWithoutToStoreInput[] | TransferOrderUncheckedCreateWithoutToStoreInput[]
    connectOrCreate?: TransferOrderCreateOrConnectWithoutToStoreInput | TransferOrderCreateOrConnectWithoutToStoreInput[]
    createMany?: TransferOrderCreateManyToStoreInputEnvelope
    connect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
  }

  export type StorePaymentConfigCreateNestedManyWithoutStoreInput = {
    create?: XOR<StorePaymentConfigCreateWithoutStoreInput, StorePaymentConfigUncheckedCreateWithoutStoreInput> | StorePaymentConfigCreateWithoutStoreInput[] | StorePaymentConfigUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StorePaymentConfigCreateOrConnectWithoutStoreInput | StorePaymentConfigCreateOrConnectWithoutStoreInput[]
    createMany?: StorePaymentConfigCreateManyStoreInputEnvelope
    connect?: StorePaymentConfigWhereUniqueInput | StorePaymentConfigWhereUniqueInput[]
  }

  export type StoreReceiptConfigCreateNestedOneWithoutStoreInput = {
    create?: XOR<StoreReceiptConfigCreateWithoutStoreInput, StoreReceiptConfigUncheckedCreateWithoutStoreInput>
    connectOrCreate?: StoreReceiptConfigCreateOrConnectWithoutStoreInput
    connect?: StoreReceiptConfigWhereUniqueInput
  }

  export type StoreDeviceConfigCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreDeviceConfigCreateWithoutStoreInput, StoreDeviceConfigUncheckedCreateWithoutStoreInput> | StoreDeviceConfigCreateWithoutStoreInput[] | StoreDeviceConfigUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreDeviceConfigCreateOrConnectWithoutStoreInput | StoreDeviceConfigCreateOrConnectWithoutStoreInput[]
    createMany?: StoreDeviceConfigCreateManyStoreInputEnvelope
    connect?: StoreDeviceConfigWhereUniqueInput | StoreDeviceConfigWhereUniqueInput[]
  }

  export type StoreIntegrationCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreIntegrationCreateWithoutStoreInput, StoreIntegrationUncheckedCreateWithoutStoreInput> | StoreIntegrationCreateWithoutStoreInput[] | StoreIntegrationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreIntegrationCreateOrConnectWithoutStoreInput | StoreIntegrationCreateOrConnectWithoutStoreInput[]
    createMany?: StoreIntegrationCreateManyStoreInputEnvelope
    connect?: StoreIntegrationWhereUniqueInput | StoreIntegrationWhereUniqueInput[]
  }

  export type StoreEmployeeUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreEmployeeCreateWithoutStoreInput, StoreEmployeeUncheckedCreateWithoutStoreInput> | StoreEmployeeCreateWithoutStoreInput[] | StoreEmployeeUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreEmployeeCreateOrConnectWithoutStoreInput | StoreEmployeeCreateOrConnectWithoutStoreInput[]
    createMany?: StoreEmployeeCreateManyStoreInputEnvelope
    connect?: StoreEmployeeWhereUniqueInput | StoreEmployeeWhereUniqueInput[]
  }

  export type StoreProductUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreProductCreateWithoutStoreInput, StoreProductUncheckedCreateWithoutStoreInput> | StoreProductCreateWithoutStoreInput[] | StoreProductUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreProductCreateOrConnectWithoutStoreInput | StoreProductCreateOrConnectWithoutStoreInput[]
    createMany?: StoreProductCreateManyStoreInputEnvelope
    connect?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<ProductCategoryCreateWithoutStoreInput, ProductCategoryUncheckedCreateWithoutStoreInput> | ProductCategoryCreateWithoutStoreInput[] | ProductCategoryUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutStoreInput | ProductCategoryCreateOrConnectWithoutStoreInput[]
    createMany?: ProductCategoryCreateManyStoreInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<SaleCreateWithoutStoreInput, SaleUncheckedCreateWithoutStoreInput> | SaleCreateWithoutStoreInput[] | SaleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutStoreInput | SaleCreateOrConnectWithoutStoreInput[]
    createMany?: SaleCreateManyStoreInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type StorePurchaseOrderUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StorePurchaseOrderCreateWithoutStoreInput, StorePurchaseOrderUncheckedCreateWithoutStoreInput> | StorePurchaseOrderCreateWithoutStoreInput[] | StorePurchaseOrderUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StorePurchaseOrderCreateOrConnectWithoutStoreInput | StorePurchaseOrderCreateOrConnectWithoutStoreInput[]
    createMany?: StorePurchaseOrderCreateManyStoreInputEnvelope
    connect?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
  }

  export type StoreSupplierUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreSupplierCreateWithoutStoreInput, StoreSupplierUncheckedCreateWithoutStoreInput> | StoreSupplierCreateWithoutStoreInput[] | StoreSupplierUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreSupplierCreateOrConnectWithoutStoreInput | StoreSupplierCreateOrConnectWithoutStoreInput[]
    createMany?: StoreSupplierCreateManyStoreInputEnvelope
    connect?: StoreSupplierWhereUniqueInput | StoreSupplierWhereUniqueInput[]
  }

  export type StoreCustomerUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreCustomerCreateWithoutStoreInput, StoreCustomerUncheckedCreateWithoutStoreInput> | StoreCustomerCreateWithoutStoreInput[] | StoreCustomerUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreCustomerCreateOrConnectWithoutStoreInput | StoreCustomerCreateOrConnectWithoutStoreInput[]
    createMany?: StoreCustomerCreateManyStoreInputEnvelope
    connect?: StoreCustomerWhereUniqueInput | StoreCustomerWhereUniqueInput[]
  }

  export type StockMovementUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StockMovementCreateWithoutStoreInput, StockMovementUncheckedCreateWithoutStoreInput> | StockMovementCreateWithoutStoreInput[] | StockMovementUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutStoreInput | StockMovementCreateOrConnectWithoutStoreInput[]
    createMany?: StockMovementCreateManyStoreInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type StoreTaxRuleUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreTaxRuleCreateWithoutStoreInput, StoreTaxRuleUncheckedCreateWithoutStoreInput> | StoreTaxRuleCreateWithoutStoreInput[] | StoreTaxRuleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreTaxRuleCreateOrConnectWithoutStoreInput | StoreTaxRuleCreateOrConnectWithoutStoreInput[]
    createMany?: StoreTaxRuleCreateManyStoreInputEnvelope
    connect?: StoreTaxRuleWhereUniqueInput | StoreTaxRuleWhereUniqueInput[]
  }

  export type StoreLoyaltyConfigUncheckedCreateNestedOneWithoutStoreInput = {
    create?: XOR<StoreLoyaltyConfigCreateWithoutStoreInput, StoreLoyaltyConfigUncheckedCreateWithoutStoreInput>
    connectOrCreate?: StoreLoyaltyConfigCreateOrConnectWithoutStoreInput
    connect?: StoreLoyaltyConfigWhereUniqueInput
  }

  export type TransferOrderUncheckedCreateNestedManyWithoutFromStoreInput = {
    create?: XOR<TransferOrderCreateWithoutFromStoreInput, TransferOrderUncheckedCreateWithoutFromStoreInput> | TransferOrderCreateWithoutFromStoreInput[] | TransferOrderUncheckedCreateWithoutFromStoreInput[]
    connectOrCreate?: TransferOrderCreateOrConnectWithoutFromStoreInput | TransferOrderCreateOrConnectWithoutFromStoreInput[]
    createMany?: TransferOrderCreateManyFromStoreInputEnvelope
    connect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
  }

  export type TransferOrderUncheckedCreateNestedManyWithoutToStoreInput = {
    create?: XOR<TransferOrderCreateWithoutToStoreInput, TransferOrderUncheckedCreateWithoutToStoreInput> | TransferOrderCreateWithoutToStoreInput[] | TransferOrderUncheckedCreateWithoutToStoreInput[]
    connectOrCreate?: TransferOrderCreateOrConnectWithoutToStoreInput | TransferOrderCreateOrConnectWithoutToStoreInput[]
    createMany?: TransferOrderCreateManyToStoreInputEnvelope
    connect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
  }

  export type StorePaymentConfigUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StorePaymentConfigCreateWithoutStoreInput, StorePaymentConfigUncheckedCreateWithoutStoreInput> | StorePaymentConfigCreateWithoutStoreInput[] | StorePaymentConfigUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StorePaymentConfigCreateOrConnectWithoutStoreInput | StorePaymentConfigCreateOrConnectWithoutStoreInput[]
    createMany?: StorePaymentConfigCreateManyStoreInputEnvelope
    connect?: StorePaymentConfigWhereUniqueInput | StorePaymentConfigWhereUniqueInput[]
  }

  export type StoreReceiptConfigUncheckedCreateNestedOneWithoutStoreInput = {
    create?: XOR<StoreReceiptConfigCreateWithoutStoreInput, StoreReceiptConfigUncheckedCreateWithoutStoreInput>
    connectOrCreate?: StoreReceiptConfigCreateOrConnectWithoutStoreInput
    connect?: StoreReceiptConfigWhereUniqueInput
  }

  export type StoreDeviceConfigUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreDeviceConfigCreateWithoutStoreInput, StoreDeviceConfigUncheckedCreateWithoutStoreInput> | StoreDeviceConfigCreateWithoutStoreInput[] | StoreDeviceConfigUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreDeviceConfigCreateOrConnectWithoutStoreInput | StoreDeviceConfigCreateOrConnectWithoutStoreInput[]
    createMany?: StoreDeviceConfigCreateManyStoreInputEnvelope
    connect?: StoreDeviceConfigWhereUniqueInput | StoreDeviceConfigWhereUniqueInput[]
  }

  export type StoreIntegrationUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreIntegrationCreateWithoutStoreInput, StoreIntegrationUncheckedCreateWithoutStoreInput> | StoreIntegrationCreateWithoutStoreInput[] | StoreIntegrationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreIntegrationCreateOrConnectWithoutStoreInput | StoreIntegrationCreateOrConnectWithoutStoreInput[]
    createMany?: StoreIntegrationCreateManyStoreInputEnvelope
    connect?: StoreIntegrationWhereUniqueInput | StoreIntegrationWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type StoreEmployeeUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreEmployeeCreateWithoutStoreInput, StoreEmployeeUncheckedCreateWithoutStoreInput> | StoreEmployeeCreateWithoutStoreInput[] | StoreEmployeeUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreEmployeeCreateOrConnectWithoutStoreInput | StoreEmployeeCreateOrConnectWithoutStoreInput[]
    upsert?: StoreEmployeeUpsertWithWhereUniqueWithoutStoreInput | StoreEmployeeUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreEmployeeCreateManyStoreInputEnvelope
    set?: StoreEmployeeWhereUniqueInput | StoreEmployeeWhereUniqueInput[]
    disconnect?: StoreEmployeeWhereUniqueInput | StoreEmployeeWhereUniqueInput[]
    delete?: StoreEmployeeWhereUniqueInput | StoreEmployeeWhereUniqueInput[]
    connect?: StoreEmployeeWhereUniqueInput | StoreEmployeeWhereUniqueInput[]
    update?: StoreEmployeeUpdateWithWhereUniqueWithoutStoreInput | StoreEmployeeUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreEmployeeUpdateManyWithWhereWithoutStoreInput | StoreEmployeeUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreEmployeeScalarWhereInput | StoreEmployeeScalarWhereInput[]
  }

  export type StoreProductUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreProductCreateWithoutStoreInput, StoreProductUncheckedCreateWithoutStoreInput> | StoreProductCreateWithoutStoreInput[] | StoreProductUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreProductCreateOrConnectWithoutStoreInput | StoreProductCreateOrConnectWithoutStoreInput[]
    upsert?: StoreProductUpsertWithWhereUniqueWithoutStoreInput | StoreProductUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreProductCreateManyStoreInputEnvelope
    set?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    disconnect?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    delete?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    connect?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    update?: StoreProductUpdateWithWhereUniqueWithoutStoreInput | StoreProductUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreProductUpdateManyWithWhereWithoutStoreInput | StoreProductUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreProductScalarWhereInput | StoreProductScalarWhereInput[]
  }

  export type ProductCategoryUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutStoreInput, ProductCategoryUncheckedCreateWithoutStoreInput> | ProductCategoryCreateWithoutStoreInput[] | ProductCategoryUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutStoreInput | ProductCategoryCreateOrConnectWithoutStoreInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutStoreInput | ProductCategoryUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ProductCategoryCreateManyStoreInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutStoreInput | ProductCategoryUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutStoreInput | ProductCategoryUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type SaleUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SaleCreateWithoutStoreInput, SaleUncheckedCreateWithoutStoreInput> | SaleCreateWithoutStoreInput[] | SaleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutStoreInput | SaleCreateOrConnectWithoutStoreInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutStoreInput | SaleUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SaleCreateManyStoreInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutStoreInput | SaleUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutStoreInput | SaleUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type StorePurchaseOrderUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StorePurchaseOrderCreateWithoutStoreInput, StorePurchaseOrderUncheckedCreateWithoutStoreInput> | StorePurchaseOrderCreateWithoutStoreInput[] | StorePurchaseOrderUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StorePurchaseOrderCreateOrConnectWithoutStoreInput | StorePurchaseOrderCreateOrConnectWithoutStoreInput[]
    upsert?: StorePurchaseOrderUpsertWithWhereUniqueWithoutStoreInput | StorePurchaseOrderUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StorePurchaseOrderCreateManyStoreInputEnvelope
    set?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
    disconnect?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
    delete?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
    connect?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
    update?: StorePurchaseOrderUpdateWithWhereUniqueWithoutStoreInput | StorePurchaseOrderUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StorePurchaseOrderUpdateManyWithWhereWithoutStoreInput | StorePurchaseOrderUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StorePurchaseOrderScalarWhereInput | StorePurchaseOrderScalarWhereInput[]
  }

  export type StoreSupplierUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreSupplierCreateWithoutStoreInput, StoreSupplierUncheckedCreateWithoutStoreInput> | StoreSupplierCreateWithoutStoreInput[] | StoreSupplierUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreSupplierCreateOrConnectWithoutStoreInput | StoreSupplierCreateOrConnectWithoutStoreInput[]
    upsert?: StoreSupplierUpsertWithWhereUniqueWithoutStoreInput | StoreSupplierUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreSupplierCreateManyStoreInputEnvelope
    set?: StoreSupplierWhereUniqueInput | StoreSupplierWhereUniqueInput[]
    disconnect?: StoreSupplierWhereUniqueInput | StoreSupplierWhereUniqueInput[]
    delete?: StoreSupplierWhereUniqueInput | StoreSupplierWhereUniqueInput[]
    connect?: StoreSupplierWhereUniqueInput | StoreSupplierWhereUniqueInput[]
    update?: StoreSupplierUpdateWithWhereUniqueWithoutStoreInput | StoreSupplierUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreSupplierUpdateManyWithWhereWithoutStoreInput | StoreSupplierUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreSupplierScalarWhereInput | StoreSupplierScalarWhereInput[]
  }

  export type StoreCustomerUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreCustomerCreateWithoutStoreInput, StoreCustomerUncheckedCreateWithoutStoreInput> | StoreCustomerCreateWithoutStoreInput[] | StoreCustomerUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreCustomerCreateOrConnectWithoutStoreInput | StoreCustomerCreateOrConnectWithoutStoreInput[]
    upsert?: StoreCustomerUpsertWithWhereUniqueWithoutStoreInput | StoreCustomerUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreCustomerCreateManyStoreInputEnvelope
    set?: StoreCustomerWhereUniqueInput | StoreCustomerWhereUniqueInput[]
    disconnect?: StoreCustomerWhereUniqueInput | StoreCustomerWhereUniqueInput[]
    delete?: StoreCustomerWhereUniqueInput | StoreCustomerWhereUniqueInput[]
    connect?: StoreCustomerWhereUniqueInput | StoreCustomerWhereUniqueInput[]
    update?: StoreCustomerUpdateWithWhereUniqueWithoutStoreInput | StoreCustomerUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreCustomerUpdateManyWithWhereWithoutStoreInput | StoreCustomerUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreCustomerScalarWhereInput | StoreCustomerScalarWhereInput[]
  }

  export type StockMovementUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StockMovementCreateWithoutStoreInput, StockMovementUncheckedCreateWithoutStoreInput> | StockMovementCreateWithoutStoreInput[] | StockMovementUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutStoreInput | StockMovementCreateOrConnectWithoutStoreInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutStoreInput | StockMovementUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StockMovementCreateManyStoreInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutStoreInput | StockMovementUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutStoreInput | StockMovementUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type StoreTaxRuleUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreTaxRuleCreateWithoutStoreInput, StoreTaxRuleUncheckedCreateWithoutStoreInput> | StoreTaxRuleCreateWithoutStoreInput[] | StoreTaxRuleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreTaxRuleCreateOrConnectWithoutStoreInput | StoreTaxRuleCreateOrConnectWithoutStoreInput[]
    upsert?: StoreTaxRuleUpsertWithWhereUniqueWithoutStoreInput | StoreTaxRuleUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreTaxRuleCreateManyStoreInputEnvelope
    set?: StoreTaxRuleWhereUniqueInput | StoreTaxRuleWhereUniqueInput[]
    disconnect?: StoreTaxRuleWhereUniqueInput | StoreTaxRuleWhereUniqueInput[]
    delete?: StoreTaxRuleWhereUniqueInput | StoreTaxRuleWhereUniqueInput[]
    connect?: StoreTaxRuleWhereUniqueInput | StoreTaxRuleWhereUniqueInput[]
    update?: StoreTaxRuleUpdateWithWhereUniqueWithoutStoreInput | StoreTaxRuleUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreTaxRuleUpdateManyWithWhereWithoutStoreInput | StoreTaxRuleUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreTaxRuleScalarWhereInput | StoreTaxRuleScalarWhereInput[]
  }

  export type StoreLoyaltyConfigUpdateOneWithoutStoreNestedInput = {
    create?: XOR<StoreLoyaltyConfigCreateWithoutStoreInput, StoreLoyaltyConfigUncheckedCreateWithoutStoreInput>
    connectOrCreate?: StoreLoyaltyConfigCreateOrConnectWithoutStoreInput
    upsert?: StoreLoyaltyConfigUpsertWithoutStoreInput
    disconnect?: StoreLoyaltyConfigWhereInput | boolean
    delete?: StoreLoyaltyConfigWhereInput | boolean
    connect?: StoreLoyaltyConfigWhereUniqueInput
    update?: XOR<XOR<StoreLoyaltyConfigUpdateToOneWithWhereWithoutStoreInput, StoreLoyaltyConfigUpdateWithoutStoreInput>, StoreLoyaltyConfigUncheckedUpdateWithoutStoreInput>
  }

  export type TransferOrderUpdateManyWithoutFromStoreNestedInput = {
    create?: XOR<TransferOrderCreateWithoutFromStoreInput, TransferOrderUncheckedCreateWithoutFromStoreInput> | TransferOrderCreateWithoutFromStoreInput[] | TransferOrderUncheckedCreateWithoutFromStoreInput[]
    connectOrCreate?: TransferOrderCreateOrConnectWithoutFromStoreInput | TransferOrderCreateOrConnectWithoutFromStoreInput[]
    upsert?: TransferOrderUpsertWithWhereUniqueWithoutFromStoreInput | TransferOrderUpsertWithWhereUniqueWithoutFromStoreInput[]
    createMany?: TransferOrderCreateManyFromStoreInputEnvelope
    set?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    disconnect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    delete?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    connect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    update?: TransferOrderUpdateWithWhereUniqueWithoutFromStoreInput | TransferOrderUpdateWithWhereUniqueWithoutFromStoreInput[]
    updateMany?: TransferOrderUpdateManyWithWhereWithoutFromStoreInput | TransferOrderUpdateManyWithWhereWithoutFromStoreInput[]
    deleteMany?: TransferOrderScalarWhereInput | TransferOrderScalarWhereInput[]
  }

  export type TransferOrderUpdateManyWithoutToStoreNestedInput = {
    create?: XOR<TransferOrderCreateWithoutToStoreInput, TransferOrderUncheckedCreateWithoutToStoreInput> | TransferOrderCreateWithoutToStoreInput[] | TransferOrderUncheckedCreateWithoutToStoreInput[]
    connectOrCreate?: TransferOrderCreateOrConnectWithoutToStoreInput | TransferOrderCreateOrConnectWithoutToStoreInput[]
    upsert?: TransferOrderUpsertWithWhereUniqueWithoutToStoreInput | TransferOrderUpsertWithWhereUniqueWithoutToStoreInput[]
    createMany?: TransferOrderCreateManyToStoreInputEnvelope
    set?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    disconnect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    delete?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    connect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    update?: TransferOrderUpdateWithWhereUniqueWithoutToStoreInput | TransferOrderUpdateWithWhereUniqueWithoutToStoreInput[]
    updateMany?: TransferOrderUpdateManyWithWhereWithoutToStoreInput | TransferOrderUpdateManyWithWhereWithoutToStoreInput[]
    deleteMany?: TransferOrderScalarWhereInput | TransferOrderScalarWhereInput[]
  }

  export type StorePaymentConfigUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StorePaymentConfigCreateWithoutStoreInput, StorePaymentConfigUncheckedCreateWithoutStoreInput> | StorePaymentConfigCreateWithoutStoreInput[] | StorePaymentConfigUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StorePaymentConfigCreateOrConnectWithoutStoreInput | StorePaymentConfigCreateOrConnectWithoutStoreInput[]
    upsert?: StorePaymentConfigUpsertWithWhereUniqueWithoutStoreInput | StorePaymentConfigUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StorePaymentConfigCreateManyStoreInputEnvelope
    set?: StorePaymentConfigWhereUniqueInput | StorePaymentConfigWhereUniqueInput[]
    disconnect?: StorePaymentConfigWhereUniqueInput | StorePaymentConfigWhereUniqueInput[]
    delete?: StorePaymentConfigWhereUniqueInput | StorePaymentConfigWhereUniqueInput[]
    connect?: StorePaymentConfigWhereUniqueInput | StorePaymentConfigWhereUniqueInput[]
    update?: StorePaymentConfigUpdateWithWhereUniqueWithoutStoreInput | StorePaymentConfigUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StorePaymentConfigUpdateManyWithWhereWithoutStoreInput | StorePaymentConfigUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StorePaymentConfigScalarWhereInput | StorePaymentConfigScalarWhereInput[]
  }

  export type StoreReceiptConfigUpdateOneWithoutStoreNestedInput = {
    create?: XOR<StoreReceiptConfigCreateWithoutStoreInput, StoreReceiptConfigUncheckedCreateWithoutStoreInput>
    connectOrCreate?: StoreReceiptConfigCreateOrConnectWithoutStoreInput
    upsert?: StoreReceiptConfigUpsertWithoutStoreInput
    disconnect?: StoreReceiptConfigWhereInput | boolean
    delete?: StoreReceiptConfigWhereInput | boolean
    connect?: StoreReceiptConfigWhereUniqueInput
    update?: XOR<XOR<StoreReceiptConfigUpdateToOneWithWhereWithoutStoreInput, StoreReceiptConfigUpdateWithoutStoreInput>, StoreReceiptConfigUncheckedUpdateWithoutStoreInput>
  }

  export type StoreDeviceConfigUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreDeviceConfigCreateWithoutStoreInput, StoreDeviceConfigUncheckedCreateWithoutStoreInput> | StoreDeviceConfigCreateWithoutStoreInput[] | StoreDeviceConfigUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreDeviceConfigCreateOrConnectWithoutStoreInput | StoreDeviceConfigCreateOrConnectWithoutStoreInput[]
    upsert?: StoreDeviceConfigUpsertWithWhereUniqueWithoutStoreInput | StoreDeviceConfigUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreDeviceConfigCreateManyStoreInputEnvelope
    set?: StoreDeviceConfigWhereUniqueInput | StoreDeviceConfigWhereUniqueInput[]
    disconnect?: StoreDeviceConfigWhereUniqueInput | StoreDeviceConfigWhereUniqueInput[]
    delete?: StoreDeviceConfigWhereUniqueInput | StoreDeviceConfigWhereUniqueInput[]
    connect?: StoreDeviceConfigWhereUniqueInput | StoreDeviceConfigWhereUniqueInput[]
    update?: StoreDeviceConfigUpdateWithWhereUniqueWithoutStoreInput | StoreDeviceConfigUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreDeviceConfigUpdateManyWithWhereWithoutStoreInput | StoreDeviceConfigUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreDeviceConfigScalarWhereInput | StoreDeviceConfigScalarWhereInput[]
  }

  export type StoreIntegrationUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreIntegrationCreateWithoutStoreInput, StoreIntegrationUncheckedCreateWithoutStoreInput> | StoreIntegrationCreateWithoutStoreInput[] | StoreIntegrationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreIntegrationCreateOrConnectWithoutStoreInput | StoreIntegrationCreateOrConnectWithoutStoreInput[]
    upsert?: StoreIntegrationUpsertWithWhereUniqueWithoutStoreInput | StoreIntegrationUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreIntegrationCreateManyStoreInputEnvelope
    set?: StoreIntegrationWhereUniqueInput | StoreIntegrationWhereUniqueInput[]
    disconnect?: StoreIntegrationWhereUniqueInput | StoreIntegrationWhereUniqueInput[]
    delete?: StoreIntegrationWhereUniqueInput | StoreIntegrationWhereUniqueInput[]
    connect?: StoreIntegrationWhereUniqueInput | StoreIntegrationWhereUniqueInput[]
    update?: StoreIntegrationUpdateWithWhereUniqueWithoutStoreInput | StoreIntegrationUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreIntegrationUpdateManyWithWhereWithoutStoreInput | StoreIntegrationUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreIntegrationScalarWhereInput | StoreIntegrationScalarWhereInput[]
  }

  export type StoreEmployeeUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreEmployeeCreateWithoutStoreInput, StoreEmployeeUncheckedCreateWithoutStoreInput> | StoreEmployeeCreateWithoutStoreInput[] | StoreEmployeeUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreEmployeeCreateOrConnectWithoutStoreInput | StoreEmployeeCreateOrConnectWithoutStoreInput[]
    upsert?: StoreEmployeeUpsertWithWhereUniqueWithoutStoreInput | StoreEmployeeUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreEmployeeCreateManyStoreInputEnvelope
    set?: StoreEmployeeWhereUniqueInput | StoreEmployeeWhereUniqueInput[]
    disconnect?: StoreEmployeeWhereUniqueInput | StoreEmployeeWhereUniqueInput[]
    delete?: StoreEmployeeWhereUniqueInput | StoreEmployeeWhereUniqueInput[]
    connect?: StoreEmployeeWhereUniqueInput | StoreEmployeeWhereUniqueInput[]
    update?: StoreEmployeeUpdateWithWhereUniqueWithoutStoreInput | StoreEmployeeUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreEmployeeUpdateManyWithWhereWithoutStoreInput | StoreEmployeeUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreEmployeeScalarWhereInput | StoreEmployeeScalarWhereInput[]
  }

  export type StoreProductUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreProductCreateWithoutStoreInput, StoreProductUncheckedCreateWithoutStoreInput> | StoreProductCreateWithoutStoreInput[] | StoreProductUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreProductCreateOrConnectWithoutStoreInput | StoreProductCreateOrConnectWithoutStoreInput[]
    upsert?: StoreProductUpsertWithWhereUniqueWithoutStoreInput | StoreProductUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreProductCreateManyStoreInputEnvelope
    set?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    disconnect?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    delete?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    connect?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    update?: StoreProductUpdateWithWhereUniqueWithoutStoreInput | StoreProductUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreProductUpdateManyWithWhereWithoutStoreInput | StoreProductUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreProductScalarWhereInput | StoreProductScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutStoreInput, ProductCategoryUncheckedCreateWithoutStoreInput> | ProductCategoryCreateWithoutStoreInput[] | ProductCategoryUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutStoreInput | ProductCategoryCreateOrConnectWithoutStoreInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutStoreInput | ProductCategoryUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ProductCategoryCreateManyStoreInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutStoreInput | ProductCategoryUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutStoreInput | ProductCategoryUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SaleCreateWithoutStoreInput, SaleUncheckedCreateWithoutStoreInput> | SaleCreateWithoutStoreInput[] | SaleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutStoreInput | SaleCreateOrConnectWithoutStoreInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutStoreInput | SaleUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SaleCreateManyStoreInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutStoreInput | SaleUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutStoreInput | SaleUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type StorePurchaseOrderUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StorePurchaseOrderCreateWithoutStoreInput, StorePurchaseOrderUncheckedCreateWithoutStoreInput> | StorePurchaseOrderCreateWithoutStoreInput[] | StorePurchaseOrderUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StorePurchaseOrderCreateOrConnectWithoutStoreInput | StorePurchaseOrderCreateOrConnectWithoutStoreInput[]
    upsert?: StorePurchaseOrderUpsertWithWhereUniqueWithoutStoreInput | StorePurchaseOrderUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StorePurchaseOrderCreateManyStoreInputEnvelope
    set?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
    disconnect?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
    delete?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
    connect?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
    update?: StorePurchaseOrderUpdateWithWhereUniqueWithoutStoreInput | StorePurchaseOrderUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StorePurchaseOrderUpdateManyWithWhereWithoutStoreInput | StorePurchaseOrderUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StorePurchaseOrderScalarWhereInput | StorePurchaseOrderScalarWhereInput[]
  }

  export type StoreSupplierUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreSupplierCreateWithoutStoreInput, StoreSupplierUncheckedCreateWithoutStoreInput> | StoreSupplierCreateWithoutStoreInput[] | StoreSupplierUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreSupplierCreateOrConnectWithoutStoreInput | StoreSupplierCreateOrConnectWithoutStoreInput[]
    upsert?: StoreSupplierUpsertWithWhereUniqueWithoutStoreInput | StoreSupplierUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreSupplierCreateManyStoreInputEnvelope
    set?: StoreSupplierWhereUniqueInput | StoreSupplierWhereUniqueInput[]
    disconnect?: StoreSupplierWhereUniqueInput | StoreSupplierWhereUniqueInput[]
    delete?: StoreSupplierWhereUniqueInput | StoreSupplierWhereUniqueInput[]
    connect?: StoreSupplierWhereUniqueInput | StoreSupplierWhereUniqueInput[]
    update?: StoreSupplierUpdateWithWhereUniqueWithoutStoreInput | StoreSupplierUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreSupplierUpdateManyWithWhereWithoutStoreInput | StoreSupplierUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreSupplierScalarWhereInput | StoreSupplierScalarWhereInput[]
  }

  export type StoreCustomerUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreCustomerCreateWithoutStoreInput, StoreCustomerUncheckedCreateWithoutStoreInput> | StoreCustomerCreateWithoutStoreInput[] | StoreCustomerUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreCustomerCreateOrConnectWithoutStoreInput | StoreCustomerCreateOrConnectWithoutStoreInput[]
    upsert?: StoreCustomerUpsertWithWhereUniqueWithoutStoreInput | StoreCustomerUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreCustomerCreateManyStoreInputEnvelope
    set?: StoreCustomerWhereUniqueInput | StoreCustomerWhereUniqueInput[]
    disconnect?: StoreCustomerWhereUniqueInput | StoreCustomerWhereUniqueInput[]
    delete?: StoreCustomerWhereUniqueInput | StoreCustomerWhereUniqueInput[]
    connect?: StoreCustomerWhereUniqueInput | StoreCustomerWhereUniqueInput[]
    update?: StoreCustomerUpdateWithWhereUniqueWithoutStoreInput | StoreCustomerUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreCustomerUpdateManyWithWhereWithoutStoreInput | StoreCustomerUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreCustomerScalarWhereInput | StoreCustomerScalarWhereInput[]
  }

  export type StockMovementUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StockMovementCreateWithoutStoreInput, StockMovementUncheckedCreateWithoutStoreInput> | StockMovementCreateWithoutStoreInput[] | StockMovementUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutStoreInput | StockMovementCreateOrConnectWithoutStoreInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutStoreInput | StockMovementUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StockMovementCreateManyStoreInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutStoreInput | StockMovementUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutStoreInput | StockMovementUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type StoreTaxRuleUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreTaxRuleCreateWithoutStoreInput, StoreTaxRuleUncheckedCreateWithoutStoreInput> | StoreTaxRuleCreateWithoutStoreInput[] | StoreTaxRuleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreTaxRuleCreateOrConnectWithoutStoreInput | StoreTaxRuleCreateOrConnectWithoutStoreInput[]
    upsert?: StoreTaxRuleUpsertWithWhereUniqueWithoutStoreInput | StoreTaxRuleUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreTaxRuleCreateManyStoreInputEnvelope
    set?: StoreTaxRuleWhereUniqueInput | StoreTaxRuleWhereUniqueInput[]
    disconnect?: StoreTaxRuleWhereUniqueInput | StoreTaxRuleWhereUniqueInput[]
    delete?: StoreTaxRuleWhereUniqueInput | StoreTaxRuleWhereUniqueInput[]
    connect?: StoreTaxRuleWhereUniqueInput | StoreTaxRuleWhereUniqueInput[]
    update?: StoreTaxRuleUpdateWithWhereUniqueWithoutStoreInput | StoreTaxRuleUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreTaxRuleUpdateManyWithWhereWithoutStoreInput | StoreTaxRuleUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreTaxRuleScalarWhereInput | StoreTaxRuleScalarWhereInput[]
  }

  export type StoreLoyaltyConfigUncheckedUpdateOneWithoutStoreNestedInput = {
    create?: XOR<StoreLoyaltyConfigCreateWithoutStoreInput, StoreLoyaltyConfigUncheckedCreateWithoutStoreInput>
    connectOrCreate?: StoreLoyaltyConfigCreateOrConnectWithoutStoreInput
    upsert?: StoreLoyaltyConfigUpsertWithoutStoreInput
    disconnect?: StoreLoyaltyConfigWhereInput | boolean
    delete?: StoreLoyaltyConfigWhereInput | boolean
    connect?: StoreLoyaltyConfigWhereUniqueInput
    update?: XOR<XOR<StoreLoyaltyConfigUpdateToOneWithWhereWithoutStoreInput, StoreLoyaltyConfigUpdateWithoutStoreInput>, StoreLoyaltyConfigUncheckedUpdateWithoutStoreInput>
  }

  export type TransferOrderUncheckedUpdateManyWithoutFromStoreNestedInput = {
    create?: XOR<TransferOrderCreateWithoutFromStoreInput, TransferOrderUncheckedCreateWithoutFromStoreInput> | TransferOrderCreateWithoutFromStoreInput[] | TransferOrderUncheckedCreateWithoutFromStoreInput[]
    connectOrCreate?: TransferOrderCreateOrConnectWithoutFromStoreInput | TransferOrderCreateOrConnectWithoutFromStoreInput[]
    upsert?: TransferOrderUpsertWithWhereUniqueWithoutFromStoreInput | TransferOrderUpsertWithWhereUniqueWithoutFromStoreInput[]
    createMany?: TransferOrderCreateManyFromStoreInputEnvelope
    set?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    disconnect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    delete?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    connect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    update?: TransferOrderUpdateWithWhereUniqueWithoutFromStoreInput | TransferOrderUpdateWithWhereUniqueWithoutFromStoreInput[]
    updateMany?: TransferOrderUpdateManyWithWhereWithoutFromStoreInput | TransferOrderUpdateManyWithWhereWithoutFromStoreInput[]
    deleteMany?: TransferOrderScalarWhereInput | TransferOrderScalarWhereInput[]
  }

  export type TransferOrderUncheckedUpdateManyWithoutToStoreNestedInput = {
    create?: XOR<TransferOrderCreateWithoutToStoreInput, TransferOrderUncheckedCreateWithoutToStoreInput> | TransferOrderCreateWithoutToStoreInput[] | TransferOrderUncheckedCreateWithoutToStoreInput[]
    connectOrCreate?: TransferOrderCreateOrConnectWithoutToStoreInput | TransferOrderCreateOrConnectWithoutToStoreInput[]
    upsert?: TransferOrderUpsertWithWhereUniqueWithoutToStoreInput | TransferOrderUpsertWithWhereUniqueWithoutToStoreInput[]
    createMany?: TransferOrderCreateManyToStoreInputEnvelope
    set?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    disconnect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    delete?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    connect?: TransferOrderWhereUniqueInput | TransferOrderWhereUniqueInput[]
    update?: TransferOrderUpdateWithWhereUniqueWithoutToStoreInput | TransferOrderUpdateWithWhereUniqueWithoutToStoreInput[]
    updateMany?: TransferOrderUpdateManyWithWhereWithoutToStoreInput | TransferOrderUpdateManyWithWhereWithoutToStoreInput[]
    deleteMany?: TransferOrderScalarWhereInput | TransferOrderScalarWhereInput[]
  }

  export type StorePaymentConfigUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StorePaymentConfigCreateWithoutStoreInput, StorePaymentConfigUncheckedCreateWithoutStoreInput> | StorePaymentConfigCreateWithoutStoreInput[] | StorePaymentConfigUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StorePaymentConfigCreateOrConnectWithoutStoreInput | StorePaymentConfigCreateOrConnectWithoutStoreInput[]
    upsert?: StorePaymentConfigUpsertWithWhereUniqueWithoutStoreInput | StorePaymentConfigUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StorePaymentConfigCreateManyStoreInputEnvelope
    set?: StorePaymentConfigWhereUniqueInput | StorePaymentConfigWhereUniqueInput[]
    disconnect?: StorePaymentConfigWhereUniqueInput | StorePaymentConfigWhereUniqueInput[]
    delete?: StorePaymentConfigWhereUniqueInput | StorePaymentConfigWhereUniqueInput[]
    connect?: StorePaymentConfigWhereUniqueInput | StorePaymentConfigWhereUniqueInput[]
    update?: StorePaymentConfigUpdateWithWhereUniqueWithoutStoreInput | StorePaymentConfigUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StorePaymentConfigUpdateManyWithWhereWithoutStoreInput | StorePaymentConfigUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StorePaymentConfigScalarWhereInput | StorePaymentConfigScalarWhereInput[]
  }

  export type StoreReceiptConfigUncheckedUpdateOneWithoutStoreNestedInput = {
    create?: XOR<StoreReceiptConfigCreateWithoutStoreInput, StoreReceiptConfigUncheckedCreateWithoutStoreInput>
    connectOrCreate?: StoreReceiptConfigCreateOrConnectWithoutStoreInput
    upsert?: StoreReceiptConfigUpsertWithoutStoreInput
    disconnect?: StoreReceiptConfigWhereInput | boolean
    delete?: StoreReceiptConfigWhereInput | boolean
    connect?: StoreReceiptConfigWhereUniqueInput
    update?: XOR<XOR<StoreReceiptConfigUpdateToOneWithWhereWithoutStoreInput, StoreReceiptConfigUpdateWithoutStoreInput>, StoreReceiptConfigUncheckedUpdateWithoutStoreInput>
  }

  export type StoreDeviceConfigUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreDeviceConfigCreateWithoutStoreInput, StoreDeviceConfigUncheckedCreateWithoutStoreInput> | StoreDeviceConfigCreateWithoutStoreInput[] | StoreDeviceConfigUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreDeviceConfigCreateOrConnectWithoutStoreInput | StoreDeviceConfigCreateOrConnectWithoutStoreInput[]
    upsert?: StoreDeviceConfigUpsertWithWhereUniqueWithoutStoreInput | StoreDeviceConfigUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreDeviceConfigCreateManyStoreInputEnvelope
    set?: StoreDeviceConfigWhereUniqueInput | StoreDeviceConfigWhereUniqueInput[]
    disconnect?: StoreDeviceConfigWhereUniqueInput | StoreDeviceConfigWhereUniqueInput[]
    delete?: StoreDeviceConfigWhereUniqueInput | StoreDeviceConfigWhereUniqueInput[]
    connect?: StoreDeviceConfigWhereUniqueInput | StoreDeviceConfigWhereUniqueInput[]
    update?: StoreDeviceConfigUpdateWithWhereUniqueWithoutStoreInput | StoreDeviceConfigUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreDeviceConfigUpdateManyWithWhereWithoutStoreInput | StoreDeviceConfigUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreDeviceConfigScalarWhereInput | StoreDeviceConfigScalarWhereInput[]
  }

  export type StoreIntegrationUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreIntegrationCreateWithoutStoreInput, StoreIntegrationUncheckedCreateWithoutStoreInput> | StoreIntegrationCreateWithoutStoreInput[] | StoreIntegrationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreIntegrationCreateOrConnectWithoutStoreInput | StoreIntegrationCreateOrConnectWithoutStoreInput[]
    upsert?: StoreIntegrationUpsertWithWhereUniqueWithoutStoreInput | StoreIntegrationUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreIntegrationCreateManyStoreInputEnvelope
    set?: StoreIntegrationWhereUniqueInput | StoreIntegrationWhereUniqueInput[]
    disconnect?: StoreIntegrationWhereUniqueInput | StoreIntegrationWhereUniqueInput[]
    delete?: StoreIntegrationWhereUniqueInput | StoreIntegrationWhereUniqueInput[]
    connect?: StoreIntegrationWhereUniqueInput | StoreIntegrationWhereUniqueInput[]
    update?: StoreIntegrationUpdateWithWhereUniqueWithoutStoreInput | StoreIntegrationUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreIntegrationUpdateManyWithWhereWithoutStoreInput | StoreIntegrationUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreIntegrationScalarWhereInput | StoreIntegrationScalarWhereInput[]
  }

  export type StoreCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<StoreCreateWithoutEmployeesInput, StoreUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutEmployeesInput
    connect?: StoreWhereUniqueInput
  }

  export type SaleCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SaleCreateWithoutEmployeeInput, SaleUncheckedCreateWithoutEmployeeInput> | SaleCreateWithoutEmployeeInput[] | SaleUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutEmployeeInput | SaleCreateOrConnectWithoutEmployeeInput[]
    createMany?: SaleCreateManyEmployeeInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SaleCreateWithoutEmployeeInput, SaleUncheckedCreateWithoutEmployeeInput> | SaleCreateWithoutEmployeeInput[] | SaleUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutEmployeeInput | SaleCreateOrConnectWithoutEmployeeInput[]
    createMany?: SaleCreateManyEmployeeInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type StoreUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<StoreCreateWithoutEmployeesInput, StoreUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutEmployeesInput
    upsert?: StoreUpsertWithoutEmployeesInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutEmployeesInput, StoreUpdateWithoutEmployeesInput>, StoreUncheckedUpdateWithoutEmployeesInput>
  }

  export type SaleUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SaleCreateWithoutEmployeeInput, SaleUncheckedCreateWithoutEmployeeInput> | SaleCreateWithoutEmployeeInput[] | SaleUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutEmployeeInput | SaleCreateOrConnectWithoutEmployeeInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutEmployeeInput | SaleUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SaleCreateManyEmployeeInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutEmployeeInput | SaleUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutEmployeeInput | SaleUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SaleCreateWithoutEmployeeInput, SaleUncheckedCreateWithoutEmployeeInput> | SaleCreateWithoutEmployeeInput[] | SaleUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutEmployeeInput | SaleCreateOrConnectWithoutEmployeeInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutEmployeeInput | SaleUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SaleCreateManyEmployeeInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutEmployeeInput | SaleUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutEmployeeInput | SaleUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type StoreCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<StoreCreateWithoutCategoriesInput, StoreUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutCategoriesInput
    connect?: StoreWhereUniqueInput
  }

  export type ProductCategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ProductCategoryCreateWithoutChildrenInput, ProductCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutChildrenInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type ProductCategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput> | ProductCategoryCreateWithoutParentInput[] | ProductCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutParentInput | ProductCategoryCreateOrConnectWithoutParentInput[]
    createMany?: ProductCategoryCreateManyParentInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type StoreProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<StoreProductCreateWithoutCategoryInput, StoreProductUncheckedCreateWithoutCategoryInput> | StoreProductCreateWithoutCategoryInput[] | StoreProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StoreProductCreateOrConnectWithoutCategoryInput | StoreProductCreateOrConnectWithoutCategoryInput[]
    createMany?: StoreProductCreateManyCategoryInputEnvelope
    connect?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput> | ProductCategoryCreateWithoutParentInput[] | ProductCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutParentInput | ProductCategoryCreateOrConnectWithoutParentInput[]
    createMany?: ProductCategoryCreateManyParentInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type StoreProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<StoreProductCreateWithoutCategoryInput, StoreProductUncheckedCreateWithoutCategoryInput> | StoreProductCreateWithoutCategoryInput[] | StoreProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StoreProductCreateOrConnectWithoutCategoryInput | StoreProductCreateOrConnectWithoutCategoryInput[]
    createMany?: StoreProductCreateManyCategoryInputEnvelope
    connect?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StoreUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<StoreCreateWithoutCategoriesInput, StoreUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutCategoriesInput
    upsert?: StoreUpsertWithoutCategoriesInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutCategoriesInput, StoreUpdateWithoutCategoriesInput>, StoreUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductCategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutChildrenInput, ProductCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutChildrenInput
    upsert?: ProductCategoryUpsertWithoutChildrenInput
    disconnect?: ProductCategoryWhereInput | boolean
    delete?: ProductCategoryWhereInput | boolean
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutChildrenInput, ProductCategoryUpdateWithoutChildrenInput>, ProductCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type ProductCategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput> | ProductCategoryCreateWithoutParentInput[] | ProductCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutParentInput | ProductCategoryCreateOrConnectWithoutParentInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutParentInput | ProductCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ProductCategoryCreateManyParentInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutParentInput | ProductCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutParentInput | ProductCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type StoreProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<StoreProductCreateWithoutCategoryInput, StoreProductUncheckedCreateWithoutCategoryInput> | StoreProductCreateWithoutCategoryInput[] | StoreProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StoreProductCreateOrConnectWithoutCategoryInput | StoreProductCreateOrConnectWithoutCategoryInput[]
    upsert?: StoreProductUpsertWithWhereUniqueWithoutCategoryInput | StoreProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: StoreProductCreateManyCategoryInputEnvelope
    set?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    disconnect?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    delete?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    connect?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    update?: StoreProductUpdateWithWhereUniqueWithoutCategoryInput | StoreProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: StoreProductUpdateManyWithWhereWithoutCategoryInput | StoreProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: StoreProductScalarWhereInput | StoreProductScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput> | ProductCategoryCreateWithoutParentInput[] | ProductCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutParentInput | ProductCategoryCreateOrConnectWithoutParentInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutParentInput | ProductCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ProductCategoryCreateManyParentInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutParentInput | ProductCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutParentInput | ProductCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type StoreProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<StoreProductCreateWithoutCategoryInput, StoreProductUncheckedCreateWithoutCategoryInput> | StoreProductCreateWithoutCategoryInput[] | StoreProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: StoreProductCreateOrConnectWithoutCategoryInput | StoreProductCreateOrConnectWithoutCategoryInput[]
    upsert?: StoreProductUpsertWithWhereUniqueWithoutCategoryInput | StoreProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: StoreProductCreateManyCategoryInputEnvelope
    set?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    disconnect?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    delete?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    connect?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    update?: StoreProductUpdateWithWhereUniqueWithoutCategoryInput | StoreProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: StoreProductUpdateManyWithWhereWithoutCategoryInput | StoreProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: StoreProductScalarWhereInput | StoreProductScalarWhereInput[]
  }

  export type StoreCreateNestedOneWithoutProductsInput = {
    create?: XOR<StoreCreateWithoutProductsInput, StoreUncheckedCreateWithoutProductsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutProductsInput
    connect?: StoreWhereUniqueInput
  }

  export type ProductCategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type StoreTaxRuleCreateNestedOneWithoutProductsInput = {
    create?: XOR<StoreTaxRuleCreateWithoutProductsInput, StoreTaxRuleUncheckedCreateWithoutProductsInput>
    connectOrCreate?: StoreTaxRuleCreateOrConnectWithoutProductsInput
    connect?: StoreTaxRuleWhereUniqueInput
  }

  export type SaleItemCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput> | SaleItemCreateWithoutProductInput[] | SaleItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutProductInput | SaleItemCreateOrConnectWithoutProductInput[]
    createMany?: SaleItemCreateManyProductInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type SaleReturnItemCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleReturnItemCreateWithoutProductInput, SaleReturnItemUncheckedCreateWithoutProductInput> | SaleReturnItemCreateWithoutProductInput[] | SaleReturnItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleReturnItemCreateOrConnectWithoutProductInput | SaleReturnItemCreateOrConnectWithoutProductInput[]
    createMany?: SaleReturnItemCreateManyProductInputEnvelope
    connect?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
  }

  export type StorePurchaseItemCreateNestedManyWithoutProductInput = {
    create?: XOR<StorePurchaseItemCreateWithoutProductInput, StorePurchaseItemUncheckedCreateWithoutProductInput> | StorePurchaseItemCreateWithoutProductInput[] | StorePurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StorePurchaseItemCreateOrConnectWithoutProductInput | StorePurchaseItemCreateOrConnectWithoutProductInput[]
    createMany?: StorePurchaseItemCreateManyProductInputEnvelope
    connect?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
  }

  export type StockMovementCreateNestedManyWithoutProductInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type StorePriceHistoryCreateNestedManyWithoutProductInput = {
    create?: XOR<StorePriceHistoryCreateWithoutProductInput, StorePriceHistoryUncheckedCreateWithoutProductInput> | StorePriceHistoryCreateWithoutProductInput[] | StorePriceHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StorePriceHistoryCreateOrConnectWithoutProductInput | StorePriceHistoryCreateOrConnectWithoutProductInput[]
    createMany?: StorePriceHistoryCreateManyProductInputEnvelope
    connect?: StorePriceHistoryWhereUniqueInput | StorePriceHistoryWhereUniqueInput[]
  }

  export type TransferOrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<TransferOrderItemCreateWithoutProductInput, TransferOrderItemUncheckedCreateWithoutProductInput> | TransferOrderItemCreateWithoutProductInput[] | TransferOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferOrderItemCreateOrConnectWithoutProductInput | TransferOrderItemCreateOrConnectWithoutProductInput[]
    createMany?: TransferOrderItemCreateManyProductInputEnvelope
    connect?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
  }

  export type SaleItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput> | SaleItemCreateWithoutProductInput[] | SaleItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutProductInput | SaleItemCreateOrConnectWithoutProductInput[]
    createMany?: SaleItemCreateManyProductInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type SaleReturnItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleReturnItemCreateWithoutProductInput, SaleReturnItemUncheckedCreateWithoutProductInput> | SaleReturnItemCreateWithoutProductInput[] | SaleReturnItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleReturnItemCreateOrConnectWithoutProductInput | SaleReturnItemCreateOrConnectWithoutProductInput[]
    createMany?: SaleReturnItemCreateManyProductInputEnvelope
    connect?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
  }

  export type StorePurchaseItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StorePurchaseItemCreateWithoutProductInput, StorePurchaseItemUncheckedCreateWithoutProductInput> | StorePurchaseItemCreateWithoutProductInput[] | StorePurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StorePurchaseItemCreateOrConnectWithoutProductInput | StorePurchaseItemCreateOrConnectWithoutProductInput[]
    createMany?: StorePurchaseItemCreateManyProductInputEnvelope
    connect?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
  }

  export type StockMovementUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type StorePriceHistoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StorePriceHistoryCreateWithoutProductInput, StorePriceHistoryUncheckedCreateWithoutProductInput> | StorePriceHistoryCreateWithoutProductInput[] | StorePriceHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StorePriceHistoryCreateOrConnectWithoutProductInput | StorePriceHistoryCreateOrConnectWithoutProductInput[]
    createMany?: StorePriceHistoryCreateManyProductInputEnvelope
    connect?: StorePriceHistoryWhereUniqueInput | StorePriceHistoryWhereUniqueInput[]
  }

  export type TransferOrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<TransferOrderItemCreateWithoutProductInput, TransferOrderItemUncheckedCreateWithoutProductInput> | TransferOrderItemCreateWithoutProductInput[] | TransferOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferOrderItemCreateOrConnectWithoutProductInput | TransferOrderItemCreateOrConnectWithoutProductInput[]
    createMany?: TransferOrderItemCreateManyProductInputEnvelope
    connect?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type StoreUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<StoreCreateWithoutProductsInput, StoreUncheckedCreateWithoutProductsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutProductsInput
    upsert?: StoreUpsertWithoutProductsInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutProductsInput, StoreUpdateWithoutProductsInput>, StoreUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    upsert?: ProductCategoryUpsertWithoutProductsInput
    disconnect?: ProductCategoryWhereInput | boolean
    delete?: ProductCategoryWhereInput | boolean
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutProductsInput, ProductCategoryUpdateWithoutProductsInput>, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type StoreTaxRuleUpdateOneWithoutProductsNestedInput = {
    create?: XOR<StoreTaxRuleCreateWithoutProductsInput, StoreTaxRuleUncheckedCreateWithoutProductsInput>
    connectOrCreate?: StoreTaxRuleCreateOrConnectWithoutProductsInput
    upsert?: StoreTaxRuleUpsertWithoutProductsInput
    disconnect?: StoreTaxRuleWhereInput | boolean
    delete?: StoreTaxRuleWhereInput | boolean
    connect?: StoreTaxRuleWhereUniqueInput
    update?: XOR<XOR<StoreTaxRuleUpdateToOneWithWhereWithoutProductsInput, StoreTaxRuleUpdateWithoutProductsInput>, StoreTaxRuleUncheckedUpdateWithoutProductsInput>
  }

  export type SaleItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput> | SaleItemCreateWithoutProductInput[] | SaleItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutProductInput | SaleItemCreateOrConnectWithoutProductInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutProductInput | SaleItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleItemCreateManyProductInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutProductInput | SaleItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutProductInput | SaleItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type SaleReturnItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleReturnItemCreateWithoutProductInput, SaleReturnItemUncheckedCreateWithoutProductInput> | SaleReturnItemCreateWithoutProductInput[] | SaleReturnItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleReturnItemCreateOrConnectWithoutProductInput | SaleReturnItemCreateOrConnectWithoutProductInput[]
    upsert?: SaleReturnItemUpsertWithWhereUniqueWithoutProductInput | SaleReturnItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleReturnItemCreateManyProductInputEnvelope
    set?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
    disconnect?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
    delete?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
    connect?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
    update?: SaleReturnItemUpdateWithWhereUniqueWithoutProductInput | SaleReturnItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleReturnItemUpdateManyWithWhereWithoutProductInput | SaleReturnItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleReturnItemScalarWhereInput | SaleReturnItemScalarWhereInput[]
  }

  export type StorePurchaseItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<StorePurchaseItemCreateWithoutProductInput, StorePurchaseItemUncheckedCreateWithoutProductInput> | StorePurchaseItemCreateWithoutProductInput[] | StorePurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StorePurchaseItemCreateOrConnectWithoutProductInput | StorePurchaseItemCreateOrConnectWithoutProductInput[]
    upsert?: StorePurchaseItemUpsertWithWhereUniqueWithoutProductInput | StorePurchaseItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StorePurchaseItemCreateManyProductInputEnvelope
    set?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
    disconnect?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
    delete?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
    connect?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
    update?: StorePurchaseItemUpdateWithWhereUniqueWithoutProductInput | StorePurchaseItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StorePurchaseItemUpdateManyWithWhereWithoutProductInput | StorePurchaseItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StorePurchaseItemScalarWhereInput | StorePurchaseItemScalarWhereInput[]
  }

  export type StockMovementUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutProductInput | StockMovementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutProductInput | StockMovementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutProductInput | StockMovementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type StorePriceHistoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<StorePriceHistoryCreateWithoutProductInput, StorePriceHistoryUncheckedCreateWithoutProductInput> | StorePriceHistoryCreateWithoutProductInput[] | StorePriceHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StorePriceHistoryCreateOrConnectWithoutProductInput | StorePriceHistoryCreateOrConnectWithoutProductInput[]
    upsert?: StorePriceHistoryUpsertWithWhereUniqueWithoutProductInput | StorePriceHistoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StorePriceHistoryCreateManyProductInputEnvelope
    set?: StorePriceHistoryWhereUniqueInput | StorePriceHistoryWhereUniqueInput[]
    disconnect?: StorePriceHistoryWhereUniqueInput | StorePriceHistoryWhereUniqueInput[]
    delete?: StorePriceHistoryWhereUniqueInput | StorePriceHistoryWhereUniqueInput[]
    connect?: StorePriceHistoryWhereUniqueInput | StorePriceHistoryWhereUniqueInput[]
    update?: StorePriceHistoryUpdateWithWhereUniqueWithoutProductInput | StorePriceHistoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StorePriceHistoryUpdateManyWithWhereWithoutProductInput | StorePriceHistoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StorePriceHistoryScalarWhereInput | StorePriceHistoryScalarWhereInput[]
  }

  export type TransferOrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransferOrderItemCreateWithoutProductInput, TransferOrderItemUncheckedCreateWithoutProductInput> | TransferOrderItemCreateWithoutProductInput[] | TransferOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferOrderItemCreateOrConnectWithoutProductInput | TransferOrderItemCreateOrConnectWithoutProductInput[]
    upsert?: TransferOrderItemUpsertWithWhereUniqueWithoutProductInput | TransferOrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransferOrderItemCreateManyProductInputEnvelope
    set?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    disconnect?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    delete?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    connect?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    update?: TransferOrderItemUpdateWithWhereUniqueWithoutProductInput | TransferOrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransferOrderItemUpdateManyWithWhereWithoutProductInput | TransferOrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransferOrderItemScalarWhereInput | TransferOrderItemScalarWhereInput[]
  }

  export type SaleItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput> | SaleItemCreateWithoutProductInput[] | SaleItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutProductInput | SaleItemCreateOrConnectWithoutProductInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutProductInput | SaleItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleItemCreateManyProductInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutProductInput | SaleItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutProductInput | SaleItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type SaleReturnItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleReturnItemCreateWithoutProductInput, SaleReturnItemUncheckedCreateWithoutProductInput> | SaleReturnItemCreateWithoutProductInput[] | SaleReturnItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleReturnItemCreateOrConnectWithoutProductInput | SaleReturnItemCreateOrConnectWithoutProductInput[]
    upsert?: SaleReturnItemUpsertWithWhereUniqueWithoutProductInput | SaleReturnItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleReturnItemCreateManyProductInputEnvelope
    set?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
    disconnect?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
    delete?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
    connect?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
    update?: SaleReturnItemUpdateWithWhereUniqueWithoutProductInput | SaleReturnItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleReturnItemUpdateManyWithWhereWithoutProductInput | SaleReturnItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleReturnItemScalarWhereInput | SaleReturnItemScalarWhereInput[]
  }

  export type StorePurchaseItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StorePurchaseItemCreateWithoutProductInput, StorePurchaseItemUncheckedCreateWithoutProductInput> | StorePurchaseItemCreateWithoutProductInput[] | StorePurchaseItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StorePurchaseItemCreateOrConnectWithoutProductInput | StorePurchaseItemCreateOrConnectWithoutProductInput[]
    upsert?: StorePurchaseItemUpsertWithWhereUniqueWithoutProductInput | StorePurchaseItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StorePurchaseItemCreateManyProductInputEnvelope
    set?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
    disconnect?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
    delete?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
    connect?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
    update?: StorePurchaseItemUpdateWithWhereUniqueWithoutProductInput | StorePurchaseItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StorePurchaseItemUpdateManyWithWhereWithoutProductInput | StorePurchaseItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StorePurchaseItemScalarWhereInput | StorePurchaseItemScalarWhereInput[]
  }

  export type StockMovementUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput> | StockMovementCreateWithoutProductInput[] | StockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutProductInput | StockMovementCreateOrConnectWithoutProductInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutProductInput | StockMovementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockMovementCreateManyProductInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutProductInput | StockMovementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutProductInput | StockMovementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type StorePriceHistoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StorePriceHistoryCreateWithoutProductInput, StorePriceHistoryUncheckedCreateWithoutProductInput> | StorePriceHistoryCreateWithoutProductInput[] | StorePriceHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StorePriceHistoryCreateOrConnectWithoutProductInput | StorePriceHistoryCreateOrConnectWithoutProductInput[]
    upsert?: StorePriceHistoryUpsertWithWhereUniqueWithoutProductInput | StorePriceHistoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StorePriceHistoryCreateManyProductInputEnvelope
    set?: StorePriceHistoryWhereUniqueInput | StorePriceHistoryWhereUniqueInput[]
    disconnect?: StorePriceHistoryWhereUniqueInput | StorePriceHistoryWhereUniqueInput[]
    delete?: StorePriceHistoryWhereUniqueInput | StorePriceHistoryWhereUniqueInput[]
    connect?: StorePriceHistoryWhereUniqueInput | StorePriceHistoryWhereUniqueInput[]
    update?: StorePriceHistoryUpdateWithWhereUniqueWithoutProductInput | StorePriceHistoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StorePriceHistoryUpdateManyWithWhereWithoutProductInput | StorePriceHistoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StorePriceHistoryScalarWhereInput | StorePriceHistoryScalarWhereInput[]
  }

  export type TransferOrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransferOrderItemCreateWithoutProductInput, TransferOrderItemUncheckedCreateWithoutProductInput> | TransferOrderItemCreateWithoutProductInput[] | TransferOrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransferOrderItemCreateOrConnectWithoutProductInput | TransferOrderItemCreateOrConnectWithoutProductInput[]
    upsert?: TransferOrderItemUpsertWithWhereUniqueWithoutProductInput | TransferOrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: TransferOrderItemCreateManyProductInputEnvelope
    set?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    disconnect?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    delete?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    connect?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    update?: TransferOrderItemUpdateWithWhereUniqueWithoutProductInput | TransferOrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransferOrderItemUpdateManyWithWhereWithoutProductInput | TransferOrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransferOrderItemScalarWhereInput | TransferOrderItemScalarWhereInput[]
  }

  export type StoreProductCreateNestedOneWithoutPriceHistoryInput = {
    create?: XOR<StoreProductCreateWithoutPriceHistoryInput, StoreProductUncheckedCreateWithoutPriceHistoryInput>
    connectOrCreate?: StoreProductCreateOrConnectWithoutPriceHistoryInput
    connect?: StoreProductWhereUniqueInput
  }

  export type StoreProductUpdateOneRequiredWithoutPriceHistoryNestedInput = {
    create?: XOR<StoreProductCreateWithoutPriceHistoryInput, StoreProductUncheckedCreateWithoutPriceHistoryInput>
    connectOrCreate?: StoreProductCreateOrConnectWithoutPriceHistoryInput
    upsert?: StoreProductUpsertWithoutPriceHistoryInput
    connect?: StoreProductWhereUniqueInput
    update?: XOR<XOR<StoreProductUpdateToOneWithWhereWithoutPriceHistoryInput, StoreProductUpdateWithoutPriceHistoryInput>, StoreProductUncheckedUpdateWithoutPriceHistoryInput>
  }

  export type StoreCreateNestedOneWithoutSalesInput = {
    create?: XOR<StoreCreateWithoutSalesInput, StoreUncheckedCreateWithoutSalesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSalesInput
    connect?: StoreWhereUniqueInput
  }

  export type StoreCustomerCreateNestedOneWithoutSalesInput = {
    create?: XOR<StoreCustomerCreateWithoutSalesInput, StoreCustomerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: StoreCustomerCreateOrConnectWithoutSalesInput
    connect?: StoreCustomerWhereUniqueInput
  }

  export type StoreEmployeeCreateNestedOneWithoutSalesInput = {
    create?: XOR<StoreEmployeeCreateWithoutSalesInput, StoreEmployeeUncheckedCreateWithoutSalesInput>
    connectOrCreate?: StoreEmployeeCreateOrConnectWithoutSalesInput
    connect?: StoreEmployeeWhereUniqueInput
  }

  export type SaleItemCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput> | SaleItemCreateWithoutSaleInput[] | SaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutSaleInput | SaleItemCreateOrConnectWithoutSaleInput[]
    createMany?: SaleItemCreateManySaleInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type SalePaymentCreateNestedManyWithoutSaleInput = {
    create?: XOR<SalePaymentCreateWithoutSaleInput, SalePaymentUncheckedCreateWithoutSaleInput> | SalePaymentCreateWithoutSaleInput[] | SalePaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SalePaymentCreateOrConnectWithoutSaleInput | SalePaymentCreateOrConnectWithoutSaleInput[]
    createMany?: SalePaymentCreateManySaleInputEnvelope
    connect?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
  }

  export type SaleReturnCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleReturnCreateWithoutSaleInput, SaleReturnUncheckedCreateWithoutSaleInput> | SaleReturnCreateWithoutSaleInput[] | SaleReturnUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleReturnCreateOrConnectWithoutSaleInput | SaleReturnCreateOrConnectWithoutSaleInput[]
    createMany?: SaleReturnCreateManySaleInputEnvelope
    connect?: SaleReturnWhereUniqueInput | SaleReturnWhereUniqueInput[]
  }

  export type SaleItemUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput> | SaleItemCreateWithoutSaleInput[] | SaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutSaleInput | SaleItemCreateOrConnectWithoutSaleInput[]
    createMany?: SaleItemCreateManySaleInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type SalePaymentUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<SalePaymentCreateWithoutSaleInput, SalePaymentUncheckedCreateWithoutSaleInput> | SalePaymentCreateWithoutSaleInput[] | SalePaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SalePaymentCreateOrConnectWithoutSaleInput | SalePaymentCreateOrConnectWithoutSaleInput[]
    createMany?: SalePaymentCreateManySaleInputEnvelope
    connect?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
  }

  export type SaleReturnUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleReturnCreateWithoutSaleInput, SaleReturnUncheckedCreateWithoutSaleInput> | SaleReturnCreateWithoutSaleInput[] | SaleReturnUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleReturnCreateOrConnectWithoutSaleInput | SaleReturnCreateOrConnectWithoutSaleInput[]
    createMany?: SaleReturnCreateManySaleInputEnvelope
    connect?: SaleReturnWhereUniqueInput | SaleReturnWhereUniqueInput[]
  }

  export type NullableEnumStoreDiscountTypeFieldUpdateOperationsInput = {
    set?: $Enums.StoreDiscountType | null
  }

  export type EnumStoreSaleStatusFieldUpdateOperationsInput = {
    set?: $Enums.StoreSaleStatus
  }

  export type StoreUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<StoreCreateWithoutSalesInput, StoreUncheckedCreateWithoutSalesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSalesInput
    upsert?: StoreUpsertWithoutSalesInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutSalesInput, StoreUpdateWithoutSalesInput>, StoreUncheckedUpdateWithoutSalesInput>
  }

  export type StoreCustomerUpdateOneWithoutSalesNestedInput = {
    create?: XOR<StoreCustomerCreateWithoutSalesInput, StoreCustomerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: StoreCustomerCreateOrConnectWithoutSalesInput
    upsert?: StoreCustomerUpsertWithoutSalesInput
    disconnect?: StoreCustomerWhereInput | boolean
    delete?: StoreCustomerWhereInput | boolean
    connect?: StoreCustomerWhereUniqueInput
    update?: XOR<XOR<StoreCustomerUpdateToOneWithWhereWithoutSalesInput, StoreCustomerUpdateWithoutSalesInput>, StoreCustomerUncheckedUpdateWithoutSalesInput>
  }

  export type StoreEmployeeUpdateOneWithoutSalesNestedInput = {
    create?: XOR<StoreEmployeeCreateWithoutSalesInput, StoreEmployeeUncheckedCreateWithoutSalesInput>
    connectOrCreate?: StoreEmployeeCreateOrConnectWithoutSalesInput
    upsert?: StoreEmployeeUpsertWithoutSalesInput
    disconnect?: StoreEmployeeWhereInput | boolean
    delete?: StoreEmployeeWhereInput | boolean
    connect?: StoreEmployeeWhereUniqueInput
    update?: XOR<XOR<StoreEmployeeUpdateToOneWithWhereWithoutSalesInput, StoreEmployeeUpdateWithoutSalesInput>, StoreEmployeeUncheckedUpdateWithoutSalesInput>
  }

  export type SaleItemUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput> | SaleItemCreateWithoutSaleInput[] | SaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutSaleInput | SaleItemCreateOrConnectWithoutSaleInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutSaleInput | SaleItemUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleItemCreateManySaleInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutSaleInput | SaleItemUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutSaleInput | SaleItemUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type SalePaymentUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SalePaymentCreateWithoutSaleInput, SalePaymentUncheckedCreateWithoutSaleInput> | SalePaymentCreateWithoutSaleInput[] | SalePaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SalePaymentCreateOrConnectWithoutSaleInput | SalePaymentCreateOrConnectWithoutSaleInput[]
    upsert?: SalePaymentUpsertWithWhereUniqueWithoutSaleInput | SalePaymentUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SalePaymentCreateManySaleInputEnvelope
    set?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
    disconnect?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
    delete?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
    connect?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
    update?: SalePaymentUpdateWithWhereUniqueWithoutSaleInput | SalePaymentUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SalePaymentUpdateManyWithWhereWithoutSaleInput | SalePaymentUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SalePaymentScalarWhereInput | SalePaymentScalarWhereInput[]
  }

  export type SaleReturnUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleReturnCreateWithoutSaleInput, SaleReturnUncheckedCreateWithoutSaleInput> | SaleReturnCreateWithoutSaleInput[] | SaleReturnUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleReturnCreateOrConnectWithoutSaleInput | SaleReturnCreateOrConnectWithoutSaleInput[]
    upsert?: SaleReturnUpsertWithWhereUniqueWithoutSaleInput | SaleReturnUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleReturnCreateManySaleInputEnvelope
    set?: SaleReturnWhereUniqueInput | SaleReturnWhereUniqueInput[]
    disconnect?: SaleReturnWhereUniqueInput | SaleReturnWhereUniqueInput[]
    delete?: SaleReturnWhereUniqueInput | SaleReturnWhereUniqueInput[]
    connect?: SaleReturnWhereUniqueInput | SaleReturnWhereUniqueInput[]
    update?: SaleReturnUpdateWithWhereUniqueWithoutSaleInput | SaleReturnUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleReturnUpdateManyWithWhereWithoutSaleInput | SaleReturnUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleReturnScalarWhereInput | SaleReturnScalarWhereInput[]
  }

  export type SaleItemUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput> | SaleItemCreateWithoutSaleInput[] | SaleItemUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutSaleInput | SaleItemCreateOrConnectWithoutSaleInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutSaleInput | SaleItemUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleItemCreateManySaleInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutSaleInput | SaleItemUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutSaleInput | SaleItemUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type SalePaymentUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SalePaymentCreateWithoutSaleInput, SalePaymentUncheckedCreateWithoutSaleInput> | SalePaymentCreateWithoutSaleInput[] | SalePaymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SalePaymentCreateOrConnectWithoutSaleInput | SalePaymentCreateOrConnectWithoutSaleInput[]
    upsert?: SalePaymentUpsertWithWhereUniqueWithoutSaleInput | SalePaymentUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SalePaymentCreateManySaleInputEnvelope
    set?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
    disconnect?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
    delete?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
    connect?: SalePaymentWhereUniqueInput | SalePaymentWhereUniqueInput[]
    update?: SalePaymentUpdateWithWhereUniqueWithoutSaleInput | SalePaymentUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SalePaymentUpdateManyWithWhereWithoutSaleInput | SalePaymentUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SalePaymentScalarWhereInput | SalePaymentScalarWhereInput[]
  }

  export type SaleReturnUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleReturnCreateWithoutSaleInput, SaleReturnUncheckedCreateWithoutSaleInput> | SaleReturnCreateWithoutSaleInput[] | SaleReturnUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleReturnCreateOrConnectWithoutSaleInput | SaleReturnCreateOrConnectWithoutSaleInput[]
    upsert?: SaleReturnUpsertWithWhereUniqueWithoutSaleInput | SaleReturnUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleReturnCreateManySaleInputEnvelope
    set?: SaleReturnWhereUniqueInput | SaleReturnWhereUniqueInput[]
    disconnect?: SaleReturnWhereUniqueInput | SaleReturnWhereUniqueInput[]
    delete?: SaleReturnWhereUniqueInput | SaleReturnWhereUniqueInput[]
    connect?: SaleReturnWhereUniqueInput | SaleReturnWhereUniqueInput[]
    update?: SaleReturnUpdateWithWhereUniqueWithoutSaleInput | SaleReturnUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleReturnUpdateManyWithWhereWithoutSaleInput | SaleReturnUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleReturnScalarWhereInput | SaleReturnScalarWhereInput[]
  }

  export type SaleCreateNestedOneWithoutItemsInput = {
    create?: XOR<SaleCreateWithoutItemsInput, SaleUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutItemsInput
    connect?: SaleWhereUniqueInput
  }

  export type StoreProductCreateNestedOneWithoutSaleItemsInput = {
    create?: XOR<StoreProductCreateWithoutSaleItemsInput, StoreProductUncheckedCreateWithoutSaleItemsInput>
    connectOrCreate?: StoreProductCreateOrConnectWithoutSaleItemsInput
    connect?: StoreProductWhereUniqueInput
  }

  export type SaleUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SaleCreateWithoutItemsInput, SaleUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutItemsInput
    upsert?: SaleUpsertWithoutItemsInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutItemsInput, SaleUpdateWithoutItemsInput>, SaleUncheckedUpdateWithoutItemsInput>
  }

  export type StoreProductUpdateOneRequiredWithoutSaleItemsNestedInput = {
    create?: XOR<StoreProductCreateWithoutSaleItemsInput, StoreProductUncheckedCreateWithoutSaleItemsInput>
    connectOrCreate?: StoreProductCreateOrConnectWithoutSaleItemsInput
    upsert?: StoreProductUpsertWithoutSaleItemsInput
    connect?: StoreProductWhereUniqueInput
    update?: XOR<XOR<StoreProductUpdateToOneWithWhereWithoutSaleItemsInput, StoreProductUpdateWithoutSaleItemsInput>, StoreProductUncheckedUpdateWithoutSaleItemsInput>
  }

  export type SaleCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SaleCreateWithoutPaymentsInput, SaleUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutPaymentsInput
    connect?: SaleWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type SaleUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<SaleCreateWithoutPaymentsInput, SaleUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutPaymentsInput
    upsert?: SaleUpsertWithoutPaymentsInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutPaymentsInput, SaleUpdateWithoutPaymentsInput>, SaleUncheckedUpdateWithoutPaymentsInput>
  }

  export type SaleCreateNestedOneWithoutReturnsInput = {
    create?: XOR<SaleCreateWithoutReturnsInput, SaleUncheckedCreateWithoutReturnsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutReturnsInput
    connect?: SaleWhereUniqueInput
  }

  export type SaleReturnItemCreateNestedManyWithoutSaleReturnInput = {
    create?: XOR<SaleReturnItemCreateWithoutSaleReturnInput, SaleReturnItemUncheckedCreateWithoutSaleReturnInput> | SaleReturnItemCreateWithoutSaleReturnInput[] | SaleReturnItemUncheckedCreateWithoutSaleReturnInput[]
    connectOrCreate?: SaleReturnItemCreateOrConnectWithoutSaleReturnInput | SaleReturnItemCreateOrConnectWithoutSaleReturnInput[]
    createMany?: SaleReturnItemCreateManySaleReturnInputEnvelope
    connect?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
  }

  export type SaleReturnItemUncheckedCreateNestedManyWithoutSaleReturnInput = {
    create?: XOR<SaleReturnItemCreateWithoutSaleReturnInput, SaleReturnItemUncheckedCreateWithoutSaleReturnInput> | SaleReturnItemCreateWithoutSaleReturnInput[] | SaleReturnItemUncheckedCreateWithoutSaleReturnInput[]
    connectOrCreate?: SaleReturnItemCreateOrConnectWithoutSaleReturnInput | SaleReturnItemCreateOrConnectWithoutSaleReturnInput[]
    createMany?: SaleReturnItemCreateManySaleReturnInputEnvelope
    connect?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
  }

  export type EnumStoreReturnStatusFieldUpdateOperationsInput = {
    set?: $Enums.StoreReturnStatus
  }

  export type SaleUpdateOneRequiredWithoutReturnsNestedInput = {
    create?: XOR<SaleCreateWithoutReturnsInput, SaleUncheckedCreateWithoutReturnsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutReturnsInput
    upsert?: SaleUpsertWithoutReturnsInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutReturnsInput, SaleUpdateWithoutReturnsInput>, SaleUncheckedUpdateWithoutReturnsInput>
  }

  export type SaleReturnItemUpdateManyWithoutSaleReturnNestedInput = {
    create?: XOR<SaleReturnItemCreateWithoutSaleReturnInput, SaleReturnItemUncheckedCreateWithoutSaleReturnInput> | SaleReturnItemCreateWithoutSaleReturnInput[] | SaleReturnItemUncheckedCreateWithoutSaleReturnInput[]
    connectOrCreate?: SaleReturnItemCreateOrConnectWithoutSaleReturnInput | SaleReturnItemCreateOrConnectWithoutSaleReturnInput[]
    upsert?: SaleReturnItemUpsertWithWhereUniqueWithoutSaleReturnInput | SaleReturnItemUpsertWithWhereUniqueWithoutSaleReturnInput[]
    createMany?: SaleReturnItemCreateManySaleReturnInputEnvelope
    set?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
    disconnect?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
    delete?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
    connect?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
    update?: SaleReturnItemUpdateWithWhereUniqueWithoutSaleReturnInput | SaleReturnItemUpdateWithWhereUniqueWithoutSaleReturnInput[]
    updateMany?: SaleReturnItemUpdateManyWithWhereWithoutSaleReturnInput | SaleReturnItemUpdateManyWithWhereWithoutSaleReturnInput[]
    deleteMany?: SaleReturnItemScalarWhereInput | SaleReturnItemScalarWhereInput[]
  }

  export type SaleReturnItemUncheckedUpdateManyWithoutSaleReturnNestedInput = {
    create?: XOR<SaleReturnItemCreateWithoutSaleReturnInput, SaleReturnItemUncheckedCreateWithoutSaleReturnInput> | SaleReturnItemCreateWithoutSaleReturnInput[] | SaleReturnItemUncheckedCreateWithoutSaleReturnInput[]
    connectOrCreate?: SaleReturnItemCreateOrConnectWithoutSaleReturnInput | SaleReturnItemCreateOrConnectWithoutSaleReturnInput[]
    upsert?: SaleReturnItemUpsertWithWhereUniqueWithoutSaleReturnInput | SaleReturnItemUpsertWithWhereUniqueWithoutSaleReturnInput[]
    createMany?: SaleReturnItemCreateManySaleReturnInputEnvelope
    set?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
    disconnect?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
    delete?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
    connect?: SaleReturnItemWhereUniqueInput | SaleReturnItemWhereUniqueInput[]
    update?: SaleReturnItemUpdateWithWhereUniqueWithoutSaleReturnInput | SaleReturnItemUpdateWithWhereUniqueWithoutSaleReturnInput[]
    updateMany?: SaleReturnItemUpdateManyWithWhereWithoutSaleReturnInput | SaleReturnItemUpdateManyWithWhereWithoutSaleReturnInput[]
    deleteMany?: SaleReturnItemScalarWhereInput | SaleReturnItemScalarWhereInput[]
  }

  export type SaleReturnCreateNestedOneWithoutItemsInput = {
    create?: XOR<SaleReturnCreateWithoutItemsInput, SaleReturnUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SaleReturnCreateOrConnectWithoutItemsInput
    connect?: SaleReturnWhereUniqueInput
  }

  export type StoreProductCreateNestedOneWithoutSaleReturnItemsInput = {
    create?: XOR<StoreProductCreateWithoutSaleReturnItemsInput, StoreProductUncheckedCreateWithoutSaleReturnItemsInput>
    connectOrCreate?: StoreProductCreateOrConnectWithoutSaleReturnItemsInput
    connect?: StoreProductWhereUniqueInput
  }

  export type SaleReturnUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SaleReturnCreateWithoutItemsInput, SaleReturnUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SaleReturnCreateOrConnectWithoutItemsInput
    upsert?: SaleReturnUpsertWithoutItemsInput
    connect?: SaleReturnWhereUniqueInput
    update?: XOR<XOR<SaleReturnUpdateToOneWithWhereWithoutItemsInput, SaleReturnUpdateWithoutItemsInput>, SaleReturnUncheckedUpdateWithoutItemsInput>
  }

  export type StoreProductUpdateOneRequiredWithoutSaleReturnItemsNestedInput = {
    create?: XOR<StoreProductCreateWithoutSaleReturnItemsInput, StoreProductUncheckedCreateWithoutSaleReturnItemsInput>
    connectOrCreate?: StoreProductCreateOrConnectWithoutSaleReturnItemsInput
    upsert?: StoreProductUpsertWithoutSaleReturnItemsInput
    connect?: StoreProductWhereUniqueInput
    update?: XOR<XOR<StoreProductUpdateToOneWithWhereWithoutSaleReturnItemsInput, StoreProductUpdateWithoutSaleReturnItemsInput>, StoreProductUncheckedUpdateWithoutSaleReturnItemsInput>
  }

  export type StoreCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<StoreCreateWithoutSuppliersInput, StoreUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSuppliersInput
    connect?: StoreWhereUniqueInput
  }

  export type StorePurchaseOrderCreateNestedManyWithoutSupplierInput = {
    create?: XOR<StorePurchaseOrderCreateWithoutSupplierInput, StorePurchaseOrderUncheckedCreateWithoutSupplierInput> | StorePurchaseOrderCreateWithoutSupplierInput[] | StorePurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: StorePurchaseOrderCreateOrConnectWithoutSupplierInput | StorePurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: StorePurchaseOrderCreateManySupplierInputEnvelope
    connect?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
  }

  export type StorePurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<StorePurchaseOrderCreateWithoutSupplierInput, StorePurchaseOrderUncheckedCreateWithoutSupplierInput> | StorePurchaseOrderCreateWithoutSupplierInput[] | StorePurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: StorePurchaseOrderCreateOrConnectWithoutSupplierInput | StorePurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: StorePurchaseOrderCreateManySupplierInputEnvelope
    connect?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
  }

  export type StoreUpdateOneRequiredWithoutSuppliersNestedInput = {
    create?: XOR<StoreCreateWithoutSuppliersInput, StoreUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSuppliersInput
    upsert?: StoreUpsertWithoutSuppliersInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutSuppliersInput, StoreUpdateWithoutSuppliersInput>, StoreUncheckedUpdateWithoutSuppliersInput>
  }

  export type StorePurchaseOrderUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<StorePurchaseOrderCreateWithoutSupplierInput, StorePurchaseOrderUncheckedCreateWithoutSupplierInput> | StorePurchaseOrderCreateWithoutSupplierInput[] | StorePurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: StorePurchaseOrderCreateOrConnectWithoutSupplierInput | StorePurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: StorePurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | StorePurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: StorePurchaseOrderCreateManySupplierInputEnvelope
    set?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
    disconnect?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
    delete?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
    connect?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
    update?: StorePurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | StorePurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: StorePurchaseOrderUpdateManyWithWhereWithoutSupplierInput | StorePurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: StorePurchaseOrderScalarWhereInput | StorePurchaseOrderScalarWhereInput[]
  }

  export type StorePurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<StorePurchaseOrderCreateWithoutSupplierInput, StorePurchaseOrderUncheckedCreateWithoutSupplierInput> | StorePurchaseOrderCreateWithoutSupplierInput[] | StorePurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: StorePurchaseOrderCreateOrConnectWithoutSupplierInput | StorePurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: StorePurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | StorePurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: StorePurchaseOrderCreateManySupplierInputEnvelope
    set?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
    disconnect?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
    delete?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
    connect?: StorePurchaseOrderWhereUniqueInput | StorePurchaseOrderWhereUniqueInput[]
    update?: StorePurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | StorePurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: StorePurchaseOrderUpdateManyWithWhereWithoutSupplierInput | StorePurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: StorePurchaseOrderScalarWhereInput | StorePurchaseOrderScalarWhereInput[]
  }

  export type StoreCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<StoreCreateWithoutPurchasesInput, StoreUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutPurchasesInput
    connect?: StoreWhereUniqueInput
  }

  export type StoreSupplierCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<StoreSupplierCreateWithoutPurchaseOrdersInput, StoreSupplierUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: StoreSupplierCreateOrConnectWithoutPurchaseOrdersInput
    connect?: StoreSupplierWhereUniqueInput
  }

  export type StorePurchaseItemCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<StorePurchaseItemCreateWithoutPurchaseOrderInput, StorePurchaseItemUncheckedCreateWithoutPurchaseOrderInput> | StorePurchaseItemCreateWithoutPurchaseOrderInput[] | StorePurchaseItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: StorePurchaseItemCreateOrConnectWithoutPurchaseOrderInput | StorePurchaseItemCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: StorePurchaseItemCreateManyPurchaseOrderInputEnvelope
    connect?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
  }

  export type StorePurchaseItemUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<StorePurchaseItemCreateWithoutPurchaseOrderInput, StorePurchaseItemUncheckedCreateWithoutPurchaseOrderInput> | StorePurchaseItemCreateWithoutPurchaseOrderInput[] | StorePurchaseItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: StorePurchaseItemCreateOrConnectWithoutPurchaseOrderInput | StorePurchaseItemCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: StorePurchaseItemCreateManyPurchaseOrderInputEnvelope
    connect?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
  }

  export type EnumStorePurchaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.StorePurchaseStatus
  }

  export type StoreUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<StoreCreateWithoutPurchasesInput, StoreUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutPurchasesInput
    upsert?: StoreUpsertWithoutPurchasesInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutPurchasesInput, StoreUpdateWithoutPurchasesInput>, StoreUncheckedUpdateWithoutPurchasesInput>
  }

  export type StoreSupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<StoreSupplierCreateWithoutPurchaseOrdersInput, StoreSupplierUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: StoreSupplierCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: StoreSupplierUpsertWithoutPurchaseOrdersInput
    connect?: StoreSupplierWhereUniqueInput
    update?: XOR<XOR<StoreSupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput, StoreSupplierUpdateWithoutPurchaseOrdersInput>, StoreSupplierUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type StorePurchaseItemUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<StorePurchaseItemCreateWithoutPurchaseOrderInput, StorePurchaseItemUncheckedCreateWithoutPurchaseOrderInput> | StorePurchaseItemCreateWithoutPurchaseOrderInput[] | StorePurchaseItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: StorePurchaseItemCreateOrConnectWithoutPurchaseOrderInput | StorePurchaseItemCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: StorePurchaseItemUpsertWithWhereUniqueWithoutPurchaseOrderInput | StorePurchaseItemUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: StorePurchaseItemCreateManyPurchaseOrderInputEnvelope
    set?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
    disconnect?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
    delete?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
    connect?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
    update?: StorePurchaseItemUpdateWithWhereUniqueWithoutPurchaseOrderInput | StorePurchaseItemUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: StorePurchaseItemUpdateManyWithWhereWithoutPurchaseOrderInput | StorePurchaseItemUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: StorePurchaseItemScalarWhereInput | StorePurchaseItemScalarWhereInput[]
  }

  export type StorePurchaseItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<StorePurchaseItemCreateWithoutPurchaseOrderInput, StorePurchaseItemUncheckedCreateWithoutPurchaseOrderInput> | StorePurchaseItemCreateWithoutPurchaseOrderInput[] | StorePurchaseItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: StorePurchaseItemCreateOrConnectWithoutPurchaseOrderInput | StorePurchaseItemCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: StorePurchaseItemUpsertWithWhereUniqueWithoutPurchaseOrderInput | StorePurchaseItemUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: StorePurchaseItemCreateManyPurchaseOrderInputEnvelope
    set?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
    disconnect?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
    delete?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
    connect?: StorePurchaseItemWhereUniqueInput | StorePurchaseItemWhereUniqueInput[]
    update?: StorePurchaseItemUpdateWithWhereUniqueWithoutPurchaseOrderInput | StorePurchaseItemUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: StorePurchaseItemUpdateManyWithWhereWithoutPurchaseOrderInput | StorePurchaseItemUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: StorePurchaseItemScalarWhereInput | StorePurchaseItemScalarWhereInput[]
  }

  export type StorePurchaseOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<StorePurchaseOrderCreateWithoutItemsInput, StorePurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: StorePurchaseOrderCreateOrConnectWithoutItemsInput
    connect?: StorePurchaseOrderWhereUniqueInput
  }

  export type StoreProductCreateNestedOneWithoutPurchaseItemsInput = {
    create?: XOR<StoreProductCreateWithoutPurchaseItemsInput, StoreProductUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: StoreProductCreateOrConnectWithoutPurchaseItemsInput
    connect?: StoreProductWhereUniqueInput
  }

  export type StorePurchaseOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<StorePurchaseOrderCreateWithoutItemsInput, StorePurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: StorePurchaseOrderCreateOrConnectWithoutItemsInput
    upsert?: StorePurchaseOrderUpsertWithoutItemsInput
    connect?: StorePurchaseOrderWhereUniqueInput
    update?: XOR<XOR<StorePurchaseOrderUpdateToOneWithWhereWithoutItemsInput, StorePurchaseOrderUpdateWithoutItemsInput>, StorePurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type StoreProductUpdateOneRequiredWithoutPurchaseItemsNestedInput = {
    create?: XOR<StoreProductCreateWithoutPurchaseItemsInput, StoreProductUncheckedCreateWithoutPurchaseItemsInput>
    connectOrCreate?: StoreProductCreateOrConnectWithoutPurchaseItemsInput
    upsert?: StoreProductUpsertWithoutPurchaseItemsInput
    connect?: StoreProductWhereUniqueInput
    update?: XOR<XOR<StoreProductUpdateToOneWithWhereWithoutPurchaseItemsInput, StoreProductUpdateWithoutPurchaseItemsInput>, StoreProductUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type StoreCreateNestedOneWithoutStockMovementsInput = {
    create?: XOR<StoreCreateWithoutStockMovementsInput, StoreUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStockMovementsInput
    connect?: StoreWhereUniqueInput
  }

  export type StoreProductCreateNestedOneWithoutStockMovementsInput = {
    create?: XOR<StoreProductCreateWithoutStockMovementsInput, StoreProductUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: StoreProductCreateOrConnectWithoutStockMovementsInput
    connect?: StoreProductWhereUniqueInput
  }

  export type EnumStoreMovementTypeFieldUpdateOperationsInput = {
    set?: $Enums.StoreMovementType
  }

  export type StoreUpdateOneRequiredWithoutStockMovementsNestedInput = {
    create?: XOR<StoreCreateWithoutStockMovementsInput, StoreUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStockMovementsInput
    upsert?: StoreUpsertWithoutStockMovementsInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutStockMovementsInput, StoreUpdateWithoutStockMovementsInput>, StoreUncheckedUpdateWithoutStockMovementsInput>
  }

  export type StoreProductUpdateOneRequiredWithoutStockMovementsNestedInput = {
    create?: XOR<StoreProductCreateWithoutStockMovementsInput, StoreProductUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: StoreProductCreateOrConnectWithoutStockMovementsInput
    upsert?: StoreProductUpsertWithoutStockMovementsInput
    connect?: StoreProductWhereUniqueInput
    update?: XOR<XOR<StoreProductUpdateToOneWithWhereWithoutStockMovementsInput, StoreProductUpdateWithoutStockMovementsInput>, StoreProductUncheckedUpdateWithoutStockMovementsInput>
  }

  export type StoreCreateNestedOneWithoutTransferOrdersOutInput = {
    create?: XOR<StoreCreateWithoutTransferOrdersOutInput, StoreUncheckedCreateWithoutTransferOrdersOutInput>
    connectOrCreate?: StoreCreateOrConnectWithoutTransferOrdersOutInput
    connect?: StoreWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutTransferOrdersInInput = {
    create?: XOR<StoreCreateWithoutTransferOrdersInInput, StoreUncheckedCreateWithoutTransferOrdersInInput>
    connectOrCreate?: StoreCreateOrConnectWithoutTransferOrdersInInput
    connect?: StoreWhereUniqueInput
  }

  export type TransferOrderItemCreateNestedManyWithoutTransferOrderInput = {
    create?: XOR<TransferOrderItemCreateWithoutTransferOrderInput, TransferOrderItemUncheckedCreateWithoutTransferOrderInput> | TransferOrderItemCreateWithoutTransferOrderInput[] | TransferOrderItemUncheckedCreateWithoutTransferOrderInput[]
    connectOrCreate?: TransferOrderItemCreateOrConnectWithoutTransferOrderInput | TransferOrderItemCreateOrConnectWithoutTransferOrderInput[]
    createMany?: TransferOrderItemCreateManyTransferOrderInputEnvelope
    connect?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
  }

  export type TransferOrderItemUncheckedCreateNestedManyWithoutTransferOrderInput = {
    create?: XOR<TransferOrderItemCreateWithoutTransferOrderInput, TransferOrderItemUncheckedCreateWithoutTransferOrderInput> | TransferOrderItemCreateWithoutTransferOrderInput[] | TransferOrderItemUncheckedCreateWithoutTransferOrderInput[]
    connectOrCreate?: TransferOrderItemCreateOrConnectWithoutTransferOrderInput | TransferOrderItemCreateOrConnectWithoutTransferOrderInput[]
    createMany?: TransferOrderItemCreateManyTransferOrderInputEnvelope
    connect?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
  }

  export type EnumTransferOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransferOrderStatus
  }

  export type StoreUpdateOneRequiredWithoutTransferOrdersOutNestedInput = {
    create?: XOR<StoreCreateWithoutTransferOrdersOutInput, StoreUncheckedCreateWithoutTransferOrdersOutInput>
    connectOrCreate?: StoreCreateOrConnectWithoutTransferOrdersOutInput
    upsert?: StoreUpsertWithoutTransferOrdersOutInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutTransferOrdersOutInput, StoreUpdateWithoutTransferOrdersOutInput>, StoreUncheckedUpdateWithoutTransferOrdersOutInput>
  }

  export type StoreUpdateOneRequiredWithoutTransferOrdersInNestedInput = {
    create?: XOR<StoreCreateWithoutTransferOrdersInInput, StoreUncheckedCreateWithoutTransferOrdersInInput>
    connectOrCreate?: StoreCreateOrConnectWithoutTransferOrdersInInput
    upsert?: StoreUpsertWithoutTransferOrdersInInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutTransferOrdersInInput, StoreUpdateWithoutTransferOrdersInInput>, StoreUncheckedUpdateWithoutTransferOrdersInInput>
  }

  export type TransferOrderItemUpdateManyWithoutTransferOrderNestedInput = {
    create?: XOR<TransferOrderItemCreateWithoutTransferOrderInput, TransferOrderItemUncheckedCreateWithoutTransferOrderInput> | TransferOrderItemCreateWithoutTransferOrderInput[] | TransferOrderItemUncheckedCreateWithoutTransferOrderInput[]
    connectOrCreate?: TransferOrderItemCreateOrConnectWithoutTransferOrderInput | TransferOrderItemCreateOrConnectWithoutTransferOrderInput[]
    upsert?: TransferOrderItemUpsertWithWhereUniqueWithoutTransferOrderInput | TransferOrderItemUpsertWithWhereUniqueWithoutTransferOrderInput[]
    createMany?: TransferOrderItemCreateManyTransferOrderInputEnvelope
    set?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    disconnect?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    delete?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    connect?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    update?: TransferOrderItemUpdateWithWhereUniqueWithoutTransferOrderInput | TransferOrderItemUpdateWithWhereUniqueWithoutTransferOrderInput[]
    updateMany?: TransferOrderItemUpdateManyWithWhereWithoutTransferOrderInput | TransferOrderItemUpdateManyWithWhereWithoutTransferOrderInput[]
    deleteMany?: TransferOrderItemScalarWhereInput | TransferOrderItemScalarWhereInput[]
  }

  export type TransferOrderItemUncheckedUpdateManyWithoutTransferOrderNestedInput = {
    create?: XOR<TransferOrderItemCreateWithoutTransferOrderInput, TransferOrderItemUncheckedCreateWithoutTransferOrderInput> | TransferOrderItemCreateWithoutTransferOrderInput[] | TransferOrderItemUncheckedCreateWithoutTransferOrderInput[]
    connectOrCreate?: TransferOrderItemCreateOrConnectWithoutTransferOrderInput | TransferOrderItemCreateOrConnectWithoutTransferOrderInput[]
    upsert?: TransferOrderItemUpsertWithWhereUniqueWithoutTransferOrderInput | TransferOrderItemUpsertWithWhereUniqueWithoutTransferOrderInput[]
    createMany?: TransferOrderItemCreateManyTransferOrderInputEnvelope
    set?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    disconnect?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    delete?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    connect?: TransferOrderItemWhereUniqueInput | TransferOrderItemWhereUniqueInput[]
    update?: TransferOrderItemUpdateWithWhereUniqueWithoutTransferOrderInput | TransferOrderItemUpdateWithWhereUniqueWithoutTransferOrderInput[]
    updateMany?: TransferOrderItemUpdateManyWithWhereWithoutTransferOrderInput | TransferOrderItemUpdateManyWithWhereWithoutTransferOrderInput[]
    deleteMany?: TransferOrderItemScalarWhereInput | TransferOrderItemScalarWhereInput[]
  }

  export type TransferOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<TransferOrderCreateWithoutItemsInput, TransferOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TransferOrderCreateOrConnectWithoutItemsInput
    connect?: TransferOrderWhereUniqueInput
  }

  export type StoreProductCreateNestedOneWithoutTransferOrderItemsInput = {
    create?: XOR<StoreProductCreateWithoutTransferOrderItemsInput, StoreProductUncheckedCreateWithoutTransferOrderItemsInput>
    connectOrCreate?: StoreProductCreateOrConnectWithoutTransferOrderItemsInput
    connect?: StoreProductWhereUniqueInput
  }

  export type TransferOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<TransferOrderCreateWithoutItemsInput, TransferOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TransferOrderCreateOrConnectWithoutItemsInput
    upsert?: TransferOrderUpsertWithoutItemsInput
    connect?: TransferOrderWhereUniqueInput
    update?: XOR<XOR<TransferOrderUpdateToOneWithWhereWithoutItemsInput, TransferOrderUpdateWithoutItemsInput>, TransferOrderUncheckedUpdateWithoutItemsInput>
  }

  export type StoreProductUpdateOneRequiredWithoutTransferOrderItemsNestedInput = {
    create?: XOR<StoreProductCreateWithoutTransferOrderItemsInput, StoreProductUncheckedCreateWithoutTransferOrderItemsInput>
    connectOrCreate?: StoreProductCreateOrConnectWithoutTransferOrderItemsInput
    upsert?: StoreProductUpsertWithoutTransferOrderItemsInput
    connect?: StoreProductWhereUniqueInput
    update?: XOR<XOR<StoreProductUpdateToOneWithWhereWithoutTransferOrderItemsInput, StoreProductUpdateWithoutTransferOrderItemsInput>, StoreProductUncheckedUpdateWithoutTransferOrderItemsInput>
  }

  export type StoreCreateNestedOneWithoutCustomersInput = {
    create?: XOR<StoreCreateWithoutCustomersInput, StoreUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: StoreCreateOrConnectWithoutCustomersInput
    connect?: StoreWhereUniqueInput
  }

  export type SaleCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type StoreLoyaltyTransactionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<StoreLoyaltyTransactionCreateWithoutCustomerInput, StoreLoyaltyTransactionUncheckedCreateWithoutCustomerInput> | StoreLoyaltyTransactionCreateWithoutCustomerInput[] | StoreLoyaltyTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: StoreLoyaltyTransactionCreateOrConnectWithoutCustomerInput | StoreLoyaltyTransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: StoreLoyaltyTransactionCreateManyCustomerInputEnvelope
    connect?: StoreLoyaltyTransactionWhereUniqueInput | StoreLoyaltyTransactionWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type StoreLoyaltyTransactionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<StoreLoyaltyTransactionCreateWithoutCustomerInput, StoreLoyaltyTransactionUncheckedCreateWithoutCustomerInput> | StoreLoyaltyTransactionCreateWithoutCustomerInput[] | StoreLoyaltyTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: StoreLoyaltyTransactionCreateOrConnectWithoutCustomerInput | StoreLoyaltyTransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: StoreLoyaltyTransactionCreateManyCustomerInputEnvelope
    connect?: StoreLoyaltyTransactionWhereUniqueInput | StoreLoyaltyTransactionWhereUniqueInput[]
  }

  export type EnumLoyaltyTierFieldUpdateOperationsInput = {
    set?: $Enums.LoyaltyTier
  }

  export type StoreUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<StoreCreateWithoutCustomersInput, StoreUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: StoreCreateOrConnectWithoutCustomersInput
    upsert?: StoreUpsertWithoutCustomersInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutCustomersInput, StoreUpdateWithoutCustomersInput>, StoreUncheckedUpdateWithoutCustomersInput>
  }

  export type SaleUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCustomerInput | SaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCustomerInput | SaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCustomerInput | SaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type StoreLoyaltyTransactionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<StoreLoyaltyTransactionCreateWithoutCustomerInput, StoreLoyaltyTransactionUncheckedCreateWithoutCustomerInput> | StoreLoyaltyTransactionCreateWithoutCustomerInput[] | StoreLoyaltyTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: StoreLoyaltyTransactionCreateOrConnectWithoutCustomerInput | StoreLoyaltyTransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: StoreLoyaltyTransactionUpsertWithWhereUniqueWithoutCustomerInput | StoreLoyaltyTransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: StoreLoyaltyTransactionCreateManyCustomerInputEnvelope
    set?: StoreLoyaltyTransactionWhereUniqueInput | StoreLoyaltyTransactionWhereUniqueInput[]
    disconnect?: StoreLoyaltyTransactionWhereUniqueInput | StoreLoyaltyTransactionWhereUniqueInput[]
    delete?: StoreLoyaltyTransactionWhereUniqueInput | StoreLoyaltyTransactionWhereUniqueInput[]
    connect?: StoreLoyaltyTransactionWhereUniqueInput | StoreLoyaltyTransactionWhereUniqueInput[]
    update?: StoreLoyaltyTransactionUpdateWithWhereUniqueWithoutCustomerInput | StoreLoyaltyTransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: StoreLoyaltyTransactionUpdateManyWithWhereWithoutCustomerInput | StoreLoyaltyTransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: StoreLoyaltyTransactionScalarWhereInput | StoreLoyaltyTransactionScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCustomerInput | SaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCustomerInput | SaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCustomerInput | SaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type StoreLoyaltyTransactionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<StoreLoyaltyTransactionCreateWithoutCustomerInput, StoreLoyaltyTransactionUncheckedCreateWithoutCustomerInput> | StoreLoyaltyTransactionCreateWithoutCustomerInput[] | StoreLoyaltyTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: StoreLoyaltyTransactionCreateOrConnectWithoutCustomerInput | StoreLoyaltyTransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: StoreLoyaltyTransactionUpsertWithWhereUniqueWithoutCustomerInput | StoreLoyaltyTransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: StoreLoyaltyTransactionCreateManyCustomerInputEnvelope
    set?: StoreLoyaltyTransactionWhereUniqueInput | StoreLoyaltyTransactionWhereUniqueInput[]
    disconnect?: StoreLoyaltyTransactionWhereUniqueInput | StoreLoyaltyTransactionWhereUniqueInput[]
    delete?: StoreLoyaltyTransactionWhereUniqueInput | StoreLoyaltyTransactionWhereUniqueInput[]
    connect?: StoreLoyaltyTransactionWhereUniqueInput | StoreLoyaltyTransactionWhereUniqueInput[]
    update?: StoreLoyaltyTransactionUpdateWithWhereUniqueWithoutCustomerInput | StoreLoyaltyTransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: StoreLoyaltyTransactionUpdateManyWithWhereWithoutCustomerInput | StoreLoyaltyTransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: StoreLoyaltyTransactionScalarWhereInput | StoreLoyaltyTransactionScalarWhereInput[]
  }

  export type StoreCreateNestedOneWithoutLoyaltyConfigInput = {
    create?: XOR<StoreCreateWithoutLoyaltyConfigInput, StoreUncheckedCreateWithoutLoyaltyConfigInput>
    connectOrCreate?: StoreCreateOrConnectWithoutLoyaltyConfigInput
    connect?: StoreWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StoreUpdateOneRequiredWithoutLoyaltyConfigNestedInput = {
    create?: XOR<StoreCreateWithoutLoyaltyConfigInput, StoreUncheckedCreateWithoutLoyaltyConfigInput>
    connectOrCreate?: StoreCreateOrConnectWithoutLoyaltyConfigInput
    upsert?: StoreUpsertWithoutLoyaltyConfigInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutLoyaltyConfigInput, StoreUpdateWithoutLoyaltyConfigInput>, StoreUncheckedUpdateWithoutLoyaltyConfigInput>
  }

  export type StoreCustomerCreateNestedOneWithoutLoyaltyTransactionsInput = {
    create?: XOR<StoreCustomerCreateWithoutLoyaltyTransactionsInput, StoreCustomerUncheckedCreateWithoutLoyaltyTransactionsInput>
    connectOrCreate?: StoreCustomerCreateOrConnectWithoutLoyaltyTransactionsInput
    connect?: StoreCustomerWhereUniqueInput
  }

  export type EnumLoyaltyTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.LoyaltyTransactionType
  }

  export type StoreCustomerUpdateOneRequiredWithoutLoyaltyTransactionsNestedInput = {
    create?: XOR<StoreCustomerCreateWithoutLoyaltyTransactionsInput, StoreCustomerUncheckedCreateWithoutLoyaltyTransactionsInput>
    connectOrCreate?: StoreCustomerCreateOrConnectWithoutLoyaltyTransactionsInput
    upsert?: StoreCustomerUpsertWithoutLoyaltyTransactionsInput
    connect?: StoreCustomerWhereUniqueInput
    update?: XOR<XOR<StoreCustomerUpdateToOneWithWhereWithoutLoyaltyTransactionsInput, StoreCustomerUpdateWithoutLoyaltyTransactionsInput>, StoreCustomerUncheckedUpdateWithoutLoyaltyTransactionsInput>
  }

  export type StoreCreateNestedOneWithoutTaxRulesInput = {
    create?: XOR<StoreCreateWithoutTaxRulesInput, StoreUncheckedCreateWithoutTaxRulesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutTaxRulesInput
    connect?: StoreWhereUniqueInput
  }

  export type StoreProductCreateNestedManyWithoutTaxRuleInput = {
    create?: XOR<StoreProductCreateWithoutTaxRuleInput, StoreProductUncheckedCreateWithoutTaxRuleInput> | StoreProductCreateWithoutTaxRuleInput[] | StoreProductUncheckedCreateWithoutTaxRuleInput[]
    connectOrCreate?: StoreProductCreateOrConnectWithoutTaxRuleInput | StoreProductCreateOrConnectWithoutTaxRuleInput[]
    createMany?: StoreProductCreateManyTaxRuleInputEnvelope
    connect?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
  }

  export type StoreProductUncheckedCreateNestedManyWithoutTaxRuleInput = {
    create?: XOR<StoreProductCreateWithoutTaxRuleInput, StoreProductUncheckedCreateWithoutTaxRuleInput> | StoreProductCreateWithoutTaxRuleInput[] | StoreProductUncheckedCreateWithoutTaxRuleInput[]
    connectOrCreate?: StoreProductCreateOrConnectWithoutTaxRuleInput | StoreProductCreateOrConnectWithoutTaxRuleInput[]
    createMany?: StoreProductCreateManyTaxRuleInputEnvelope
    connect?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
  }

  export type StoreUpdateOneRequiredWithoutTaxRulesNestedInput = {
    create?: XOR<StoreCreateWithoutTaxRulesInput, StoreUncheckedCreateWithoutTaxRulesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutTaxRulesInput
    upsert?: StoreUpsertWithoutTaxRulesInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutTaxRulesInput, StoreUpdateWithoutTaxRulesInput>, StoreUncheckedUpdateWithoutTaxRulesInput>
  }

  export type StoreProductUpdateManyWithoutTaxRuleNestedInput = {
    create?: XOR<StoreProductCreateWithoutTaxRuleInput, StoreProductUncheckedCreateWithoutTaxRuleInput> | StoreProductCreateWithoutTaxRuleInput[] | StoreProductUncheckedCreateWithoutTaxRuleInput[]
    connectOrCreate?: StoreProductCreateOrConnectWithoutTaxRuleInput | StoreProductCreateOrConnectWithoutTaxRuleInput[]
    upsert?: StoreProductUpsertWithWhereUniqueWithoutTaxRuleInput | StoreProductUpsertWithWhereUniqueWithoutTaxRuleInput[]
    createMany?: StoreProductCreateManyTaxRuleInputEnvelope
    set?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    disconnect?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    delete?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    connect?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    update?: StoreProductUpdateWithWhereUniqueWithoutTaxRuleInput | StoreProductUpdateWithWhereUniqueWithoutTaxRuleInput[]
    updateMany?: StoreProductUpdateManyWithWhereWithoutTaxRuleInput | StoreProductUpdateManyWithWhereWithoutTaxRuleInput[]
    deleteMany?: StoreProductScalarWhereInput | StoreProductScalarWhereInput[]
  }

  export type StoreProductUncheckedUpdateManyWithoutTaxRuleNestedInput = {
    create?: XOR<StoreProductCreateWithoutTaxRuleInput, StoreProductUncheckedCreateWithoutTaxRuleInput> | StoreProductCreateWithoutTaxRuleInput[] | StoreProductUncheckedCreateWithoutTaxRuleInput[]
    connectOrCreate?: StoreProductCreateOrConnectWithoutTaxRuleInput | StoreProductCreateOrConnectWithoutTaxRuleInput[]
    upsert?: StoreProductUpsertWithWhereUniqueWithoutTaxRuleInput | StoreProductUpsertWithWhereUniqueWithoutTaxRuleInput[]
    createMany?: StoreProductCreateManyTaxRuleInputEnvelope
    set?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    disconnect?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    delete?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    connect?: StoreProductWhereUniqueInput | StoreProductWhereUniqueInput[]
    update?: StoreProductUpdateWithWhereUniqueWithoutTaxRuleInput | StoreProductUpdateWithWhereUniqueWithoutTaxRuleInput[]
    updateMany?: StoreProductUpdateManyWithWhereWithoutTaxRuleInput | StoreProductUpdateManyWithWhereWithoutTaxRuleInput[]
    deleteMany?: StoreProductScalarWhereInput | StoreProductScalarWhereInput[]
  }

  export type StoreCreateNestedOneWithoutPaymentMethodsInput = {
    create?: XOR<StoreCreateWithoutPaymentMethodsInput, StoreUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutPaymentMethodsInput
    connect?: StoreWhereUniqueInput
  }

  export type StoreUpdateOneRequiredWithoutPaymentMethodsNestedInput = {
    create?: XOR<StoreCreateWithoutPaymentMethodsInput, StoreUncheckedCreateWithoutPaymentMethodsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutPaymentMethodsInput
    upsert?: StoreUpsertWithoutPaymentMethodsInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutPaymentMethodsInput, StoreUpdateWithoutPaymentMethodsInput>, StoreUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type StoreCreateNestedOneWithoutReceiptConfigInput = {
    create?: XOR<StoreCreateWithoutReceiptConfigInput, StoreUncheckedCreateWithoutReceiptConfigInput>
    connectOrCreate?: StoreCreateOrConnectWithoutReceiptConfigInput
    connect?: StoreWhereUniqueInput
  }

  export type StoreUpdateOneRequiredWithoutReceiptConfigNestedInput = {
    create?: XOR<StoreCreateWithoutReceiptConfigInput, StoreUncheckedCreateWithoutReceiptConfigInput>
    connectOrCreate?: StoreCreateOrConnectWithoutReceiptConfigInput
    upsert?: StoreUpsertWithoutReceiptConfigInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutReceiptConfigInput, StoreUpdateWithoutReceiptConfigInput>, StoreUncheckedUpdateWithoutReceiptConfigInput>
  }

  export type StoreCreateNestedOneWithoutDevicesInput = {
    create?: XOR<StoreCreateWithoutDevicesInput, StoreUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutDevicesInput
    connect?: StoreWhereUniqueInput
  }

  export type EnumStoreDeviceTypeFieldUpdateOperationsInput = {
    set?: $Enums.StoreDeviceType
  }

  export type StoreUpdateOneRequiredWithoutDevicesNestedInput = {
    create?: XOR<StoreCreateWithoutDevicesInput, StoreUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: StoreCreateOrConnectWithoutDevicesInput
    upsert?: StoreUpsertWithoutDevicesInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutDevicesInput, StoreUpdateWithoutDevicesInput>, StoreUncheckedUpdateWithoutDevicesInput>
  }

  export type StoreCreateNestedOneWithoutIntegrationsInput = {
    create?: XOR<StoreCreateWithoutIntegrationsInput, StoreUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutIntegrationsInput
    connect?: StoreWhereUniqueInput
  }

  export type EnumStoreIntegrationTypeFieldUpdateOperationsInput = {
    set?: $Enums.StoreIntegrationType
  }

  export type StoreUpdateOneRequiredWithoutIntegrationsNestedInput = {
    create?: XOR<StoreCreateWithoutIntegrationsInput, StoreUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutIntegrationsInput
    upsert?: StoreUpsertWithoutIntegrationsInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutIntegrationsInput, StoreUpdateWithoutIntegrationsInput>, StoreUncheckedUpdateWithoutIntegrationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumStoreDiscountTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreDiscountType | EnumStoreDiscountTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.StoreDiscountType[] | ListEnumStoreDiscountTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StoreDiscountType[] | ListEnumStoreDiscountTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStoreDiscountTypeNullableFilter<$PrismaModel> | $Enums.StoreDiscountType | null
  }

  export type NestedEnumStoreSaleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreSaleStatus | EnumStoreSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoreSaleStatus[] | ListEnumStoreSaleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreSaleStatus[] | ListEnumStoreSaleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreSaleStatusFilter<$PrismaModel> | $Enums.StoreSaleStatus
  }

  export type NestedEnumStoreDiscountTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreDiscountType | EnumStoreDiscountTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.StoreDiscountType[] | ListEnumStoreDiscountTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StoreDiscountType[] | ListEnumStoreDiscountTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStoreDiscountTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.StoreDiscountType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStoreDiscountTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumStoreDiscountTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumStoreSaleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreSaleStatus | EnumStoreSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoreSaleStatus[] | ListEnumStoreSaleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreSaleStatus[] | ListEnumStoreSaleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreSaleStatusWithAggregatesFilter<$PrismaModel> | $Enums.StoreSaleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoreSaleStatusFilter<$PrismaModel>
    _max?: NestedEnumStoreSaleStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumStoreReturnStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreReturnStatus | EnumStoreReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoreReturnStatus[] | ListEnumStoreReturnStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreReturnStatus[] | ListEnumStoreReturnStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreReturnStatusFilter<$PrismaModel> | $Enums.StoreReturnStatus
  }

  export type NestedEnumStoreReturnStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreReturnStatus | EnumStoreReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StoreReturnStatus[] | ListEnumStoreReturnStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreReturnStatus[] | ListEnumStoreReturnStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreReturnStatusWithAggregatesFilter<$PrismaModel> | $Enums.StoreReturnStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoreReturnStatusFilter<$PrismaModel>
    _max?: NestedEnumStoreReturnStatusFilter<$PrismaModel>
  }

  export type NestedEnumStorePurchaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StorePurchaseStatus | EnumStorePurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StorePurchaseStatus[] | ListEnumStorePurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StorePurchaseStatus[] | ListEnumStorePurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStorePurchaseStatusFilter<$PrismaModel> | $Enums.StorePurchaseStatus
  }

  export type NestedEnumStorePurchaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StorePurchaseStatus | EnumStorePurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StorePurchaseStatus[] | ListEnumStorePurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StorePurchaseStatus[] | ListEnumStorePurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStorePurchaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.StorePurchaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStorePurchaseStatusFilter<$PrismaModel>
    _max?: NestedEnumStorePurchaseStatusFilter<$PrismaModel>
  }

  export type NestedEnumStoreMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreMovementType | EnumStoreMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoreMovementType[] | ListEnumStoreMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreMovementType[] | ListEnumStoreMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreMovementTypeFilter<$PrismaModel> | $Enums.StoreMovementType
  }

  export type NestedEnumStoreMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreMovementType | EnumStoreMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoreMovementType[] | ListEnumStoreMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreMovementType[] | ListEnumStoreMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.StoreMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoreMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumStoreMovementTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransferOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferOrderStatus | EnumTransferOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferOrderStatus[] | ListEnumTransferOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferOrderStatus[] | ListEnumTransferOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferOrderStatusFilter<$PrismaModel> | $Enums.TransferOrderStatus
  }

  export type NestedEnumTransferOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferOrderStatus | EnumTransferOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferOrderStatus[] | ListEnumTransferOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferOrderStatus[] | ListEnumTransferOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumLoyaltyTierFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTier | EnumLoyaltyTierFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTierFilter<$PrismaModel> | $Enums.LoyaltyTier
  }

  export type NestedEnumLoyaltyTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTier | EnumLoyaltyTierFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTier[] | ListEnumLoyaltyTierFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTierWithAggregatesFilter<$PrismaModel> | $Enums.LoyaltyTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoyaltyTierFilter<$PrismaModel>
    _max?: NestedEnumLoyaltyTierFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTransactionType | EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel> | $Enums.LoyaltyTransactionType
  }

  export type NestedEnumLoyaltyTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoyaltyTransactionType | EnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LoyaltyTransactionType[] | ListEnumLoyaltyTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLoyaltyTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.LoyaltyTransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumLoyaltyTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumStoreDeviceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreDeviceType | EnumStoreDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoreDeviceType[] | ListEnumStoreDeviceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreDeviceType[] | ListEnumStoreDeviceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreDeviceTypeFilter<$PrismaModel> | $Enums.StoreDeviceType
  }

  export type NestedEnumStoreDeviceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreDeviceType | EnumStoreDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoreDeviceType[] | ListEnumStoreDeviceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreDeviceType[] | ListEnumStoreDeviceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreDeviceTypeWithAggregatesFilter<$PrismaModel> | $Enums.StoreDeviceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoreDeviceTypeFilter<$PrismaModel>
    _max?: NestedEnumStoreDeviceTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumStoreIntegrationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreIntegrationType | EnumStoreIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoreIntegrationType[] | ListEnumStoreIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreIntegrationType[] | ListEnumStoreIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreIntegrationTypeFilter<$PrismaModel> | $Enums.StoreIntegrationType
  }

  export type NestedEnumStoreIntegrationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreIntegrationType | EnumStoreIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoreIntegrationType[] | ListEnumStoreIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreIntegrationType[] | ListEnumStoreIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreIntegrationTypeWithAggregatesFilter<$PrismaModel> | $Enums.StoreIntegrationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoreIntegrationTypeFilter<$PrismaModel>
    _max?: NestedEnumStoreIntegrationTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserCreateWithoutOrganizationInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    avatar?: string | null
    emailVerified?: Date | string | null
    lastLoginAt?: Date | string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutOrganizationInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    avatar?: string | null
    emailVerified?: Date | string | null
    lastLoginAt?: Date | string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserCreateManyOrganizationInputEnvelope = {
    data: UserCreateManyOrganizationInput | UserCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserUpdateManyWithWhereWithoutOrganizationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    organizationId?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type OrganizationCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    logo?: string | null
    company?: string | null
    taxId?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    tenantId?: string
    hotelCode: string
    storeCode?: string | null
    databaseUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    email: string
    phone?: string | null
    address?: string | null
    logo?: string | null
    company?: string | null
    taxId?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    tenantId?: string
    hotelCode: string
    storeCode?: string | null
    databaseUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationCreateOrConnectWithoutUsersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
  }

  export type OrganizationUpsertWithoutUsersInput = {
    update: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUsersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type OrganizationUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    hotelCode?: StringFieldUpdateOperationsInput | string
    storeCode?: NullableStringFieldUpdateOperationsInput | string | null
    databaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    hotelCode?: StringFieldUpdateOperationsInput | string
    storeCode?: NullableStringFieldUpdateOperationsInput | string | null
    databaseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreEmployeeCreateWithoutStoreInput = {
    id?: string
    userId?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    role?: string
    pin?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleCreateNestedManyWithoutEmployeeInput
  }

  export type StoreEmployeeUncheckedCreateWithoutStoreInput = {
    id?: string
    userId?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    role?: string
    pin?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type StoreEmployeeCreateOrConnectWithoutStoreInput = {
    where: StoreEmployeeWhereUniqueInput
    create: XOR<StoreEmployeeCreateWithoutStoreInput, StoreEmployeeUncheckedCreateWithoutStoreInput>
  }

  export type StoreEmployeeCreateManyStoreInputEnvelope = {
    data: StoreEmployeeCreateManyStoreInput | StoreEmployeeCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type StoreProductCreateWithoutStoreInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    taxRule?: StoreTaxRuleCreateNestedOneWithoutProductsInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    saleReturnItems?: SaleReturnItemCreateNestedManyWithoutProductInput
    purchaseItems?: StorePurchaseItemCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    priceHistory?: StorePriceHistoryCreateNestedManyWithoutProductInput
    transferOrderItems?: TransferOrderItemCreateNestedManyWithoutProductInput
  }

  export type StoreProductUncheckedCreateWithoutStoreInput = {
    id?: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    taxRuleId?: string | null
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    saleReturnItems?: SaleReturnItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: StorePurchaseItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: StorePriceHistoryUncheckedCreateNestedManyWithoutProductInput
    transferOrderItems?: TransferOrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type StoreProductCreateOrConnectWithoutStoreInput = {
    where: StoreProductWhereUniqueInput
    create: XOR<StoreProductCreateWithoutStoreInput, StoreProductUncheckedCreateWithoutStoreInput>
  }

  export type StoreProductCreateManyStoreInputEnvelope = {
    data: StoreProductCreateManyStoreInput | StoreProductCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type ProductCategoryCreateWithoutStoreInput = {
    id?: string
    name: string
    nameKa?: string | null
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: ProductCategoryCreateNestedOneWithoutChildrenInput
    children?: ProductCategoryCreateNestedManyWithoutParentInput
    products?: StoreProductCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutStoreInput = {
    id?: string
    name: string
    nameKa?: string | null
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    sortOrder?: number
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ProductCategoryUncheckedCreateNestedManyWithoutParentInput
    products?: StoreProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutStoreInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutStoreInput, ProductCategoryUncheckedCreateWithoutStoreInput>
  }

  export type ProductCategoryCreateManyStoreInputEnvelope = {
    data: ProductCategoryCreateManyStoreInput | ProductCategoryCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type SaleCreateWithoutStoreInput = {
    id?: string
    saleNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.StoreDiscountType | null
    total: Decimal | DecimalJsLike | number | string
    paidAmount: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.StoreSaleStatus
    notes?: string | null
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: StoreCustomerCreateNestedOneWithoutSalesInput
    employee?: StoreEmployeeCreateNestedOneWithoutSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
    payments?: SalePaymentCreateNestedManyWithoutSaleInput
    returns?: SaleReturnCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutStoreInput = {
    id?: string
    saleNumber: string
    customerId?: string | null
    employeeId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.StoreDiscountType | null
    total: Decimal | DecimalJsLike | number | string
    paidAmount: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.StoreSaleStatus
    notes?: string | null
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
    payments?: SalePaymentUncheckedCreateNestedManyWithoutSaleInput
    returns?: SaleReturnUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutStoreInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutStoreInput, SaleUncheckedCreateWithoutStoreInput>
  }

  export type SaleCreateManyStoreInputEnvelope = {
    data: SaleCreateManyStoreInput | SaleCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type StorePurchaseOrderCreateWithoutStoreInput = {
    id?: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.StorePurchaseStatus
    notes?: string | null
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: StoreSupplierCreateNestedOneWithoutPurchaseOrdersInput
    items?: StorePurchaseItemCreateNestedManyWithoutPurchaseOrderInput
  }

  export type StorePurchaseOrderUncheckedCreateWithoutStoreInput = {
    id?: string
    supplierId: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.StorePurchaseStatus
    notes?: string | null
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: StorePurchaseItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type StorePurchaseOrderCreateOrConnectWithoutStoreInput = {
    where: StorePurchaseOrderWhereUniqueInput
    create: XOR<StorePurchaseOrderCreateWithoutStoreInput, StorePurchaseOrderUncheckedCreateWithoutStoreInput>
  }

  export type StorePurchaseOrderCreateManyStoreInputEnvelope = {
    data: StorePurchaseOrderCreateManyStoreInput | StorePurchaseOrderCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type StoreSupplierCreateWithoutStoreInput = {
    id?: string
    name: string
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: StorePurchaseOrderCreateNestedManyWithoutSupplierInput
  }

  export type StoreSupplierUncheckedCreateWithoutStoreInput = {
    id?: string
    name: string
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: StorePurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type StoreSupplierCreateOrConnectWithoutStoreInput = {
    where: StoreSupplierWhereUniqueInput
    create: XOR<StoreSupplierCreateWithoutStoreInput, StoreSupplierUncheckedCreateWithoutStoreInput>
  }

  export type StoreSupplierCreateManyStoreInputEnvelope = {
    data: StoreSupplierCreateManyStoreInput | StoreSupplierCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type StoreCustomerCreateWithoutStoreInput = {
    id?: string
    firstName: string
    lastName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    taxId?: string | null
    notes?: string | null
    totalPurchases?: Decimal | DecimalJsLike | number | string
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    totalLifetimePurchases?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: StoreLoyaltyTransactionCreateNestedManyWithoutCustomerInput
  }

  export type StoreCustomerUncheckedCreateWithoutStoreInput = {
    id?: string
    firstName: string
    lastName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    taxId?: string | null
    notes?: string | null
    totalPurchases?: Decimal | DecimalJsLike | number | string
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    totalLifetimePurchases?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
    loyaltyTransactions?: StoreLoyaltyTransactionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type StoreCustomerCreateOrConnectWithoutStoreInput = {
    where: StoreCustomerWhereUniqueInput
    create: XOR<StoreCustomerCreateWithoutStoreInput, StoreCustomerUncheckedCreateWithoutStoreInput>
  }

  export type StoreCustomerCreateManyStoreInputEnvelope = {
    data: StoreCustomerCreateManyStoreInput | StoreCustomerCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type StockMovementCreateWithoutStoreInput = {
    id?: string
    type: $Enums.StoreMovementType
    quantity: Decimal | DecimalJsLike | number | string
    previousStock: Decimal | DecimalJsLike | number | string
    newStock: Decimal | DecimalJsLike | number | string
    reason?: string | null
    referenceType?: string | null
    referenceId?: string | null
    performedBy?: string | null
    createdAt?: Date | string
    product: StoreProductCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateWithoutStoreInput = {
    id?: string
    productId: string
    type: $Enums.StoreMovementType
    quantity: Decimal | DecimalJsLike | number | string
    previousStock: Decimal | DecimalJsLike | number | string
    newStock: Decimal | DecimalJsLike | number | string
    reason?: string | null
    referenceType?: string | null
    referenceId?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type StockMovementCreateOrConnectWithoutStoreInput = {
    where: StockMovementWhereUniqueInput
    create: XOR<StockMovementCreateWithoutStoreInput, StockMovementUncheckedCreateWithoutStoreInput>
  }

  export type StockMovementCreateManyStoreInputEnvelope = {
    data: StockMovementCreateManyStoreInput | StockMovementCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type StoreTaxRuleCreateWithoutStoreInput = {
    id?: string
    name: string
    rate: Decimal | DecimalJsLike | number | string
    isDefault?: boolean
    isActive?: boolean
    products?: StoreProductCreateNestedManyWithoutTaxRuleInput
  }

  export type StoreTaxRuleUncheckedCreateWithoutStoreInput = {
    id?: string
    name: string
    rate: Decimal | DecimalJsLike | number | string
    isDefault?: boolean
    isActive?: boolean
    products?: StoreProductUncheckedCreateNestedManyWithoutTaxRuleInput
  }

  export type StoreTaxRuleCreateOrConnectWithoutStoreInput = {
    where: StoreTaxRuleWhereUniqueInput
    create: XOR<StoreTaxRuleCreateWithoutStoreInput, StoreTaxRuleUncheckedCreateWithoutStoreInput>
  }

  export type StoreTaxRuleCreateManyStoreInputEnvelope = {
    data: StoreTaxRuleCreateManyStoreInput | StoreTaxRuleCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type StoreLoyaltyConfigCreateWithoutStoreInput = {
    id?: string
    pointsPerGel?: number
    redemptionRate?: number
    minRedemptionPoints?: number
    expirationDays?: number | null
    bronzeMinSpend?: Decimal | DecimalJsLike | number | string | null
    silverMinSpend?: Decimal | DecimalJsLike | number | string | null
    goldMinSpend?: Decimal | DecimalJsLike | number | string | null
    platinumMinSpend?: Decimal | DecimalJsLike | number | string | null
    goldDiscountPercent?: Decimal | DecimalJsLike | number | string | null
    platinumDiscountPercent?: Decimal | DecimalJsLike | number | string | null
  }

  export type StoreLoyaltyConfigUncheckedCreateWithoutStoreInput = {
    id?: string
    pointsPerGel?: number
    redemptionRate?: number
    minRedemptionPoints?: number
    expirationDays?: number | null
    bronzeMinSpend?: Decimal | DecimalJsLike | number | string | null
    silverMinSpend?: Decimal | DecimalJsLike | number | string | null
    goldMinSpend?: Decimal | DecimalJsLike | number | string | null
    platinumMinSpend?: Decimal | DecimalJsLike | number | string | null
    goldDiscountPercent?: Decimal | DecimalJsLike | number | string | null
    platinumDiscountPercent?: Decimal | DecimalJsLike | number | string | null
  }

  export type StoreLoyaltyConfigCreateOrConnectWithoutStoreInput = {
    where: StoreLoyaltyConfigWhereUniqueInput
    create: XOR<StoreLoyaltyConfigCreateWithoutStoreInput, StoreLoyaltyConfigUncheckedCreateWithoutStoreInput>
  }

  export type TransferOrderCreateWithoutFromStoreInput = {
    id?: string
    transferNumber: string
    status?: $Enums.TransferOrderStatus
    notes?: string | null
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    toStore: StoreCreateNestedOneWithoutTransferOrdersInInput
    items?: TransferOrderItemCreateNestedManyWithoutTransferOrderInput
  }

  export type TransferOrderUncheckedCreateWithoutFromStoreInput = {
    id?: string
    toStoreId: string
    transferNumber: string
    status?: $Enums.TransferOrderStatus
    notes?: string | null
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferOrderItemUncheckedCreateNestedManyWithoutTransferOrderInput
  }

  export type TransferOrderCreateOrConnectWithoutFromStoreInput = {
    where: TransferOrderWhereUniqueInput
    create: XOR<TransferOrderCreateWithoutFromStoreInput, TransferOrderUncheckedCreateWithoutFromStoreInput>
  }

  export type TransferOrderCreateManyFromStoreInputEnvelope = {
    data: TransferOrderCreateManyFromStoreInput | TransferOrderCreateManyFromStoreInput[]
    skipDuplicates?: boolean
  }

  export type TransferOrderCreateWithoutToStoreInput = {
    id?: string
    transferNumber: string
    status?: $Enums.TransferOrderStatus
    notes?: string | null
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fromStore: StoreCreateNestedOneWithoutTransferOrdersOutInput
    items?: TransferOrderItemCreateNestedManyWithoutTransferOrderInput
  }

  export type TransferOrderUncheckedCreateWithoutToStoreInput = {
    id?: string
    fromStoreId: string
    transferNumber: string
    status?: $Enums.TransferOrderStatus
    notes?: string | null
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TransferOrderItemUncheckedCreateNestedManyWithoutTransferOrderInput
  }

  export type TransferOrderCreateOrConnectWithoutToStoreInput = {
    where: TransferOrderWhereUniqueInput
    create: XOR<TransferOrderCreateWithoutToStoreInput, TransferOrderUncheckedCreateWithoutToStoreInput>
  }

  export type TransferOrderCreateManyToStoreInputEnvelope = {
    data: TransferOrderCreateManyToStoreInput | TransferOrderCreateManyToStoreInput[]
    skipDuplicates?: boolean
  }

  export type StorePaymentConfigCreateWithoutStoreInput = {
    id?: string
    name: string
    type: $Enums.PaymentMethod
    isActive?: boolean
    sortOrder?: number
  }

  export type StorePaymentConfigUncheckedCreateWithoutStoreInput = {
    id?: string
    name: string
    type: $Enums.PaymentMethod
    isActive?: boolean
    sortOrder?: number
  }

  export type StorePaymentConfigCreateOrConnectWithoutStoreInput = {
    where: StorePaymentConfigWhereUniqueInput
    create: XOR<StorePaymentConfigCreateWithoutStoreInput, StorePaymentConfigUncheckedCreateWithoutStoreInput>
  }

  export type StorePaymentConfigCreateManyStoreInputEnvelope = {
    data: StorePaymentConfigCreateManyStoreInput | StorePaymentConfigCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type StoreReceiptConfigCreateWithoutStoreInput = {
    id?: string
    headerText?: string | null
    footerText?: string | null
    showLogo?: boolean
    showTaxId?: boolean
    showBarcode?: boolean
    paperWidth?: number
  }

  export type StoreReceiptConfigUncheckedCreateWithoutStoreInput = {
    id?: string
    headerText?: string | null
    footerText?: string | null
    showLogo?: boolean
    showTaxId?: boolean
    showBarcode?: boolean
    paperWidth?: number
  }

  export type StoreReceiptConfigCreateOrConnectWithoutStoreInput = {
    where: StoreReceiptConfigWhereUniqueInput
    create: XOR<StoreReceiptConfigCreateWithoutStoreInput, StoreReceiptConfigUncheckedCreateWithoutStoreInput>
  }

  export type StoreDeviceConfigCreateWithoutStoreInput = {
    id?: string
    deviceType: $Enums.StoreDeviceType
    name: string
    connectionType: string
    settings: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreDeviceConfigUncheckedCreateWithoutStoreInput = {
    id?: string
    deviceType: $Enums.StoreDeviceType
    name: string
    connectionType: string
    settings: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreDeviceConfigCreateOrConnectWithoutStoreInput = {
    where: StoreDeviceConfigWhereUniqueInput
    create: XOR<StoreDeviceConfigCreateWithoutStoreInput, StoreDeviceConfigUncheckedCreateWithoutStoreInput>
  }

  export type StoreDeviceConfigCreateManyStoreInputEnvelope = {
    data: StoreDeviceConfigCreateManyStoreInput | StoreDeviceConfigCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type StoreIntegrationCreateWithoutStoreInput = {
    id?: string
    type: $Enums.StoreIntegrationType
    name: string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreIntegrationUncheckedCreateWithoutStoreInput = {
    id?: string
    type: $Enums.StoreIntegrationType
    name: string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreIntegrationCreateOrConnectWithoutStoreInput = {
    where: StoreIntegrationWhereUniqueInput
    create: XOR<StoreIntegrationCreateWithoutStoreInput, StoreIntegrationUncheckedCreateWithoutStoreInput>
  }

  export type StoreIntegrationCreateManyStoreInputEnvelope = {
    data: StoreIntegrationCreateManyStoreInput | StoreIntegrationCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type StoreEmployeeUpsertWithWhereUniqueWithoutStoreInput = {
    where: StoreEmployeeWhereUniqueInput
    update: XOR<StoreEmployeeUpdateWithoutStoreInput, StoreEmployeeUncheckedUpdateWithoutStoreInput>
    create: XOR<StoreEmployeeCreateWithoutStoreInput, StoreEmployeeUncheckedCreateWithoutStoreInput>
  }

  export type StoreEmployeeUpdateWithWhereUniqueWithoutStoreInput = {
    where: StoreEmployeeWhereUniqueInput
    data: XOR<StoreEmployeeUpdateWithoutStoreInput, StoreEmployeeUncheckedUpdateWithoutStoreInput>
  }

  export type StoreEmployeeUpdateManyWithWhereWithoutStoreInput = {
    where: StoreEmployeeScalarWhereInput
    data: XOR<StoreEmployeeUpdateManyMutationInput, StoreEmployeeUncheckedUpdateManyWithoutStoreInput>
  }

  export type StoreEmployeeScalarWhereInput = {
    AND?: StoreEmployeeScalarWhereInput | StoreEmployeeScalarWhereInput[]
    OR?: StoreEmployeeScalarWhereInput[]
    NOT?: StoreEmployeeScalarWhereInput | StoreEmployeeScalarWhereInput[]
    id?: StringFilter<"StoreEmployee"> | string
    storeId?: StringFilter<"StoreEmployee"> | string
    userId?: StringNullableFilter<"StoreEmployee"> | string | null
    firstName?: StringFilter<"StoreEmployee"> | string
    lastName?: StringFilter<"StoreEmployee"> | string
    phone?: StringNullableFilter<"StoreEmployee"> | string | null
    email?: StringNullableFilter<"StoreEmployee"> | string | null
    role?: StringFilter<"StoreEmployee"> | string
    pin?: StringNullableFilter<"StoreEmployee"> | string | null
    isActive?: BoolFilter<"StoreEmployee"> | boolean
    createdAt?: DateTimeFilter<"StoreEmployee"> | Date | string
    updatedAt?: DateTimeFilter<"StoreEmployee"> | Date | string
  }

  export type StoreProductUpsertWithWhereUniqueWithoutStoreInput = {
    where: StoreProductWhereUniqueInput
    update: XOR<StoreProductUpdateWithoutStoreInput, StoreProductUncheckedUpdateWithoutStoreInput>
    create: XOR<StoreProductCreateWithoutStoreInput, StoreProductUncheckedCreateWithoutStoreInput>
  }

  export type StoreProductUpdateWithWhereUniqueWithoutStoreInput = {
    where: StoreProductWhereUniqueInput
    data: XOR<StoreProductUpdateWithoutStoreInput, StoreProductUncheckedUpdateWithoutStoreInput>
  }

  export type StoreProductUpdateManyWithWhereWithoutStoreInput = {
    where: StoreProductScalarWhereInput
    data: XOR<StoreProductUpdateManyMutationInput, StoreProductUncheckedUpdateManyWithoutStoreInput>
  }

  export type StoreProductScalarWhereInput = {
    AND?: StoreProductScalarWhereInput | StoreProductScalarWhereInput[]
    OR?: StoreProductScalarWhereInput[]
    NOT?: StoreProductScalarWhereInput | StoreProductScalarWhereInput[]
    id?: StringFilter<"StoreProduct"> | string
    storeId?: StringFilter<"StoreProduct"> | string
    categoryId?: StringNullableFilter<"StoreProduct"> | string | null
    sku?: StringFilter<"StoreProduct"> | string
    barcode?: StringNullableFilter<"StoreProduct"> | string | null
    name?: StringFilter<"StoreProduct"> | string
    nameKa?: StringNullableFilter<"StoreProduct"> | string | null
    description?: StringNullableFilter<"StoreProduct"> | string | null
    imageUrl?: StringNullableFilter<"StoreProduct"> | string | null
    costPrice?: DecimalFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string
    wholesalePrice?: DecimalNullableFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string
    maxStock?: DecimalNullableFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringFilter<"StoreProduct"> | string
    taxRuleId?: StringNullableFilter<"StoreProduct"> | string | null
    isActive?: BoolFilter<"StoreProduct"> | boolean
    isFavorite?: BoolFilter<"StoreProduct"> | boolean
    sortOrder?: IntFilter<"StoreProduct"> | number
    createdAt?: DateTimeFilter<"StoreProduct"> | Date | string
    updatedAt?: DateTimeFilter<"StoreProduct"> | Date | string
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutStoreInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutStoreInput, ProductCategoryUncheckedUpdateWithoutStoreInput>
    create: XOR<ProductCategoryCreateWithoutStoreInput, ProductCategoryUncheckedCreateWithoutStoreInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutStoreInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutStoreInput, ProductCategoryUncheckedUpdateWithoutStoreInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutStoreInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutStoreInput>
  }

  export type ProductCategoryScalarWhereInput = {
    AND?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    OR?: ProductCategoryScalarWhereInput[]
    NOT?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    id?: StringFilter<"ProductCategory"> | string
    storeId?: StringFilter<"ProductCategory"> | string
    name?: StringFilter<"ProductCategory"> | string
    nameKa?: StringNullableFilter<"ProductCategory"> | string | null
    slug?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    color?: StringNullableFilter<"ProductCategory"> | string | null
    icon?: StringNullableFilter<"ProductCategory"> | string | null
    sortOrder?: IntFilter<"ProductCategory"> | number
    parentId?: StringNullableFilter<"ProductCategory"> | string | null
    isActive?: BoolFilter<"ProductCategory"> | boolean
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
  }

  export type SaleUpsertWithWhereUniqueWithoutStoreInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutStoreInput, SaleUncheckedUpdateWithoutStoreInput>
    create: XOR<SaleCreateWithoutStoreInput, SaleUncheckedCreateWithoutStoreInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutStoreInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutStoreInput, SaleUncheckedUpdateWithoutStoreInput>
  }

  export type SaleUpdateManyWithWhereWithoutStoreInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutStoreInput>
  }

  export type SaleScalarWhereInput = {
    AND?: SaleScalarWhereInput | SaleScalarWhereInput[]
    OR?: SaleScalarWhereInput[]
    NOT?: SaleScalarWhereInput | SaleScalarWhereInput[]
    id?: StringFilter<"Sale"> | string
    storeId?: StringFilter<"Sale"> | string
    saleNumber?: StringFilter<"Sale"> | string
    customerId?: StringNullableFilter<"Sale"> | string | null
    employeeId?: StringNullableFilter<"Sale"> | string | null
    subtotal?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    discountType?: EnumStoreDiscountTypeNullableFilter<"Sale"> | $Enums.StoreDiscountType | null
    total?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFilter<"Sale"> | $Enums.StoreSaleStatus
    notes?: StringNullableFilter<"Sale"> | string | null
    receiptPrinted?: BoolFilter<"Sale"> | boolean
    fiscalPrinted?: BoolFilter<"Sale"> | boolean
    fiscalNumber?: StringNullableFilter<"Sale"> | string | null
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
  }

  export type StorePurchaseOrderUpsertWithWhereUniqueWithoutStoreInput = {
    where: StorePurchaseOrderWhereUniqueInput
    update: XOR<StorePurchaseOrderUpdateWithoutStoreInput, StorePurchaseOrderUncheckedUpdateWithoutStoreInput>
    create: XOR<StorePurchaseOrderCreateWithoutStoreInput, StorePurchaseOrderUncheckedCreateWithoutStoreInput>
  }

  export type StorePurchaseOrderUpdateWithWhereUniqueWithoutStoreInput = {
    where: StorePurchaseOrderWhereUniqueInput
    data: XOR<StorePurchaseOrderUpdateWithoutStoreInput, StorePurchaseOrderUncheckedUpdateWithoutStoreInput>
  }

  export type StorePurchaseOrderUpdateManyWithWhereWithoutStoreInput = {
    where: StorePurchaseOrderScalarWhereInput
    data: XOR<StorePurchaseOrderUpdateManyMutationInput, StorePurchaseOrderUncheckedUpdateManyWithoutStoreInput>
  }

  export type StorePurchaseOrderScalarWhereInput = {
    AND?: StorePurchaseOrderScalarWhereInput | StorePurchaseOrderScalarWhereInput[]
    OR?: StorePurchaseOrderScalarWhereInput[]
    NOT?: StorePurchaseOrderScalarWhereInput | StorePurchaseOrderScalarWhereInput[]
    id?: StringFilter<"StorePurchaseOrder"> | string
    storeId?: StringFilter<"StorePurchaseOrder"> | string
    supplierId?: StringFilter<"StorePurchaseOrder"> | string
    orderNumber?: StringFilter<"StorePurchaseOrder"> | string
    subtotal?: DecimalFilter<"StorePurchaseOrder"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"StorePurchaseOrder"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"StorePurchaseOrder"> | Decimal | DecimalJsLike | number | string
    status?: EnumStorePurchaseStatusFilter<"StorePurchaseOrder"> | $Enums.StorePurchaseStatus
    notes?: StringNullableFilter<"StorePurchaseOrder"> | string | null
    expectedDate?: DateTimeNullableFilter<"StorePurchaseOrder"> | Date | string | null
    receivedDate?: DateTimeNullableFilter<"StorePurchaseOrder"> | Date | string | null
    createdAt?: DateTimeFilter<"StorePurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"StorePurchaseOrder"> | Date | string
  }

  export type StoreSupplierUpsertWithWhereUniqueWithoutStoreInput = {
    where: StoreSupplierWhereUniqueInput
    update: XOR<StoreSupplierUpdateWithoutStoreInput, StoreSupplierUncheckedUpdateWithoutStoreInput>
    create: XOR<StoreSupplierCreateWithoutStoreInput, StoreSupplierUncheckedCreateWithoutStoreInput>
  }

  export type StoreSupplierUpdateWithWhereUniqueWithoutStoreInput = {
    where: StoreSupplierWhereUniqueInput
    data: XOR<StoreSupplierUpdateWithoutStoreInput, StoreSupplierUncheckedUpdateWithoutStoreInput>
  }

  export type StoreSupplierUpdateManyWithWhereWithoutStoreInput = {
    where: StoreSupplierScalarWhereInput
    data: XOR<StoreSupplierUpdateManyMutationInput, StoreSupplierUncheckedUpdateManyWithoutStoreInput>
  }

  export type StoreSupplierScalarWhereInput = {
    AND?: StoreSupplierScalarWhereInput | StoreSupplierScalarWhereInput[]
    OR?: StoreSupplierScalarWhereInput[]
    NOT?: StoreSupplierScalarWhereInput | StoreSupplierScalarWhereInput[]
    id?: StringFilter<"StoreSupplier"> | string
    storeId?: StringFilter<"StoreSupplier"> | string
    name?: StringFilter<"StoreSupplier"> | string
    contactPerson?: StringNullableFilter<"StoreSupplier"> | string | null
    phone?: StringNullableFilter<"StoreSupplier"> | string | null
    email?: StringNullableFilter<"StoreSupplier"> | string | null
    address?: StringNullableFilter<"StoreSupplier"> | string | null
    taxId?: StringNullableFilter<"StoreSupplier"> | string | null
    bankAccount?: StringNullableFilter<"StoreSupplier"> | string | null
    notes?: StringNullableFilter<"StoreSupplier"> | string | null
    isActive?: BoolFilter<"StoreSupplier"> | boolean
    createdAt?: DateTimeFilter<"StoreSupplier"> | Date | string
    updatedAt?: DateTimeFilter<"StoreSupplier"> | Date | string
  }

  export type StoreCustomerUpsertWithWhereUniqueWithoutStoreInput = {
    where: StoreCustomerWhereUniqueInput
    update: XOR<StoreCustomerUpdateWithoutStoreInput, StoreCustomerUncheckedUpdateWithoutStoreInput>
    create: XOR<StoreCustomerCreateWithoutStoreInput, StoreCustomerUncheckedCreateWithoutStoreInput>
  }

  export type StoreCustomerUpdateWithWhereUniqueWithoutStoreInput = {
    where: StoreCustomerWhereUniqueInput
    data: XOR<StoreCustomerUpdateWithoutStoreInput, StoreCustomerUncheckedUpdateWithoutStoreInput>
  }

  export type StoreCustomerUpdateManyWithWhereWithoutStoreInput = {
    where: StoreCustomerScalarWhereInput
    data: XOR<StoreCustomerUpdateManyMutationInput, StoreCustomerUncheckedUpdateManyWithoutStoreInput>
  }

  export type StoreCustomerScalarWhereInput = {
    AND?: StoreCustomerScalarWhereInput | StoreCustomerScalarWhereInput[]
    OR?: StoreCustomerScalarWhereInput[]
    NOT?: StoreCustomerScalarWhereInput | StoreCustomerScalarWhereInput[]
    id?: StringFilter<"StoreCustomer"> | string
    storeId?: StringFilter<"StoreCustomer"> | string
    firstName?: StringFilter<"StoreCustomer"> | string
    lastName?: StringNullableFilter<"StoreCustomer"> | string | null
    phone?: StringNullableFilter<"StoreCustomer"> | string | null
    email?: StringNullableFilter<"StoreCustomer"> | string | null
    address?: StringNullableFilter<"StoreCustomer"> | string | null
    taxId?: StringNullableFilter<"StoreCustomer"> | string | null
    notes?: StringNullableFilter<"StoreCustomer"> | string | null
    totalPurchases?: DecimalFilter<"StoreCustomer"> | Decimal | DecimalJsLike | number | string
    loyaltyPoints?: IntFilter<"StoreCustomer"> | number
    loyaltyTier?: EnumLoyaltyTierFilter<"StoreCustomer"> | $Enums.LoyaltyTier
    totalLifetimePurchases?: DecimalFilter<"StoreCustomer"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"StoreCustomer"> | boolean
    createdAt?: DateTimeFilter<"StoreCustomer"> | Date | string
    updatedAt?: DateTimeFilter<"StoreCustomer"> | Date | string
  }

  export type StockMovementUpsertWithWhereUniqueWithoutStoreInput = {
    where: StockMovementWhereUniqueInput
    update: XOR<StockMovementUpdateWithoutStoreInput, StockMovementUncheckedUpdateWithoutStoreInput>
    create: XOR<StockMovementCreateWithoutStoreInput, StockMovementUncheckedCreateWithoutStoreInput>
  }

  export type StockMovementUpdateWithWhereUniqueWithoutStoreInput = {
    where: StockMovementWhereUniqueInput
    data: XOR<StockMovementUpdateWithoutStoreInput, StockMovementUncheckedUpdateWithoutStoreInput>
  }

  export type StockMovementUpdateManyWithWhereWithoutStoreInput = {
    where: StockMovementScalarWhereInput
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyWithoutStoreInput>
  }

  export type StockMovementScalarWhereInput = {
    AND?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
    OR?: StockMovementScalarWhereInput[]
    NOT?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
    id?: StringFilter<"StockMovement"> | string
    storeId?: StringFilter<"StockMovement"> | string
    productId?: StringFilter<"StockMovement"> | string
    type?: EnumStoreMovementTypeFilter<"StockMovement"> | $Enums.StoreMovementType
    quantity?: DecimalFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    previousStock?: DecimalFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    newStock?: DecimalFilter<"StockMovement"> | Decimal | DecimalJsLike | number | string
    reason?: StringNullableFilter<"StockMovement"> | string | null
    referenceType?: StringNullableFilter<"StockMovement"> | string | null
    referenceId?: StringNullableFilter<"StockMovement"> | string | null
    performedBy?: StringNullableFilter<"StockMovement"> | string | null
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
  }

  export type StoreTaxRuleUpsertWithWhereUniqueWithoutStoreInput = {
    where: StoreTaxRuleWhereUniqueInput
    update: XOR<StoreTaxRuleUpdateWithoutStoreInput, StoreTaxRuleUncheckedUpdateWithoutStoreInput>
    create: XOR<StoreTaxRuleCreateWithoutStoreInput, StoreTaxRuleUncheckedCreateWithoutStoreInput>
  }

  export type StoreTaxRuleUpdateWithWhereUniqueWithoutStoreInput = {
    where: StoreTaxRuleWhereUniqueInput
    data: XOR<StoreTaxRuleUpdateWithoutStoreInput, StoreTaxRuleUncheckedUpdateWithoutStoreInput>
  }

  export type StoreTaxRuleUpdateManyWithWhereWithoutStoreInput = {
    where: StoreTaxRuleScalarWhereInput
    data: XOR<StoreTaxRuleUpdateManyMutationInput, StoreTaxRuleUncheckedUpdateManyWithoutStoreInput>
  }

  export type StoreTaxRuleScalarWhereInput = {
    AND?: StoreTaxRuleScalarWhereInput | StoreTaxRuleScalarWhereInput[]
    OR?: StoreTaxRuleScalarWhereInput[]
    NOT?: StoreTaxRuleScalarWhereInput | StoreTaxRuleScalarWhereInput[]
    id?: StringFilter<"StoreTaxRule"> | string
    storeId?: StringFilter<"StoreTaxRule"> | string
    name?: StringFilter<"StoreTaxRule"> | string
    rate?: DecimalFilter<"StoreTaxRule"> | Decimal | DecimalJsLike | number | string
    isDefault?: BoolFilter<"StoreTaxRule"> | boolean
    isActive?: BoolFilter<"StoreTaxRule"> | boolean
  }

  export type StoreLoyaltyConfigUpsertWithoutStoreInput = {
    update: XOR<StoreLoyaltyConfigUpdateWithoutStoreInput, StoreLoyaltyConfigUncheckedUpdateWithoutStoreInput>
    create: XOR<StoreLoyaltyConfigCreateWithoutStoreInput, StoreLoyaltyConfigUncheckedCreateWithoutStoreInput>
    where?: StoreLoyaltyConfigWhereInput
  }

  export type StoreLoyaltyConfigUpdateToOneWithWhereWithoutStoreInput = {
    where?: StoreLoyaltyConfigWhereInput
    data: XOR<StoreLoyaltyConfigUpdateWithoutStoreInput, StoreLoyaltyConfigUncheckedUpdateWithoutStoreInput>
  }

  export type StoreLoyaltyConfigUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsPerGel?: IntFieldUpdateOperationsInput | number
    redemptionRate?: IntFieldUpdateOperationsInput | number
    minRedemptionPoints?: IntFieldUpdateOperationsInput | number
    expirationDays?: NullableIntFieldUpdateOperationsInput | number | null
    bronzeMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    silverMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    goldMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platinumMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    goldDiscountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platinumDiscountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type StoreLoyaltyConfigUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointsPerGel?: IntFieldUpdateOperationsInput | number
    redemptionRate?: IntFieldUpdateOperationsInput | number
    minRedemptionPoints?: IntFieldUpdateOperationsInput | number
    expirationDays?: NullableIntFieldUpdateOperationsInput | number | null
    bronzeMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    silverMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    goldMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platinumMinSpend?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    goldDiscountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platinumDiscountPercent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type TransferOrderUpsertWithWhereUniqueWithoutFromStoreInput = {
    where: TransferOrderWhereUniqueInput
    update: XOR<TransferOrderUpdateWithoutFromStoreInput, TransferOrderUncheckedUpdateWithoutFromStoreInput>
    create: XOR<TransferOrderCreateWithoutFromStoreInput, TransferOrderUncheckedCreateWithoutFromStoreInput>
  }

  export type TransferOrderUpdateWithWhereUniqueWithoutFromStoreInput = {
    where: TransferOrderWhereUniqueInput
    data: XOR<TransferOrderUpdateWithoutFromStoreInput, TransferOrderUncheckedUpdateWithoutFromStoreInput>
  }

  export type TransferOrderUpdateManyWithWhereWithoutFromStoreInput = {
    where: TransferOrderScalarWhereInput
    data: XOR<TransferOrderUpdateManyMutationInput, TransferOrderUncheckedUpdateManyWithoutFromStoreInput>
  }

  export type TransferOrderScalarWhereInput = {
    AND?: TransferOrderScalarWhereInput | TransferOrderScalarWhereInput[]
    OR?: TransferOrderScalarWhereInput[]
    NOT?: TransferOrderScalarWhereInput | TransferOrderScalarWhereInput[]
    id?: StringFilter<"TransferOrder"> | string
    fromStoreId?: StringFilter<"TransferOrder"> | string
    toStoreId?: StringFilter<"TransferOrder"> | string
    transferNumber?: StringFilter<"TransferOrder"> | string
    status?: EnumTransferOrderStatusFilter<"TransferOrder"> | $Enums.TransferOrderStatus
    notes?: StringNullableFilter<"TransferOrder"> | string | null
    sentAt?: DateTimeNullableFilter<"TransferOrder"> | Date | string | null
    receivedAt?: DateTimeNullableFilter<"TransferOrder"> | Date | string | null
    createdAt?: DateTimeFilter<"TransferOrder"> | Date | string
    updatedAt?: DateTimeFilter<"TransferOrder"> | Date | string
  }

  export type TransferOrderUpsertWithWhereUniqueWithoutToStoreInput = {
    where: TransferOrderWhereUniqueInput
    update: XOR<TransferOrderUpdateWithoutToStoreInput, TransferOrderUncheckedUpdateWithoutToStoreInput>
    create: XOR<TransferOrderCreateWithoutToStoreInput, TransferOrderUncheckedCreateWithoutToStoreInput>
  }

  export type TransferOrderUpdateWithWhereUniqueWithoutToStoreInput = {
    where: TransferOrderWhereUniqueInput
    data: XOR<TransferOrderUpdateWithoutToStoreInput, TransferOrderUncheckedUpdateWithoutToStoreInput>
  }

  export type TransferOrderUpdateManyWithWhereWithoutToStoreInput = {
    where: TransferOrderScalarWhereInput
    data: XOR<TransferOrderUpdateManyMutationInput, TransferOrderUncheckedUpdateManyWithoutToStoreInput>
  }

  export type StorePaymentConfigUpsertWithWhereUniqueWithoutStoreInput = {
    where: StorePaymentConfigWhereUniqueInput
    update: XOR<StorePaymentConfigUpdateWithoutStoreInput, StorePaymentConfigUncheckedUpdateWithoutStoreInput>
    create: XOR<StorePaymentConfigCreateWithoutStoreInput, StorePaymentConfigUncheckedCreateWithoutStoreInput>
  }

  export type StorePaymentConfigUpdateWithWhereUniqueWithoutStoreInput = {
    where: StorePaymentConfigWhereUniqueInput
    data: XOR<StorePaymentConfigUpdateWithoutStoreInput, StorePaymentConfigUncheckedUpdateWithoutStoreInput>
  }

  export type StorePaymentConfigUpdateManyWithWhereWithoutStoreInput = {
    where: StorePaymentConfigScalarWhereInput
    data: XOR<StorePaymentConfigUpdateManyMutationInput, StorePaymentConfigUncheckedUpdateManyWithoutStoreInput>
  }

  export type StorePaymentConfigScalarWhereInput = {
    AND?: StorePaymentConfigScalarWhereInput | StorePaymentConfigScalarWhereInput[]
    OR?: StorePaymentConfigScalarWhereInput[]
    NOT?: StorePaymentConfigScalarWhereInput | StorePaymentConfigScalarWhereInput[]
    id?: StringFilter<"StorePaymentConfig"> | string
    storeId?: StringFilter<"StorePaymentConfig"> | string
    name?: StringFilter<"StorePaymentConfig"> | string
    type?: EnumPaymentMethodFilter<"StorePaymentConfig"> | $Enums.PaymentMethod
    isActive?: BoolFilter<"StorePaymentConfig"> | boolean
    sortOrder?: IntFilter<"StorePaymentConfig"> | number
  }

  export type StoreReceiptConfigUpsertWithoutStoreInput = {
    update: XOR<StoreReceiptConfigUpdateWithoutStoreInput, StoreReceiptConfigUncheckedUpdateWithoutStoreInput>
    create: XOR<StoreReceiptConfigCreateWithoutStoreInput, StoreReceiptConfigUncheckedCreateWithoutStoreInput>
    where?: StoreReceiptConfigWhereInput
  }

  export type StoreReceiptConfigUpdateToOneWithWhereWithoutStoreInput = {
    where?: StoreReceiptConfigWhereInput
    data: XOR<StoreReceiptConfigUpdateWithoutStoreInput, StoreReceiptConfigUncheckedUpdateWithoutStoreInput>
  }

  export type StoreReceiptConfigUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    headerText?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    showLogo?: BoolFieldUpdateOperationsInput | boolean
    showTaxId?: BoolFieldUpdateOperationsInput | boolean
    showBarcode?: BoolFieldUpdateOperationsInput | boolean
    paperWidth?: IntFieldUpdateOperationsInput | number
  }

  export type StoreReceiptConfigUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    headerText?: NullableStringFieldUpdateOperationsInput | string | null
    footerText?: NullableStringFieldUpdateOperationsInput | string | null
    showLogo?: BoolFieldUpdateOperationsInput | boolean
    showTaxId?: BoolFieldUpdateOperationsInput | boolean
    showBarcode?: BoolFieldUpdateOperationsInput | boolean
    paperWidth?: IntFieldUpdateOperationsInput | number
  }

  export type StoreDeviceConfigUpsertWithWhereUniqueWithoutStoreInput = {
    where: StoreDeviceConfigWhereUniqueInput
    update: XOR<StoreDeviceConfigUpdateWithoutStoreInput, StoreDeviceConfigUncheckedUpdateWithoutStoreInput>
    create: XOR<StoreDeviceConfigCreateWithoutStoreInput, StoreDeviceConfigUncheckedCreateWithoutStoreInput>
  }

  export type StoreDeviceConfigUpdateWithWhereUniqueWithoutStoreInput = {
    where: StoreDeviceConfigWhereUniqueInput
    data: XOR<StoreDeviceConfigUpdateWithoutStoreInput, StoreDeviceConfigUncheckedUpdateWithoutStoreInput>
  }

  export type StoreDeviceConfigUpdateManyWithWhereWithoutStoreInput = {
    where: StoreDeviceConfigScalarWhereInput
    data: XOR<StoreDeviceConfigUpdateManyMutationInput, StoreDeviceConfigUncheckedUpdateManyWithoutStoreInput>
  }

  export type StoreDeviceConfigScalarWhereInput = {
    AND?: StoreDeviceConfigScalarWhereInput | StoreDeviceConfigScalarWhereInput[]
    OR?: StoreDeviceConfigScalarWhereInput[]
    NOT?: StoreDeviceConfigScalarWhereInput | StoreDeviceConfigScalarWhereInput[]
    id?: StringFilter<"StoreDeviceConfig"> | string
    storeId?: StringFilter<"StoreDeviceConfig"> | string
    deviceType?: EnumStoreDeviceTypeFilter<"StoreDeviceConfig"> | $Enums.StoreDeviceType
    name?: StringFilter<"StoreDeviceConfig"> | string
    connectionType?: StringFilter<"StoreDeviceConfig"> | string
    settings?: JsonFilter<"StoreDeviceConfig">
    isActive?: BoolFilter<"StoreDeviceConfig"> | boolean
    createdAt?: DateTimeFilter<"StoreDeviceConfig"> | Date | string
    updatedAt?: DateTimeFilter<"StoreDeviceConfig"> | Date | string
  }

  export type StoreIntegrationUpsertWithWhereUniqueWithoutStoreInput = {
    where: StoreIntegrationWhereUniqueInput
    update: XOR<StoreIntegrationUpdateWithoutStoreInput, StoreIntegrationUncheckedUpdateWithoutStoreInput>
    create: XOR<StoreIntegrationCreateWithoutStoreInput, StoreIntegrationUncheckedCreateWithoutStoreInput>
  }

  export type StoreIntegrationUpdateWithWhereUniqueWithoutStoreInput = {
    where: StoreIntegrationWhereUniqueInput
    data: XOR<StoreIntegrationUpdateWithoutStoreInput, StoreIntegrationUncheckedUpdateWithoutStoreInput>
  }

  export type StoreIntegrationUpdateManyWithWhereWithoutStoreInput = {
    where: StoreIntegrationScalarWhereInput
    data: XOR<StoreIntegrationUpdateManyMutationInput, StoreIntegrationUncheckedUpdateManyWithoutStoreInput>
  }

  export type StoreIntegrationScalarWhereInput = {
    AND?: StoreIntegrationScalarWhereInput | StoreIntegrationScalarWhereInput[]
    OR?: StoreIntegrationScalarWhereInput[]
    NOT?: StoreIntegrationScalarWhereInput | StoreIntegrationScalarWhereInput[]
    id?: StringFilter<"StoreIntegration"> | string
    storeId?: StringFilter<"StoreIntegration"> | string
    type?: EnumStoreIntegrationTypeFilter<"StoreIntegration"> | $Enums.StoreIntegrationType
    name?: StringFilter<"StoreIntegration"> | string
    credentials?: JsonNullableFilter<"StoreIntegration">
    settings?: JsonNullableFilter<"StoreIntegration">
    lastSyncAt?: DateTimeNullableFilter<"StoreIntegration"> | Date | string | null
    isActive?: BoolFilter<"StoreIntegration"> | boolean
    createdAt?: DateTimeFilter<"StoreIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"StoreIntegration"> | Date | string
  }

  export type StoreCreateWithoutEmployeesInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: StoreProductCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutEmployeesInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: StoreProductUncheckedCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderUncheckedCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierUncheckedCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerUncheckedCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleUncheckedCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderUncheckedCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderUncheckedCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigUncheckedCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigUncheckedCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigUncheckedCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutEmployeesInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutEmployeesInput, StoreUncheckedCreateWithoutEmployeesInput>
  }

  export type SaleCreateWithoutEmployeeInput = {
    id?: string
    saleNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.StoreDiscountType | null
    total: Decimal | DecimalJsLike | number | string
    paidAmount: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.StoreSaleStatus
    notes?: string | null
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSalesInput
    customer?: StoreCustomerCreateNestedOneWithoutSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
    payments?: SalePaymentCreateNestedManyWithoutSaleInput
    returns?: SaleReturnCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutEmployeeInput = {
    id?: string
    storeId: string
    saleNumber: string
    customerId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.StoreDiscountType | null
    total: Decimal | DecimalJsLike | number | string
    paidAmount: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.StoreSaleStatus
    notes?: string | null
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
    payments?: SalePaymentUncheckedCreateNestedManyWithoutSaleInput
    returns?: SaleReturnUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutEmployeeInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutEmployeeInput, SaleUncheckedCreateWithoutEmployeeInput>
  }

  export type SaleCreateManyEmployeeInputEnvelope = {
    data: SaleCreateManyEmployeeInput | SaleCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type StoreUpsertWithoutEmployeesInput = {
    update: XOR<StoreUpdateWithoutEmployeesInput, StoreUncheckedUpdateWithoutEmployeesInput>
    create: XOR<StoreCreateWithoutEmployeesInput, StoreUncheckedCreateWithoutEmployeesInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutEmployeesInput, StoreUncheckedUpdateWithoutEmployeesInput>
  }

  export type StoreUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: StoreProductUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: StoreProductUncheckedUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUncheckedUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUncheckedUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUncheckedUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUncheckedUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUncheckedUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUncheckedUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUncheckedUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUncheckedUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUncheckedUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type SaleUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutEmployeeInput, SaleUncheckedUpdateWithoutEmployeeInput>
    create: XOR<SaleCreateWithoutEmployeeInput, SaleUncheckedCreateWithoutEmployeeInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutEmployeeInput, SaleUncheckedUpdateWithoutEmployeeInput>
  }

  export type SaleUpdateManyWithWhereWithoutEmployeeInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type StoreCreateWithoutCategoriesInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeCreateNestedManyWithoutStoreInput
    products?: StoreProductCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutCategoriesInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeUncheckedCreateNestedManyWithoutStoreInput
    products?: StoreProductUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderUncheckedCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierUncheckedCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerUncheckedCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleUncheckedCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderUncheckedCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderUncheckedCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigUncheckedCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigUncheckedCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigUncheckedCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutCategoriesInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutCategoriesInput, StoreUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductCategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    nameKa?: string | null
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutCategoriesInput
    parent?: ProductCategoryCreateNestedOneWithoutChildrenInput
    products?: StoreProductCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    storeId: string
    name: string
    nameKa?: string | null
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    sortOrder?: number
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: StoreProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutChildrenInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutChildrenInput, ProductCategoryUncheckedCreateWithoutChildrenInput>
  }

  export type ProductCategoryCreateWithoutParentInput = {
    id?: string
    name: string
    nameKa?: string | null
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutCategoriesInput
    children?: ProductCategoryCreateNestedManyWithoutParentInput
    products?: StoreProductCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutParentInput = {
    id?: string
    storeId: string
    name: string
    nameKa?: string | null
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ProductCategoryUncheckedCreateNestedManyWithoutParentInput
    products?: StoreProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutParentInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput>
  }

  export type ProductCategoryCreateManyParentInputEnvelope = {
    data: ProductCategoryCreateManyParentInput | ProductCategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type StoreProductCreateWithoutCategoryInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutProductsInput
    taxRule?: StoreTaxRuleCreateNestedOneWithoutProductsInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    saleReturnItems?: SaleReturnItemCreateNestedManyWithoutProductInput
    purchaseItems?: StorePurchaseItemCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    priceHistory?: StorePriceHistoryCreateNestedManyWithoutProductInput
    transferOrderItems?: TransferOrderItemCreateNestedManyWithoutProductInput
  }

  export type StoreProductUncheckedCreateWithoutCategoryInput = {
    id?: string
    storeId: string
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    taxRuleId?: string | null
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    saleReturnItems?: SaleReturnItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: StorePurchaseItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: StorePriceHistoryUncheckedCreateNestedManyWithoutProductInput
    transferOrderItems?: TransferOrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type StoreProductCreateOrConnectWithoutCategoryInput = {
    where: StoreProductWhereUniqueInput
    create: XOR<StoreProductCreateWithoutCategoryInput, StoreProductUncheckedCreateWithoutCategoryInput>
  }

  export type StoreProductCreateManyCategoryInputEnvelope = {
    data: StoreProductCreateManyCategoryInput | StoreProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type StoreUpsertWithoutCategoriesInput = {
    update: XOR<StoreUpdateWithoutCategoriesInput, StoreUncheckedUpdateWithoutCategoriesInput>
    create: XOR<StoreCreateWithoutCategoriesInput, StoreUncheckedCreateWithoutCategoriesInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutCategoriesInput, StoreUncheckedUpdateWithoutCategoriesInput>
  }

  export type StoreUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUpdateManyWithoutStoreNestedInput
    products?: StoreProductUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUncheckedUpdateManyWithoutStoreNestedInput
    products?: StoreProductUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUncheckedUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUncheckedUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUncheckedUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUncheckedUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUncheckedUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUncheckedUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUncheckedUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUncheckedUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUncheckedUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ProductCategoryUpsertWithoutChildrenInput = {
    update: XOR<ProductCategoryUpdateWithoutChildrenInput, ProductCategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<ProductCategoryCreateWithoutChildrenInput, ProductCategoryUncheckedCreateWithoutChildrenInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutChildrenInput, ProductCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type ProductCategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutCategoriesNestedInput
    parent?: ProductCategoryUpdateOneWithoutChildrenNestedInput
    products?: StoreProductUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: StoreProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutParentInput, ProductCategoryUncheckedUpdateWithoutParentInput>
    create: XOR<ProductCategoryCreateWithoutParentInput, ProductCategoryUncheckedCreateWithoutParentInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutParentInput, ProductCategoryUncheckedUpdateWithoutParentInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutParentInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type StoreProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: StoreProductWhereUniqueInput
    update: XOR<StoreProductUpdateWithoutCategoryInput, StoreProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<StoreProductCreateWithoutCategoryInput, StoreProductUncheckedCreateWithoutCategoryInput>
  }

  export type StoreProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: StoreProductWhereUniqueInput
    data: XOR<StoreProductUpdateWithoutCategoryInput, StoreProductUncheckedUpdateWithoutCategoryInput>
  }

  export type StoreProductUpdateManyWithWhereWithoutCategoryInput = {
    where: StoreProductScalarWhereInput
    data: XOR<StoreProductUpdateManyMutationInput, StoreProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type StoreCreateWithoutProductsInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutProductsInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeUncheckedCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderUncheckedCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierUncheckedCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerUncheckedCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleUncheckedCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderUncheckedCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderUncheckedCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigUncheckedCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigUncheckedCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigUncheckedCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutProductsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutProductsInput, StoreUncheckedCreateWithoutProductsInput>
  }

  export type ProductCategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    nameKa?: string | null
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutCategoriesInput
    parent?: ProductCategoryCreateNestedOneWithoutChildrenInput
    children?: ProductCategoryCreateNestedManyWithoutParentInput
  }

  export type ProductCategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    storeId: string
    name: string
    nameKa?: string | null
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    sortOrder?: number
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ProductCategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type ProductCategoryCreateOrConnectWithoutProductsInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
  }

  export type StoreTaxRuleCreateWithoutProductsInput = {
    id?: string
    name: string
    rate: Decimal | DecimalJsLike | number | string
    isDefault?: boolean
    isActive?: boolean
    store: StoreCreateNestedOneWithoutTaxRulesInput
  }

  export type StoreTaxRuleUncheckedCreateWithoutProductsInput = {
    id?: string
    storeId: string
    name: string
    rate: Decimal | DecimalJsLike | number | string
    isDefault?: boolean
    isActive?: boolean
  }

  export type StoreTaxRuleCreateOrConnectWithoutProductsInput = {
    where: StoreTaxRuleWhereUniqueInput
    create: XOR<StoreTaxRuleCreateWithoutProductsInput, StoreTaxRuleUncheckedCreateWithoutProductsInput>
  }

  export type SaleItemCreateWithoutProductInput = {
    id?: string
    productName: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    sale: SaleCreateNestedOneWithoutItemsInput
  }

  export type SaleItemUncheckedCreateWithoutProductInput = {
    id?: string
    saleId: string
    productName: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type SaleItemCreateOrConnectWithoutProductInput = {
    where: SaleItemWhereUniqueInput
    create: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput>
  }

  export type SaleItemCreateManyProductInputEnvelope = {
    data: SaleItemCreateManyProductInput | SaleItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SaleReturnItemCreateWithoutProductInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    refundAmount: Decimal | DecimalJsLike | number | string
    saleReturn: SaleReturnCreateNestedOneWithoutItemsInput
  }

  export type SaleReturnItemUncheckedCreateWithoutProductInput = {
    id?: string
    returnId: string
    quantity: Decimal | DecimalJsLike | number | string
    refundAmount: Decimal | DecimalJsLike | number | string
  }

  export type SaleReturnItemCreateOrConnectWithoutProductInput = {
    where: SaleReturnItemWhereUniqueInput
    create: XOR<SaleReturnItemCreateWithoutProductInput, SaleReturnItemUncheckedCreateWithoutProductInput>
  }

  export type SaleReturnItemCreateManyProductInputEnvelope = {
    data: SaleReturnItemCreateManyProductInput | SaleReturnItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type StorePurchaseItemCreateWithoutProductInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedQty?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    purchaseOrder: StorePurchaseOrderCreateNestedOneWithoutItemsInput
  }

  export type StorePurchaseItemUncheckedCreateWithoutProductInput = {
    id?: string
    purchaseOrderId: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedQty?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type StorePurchaseItemCreateOrConnectWithoutProductInput = {
    where: StorePurchaseItemWhereUniqueInput
    create: XOR<StorePurchaseItemCreateWithoutProductInput, StorePurchaseItemUncheckedCreateWithoutProductInput>
  }

  export type StorePurchaseItemCreateManyProductInputEnvelope = {
    data: StorePurchaseItemCreateManyProductInput | StorePurchaseItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type StockMovementCreateWithoutProductInput = {
    id?: string
    type: $Enums.StoreMovementType
    quantity: Decimal | DecimalJsLike | number | string
    previousStock: Decimal | DecimalJsLike | number | string
    newStock: Decimal | DecimalJsLike | number | string
    reason?: string | null
    referenceType?: string | null
    referenceId?: string | null
    performedBy?: string | null
    createdAt?: Date | string
    store: StoreCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateWithoutProductInput = {
    id?: string
    storeId: string
    type: $Enums.StoreMovementType
    quantity: Decimal | DecimalJsLike | number | string
    previousStock: Decimal | DecimalJsLike | number | string
    newStock: Decimal | DecimalJsLike | number | string
    reason?: string | null
    referenceType?: string | null
    referenceId?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type StockMovementCreateOrConnectWithoutProductInput = {
    where: StockMovementWhereUniqueInput
    create: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput>
  }

  export type StockMovementCreateManyProductInputEnvelope = {
    data: StockMovementCreateManyProductInput | StockMovementCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type StorePriceHistoryCreateWithoutProductInput = {
    id?: string
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    changedBy?: string | null
    changedAt?: Date | string
  }

  export type StorePriceHistoryUncheckedCreateWithoutProductInput = {
    id?: string
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    changedBy?: string | null
    changedAt?: Date | string
  }

  export type StorePriceHistoryCreateOrConnectWithoutProductInput = {
    where: StorePriceHistoryWhereUniqueInput
    create: XOR<StorePriceHistoryCreateWithoutProductInput, StorePriceHistoryUncheckedCreateWithoutProductInput>
  }

  export type StorePriceHistoryCreateManyProductInputEnvelope = {
    data: StorePriceHistoryCreateManyProductInput | StorePriceHistoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type TransferOrderItemCreateWithoutProductInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    transferOrder: TransferOrderCreateNestedOneWithoutItemsInput
  }

  export type TransferOrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    transferOrderId: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type TransferOrderItemCreateOrConnectWithoutProductInput = {
    where: TransferOrderItemWhereUniqueInput
    create: XOR<TransferOrderItemCreateWithoutProductInput, TransferOrderItemUncheckedCreateWithoutProductInput>
  }

  export type TransferOrderItemCreateManyProductInputEnvelope = {
    data: TransferOrderItemCreateManyProductInput | TransferOrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type StoreUpsertWithoutProductsInput = {
    update: XOR<StoreUpdateWithoutProductsInput, StoreUncheckedUpdateWithoutProductsInput>
    create: XOR<StoreCreateWithoutProductsInput, StoreUncheckedCreateWithoutProductsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutProductsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutProductsInput, StoreUncheckedUpdateWithoutProductsInput>
  }

  export type StoreUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUncheckedUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUncheckedUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUncheckedUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUncheckedUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUncheckedUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUncheckedUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUncheckedUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUncheckedUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUncheckedUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUncheckedUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ProductCategoryUpsertWithoutProductsInput = {
    update: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutCategoriesNestedInput
    parent?: ProductCategoryUpdateOneWithoutChildrenNestedInput
    children?: ProductCategoryUpdateManyWithoutParentNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ProductCategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type StoreTaxRuleUpsertWithoutProductsInput = {
    update: XOR<StoreTaxRuleUpdateWithoutProductsInput, StoreTaxRuleUncheckedUpdateWithoutProductsInput>
    create: XOR<StoreTaxRuleCreateWithoutProductsInput, StoreTaxRuleUncheckedCreateWithoutProductsInput>
    where?: StoreTaxRuleWhereInput
  }

  export type StoreTaxRuleUpdateToOneWithWhereWithoutProductsInput = {
    where?: StoreTaxRuleWhereInput
    data: XOR<StoreTaxRuleUpdateWithoutProductsInput, StoreTaxRuleUncheckedUpdateWithoutProductsInput>
  }

  export type StoreTaxRuleUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    store?: StoreUpdateOneRequiredWithoutTaxRulesNestedInput
  }

  export type StoreTaxRuleUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SaleItemUpsertWithWhereUniqueWithoutProductInput = {
    where: SaleItemWhereUniqueInput
    update: XOR<SaleItemUpdateWithoutProductInput, SaleItemUncheckedUpdateWithoutProductInput>
    create: XOR<SaleItemCreateWithoutProductInput, SaleItemUncheckedCreateWithoutProductInput>
  }

  export type SaleItemUpdateWithWhereUniqueWithoutProductInput = {
    where: SaleItemWhereUniqueInput
    data: XOR<SaleItemUpdateWithoutProductInput, SaleItemUncheckedUpdateWithoutProductInput>
  }

  export type SaleItemUpdateManyWithWhereWithoutProductInput = {
    where: SaleItemScalarWhereInput
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyWithoutProductInput>
  }

  export type SaleItemScalarWhereInput = {
    AND?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
    OR?: SaleItemScalarWhereInput[]
    NOT?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
    id?: StringFilter<"SaleItem"> | string
    saleId?: StringFilter<"SaleItem"> | string
    productId?: StringFilter<"SaleItem"> | string
    productName?: StringFilter<"SaleItem"> | string
    quantity?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
  }

  export type SaleReturnItemUpsertWithWhereUniqueWithoutProductInput = {
    where: SaleReturnItemWhereUniqueInput
    update: XOR<SaleReturnItemUpdateWithoutProductInput, SaleReturnItemUncheckedUpdateWithoutProductInput>
    create: XOR<SaleReturnItemCreateWithoutProductInput, SaleReturnItemUncheckedCreateWithoutProductInput>
  }

  export type SaleReturnItemUpdateWithWhereUniqueWithoutProductInput = {
    where: SaleReturnItemWhereUniqueInput
    data: XOR<SaleReturnItemUpdateWithoutProductInput, SaleReturnItemUncheckedUpdateWithoutProductInput>
  }

  export type SaleReturnItemUpdateManyWithWhereWithoutProductInput = {
    where: SaleReturnItemScalarWhereInput
    data: XOR<SaleReturnItemUpdateManyMutationInput, SaleReturnItemUncheckedUpdateManyWithoutProductInput>
  }

  export type SaleReturnItemScalarWhereInput = {
    AND?: SaleReturnItemScalarWhereInput | SaleReturnItemScalarWhereInput[]
    OR?: SaleReturnItemScalarWhereInput[]
    NOT?: SaleReturnItemScalarWhereInput | SaleReturnItemScalarWhereInput[]
    id?: StringFilter<"SaleReturnItem"> | string
    returnId?: StringFilter<"SaleReturnItem"> | string
    productId?: StringFilter<"SaleReturnItem"> | string
    quantity?: DecimalFilter<"SaleReturnItem"> | Decimal | DecimalJsLike | number | string
    refundAmount?: DecimalFilter<"SaleReturnItem"> | Decimal | DecimalJsLike | number | string
  }

  export type StorePurchaseItemUpsertWithWhereUniqueWithoutProductInput = {
    where: StorePurchaseItemWhereUniqueInput
    update: XOR<StorePurchaseItemUpdateWithoutProductInput, StorePurchaseItemUncheckedUpdateWithoutProductInput>
    create: XOR<StorePurchaseItemCreateWithoutProductInput, StorePurchaseItemUncheckedCreateWithoutProductInput>
  }

  export type StorePurchaseItemUpdateWithWhereUniqueWithoutProductInput = {
    where: StorePurchaseItemWhereUniqueInput
    data: XOR<StorePurchaseItemUpdateWithoutProductInput, StorePurchaseItemUncheckedUpdateWithoutProductInput>
  }

  export type StorePurchaseItemUpdateManyWithWhereWithoutProductInput = {
    where: StorePurchaseItemScalarWhereInput
    data: XOR<StorePurchaseItemUpdateManyMutationInput, StorePurchaseItemUncheckedUpdateManyWithoutProductInput>
  }

  export type StorePurchaseItemScalarWhereInput = {
    AND?: StorePurchaseItemScalarWhereInput | StorePurchaseItemScalarWhereInput[]
    OR?: StorePurchaseItemScalarWhereInput[]
    NOT?: StorePurchaseItemScalarWhereInput | StorePurchaseItemScalarWhereInput[]
    id?: StringFilter<"StorePurchaseItem"> | string
    purchaseOrderId?: StringFilter<"StorePurchaseItem"> | string
    productId?: StringFilter<"StorePurchaseItem"> | string
    quantity?: DecimalFilter<"StorePurchaseItem"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFilter<"StorePurchaseItem"> | Decimal | DecimalJsLike | number | string
    receivedQty?: DecimalFilter<"StorePurchaseItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"StorePurchaseItem"> | Decimal | DecimalJsLike | number | string
  }

  export type StockMovementUpsertWithWhereUniqueWithoutProductInput = {
    where: StockMovementWhereUniqueInput
    update: XOR<StockMovementUpdateWithoutProductInput, StockMovementUncheckedUpdateWithoutProductInput>
    create: XOR<StockMovementCreateWithoutProductInput, StockMovementUncheckedCreateWithoutProductInput>
  }

  export type StockMovementUpdateWithWhereUniqueWithoutProductInput = {
    where: StockMovementWhereUniqueInput
    data: XOR<StockMovementUpdateWithoutProductInput, StockMovementUncheckedUpdateWithoutProductInput>
  }

  export type StockMovementUpdateManyWithWhereWithoutProductInput = {
    where: StockMovementScalarWhereInput
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyWithoutProductInput>
  }

  export type StorePriceHistoryUpsertWithWhereUniqueWithoutProductInput = {
    where: StorePriceHistoryWhereUniqueInput
    update: XOR<StorePriceHistoryUpdateWithoutProductInput, StorePriceHistoryUncheckedUpdateWithoutProductInput>
    create: XOR<StorePriceHistoryCreateWithoutProductInput, StorePriceHistoryUncheckedCreateWithoutProductInput>
  }

  export type StorePriceHistoryUpdateWithWhereUniqueWithoutProductInput = {
    where: StorePriceHistoryWhereUniqueInput
    data: XOR<StorePriceHistoryUpdateWithoutProductInput, StorePriceHistoryUncheckedUpdateWithoutProductInput>
  }

  export type StorePriceHistoryUpdateManyWithWhereWithoutProductInput = {
    where: StorePriceHistoryScalarWhereInput
    data: XOR<StorePriceHistoryUpdateManyMutationInput, StorePriceHistoryUncheckedUpdateManyWithoutProductInput>
  }

  export type StorePriceHistoryScalarWhereInput = {
    AND?: StorePriceHistoryScalarWhereInput | StorePriceHistoryScalarWhereInput[]
    OR?: StorePriceHistoryScalarWhereInput[]
    NOT?: StorePriceHistoryScalarWhereInput | StorePriceHistoryScalarWhereInput[]
    id?: StringFilter<"StorePriceHistory"> | string
    productId?: StringFilter<"StorePriceHistory"> | string
    costPrice?: DecimalFilter<"StorePriceHistory"> | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFilter<"StorePriceHistory"> | Decimal | DecimalJsLike | number | string
    changedBy?: StringNullableFilter<"StorePriceHistory"> | string | null
    changedAt?: DateTimeFilter<"StorePriceHistory"> | Date | string
  }

  export type TransferOrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: TransferOrderItemWhereUniqueInput
    update: XOR<TransferOrderItemUpdateWithoutProductInput, TransferOrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<TransferOrderItemCreateWithoutProductInput, TransferOrderItemUncheckedCreateWithoutProductInput>
  }

  export type TransferOrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: TransferOrderItemWhereUniqueInput
    data: XOR<TransferOrderItemUpdateWithoutProductInput, TransferOrderItemUncheckedUpdateWithoutProductInput>
  }

  export type TransferOrderItemUpdateManyWithWhereWithoutProductInput = {
    where: TransferOrderItemScalarWhereInput
    data: XOR<TransferOrderItemUpdateManyMutationInput, TransferOrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type TransferOrderItemScalarWhereInput = {
    AND?: TransferOrderItemScalarWhereInput | TransferOrderItemScalarWhereInput[]
    OR?: TransferOrderItemScalarWhereInput[]
    NOT?: TransferOrderItemScalarWhereInput | TransferOrderItemScalarWhereInput[]
    id?: StringFilter<"TransferOrderItem"> | string
    transferOrderId?: StringFilter<"TransferOrderItem"> | string
    productId?: StringFilter<"TransferOrderItem"> | string
    quantity?: DecimalFilter<"TransferOrderItem"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalNullableFilter<"TransferOrderItem"> | Decimal | DecimalJsLike | number | string | null
  }

  export type StoreProductCreateWithoutPriceHistoryInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutProductsInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    taxRule?: StoreTaxRuleCreateNestedOneWithoutProductsInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    saleReturnItems?: SaleReturnItemCreateNestedManyWithoutProductInput
    purchaseItems?: StorePurchaseItemCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    transferOrderItems?: TransferOrderItemCreateNestedManyWithoutProductInput
  }

  export type StoreProductUncheckedCreateWithoutPriceHistoryInput = {
    id?: string
    storeId: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    taxRuleId?: string | null
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    saleReturnItems?: SaleReturnItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: StorePurchaseItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    transferOrderItems?: TransferOrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type StoreProductCreateOrConnectWithoutPriceHistoryInput = {
    where: StoreProductWhereUniqueInput
    create: XOR<StoreProductCreateWithoutPriceHistoryInput, StoreProductUncheckedCreateWithoutPriceHistoryInput>
  }

  export type StoreProductUpsertWithoutPriceHistoryInput = {
    update: XOR<StoreProductUpdateWithoutPriceHistoryInput, StoreProductUncheckedUpdateWithoutPriceHistoryInput>
    create: XOR<StoreProductCreateWithoutPriceHistoryInput, StoreProductUncheckedCreateWithoutPriceHistoryInput>
    where?: StoreProductWhereInput
  }

  export type StoreProductUpdateToOneWithWhereWithoutPriceHistoryInput = {
    where?: StoreProductWhereInput
    data: XOR<StoreProductUpdateWithoutPriceHistoryInput, StoreProductUncheckedUpdateWithoutPriceHistoryInput>
  }

  export type StoreProductUpdateWithoutPriceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    taxRule?: StoreTaxRuleUpdateOneWithoutProductsNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    saleReturnItems?: SaleReturnItemUpdateManyWithoutProductNestedInput
    purchaseItems?: StorePurchaseItemUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    transferOrderItems?: TransferOrderItemUpdateManyWithoutProductNestedInput
  }

  export type StoreProductUncheckedUpdateWithoutPriceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    taxRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    saleReturnItems?: SaleReturnItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: StorePurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    transferOrderItems?: TransferOrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StoreCreateWithoutSalesInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeCreateNestedManyWithoutStoreInput
    products?: StoreProductCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutSalesInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeUncheckedCreateNestedManyWithoutStoreInput
    products?: StoreProductUncheckedCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderUncheckedCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierUncheckedCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerUncheckedCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleUncheckedCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderUncheckedCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderUncheckedCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigUncheckedCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigUncheckedCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigUncheckedCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutSalesInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutSalesInput, StoreUncheckedCreateWithoutSalesInput>
  }

  export type StoreCustomerCreateWithoutSalesInput = {
    id?: string
    firstName: string
    lastName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    taxId?: string | null
    notes?: string | null
    totalPurchases?: Decimal | DecimalJsLike | number | string
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    totalLifetimePurchases?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutCustomersInput
    loyaltyTransactions?: StoreLoyaltyTransactionCreateNestedManyWithoutCustomerInput
  }

  export type StoreCustomerUncheckedCreateWithoutSalesInput = {
    id?: string
    storeId: string
    firstName: string
    lastName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    taxId?: string | null
    notes?: string | null
    totalPurchases?: Decimal | DecimalJsLike | number | string
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    totalLifetimePurchases?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    loyaltyTransactions?: StoreLoyaltyTransactionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type StoreCustomerCreateOrConnectWithoutSalesInput = {
    where: StoreCustomerWhereUniqueInput
    create: XOR<StoreCustomerCreateWithoutSalesInput, StoreCustomerUncheckedCreateWithoutSalesInput>
  }

  export type StoreEmployeeCreateWithoutSalesInput = {
    id?: string
    userId?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    role?: string
    pin?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutEmployeesInput
  }

  export type StoreEmployeeUncheckedCreateWithoutSalesInput = {
    id?: string
    storeId: string
    userId?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    role?: string
    pin?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreEmployeeCreateOrConnectWithoutSalesInput = {
    where: StoreEmployeeWhereUniqueInput
    create: XOR<StoreEmployeeCreateWithoutSalesInput, StoreEmployeeUncheckedCreateWithoutSalesInput>
  }

  export type SaleItemCreateWithoutSaleInput = {
    id?: string
    productName: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    product: StoreProductCreateNestedOneWithoutSaleItemsInput
  }

  export type SaleItemUncheckedCreateWithoutSaleInput = {
    id?: string
    productId: string
    productName: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type SaleItemCreateOrConnectWithoutSaleInput = {
    where: SaleItemWhereUniqueInput
    create: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput>
  }

  export type SaleItemCreateManySaleInputEnvelope = {
    data: SaleItemCreateManySaleInput | SaleItemCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type SalePaymentCreateWithoutSaleInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdAt?: Date | string
  }

  export type SalePaymentUncheckedCreateWithoutSaleInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdAt?: Date | string
  }

  export type SalePaymentCreateOrConnectWithoutSaleInput = {
    where: SalePaymentWhereUniqueInput
    create: XOR<SalePaymentCreateWithoutSaleInput, SalePaymentUncheckedCreateWithoutSaleInput>
  }

  export type SalePaymentCreateManySaleInputEnvelope = {
    data: SalePaymentCreateManySaleInput | SalePaymentCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type SaleReturnCreateWithoutSaleInput = {
    id?: string
    reason: string
    refundAmount: Decimal | DecimalJsLike | number | string
    refundMethod: $Enums.PaymentMethod
    status?: $Enums.StoreReturnStatus
    createdAt?: Date | string
    processedAt?: Date | string | null
    items?: SaleReturnItemCreateNestedManyWithoutSaleReturnInput
  }

  export type SaleReturnUncheckedCreateWithoutSaleInput = {
    id?: string
    reason: string
    refundAmount: Decimal | DecimalJsLike | number | string
    refundMethod: $Enums.PaymentMethod
    status?: $Enums.StoreReturnStatus
    createdAt?: Date | string
    processedAt?: Date | string | null
    items?: SaleReturnItemUncheckedCreateNestedManyWithoutSaleReturnInput
  }

  export type SaleReturnCreateOrConnectWithoutSaleInput = {
    where: SaleReturnWhereUniqueInput
    create: XOR<SaleReturnCreateWithoutSaleInput, SaleReturnUncheckedCreateWithoutSaleInput>
  }

  export type SaleReturnCreateManySaleInputEnvelope = {
    data: SaleReturnCreateManySaleInput | SaleReturnCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type StoreUpsertWithoutSalesInput = {
    update: XOR<StoreUpdateWithoutSalesInput, StoreUncheckedUpdateWithoutSalesInput>
    create: XOR<StoreCreateWithoutSalesInput, StoreUncheckedCreateWithoutSalesInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutSalesInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutSalesInput, StoreUncheckedUpdateWithoutSalesInput>
  }

  export type StoreUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUpdateManyWithoutStoreNestedInput
    products?: StoreProductUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUncheckedUpdateManyWithoutStoreNestedInput
    products?: StoreProductUncheckedUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUncheckedUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUncheckedUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUncheckedUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUncheckedUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUncheckedUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUncheckedUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUncheckedUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUncheckedUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUncheckedUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreCustomerUpsertWithoutSalesInput = {
    update: XOR<StoreCustomerUpdateWithoutSalesInput, StoreCustomerUncheckedUpdateWithoutSalesInput>
    create: XOR<StoreCustomerCreateWithoutSalesInput, StoreCustomerUncheckedCreateWithoutSalesInput>
    where?: StoreCustomerWhereInput
  }

  export type StoreCustomerUpdateToOneWithWhereWithoutSalesInput = {
    where?: StoreCustomerWhereInput
    data: XOR<StoreCustomerUpdateWithoutSalesInput, StoreCustomerUncheckedUpdateWithoutSalesInput>
  }

  export type StoreCustomerUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    totalLifetimePurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutCustomersNestedInput
    loyaltyTransactions?: StoreLoyaltyTransactionUpdateManyWithoutCustomerNestedInput
  }

  export type StoreCustomerUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    totalLifetimePurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loyaltyTransactions?: StoreLoyaltyTransactionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type StoreEmployeeUpsertWithoutSalesInput = {
    update: XOR<StoreEmployeeUpdateWithoutSalesInput, StoreEmployeeUncheckedUpdateWithoutSalesInput>
    create: XOR<StoreEmployeeCreateWithoutSalesInput, StoreEmployeeUncheckedCreateWithoutSalesInput>
    where?: StoreEmployeeWhereInput
  }

  export type StoreEmployeeUpdateToOneWithWhereWithoutSalesInput = {
    where?: StoreEmployeeWhereInput
    data: XOR<StoreEmployeeUpdateWithoutSalesInput, StoreEmployeeUncheckedUpdateWithoutSalesInput>
  }

  export type StoreEmployeeUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type StoreEmployeeUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemUpsertWithWhereUniqueWithoutSaleInput = {
    where: SaleItemWhereUniqueInput
    update: XOR<SaleItemUpdateWithoutSaleInput, SaleItemUncheckedUpdateWithoutSaleInput>
    create: XOR<SaleItemCreateWithoutSaleInput, SaleItemUncheckedCreateWithoutSaleInput>
  }

  export type SaleItemUpdateWithWhereUniqueWithoutSaleInput = {
    where: SaleItemWhereUniqueInput
    data: XOR<SaleItemUpdateWithoutSaleInput, SaleItemUncheckedUpdateWithoutSaleInput>
  }

  export type SaleItemUpdateManyWithWhereWithoutSaleInput = {
    where: SaleItemScalarWhereInput
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyWithoutSaleInput>
  }

  export type SalePaymentUpsertWithWhereUniqueWithoutSaleInput = {
    where: SalePaymentWhereUniqueInput
    update: XOR<SalePaymentUpdateWithoutSaleInput, SalePaymentUncheckedUpdateWithoutSaleInput>
    create: XOR<SalePaymentCreateWithoutSaleInput, SalePaymentUncheckedCreateWithoutSaleInput>
  }

  export type SalePaymentUpdateWithWhereUniqueWithoutSaleInput = {
    where: SalePaymentWhereUniqueInput
    data: XOR<SalePaymentUpdateWithoutSaleInput, SalePaymentUncheckedUpdateWithoutSaleInput>
  }

  export type SalePaymentUpdateManyWithWhereWithoutSaleInput = {
    where: SalePaymentScalarWhereInput
    data: XOR<SalePaymentUpdateManyMutationInput, SalePaymentUncheckedUpdateManyWithoutSaleInput>
  }

  export type SalePaymentScalarWhereInput = {
    AND?: SalePaymentScalarWhereInput | SalePaymentScalarWhereInput[]
    OR?: SalePaymentScalarWhereInput[]
    NOT?: SalePaymentScalarWhereInput | SalePaymentScalarWhereInput[]
    id?: StringFilter<"SalePayment"> | string
    saleId?: StringFilter<"SalePayment"> | string
    method?: EnumPaymentMethodFilter<"SalePayment"> | $Enums.PaymentMethod
    amount?: DecimalFilter<"SalePayment"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"SalePayment"> | string | null
    createdAt?: DateTimeFilter<"SalePayment"> | Date | string
  }

  export type SaleReturnUpsertWithWhereUniqueWithoutSaleInput = {
    where: SaleReturnWhereUniqueInput
    update: XOR<SaleReturnUpdateWithoutSaleInput, SaleReturnUncheckedUpdateWithoutSaleInput>
    create: XOR<SaleReturnCreateWithoutSaleInput, SaleReturnUncheckedCreateWithoutSaleInput>
  }

  export type SaleReturnUpdateWithWhereUniqueWithoutSaleInput = {
    where: SaleReturnWhereUniqueInput
    data: XOR<SaleReturnUpdateWithoutSaleInput, SaleReturnUncheckedUpdateWithoutSaleInput>
  }

  export type SaleReturnUpdateManyWithWhereWithoutSaleInput = {
    where: SaleReturnScalarWhereInput
    data: XOR<SaleReturnUpdateManyMutationInput, SaleReturnUncheckedUpdateManyWithoutSaleInput>
  }

  export type SaleReturnScalarWhereInput = {
    AND?: SaleReturnScalarWhereInput | SaleReturnScalarWhereInput[]
    OR?: SaleReturnScalarWhereInput[]
    NOT?: SaleReturnScalarWhereInput | SaleReturnScalarWhereInput[]
    id?: StringFilter<"SaleReturn"> | string
    saleId?: StringFilter<"SaleReturn"> | string
    reason?: StringFilter<"SaleReturn"> | string
    refundAmount?: DecimalFilter<"SaleReturn"> | Decimal | DecimalJsLike | number | string
    refundMethod?: EnumPaymentMethodFilter<"SaleReturn"> | $Enums.PaymentMethod
    status?: EnumStoreReturnStatusFilter<"SaleReturn"> | $Enums.StoreReturnStatus
    createdAt?: DateTimeFilter<"SaleReturn"> | Date | string
    processedAt?: DateTimeNullableFilter<"SaleReturn"> | Date | string | null
  }

  export type SaleCreateWithoutItemsInput = {
    id?: string
    saleNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.StoreDiscountType | null
    total: Decimal | DecimalJsLike | number | string
    paidAmount: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.StoreSaleStatus
    notes?: string | null
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSalesInput
    customer?: StoreCustomerCreateNestedOneWithoutSalesInput
    employee?: StoreEmployeeCreateNestedOneWithoutSalesInput
    payments?: SalePaymentCreateNestedManyWithoutSaleInput
    returns?: SaleReturnCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutItemsInput = {
    id?: string
    storeId: string
    saleNumber: string
    customerId?: string | null
    employeeId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.StoreDiscountType | null
    total: Decimal | DecimalJsLike | number | string
    paidAmount: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.StoreSaleStatus
    notes?: string | null
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: SalePaymentUncheckedCreateNestedManyWithoutSaleInput
    returns?: SaleReturnUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutItemsInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutItemsInput, SaleUncheckedCreateWithoutItemsInput>
  }

  export type StoreProductCreateWithoutSaleItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutProductsInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    taxRule?: StoreTaxRuleCreateNestedOneWithoutProductsInput
    saleReturnItems?: SaleReturnItemCreateNestedManyWithoutProductInput
    purchaseItems?: StorePurchaseItemCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    priceHistory?: StorePriceHistoryCreateNestedManyWithoutProductInput
    transferOrderItems?: TransferOrderItemCreateNestedManyWithoutProductInput
  }

  export type StoreProductUncheckedCreateWithoutSaleItemsInput = {
    id?: string
    storeId: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    taxRuleId?: string | null
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    saleReturnItems?: SaleReturnItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: StorePurchaseItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: StorePriceHistoryUncheckedCreateNestedManyWithoutProductInput
    transferOrderItems?: TransferOrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type StoreProductCreateOrConnectWithoutSaleItemsInput = {
    where: StoreProductWhereUniqueInput
    create: XOR<StoreProductCreateWithoutSaleItemsInput, StoreProductUncheckedCreateWithoutSaleItemsInput>
  }

  export type SaleUpsertWithoutItemsInput = {
    update: XOR<SaleUpdateWithoutItemsInput, SaleUncheckedUpdateWithoutItemsInput>
    create: XOR<SaleCreateWithoutItemsInput, SaleUncheckedCreateWithoutItemsInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutItemsInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutItemsInput, SaleUncheckedUpdateWithoutItemsInput>
  }

  export type SaleUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumStoreDiscountTypeFieldUpdateOperationsInput | $Enums.StoreDiscountType | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFieldUpdateOperationsInput | $Enums.StoreSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSalesNestedInput
    customer?: StoreCustomerUpdateOneWithoutSalesNestedInput
    employee?: StoreEmployeeUpdateOneWithoutSalesNestedInput
    payments?: SalePaymentUpdateManyWithoutSaleNestedInput
    returns?: SaleReturnUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumStoreDiscountTypeFieldUpdateOperationsInput | $Enums.StoreDiscountType | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFieldUpdateOperationsInput | $Enums.StoreSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: SalePaymentUncheckedUpdateManyWithoutSaleNestedInput
    returns?: SaleReturnUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type StoreProductUpsertWithoutSaleItemsInput = {
    update: XOR<StoreProductUpdateWithoutSaleItemsInput, StoreProductUncheckedUpdateWithoutSaleItemsInput>
    create: XOR<StoreProductCreateWithoutSaleItemsInput, StoreProductUncheckedCreateWithoutSaleItemsInput>
    where?: StoreProductWhereInput
  }

  export type StoreProductUpdateToOneWithWhereWithoutSaleItemsInput = {
    where?: StoreProductWhereInput
    data: XOR<StoreProductUpdateWithoutSaleItemsInput, StoreProductUncheckedUpdateWithoutSaleItemsInput>
  }

  export type StoreProductUpdateWithoutSaleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    taxRule?: StoreTaxRuleUpdateOneWithoutProductsNestedInput
    saleReturnItems?: SaleReturnItemUpdateManyWithoutProductNestedInput
    purchaseItems?: StorePurchaseItemUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    priceHistory?: StorePriceHistoryUpdateManyWithoutProductNestedInput
    transferOrderItems?: TransferOrderItemUpdateManyWithoutProductNestedInput
  }

  export type StoreProductUncheckedUpdateWithoutSaleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    taxRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleReturnItems?: SaleReturnItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: StorePurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: StorePriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    transferOrderItems?: TransferOrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SaleCreateWithoutPaymentsInput = {
    id?: string
    saleNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.StoreDiscountType | null
    total: Decimal | DecimalJsLike | number | string
    paidAmount: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.StoreSaleStatus
    notes?: string | null
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSalesInput
    customer?: StoreCustomerCreateNestedOneWithoutSalesInput
    employee?: StoreEmployeeCreateNestedOneWithoutSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
    returns?: SaleReturnCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutPaymentsInput = {
    id?: string
    storeId: string
    saleNumber: string
    customerId?: string | null
    employeeId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.StoreDiscountType | null
    total: Decimal | DecimalJsLike | number | string
    paidAmount: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.StoreSaleStatus
    notes?: string | null
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
    returns?: SaleReturnUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutPaymentsInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutPaymentsInput, SaleUncheckedCreateWithoutPaymentsInput>
  }

  export type SaleUpsertWithoutPaymentsInput = {
    update: XOR<SaleUpdateWithoutPaymentsInput, SaleUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SaleCreateWithoutPaymentsInput, SaleUncheckedCreateWithoutPaymentsInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutPaymentsInput, SaleUncheckedUpdateWithoutPaymentsInput>
  }

  export type SaleUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumStoreDiscountTypeFieldUpdateOperationsInput | $Enums.StoreDiscountType | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFieldUpdateOperationsInput | $Enums.StoreSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSalesNestedInput
    customer?: StoreCustomerUpdateOneWithoutSalesNestedInput
    employee?: StoreEmployeeUpdateOneWithoutSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
    returns?: SaleReturnUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumStoreDiscountTypeFieldUpdateOperationsInput | $Enums.StoreDiscountType | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFieldUpdateOperationsInput | $Enums.StoreSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
    returns?: SaleReturnUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleCreateWithoutReturnsInput = {
    id?: string
    saleNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.StoreDiscountType | null
    total: Decimal | DecimalJsLike | number | string
    paidAmount: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.StoreSaleStatus
    notes?: string | null
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSalesInput
    customer?: StoreCustomerCreateNestedOneWithoutSalesInput
    employee?: StoreEmployeeCreateNestedOneWithoutSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
    payments?: SalePaymentCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutReturnsInput = {
    id?: string
    storeId: string
    saleNumber: string
    customerId?: string | null
    employeeId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.StoreDiscountType | null
    total: Decimal | DecimalJsLike | number | string
    paidAmount: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.StoreSaleStatus
    notes?: string | null
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
    payments?: SalePaymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutReturnsInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutReturnsInput, SaleUncheckedCreateWithoutReturnsInput>
  }

  export type SaleReturnItemCreateWithoutSaleReturnInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    refundAmount: Decimal | DecimalJsLike | number | string
    product: StoreProductCreateNestedOneWithoutSaleReturnItemsInput
  }

  export type SaleReturnItemUncheckedCreateWithoutSaleReturnInput = {
    id?: string
    productId: string
    quantity: Decimal | DecimalJsLike | number | string
    refundAmount: Decimal | DecimalJsLike | number | string
  }

  export type SaleReturnItemCreateOrConnectWithoutSaleReturnInput = {
    where: SaleReturnItemWhereUniqueInput
    create: XOR<SaleReturnItemCreateWithoutSaleReturnInput, SaleReturnItemUncheckedCreateWithoutSaleReturnInput>
  }

  export type SaleReturnItemCreateManySaleReturnInputEnvelope = {
    data: SaleReturnItemCreateManySaleReturnInput | SaleReturnItemCreateManySaleReturnInput[]
    skipDuplicates?: boolean
  }

  export type SaleUpsertWithoutReturnsInput = {
    update: XOR<SaleUpdateWithoutReturnsInput, SaleUncheckedUpdateWithoutReturnsInput>
    create: XOR<SaleCreateWithoutReturnsInput, SaleUncheckedCreateWithoutReturnsInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutReturnsInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutReturnsInput, SaleUncheckedUpdateWithoutReturnsInput>
  }

  export type SaleUpdateWithoutReturnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumStoreDiscountTypeFieldUpdateOperationsInput | $Enums.StoreDiscountType | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFieldUpdateOperationsInput | $Enums.StoreSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSalesNestedInput
    customer?: StoreCustomerUpdateOneWithoutSalesNestedInput
    employee?: StoreEmployeeUpdateOneWithoutSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutReturnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumStoreDiscountTypeFieldUpdateOperationsInput | $Enums.StoreDiscountType | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFieldUpdateOperationsInput | $Enums.StoreSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleReturnItemUpsertWithWhereUniqueWithoutSaleReturnInput = {
    where: SaleReturnItemWhereUniqueInput
    update: XOR<SaleReturnItemUpdateWithoutSaleReturnInput, SaleReturnItemUncheckedUpdateWithoutSaleReturnInput>
    create: XOR<SaleReturnItemCreateWithoutSaleReturnInput, SaleReturnItemUncheckedCreateWithoutSaleReturnInput>
  }

  export type SaleReturnItemUpdateWithWhereUniqueWithoutSaleReturnInput = {
    where: SaleReturnItemWhereUniqueInput
    data: XOR<SaleReturnItemUpdateWithoutSaleReturnInput, SaleReturnItemUncheckedUpdateWithoutSaleReturnInput>
  }

  export type SaleReturnItemUpdateManyWithWhereWithoutSaleReturnInput = {
    where: SaleReturnItemScalarWhereInput
    data: XOR<SaleReturnItemUpdateManyMutationInput, SaleReturnItemUncheckedUpdateManyWithoutSaleReturnInput>
  }

  export type SaleReturnCreateWithoutItemsInput = {
    id?: string
    reason: string
    refundAmount: Decimal | DecimalJsLike | number | string
    refundMethod: $Enums.PaymentMethod
    status?: $Enums.StoreReturnStatus
    createdAt?: Date | string
    processedAt?: Date | string | null
    sale: SaleCreateNestedOneWithoutReturnsInput
  }

  export type SaleReturnUncheckedCreateWithoutItemsInput = {
    id?: string
    saleId: string
    reason: string
    refundAmount: Decimal | DecimalJsLike | number | string
    refundMethod: $Enums.PaymentMethod
    status?: $Enums.StoreReturnStatus
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type SaleReturnCreateOrConnectWithoutItemsInput = {
    where: SaleReturnWhereUniqueInput
    create: XOR<SaleReturnCreateWithoutItemsInput, SaleReturnUncheckedCreateWithoutItemsInput>
  }

  export type StoreProductCreateWithoutSaleReturnItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutProductsInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    taxRule?: StoreTaxRuleCreateNestedOneWithoutProductsInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    purchaseItems?: StorePurchaseItemCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    priceHistory?: StorePriceHistoryCreateNestedManyWithoutProductInput
    transferOrderItems?: TransferOrderItemCreateNestedManyWithoutProductInput
  }

  export type StoreProductUncheckedCreateWithoutSaleReturnItemsInput = {
    id?: string
    storeId: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    taxRuleId?: string | null
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: StorePurchaseItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: StorePriceHistoryUncheckedCreateNestedManyWithoutProductInput
    transferOrderItems?: TransferOrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type StoreProductCreateOrConnectWithoutSaleReturnItemsInput = {
    where: StoreProductWhereUniqueInput
    create: XOR<StoreProductCreateWithoutSaleReturnItemsInput, StoreProductUncheckedCreateWithoutSaleReturnItemsInput>
  }

  export type SaleReturnUpsertWithoutItemsInput = {
    update: XOR<SaleReturnUpdateWithoutItemsInput, SaleReturnUncheckedUpdateWithoutItemsInput>
    create: XOR<SaleReturnCreateWithoutItemsInput, SaleReturnUncheckedCreateWithoutItemsInput>
    where?: SaleReturnWhereInput
  }

  export type SaleReturnUpdateToOneWithWhereWithoutItemsInput = {
    where?: SaleReturnWhereInput
    data: XOR<SaleReturnUpdateWithoutItemsInput, SaleReturnUncheckedUpdateWithoutItemsInput>
  }

  export type SaleReturnUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumStoreReturnStatusFieldUpdateOperationsInput | $Enums.StoreReturnStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale?: SaleUpdateOneRequiredWithoutReturnsNestedInput
  }

  export type SaleReturnUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumStoreReturnStatusFieldUpdateOperationsInput | $Enums.StoreReturnStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StoreProductUpsertWithoutSaleReturnItemsInput = {
    update: XOR<StoreProductUpdateWithoutSaleReturnItemsInput, StoreProductUncheckedUpdateWithoutSaleReturnItemsInput>
    create: XOR<StoreProductCreateWithoutSaleReturnItemsInput, StoreProductUncheckedCreateWithoutSaleReturnItemsInput>
    where?: StoreProductWhereInput
  }

  export type StoreProductUpdateToOneWithWhereWithoutSaleReturnItemsInput = {
    where?: StoreProductWhereInput
    data: XOR<StoreProductUpdateWithoutSaleReturnItemsInput, StoreProductUncheckedUpdateWithoutSaleReturnItemsInput>
  }

  export type StoreProductUpdateWithoutSaleReturnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    taxRule?: StoreTaxRuleUpdateOneWithoutProductsNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    purchaseItems?: StorePurchaseItemUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    priceHistory?: StorePriceHistoryUpdateManyWithoutProductNestedInput
    transferOrderItems?: TransferOrderItemUpdateManyWithoutProductNestedInput
  }

  export type StoreProductUncheckedUpdateWithoutSaleReturnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    taxRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: StorePurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: StorePriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    transferOrderItems?: TransferOrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StoreCreateWithoutSuppliersInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeCreateNestedManyWithoutStoreInput
    products?: StoreProductCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutSuppliersInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeUncheckedCreateNestedManyWithoutStoreInput
    products?: StoreProductUncheckedCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderUncheckedCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerUncheckedCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleUncheckedCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderUncheckedCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderUncheckedCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigUncheckedCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigUncheckedCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigUncheckedCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutSuppliersInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutSuppliersInput, StoreUncheckedCreateWithoutSuppliersInput>
  }

  export type StorePurchaseOrderCreateWithoutSupplierInput = {
    id?: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.StorePurchaseStatus
    notes?: string | null
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutPurchasesInput
    items?: StorePurchaseItemCreateNestedManyWithoutPurchaseOrderInput
  }

  export type StorePurchaseOrderUncheckedCreateWithoutSupplierInput = {
    id?: string
    storeId: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.StorePurchaseStatus
    notes?: string | null
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: StorePurchaseItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type StorePurchaseOrderCreateOrConnectWithoutSupplierInput = {
    where: StorePurchaseOrderWhereUniqueInput
    create: XOR<StorePurchaseOrderCreateWithoutSupplierInput, StorePurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type StorePurchaseOrderCreateManySupplierInputEnvelope = {
    data: StorePurchaseOrderCreateManySupplierInput | StorePurchaseOrderCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type StoreUpsertWithoutSuppliersInput = {
    update: XOR<StoreUpdateWithoutSuppliersInput, StoreUncheckedUpdateWithoutSuppliersInput>
    create: XOR<StoreCreateWithoutSuppliersInput, StoreUncheckedCreateWithoutSuppliersInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutSuppliersInput, StoreUncheckedUpdateWithoutSuppliersInput>
  }

  export type StoreUpdateWithoutSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUpdateManyWithoutStoreNestedInput
    products?: StoreProductUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUncheckedUpdateManyWithoutStoreNestedInput
    products?: StoreProductUncheckedUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUncheckedUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUncheckedUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUncheckedUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUncheckedUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUncheckedUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUncheckedUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUncheckedUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUncheckedUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StorePurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput = {
    where: StorePurchaseOrderWhereUniqueInput
    update: XOR<StorePurchaseOrderUpdateWithoutSupplierInput, StorePurchaseOrderUncheckedUpdateWithoutSupplierInput>
    create: XOR<StorePurchaseOrderCreateWithoutSupplierInput, StorePurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type StorePurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput = {
    where: StorePurchaseOrderWhereUniqueInput
    data: XOR<StorePurchaseOrderUpdateWithoutSupplierInput, StorePurchaseOrderUncheckedUpdateWithoutSupplierInput>
  }

  export type StorePurchaseOrderUpdateManyWithWhereWithoutSupplierInput = {
    where: StorePurchaseOrderScalarWhereInput
    data: XOR<StorePurchaseOrderUpdateManyMutationInput, StorePurchaseOrderUncheckedUpdateManyWithoutSupplierInput>
  }

  export type StoreCreateWithoutPurchasesInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeCreateNestedManyWithoutStoreInput
    products?: StoreProductCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutPurchasesInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeUncheckedCreateNestedManyWithoutStoreInput
    products?: StoreProductUncheckedCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierUncheckedCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerUncheckedCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleUncheckedCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderUncheckedCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderUncheckedCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigUncheckedCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigUncheckedCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigUncheckedCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutPurchasesInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutPurchasesInput, StoreUncheckedCreateWithoutPurchasesInput>
  }

  export type StoreSupplierCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSuppliersInput
  }

  export type StoreSupplierUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: string
    storeId: string
    name: string
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreSupplierCreateOrConnectWithoutPurchaseOrdersInput = {
    where: StoreSupplierWhereUniqueInput
    create: XOR<StoreSupplierCreateWithoutPurchaseOrdersInput, StoreSupplierUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type StorePurchaseItemCreateWithoutPurchaseOrderInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedQty?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    product: StoreProductCreateNestedOneWithoutPurchaseItemsInput
  }

  export type StorePurchaseItemUncheckedCreateWithoutPurchaseOrderInput = {
    id?: string
    productId: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedQty?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type StorePurchaseItemCreateOrConnectWithoutPurchaseOrderInput = {
    where: StorePurchaseItemWhereUniqueInput
    create: XOR<StorePurchaseItemCreateWithoutPurchaseOrderInput, StorePurchaseItemUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type StorePurchaseItemCreateManyPurchaseOrderInputEnvelope = {
    data: StorePurchaseItemCreateManyPurchaseOrderInput | StorePurchaseItemCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type StoreUpsertWithoutPurchasesInput = {
    update: XOR<StoreUpdateWithoutPurchasesInput, StoreUncheckedUpdateWithoutPurchasesInput>
    create: XOR<StoreCreateWithoutPurchasesInput, StoreUncheckedCreateWithoutPurchasesInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutPurchasesInput, StoreUncheckedUpdateWithoutPurchasesInput>
  }

  export type StoreUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUpdateManyWithoutStoreNestedInput
    products?: StoreProductUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUncheckedUpdateManyWithoutStoreNestedInput
    products?: StoreProductUncheckedUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUncheckedUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUncheckedUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUncheckedUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUncheckedUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUncheckedUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUncheckedUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUncheckedUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUncheckedUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreSupplierUpsertWithoutPurchaseOrdersInput = {
    update: XOR<StoreSupplierUpdateWithoutPurchaseOrdersInput, StoreSupplierUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<StoreSupplierCreateWithoutPurchaseOrdersInput, StoreSupplierUncheckedCreateWithoutPurchaseOrdersInput>
    where?: StoreSupplierWhereInput
  }

  export type StoreSupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: StoreSupplierWhereInput
    data: XOR<StoreSupplierUpdateWithoutPurchaseOrdersInput, StoreSupplierUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type StoreSupplierUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSuppliersNestedInput
  }

  export type StoreSupplierUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorePurchaseItemUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: StorePurchaseItemWhereUniqueInput
    update: XOR<StorePurchaseItemUpdateWithoutPurchaseOrderInput, StorePurchaseItemUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<StorePurchaseItemCreateWithoutPurchaseOrderInput, StorePurchaseItemUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type StorePurchaseItemUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: StorePurchaseItemWhereUniqueInput
    data: XOR<StorePurchaseItemUpdateWithoutPurchaseOrderInput, StorePurchaseItemUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type StorePurchaseItemUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: StorePurchaseItemScalarWhereInput
    data: XOR<StorePurchaseItemUpdateManyMutationInput, StorePurchaseItemUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type StorePurchaseOrderCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.StorePurchaseStatus
    notes?: string | null
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutPurchasesInput
    supplier: StoreSupplierCreateNestedOneWithoutPurchaseOrdersInput
  }

  export type StorePurchaseOrderUncheckedCreateWithoutItemsInput = {
    id?: string
    storeId: string
    supplierId: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.StorePurchaseStatus
    notes?: string | null
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorePurchaseOrderCreateOrConnectWithoutItemsInput = {
    where: StorePurchaseOrderWhereUniqueInput
    create: XOR<StorePurchaseOrderCreateWithoutItemsInput, StorePurchaseOrderUncheckedCreateWithoutItemsInput>
  }

  export type StoreProductCreateWithoutPurchaseItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutProductsInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    taxRule?: StoreTaxRuleCreateNestedOneWithoutProductsInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    saleReturnItems?: SaleReturnItemCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    priceHistory?: StorePriceHistoryCreateNestedManyWithoutProductInput
    transferOrderItems?: TransferOrderItemCreateNestedManyWithoutProductInput
  }

  export type StoreProductUncheckedCreateWithoutPurchaseItemsInput = {
    id?: string
    storeId: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    taxRuleId?: string | null
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    saleReturnItems?: SaleReturnItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: StorePriceHistoryUncheckedCreateNestedManyWithoutProductInput
    transferOrderItems?: TransferOrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type StoreProductCreateOrConnectWithoutPurchaseItemsInput = {
    where: StoreProductWhereUniqueInput
    create: XOR<StoreProductCreateWithoutPurchaseItemsInput, StoreProductUncheckedCreateWithoutPurchaseItemsInput>
  }

  export type StorePurchaseOrderUpsertWithoutItemsInput = {
    update: XOR<StorePurchaseOrderUpdateWithoutItemsInput, StorePurchaseOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<StorePurchaseOrderCreateWithoutItemsInput, StorePurchaseOrderUncheckedCreateWithoutItemsInput>
    where?: StorePurchaseOrderWhereInput
  }

  export type StorePurchaseOrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: StorePurchaseOrderWhereInput
    data: XOR<StorePurchaseOrderUpdateWithoutItemsInput, StorePurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type StorePurchaseOrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStorePurchaseStatusFieldUpdateOperationsInput | $Enums.StorePurchaseStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutPurchasesNestedInput
    supplier?: StoreSupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
  }

  export type StorePurchaseOrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStorePurchaseStatusFieldUpdateOperationsInput | $Enums.StorePurchaseStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreProductUpsertWithoutPurchaseItemsInput = {
    update: XOR<StoreProductUpdateWithoutPurchaseItemsInput, StoreProductUncheckedUpdateWithoutPurchaseItemsInput>
    create: XOR<StoreProductCreateWithoutPurchaseItemsInput, StoreProductUncheckedCreateWithoutPurchaseItemsInput>
    where?: StoreProductWhereInput
  }

  export type StoreProductUpdateToOneWithWhereWithoutPurchaseItemsInput = {
    where?: StoreProductWhereInput
    data: XOR<StoreProductUpdateWithoutPurchaseItemsInput, StoreProductUncheckedUpdateWithoutPurchaseItemsInput>
  }

  export type StoreProductUpdateWithoutPurchaseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    taxRule?: StoreTaxRuleUpdateOneWithoutProductsNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    saleReturnItems?: SaleReturnItemUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    priceHistory?: StorePriceHistoryUpdateManyWithoutProductNestedInput
    transferOrderItems?: TransferOrderItemUpdateManyWithoutProductNestedInput
  }

  export type StoreProductUncheckedUpdateWithoutPurchaseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    taxRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    saleReturnItems?: SaleReturnItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: StorePriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    transferOrderItems?: TransferOrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StoreCreateWithoutStockMovementsInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeCreateNestedManyWithoutStoreInput
    products?: StoreProductCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutStockMovementsInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeUncheckedCreateNestedManyWithoutStoreInput
    products?: StoreProductUncheckedCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderUncheckedCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierUncheckedCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerUncheckedCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleUncheckedCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderUncheckedCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderUncheckedCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigUncheckedCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigUncheckedCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigUncheckedCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutStockMovementsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutStockMovementsInput, StoreUncheckedCreateWithoutStockMovementsInput>
  }

  export type StoreProductCreateWithoutStockMovementsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutProductsInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    taxRule?: StoreTaxRuleCreateNestedOneWithoutProductsInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    saleReturnItems?: SaleReturnItemCreateNestedManyWithoutProductInput
    purchaseItems?: StorePurchaseItemCreateNestedManyWithoutProductInput
    priceHistory?: StorePriceHistoryCreateNestedManyWithoutProductInput
    transferOrderItems?: TransferOrderItemCreateNestedManyWithoutProductInput
  }

  export type StoreProductUncheckedCreateWithoutStockMovementsInput = {
    id?: string
    storeId: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    taxRuleId?: string | null
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    saleReturnItems?: SaleReturnItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: StorePurchaseItemUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: StorePriceHistoryUncheckedCreateNestedManyWithoutProductInput
    transferOrderItems?: TransferOrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type StoreProductCreateOrConnectWithoutStockMovementsInput = {
    where: StoreProductWhereUniqueInput
    create: XOR<StoreProductCreateWithoutStockMovementsInput, StoreProductUncheckedCreateWithoutStockMovementsInput>
  }

  export type StoreUpsertWithoutStockMovementsInput = {
    update: XOR<StoreUpdateWithoutStockMovementsInput, StoreUncheckedUpdateWithoutStockMovementsInput>
    create: XOR<StoreCreateWithoutStockMovementsInput, StoreUncheckedCreateWithoutStockMovementsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutStockMovementsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutStockMovementsInput, StoreUncheckedUpdateWithoutStockMovementsInput>
  }

  export type StoreUpdateWithoutStockMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUpdateManyWithoutStoreNestedInput
    products?: StoreProductUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutStockMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUncheckedUpdateManyWithoutStoreNestedInput
    products?: StoreProductUncheckedUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUncheckedUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUncheckedUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUncheckedUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUncheckedUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUncheckedUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUncheckedUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUncheckedUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUncheckedUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUncheckedUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreProductUpsertWithoutStockMovementsInput = {
    update: XOR<StoreProductUpdateWithoutStockMovementsInput, StoreProductUncheckedUpdateWithoutStockMovementsInput>
    create: XOR<StoreProductCreateWithoutStockMovementsInput, StoreProductUncheckedCreateWithoutStockMovementsInput>
    where?: StoreProductWhereInput
  }

  export type StoreProductUpdateToOneWithWhereWithoutStockMovementsInput = {
    where?: StoreProductWhereInput
    data: XOR<StoreProductUpdateWithoutStockMovementsInput, StoreProductUncheckedUpdateWithoutStockMovementsInput>
  }

  export type StoreProductUpdateWithoutStockMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    taxRule?: StoreTaxRuleUpdateOneWithoutProductsNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    saleReturnItems?: SaleReturnItemUpdateManyWithoutProductNestedInput
    purchaseItems?: StorePurchaseItemUpdateManyWithoutProductNestedInput
    priceHistory?: StorePriceHistoryUpdateManyWithoutProductNestedInput
    transferOrderItems?: TransferOrderItemUpdateManyWithoutProductNestedInput
  }

  export type StoreProductUncheckedUpdateWithoutStockMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    taxRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    saleReturnItems?: SaleReturnItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: StorePurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: StorePriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    transferOrderItems?: TransferOrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StoreCreateWithoutTransferOrdersOutInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeCreateNestedManyWithoutStoreInput
    products?: StoreProductCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigCreateNestedOneWithoutStoreInput
    transferOrdersIn?: TransferOrderCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutTransferOrdersOutInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeUncheckedCreateNestedManyWithoutStoreInput
    products?: StoreProductUncheckedCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderUncheckedCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierUncheckedCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerUncheckedCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleUncheckedCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedCreateNestedOneWithoutStoreInput
    transferOrdersIn?: TransferOrderUncheckedCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigUncheckedCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigUncheckedCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigUncheckedCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutTransferOrdersOutInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutTransferOrdersOutInput, StoreUncheckedCreateWithoutTransferOrdersOutInput>
  }

  export type StoreCreateWithoutTransferOrdersInInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeCreateNestedManyWithoutStoreInput
    products?: StoreProductCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderCreateNestedManyWithoutFromStoreInput
    paymentMethods?: StorePaymentConfigCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutTransferOrdersInInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeUncheckedCreateNestedManyWithoutStoreInput
    products?: StoreProductUncheckedCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderUncheckedCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierUncheckedCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerUncheckedCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleUncheckedCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderUncheckedCreateNestedManyWithoutFromStoreInput
    paymentMethods?: StorePaymentConfigUncheckedCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigUncheckedCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigUncheckedCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutTransferOrdersInInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutTransferOrdersInInput, StoreUncheckedCreateWithoutTransferOrdersInInput>
  }

  export type TransferOrderItemCreateWithoutTransferOrderInput = {
    id?: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    product: StoreProductCreateNestedOneWithoutTransferOrderItemsInput
  }

  export type TransferOrderItemUncheckedCreateWithoutTransferOrderInput = {
    id?: string
    productId: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type TransferOrderItemCreateOrConnectWithoutTransferOrderInput = {
    where: TransferOrderItemWhereUniqueInput
    create: XOR<TransferOrderItemCreateWithoutTransferOrderInput, TransferOrderItemUncheckedCreateWithoutTransferOrderInput>
  }

  export type TransferOrderItemCreateManyTransferOrderInputEnvelope = {
    data: TransferOrderItemCreateManyTransferOrderInput | TransferOrderItemCreateManyTransferOrderInput[]
    skipDuplicates?: boolean
  }

  export type StoreUpsertWithoutTransferOrdersOutInput = {
    update: XOR<StoreUpdateWithoutTransferOrdersOutInput, StoreUncheckedUpdateWithoutTransferOrdersOutInput>
    create: XOR<StoreCreateWithoutTransferOrdersOutInput, StoreUncheckedCreateWithoutTransferOrdersOutInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutTransferOrdersOutInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutTransferOrdersOutInput, StoreUncheckedUpdateWithoutTransferOrdersOutInput>
  }

  export type StoreUpdateWithoutTransferOrdersOutInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUpdateManyWithoutStoreNestedInput
    products?: StoreProductUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUpdateOneWithoutStoreNestedInput
    transferOrdersIn?: TransferOrderUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutTransferOrdersOutInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUncheckedUpdateManyWithoutStoreNestedInput
    products?: StoreProductUncheckedUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUncheckedUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUncheckedUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUncheckedUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUncheckedUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedUpdateOneWithoutStoreNestedInput
    transferOrdersIn?: TransferOrderUncheckedUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUncheckedUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUncheckedUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUncheckedUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreUpsertWithoutTransferOrdersInInput = {
    update: XOR<StoreUpdateWithoutTransferOrdersInInput, StoreUncheckedUpdateWithoutTransferOrdersInInput>
    create: XOR<StoreCreateWithoutTransferOrdersInInput, StoreUncheckedCreateWithoutTransferOrdersInInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutTransferOrdersInInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutTransferOrdersInInput, StoreUncheckedUpdateWithoutTransferOrdersInInput>
  }

  export type StoreUpdateWithoutTransferOrdersInInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUpdateManyWithoutStoreNestedInput
    products?: StoreProductUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUpdateManyWithoutFromStoreNestedInput
    paymentMethods?: StorePaymentConfigUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutTransferOrdersInInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUncheckedUpdateManyWithoutStoreNestedInput
    products?: StoreProductUncheckedUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUncheckedUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUncheckedUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUncheckedUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUncheckedUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUncheckedUpdateManyWithoutFromStoreNestedInput
    paymentMethods?: StorePaymentConfigUncheckedUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUncheckedUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUncheckedUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type TransferOrderItemUpsertWithWhereUniqueWithoutTransferOrderInput = {
    where: TransferOrderItemWhereUniqueInput
    update: XOR<TransferOrderItemUpdateWithoutTransferOrderInput, TransferOrderItemUncheckedUpdateWithoutTransferOrderInput>
    create: XOR<TransferOrderItemCreateWithoutTransferOrderInput, TransferOrderItemUncheckedCreateWithoutTransferOrderInput>
  }

  export type TransferOrderItemUpdateWithWhereUniqueWithoutTransferOrderInput = {
    where: TransferOrderItemWhereUniqueInput
    data: XOR<TransferOrderItemUpdateWithoutTransferOrderInput, TransferOrderItemUncheckedUpdateWithoutTransferOrderInput>
  }

  export type TransferOrderItemUpdateManyWithWhereWithoutTransferOrderInput = {
    where: TransferOrderItemScalarWhereInput
    data: XOR<TransferOrderItemUpdateManyMutationInput, TransferOrderItemUncheckedUpdateManyWithoutTransferOrderInput>
  }

  export type TransferOrderCreateWithoutItemsInput = {
    id?: string
    transferNumber: string
    status?: $Enums.TransferOrderStatus
    notes?: string | null
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fromStore: StoreCreateNestedOneWithoutTransferOrdersOutInput
    toStore: StoreCreateNestedOneWithoutTransferOrdersInInput
  }

  export type TransferOrderUncheckedCreateWithoutItemsInput = {
    id?: string
    fromStoreId: string
    toStoreId: string
    transferNumber: string
    status?: $Enums.TransferOrderStatus
    notes?: string | null
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferOrderCreateOrConnectWithoutItemsInput = {
    where: TransferOrderWhereUniqueInput
    create: XOR<TransferOrderCreateWithoutItemsInput, TransferOrderUncheckedCreateWithoutItemsInput>
  }

  export type StoreProductCreateWithoutTransferOrderItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutProductsInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    taxRule?: StoreTaxRuleCreateNestedOneWithoutProductsInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    saleReturnItems?: SaleReturnItemCreateNestedManyWithoutProductInput
    purchaseItems?: StorePurchaseItemCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    priceHistory?: StorePriceHistoryCreateNestedManyWithoutProductInput
  }

  export type StoreProductUncheckedCreateWithoutTransferOrderItemsInput = {
    id?: string
    storeId: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    taxRuleId?: string | null
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    saleReturnItems?: SaleReturnItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: StorePurchaseItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: StorePriceHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type StoreProductCreateOrConnectWithoutTransferOrderItemsInput = {
    where: StoreProductWhereUniqueInput
    create: XOR<StoreProductCreateWithoutTransferOrderItemsInput, StoreProductUncheckedCreateWithoutTransferOrderItemsInput>
  }

  export type TransferOrderUpsertWithoutItemsInput = {
    update: XOR<TransferOrderUpdateWithoutItemsInput, TransferOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<TransferOrderCreateWithoutItemsInput, TransferOrderUncheckedCreateWithoutItemsInput>
    where?: TransferOrderWhereInput
  }

  export type TransferOrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: TransferOrderWhereInput
    data: XOR<TransferOrderUpdateWithoutItemsInput, TransferOrderUncheckedUpdateWithoutItemsInput>
  }

  export type TransferOrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferOrderStatusFieldUpdateOperationsInput | $Enums.TransferOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromStore?: StoreUpdateOneRequiredWithoutTransferOrdersOutNestedInput
    toStore?: StoreUpdateOneRequiredWithoutTransferOrdersInNestedInput
  }

  export type TransferOrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromStoreId?: StringFieldUpdateOperationsInput | string
    toStoreId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferOrderStatusFieldUpdateOperationsInput | $Enums.TransferOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreProductUpsertWithoutTransferOrderItemsInput = {
    update: XOR<StoreProductUpdateWithoutTransferOrderItemsInput, StoreProductUncheckedUpdateWithoutTransferOrderItemsInput>
    create: XOR<StoreProductCreateWithoutTransferOrderItemsInput, StoreProductUncheckedCreateWithoutTransferOrderItemsInput>
    where?: StoreProductWhereInput
  }

  export type StoreProductUpdateToOneWithWhereWithoutTransferOrderItemsInput = {
    where?: StoreProductWhereInput
    data: XOR<StoreProductUpdateWithoutTransferOrderItemsInput, StoreProductUncheckedUpdateWithoutTransferOrderItemsInput>
  }

  export type StoreProductUpdateWithoutTransferOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    taxRule?: StoreTaxRuleUpdateOneWithoutProductsNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    saleReturnItems?: SaleReturnItemUpdateManyWithoutProductNestedInput
    purchaseItems?: StorePurchaseItemUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    priceHistory?: StorePriceHistoryUpdateManyWithoutProductNestedInput
  }

  export type StoreProductUncheckedUpdateWithoutTransferOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    taxRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    saleReturnItems?: SaleReturnItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: StorePurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: StorePriceHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StoreCreateWithoutCustomersInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeCreateNestedManyWithoutStoreInput
    products?: StoreProductCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutCustomersInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeUncheckedCreateNestedManyWithoutStoreInput
    products?: StoreProductUncheckedCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderUncheckedCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierUncheckedCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleUncheckedCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderUncheckedCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderUncheckedCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigUncheckedCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigUncheckedCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigUncheckedCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutCustomersInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutCustomersInput, StoreUncheckedCreateWithoutCustomersInput>
  }

  export type SaleCreateWithoutCustomerInput = {
    id?: string
    saleNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.StoreDiscountType | null
    total: Decimal | DecimalJsLike | number | string
    paidAmount: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.StoreSaleStatus
    notes?: string | null
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutSalesInput
    employee?: StoreEmployeeCreateNestedOneWithoutSalesInput
    items?: SaleItemCreateNestedManyWithoutSaleInput
    payments?: SalePaymentCreateNestedManyWithoutSaleInput
    returns?: SaleReturnCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutCustomerInput = {
    id?: string
    storeId: string
    saleNumber: string
    employeeId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.StoreDiscountType | null
    total: Decimal | DecimalJsLike | number | string
    paidAmount: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.StoreSaleStatus
    notes?: string | null
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SaleItemUncheckedCreateNestedManyWithoutSaleInput
    payments?: SalePaymentUncheckedCreateNestedManyWithoutSaleInput
    returns?: SaleReturnUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput>
  }

  export type SaleCreateManyCustomerInputEnvelope = {
    data: SaleCreateManyCustomerInput | SaleCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type StoreLoyaltyTransactionCreateWithoutCustomerInput = {
    id?: string
    type: $Enums.LoyaltyTransactionType
    points: number
    saleId?: string | null
    description?: string | null
    createdAt?: Date | string
  }

  export type StoreLoyaltyTransactionUncheckedCreateWithoutCustomerInput = {
    id?: string
    type: $Enums.LoyaltyTransactionType
    points: number
    saleId?: string | null
    description?: string | null
    createdAt?: Date | string
  }

  export type StoreLoyaltyTransactionCreateOrConnectWithoutCustomerInput = {
    where: StoreLoyaltyTransactionWhereUniqueInput
    create: XOR<StoreLoyaltyTransactionCreateWithoutCustomerInput, StoreLoyaltyTransactionUncheckedCreateWithoutCustomerInput>
  }

  export type StoreLoyaltyTransactionCreateManyCustomerInputEnvelope = {
    data: StoreLoyaltyTransactionCreateManyCustomerInput | StoreLoyaltyTransactionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type StoreUpsertWithoutCustomersInput = {
    update: XOR<StoreUpdateWithoutCustomersInput, StoreUncheckedUpdateWithoutCustomersInput>
    create: XOR<StoreCreateWithoutCustomersInput, StoreUncheckedCreateWithoutCustomersInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutCustomersInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutCustomersInput, StoreUncheckedUpdateWithoutCustomersInput>
  }

  export type StoreUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUpdateManyWithoutStoreNestedInput
    products?: StoreProductUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUncheckedUpdateManyWithoutStoreNestedInput
    products?: StoreProductUncheckedUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUncheckedUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUncheckedUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUncheckedUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUncheckedUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUncheckedUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUncheckedUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUncheckedUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUncheckedUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type SaleUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutCustomerInput, SaleUncheckedUpdateWithoutCustomerInput>
    create: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutCustomerInput, SaleUncheckedUpdateWithoutCustomerInput>
  }

  export type SaleUpdateManyWithWhereWithoutCustomerInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutCustomerInput>
  }

  export type StoreLoyaltyTransactionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: StoreLoyaltyTransactionWhereUniqueInput
    update: XOR<StoreLoyaltyTransactionUpdateWithoutCustomerInput, StoreLoyaltyTransactionUncheckedUpdateWithoutCustomerInput>
    create: XOR<StoreLoyaltyTransactionCreateWithoutCustomerInput, StoreLoyaltyTransactionUncheckedCreateWithoutCustomerInput>
  }

  export type StoreLoyaltyTransactionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: StoreLoyaltyTransactionWhereUniqueInput
    data: XOR<StoreLoyaltyTransactionUpdateWithoutCustomerInput, StoreLoyaltyTransactionUncheckedUpdateWithoutCustomerInput>
  }

  export type StoreLoyaltyTransactionUpdateManyWithWhereWithoutCustomerInput = {
    where: StoreLoyaltyTransactionScalarWhereInput
    data: XOR<StoreLoyaltyTransactionUpdateManyMutationInput, StoreLoyaltyTransactionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type StoreLoyaltyTransactionScalarWhereInput = {
    AND?: StoreLoyaltyTransactionScalarWhereInput | StoreLoyaltyTransactionScalarWhereInput[]
    OR?: StoreLoyaltyTransactionScalarWhereInput[]
    NOT?: StoreLoyaltyTransactionScalarWhereInput | StoreLoyaltyTransactionScalarWhereInput[]
    id?: StringFilter<"StoreLoyaltyTransaction"> | string
    customerId?: StringFilter<"StoreLoyaltyTransaction"> | string
    type?: EnumLoyaltyTransactionTypeFilter<"StoreLoyaltyTransaction"> | $Enums.LoyaltyTransactionType
    points?: IntFilter<"StoreLoyaltyTransaction"> | number
    saleId?: StringNullableFilter<"StoreLoyaltyTransaction"> | string | null
    description?: StringNullableFilter<"StoreLoyaltyTransaction"> | string | null
    createdAt?: DateTimeFilter<"StoreLoyaltyTransaction"> | Date | string
  }

  export type StoreCreateWithoutLoyaltyConfigInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeCreateNestedManyWithoutStoreInput
    products?: StoreProductCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleCreateNestedManyWithoutStoreInput
    transferOrdersOut?: TransferOrderCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutLoyaltyConfigInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeUncheckedCreateNestedManyWithoutStoreInput
    products?: StoreProductUncheckedCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderUncheckedCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierUncheckedCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerUncheckedCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleUncheckedCreateNestedManyWithoutStoreInput
    transferOrdersOut?: TransferOrderUncheckedCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderUncheckedCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigUncheckedCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigUncheckedCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigUncheckedCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutLoyaltyConfigInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutLoyaltyConfigInput, StoreUncheckedCreateWithoutLoyaltyConfigInput>
  }

  export type StoreUpsertWithoutLoyaltyConfigInput = {
    update: XOR<StoreUpdateWithoutLoyaltyConfigInput, StoreUncheckedUpdateWithoutLoyaltyConfigInput>
    create: XOR<StoreCreateWithoutLoyaltyConfigInput, StoreUncheckedCreateWithoutLoyaltyConfigInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutLoyaltyConfigInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutLoyaltyConfigInput, StoreUncheckedUpdateWithoutLoyaltyConfigInput>
  }

  export type StoreUpdateWithoutLoyaltyConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUpdateManyWithoutStoreNestedInput
    products?: StoreProductUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUpdateManyWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutLoyaltyConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUncheckedUpdateManyWithoutStoreNestedInput
    products?: StoreProductUncheckedUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUncheckedUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUncheckedUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUncheckedUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUncheckedUpdateManyWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUncheckedUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUncheckedUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUncheckedUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUncheckedUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUncheckedUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreCustomerCreateWithoutLoyaltyTransactionsInput = {
    id?: string
    firstName: string
    lastName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    taxId?: string | null
    notes?: string | null
    totalPurchases?: Decimal | DecimalJsLike | number | string
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    totalLifetimePurchases?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutCustomersInput
    sales?: SaleCreateNestedManyWithoutCustomerInput
  }

  export type StoreCustomerUncheckedCreateWithoutLoyaltyTransactionsInput = {
    id?: string
    storeId: string
    firstName: string
    lastName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    taxId?: string | null
    notes?: string | null
    totalPurchases?: Decimal | DecimalJsLike | number | string
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    totalLifetimePurchases?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type StoreCustomerCreateOrConnectWithoutLoyaltyTransactionsInput = {
    where: StoreCustomerWhereUniqueInput
    create: XOR<StoreCustomerCreateWithoutLoyaltyTransactionsInput, StoreCustomerUncheckedCreateWithoutLoyaltyTransactionsInput>
  }

  export type StoreCustomerUpsertWithoutLoyaltyTransactionsInput = {
    update: XOR<StoreCustomerUpdateWithoutLoyaltyTransactionsInput, StoreCustomerUncheckedUpdateWithoutLoyaltyTransactionsInput>
    create: XOR<StoreCustomerCreateWithoutLoyaltyTransactionsInput, StoreCustomerUncheckedCreateWithoutLoyaltyTransactionsInput>
    where?: StoreCustomerWhereInput
  }

  export type StoreCustomerUpdateToOneWithWhereWithoutLoyaltyTransactionsInput = {
    where?: StoreCustomerWhereInput
    data: XOR<StoreCustomerUpdateWithoutLoyaltyTransactionsInput, StoreCustomerUncheckedUpdateWithoutLoyaltyTransactionsInput>
  }

  export type StoreCustomerUpdateWithoutLoyaltyTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    totalLifetimePurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutCustomersNestedInput
    sales?: SaleUpdateManyWithoutCustomerNestedInput
  }

  export type StoreCustomerUncheckedUpdateWithoutLoyaltyTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    totalLifetimePurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type StoreCreateWithoutTaxRulesInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeCreateNestedManyWithoutStoreInput
    products?: StoreProductCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutTaxRulesInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeUncheckedCreateNestedManyWithoutStoreInput
    products?: StoreProductUncheckedCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderUncheckedCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierUncheckedCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerUncheckedCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderUncheckedCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderUncheckedCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigUncheckedCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigUncheckedCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigUncheckedCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutTaxRulesInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutTaxRulesInput, StoreUncheckedCreateWithoutTaxRulesInput>
  }

  export type StoreProductCreateWithoutTaxRuleInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    store: StoreCreateNestedOneWithoutProductsInput
    category?: ProductCategoryCreateNestedOneWithoutProductsInput
    saleItems?: SaleItemCreateNestedManyWithoutProductInput
    saleReturnItems?: SaleReturnItemCreateNestedManyWithoutProductInput
    purchaseItems?: StorePurchaseItemCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementCreateNestedManyWithoutProductInput
    priceHistory?: StorePriceHistoryCreateNestedManyWithoutProductInput
    transferOrderItems?: TransferOrderItemCreateNestedManyWithoutProductInput
  }

  export type StoreProductUncheckedCreateWithoutTaxRuleInput = {
    id?: string
    storeId: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutProductInput
    saleReturnItems?: SaleReturnItemUncheckedCreateNestedManyWithoutProductInput
    purchaseItems?: StorePurchaseItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: StorePriceHistoryUncheckedCreateNestedManyWithoutProductInput
    transferOrderItems?: TransferOrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type StoreProductCreateOrConnectWithoutTaxRuleInput = {
    where: StoreProductWhereUniqueInput
    create: XOR<StoreProductCreateWithoutTaxRuleInput, StoreProductUncheckedCreateWithoutTaxRuleInput>
  }

  export type StoreProductCreateManyTaxRuleInputEnvelope = {
    data: StoreProductCreateManyTaxRuleInput | StoreProductCreateManyTaxRuleInput[]
    skipDuplicates?: boolean
  }

  export type StoreUpsertWithoutTaxRulesInput = {
    update: XOR<StoreUpdateWithoutTaxRulesInput, StoreUncheckedUpdateWithoutTaxRulesInput>
    create: XOR<StoreCreateWithoutTaxRulesInput, StoreUncheckedCreateWithoutTaxRulesInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutTaxRulesInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutTaxRulesInput, StoreUncheckedUpdateWithoutTaxRulesInput>
  }

  export type StoreUpdateWithoutTaxRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUpdateManyWithoutStoreNestedInput
    products?: StoreProductUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutTaxRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUncheckedUpdateManyWithoutStoreNestedInput
    products?: StoreProductUncheckedUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUncheckedUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUncheckedUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUncheckedUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUncheckedUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUncheckedUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUncheckedUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUncheckedUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUncheckedUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreProductUpsertWithWhereUniqueWithoutTaxRuleInput = {
    where: StoreProductWhereUniqueInput
    update: XOR<StoreProductUpdateWithoutTaxRuleInput, StoreProductUncheckedUpdateWithoutTaxRuleInput>
    create: XOR<StoreProductCreateWithoutTaxRuleInput, StoreProductUncheckedCreateWithoutTaxRuleInput>
  }

  export type StoreProductUpdateWithWhereUniqueWithoutTaxRuleInput = {
    where: StoreProductWhereUniqueInput
    data: XOR<StoreProductUpdateWithoutTaxRuleInput, StoreProductUncheckedUpdateWithoutTaxRuleInput>
  }

  export type StoreProductUpdateManyWithWhereWithoutTaxRuleInput = {
    where: StoreProductScalarWhereInput
    data: XOR<StoreProductUpdateManyMutationInput, StoreProductUncheckedUpdateManyWithoutTaxRuleInput>
  }

  export type StoreCreateWithoutPaymentMethodsInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeCreateNestedManyWithoutStoreInput
    products?: StoreProductCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderCreateNestedManyWithoutToStoreInput
    receiptConfig?: StoreReceiptConfigCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutPaymentMethodsInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeUncheckedCreateNestedManyWithoutStoreInput
    products?: StoreProductUncheckedCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderUncheckedCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierUncheckedCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerUncheckedCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleUncheckedCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderUncheckedCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderUncheckedCreateNestedManyWithoutToStoreInput
    receiptConfig?: StoreReceiptConfigUncheckedCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigUncheckedCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutPaymentMethodsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutPaymentMethodsInput, StoreUncheckedCreateWithoutPaymentMethodsInput>
  }

  export type StoreUpsertWithoutPaymentMethodsInput = {
    update: XOR<StoreUpdateWithoutPaymentMethodsInput, StoreUncheckedUpdateWithoutPaymentMethodsInput>
    create: XOR<StoreCreateWithoutPaymentMethodsInput, StoreUncheckedCreateWithoutPaymentMethodsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutPaymentMethodsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutPaymentMethodsInput, StoreUncheckedUpdateWithoutPaymentMethodsInput>
  }

  export type StoreUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUpdateManyWithoutStoreNestedInput
    products?: StoreProductUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUpdateManyWithoutToStoreNestedInput
    receiptConfig?: StoreReceiptConfigUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutPaymentMethodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUncheckedUpdateManyWithoutStoreNestedInput
    products?: StoreProductUncheckedUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUncheckedUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUncheckedUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUncheckedUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUncheckedUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUncheckedUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUncheckedUpdateManyWithoutToStoreNestedInput
    receiptConfig?: StoreReceiptConfigUncheckedUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUncheckedUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreCreateWithoutReceiptConfigInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeCreateNestedManyWithoutStoreInput
    products?: StoreProductCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigCreateNestedManyWithoutStoreInput
    devices?: StoreDeviceConfigCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutReceiptConfigInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeUncheckedCreateNestedManyWithoutStoreInput
    products?: StoreProductUncheckedCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderUncheckedCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierUncheckedCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerUncheckedCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleUncheckedCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderUncheckedCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderUncheckedCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigUncheckedCreateNestedManyWithoutStoreInput
    devices?: StoreDeviceConfigUncheckedCreateNestedManyWithoutStoreInput
    integrations?: StoreIntegrationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutReceiptConfigInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutReceiptConfigInput, StoreUncheckedCreateWithoutReceiptConfigInput>
  }

  export type StoreUpsertWithoutReceiptConfigInput = {
    update: XOR<StoreUpdateWithoutReceiptConfigInput, StoreUncheckedUpdateWithoutReceiptConfigInput>
    create: XOR<StoreCreateWithoutReceiptConfigInput, StoreUncheckedCreateWithoutReceiptConfigInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutReceiptConfigInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutReceiptConfigInput, StoreUncheckedUpdateWithoutReceiptConfigInput>
  }

  export type StoreUpdateWithoutReceiptConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUpdateManyWithoutStoreNestedInput
    products?: StoreProductUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUpdateManyWithoutStoreNestedInput
    devices?: StoreDeviceConfigUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutReceiptConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUncheckedUpdateManyWithoutStoreNestedInput
    products?: StoreProductUncheckedUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUncheckedUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUncheckedUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUncheckedUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUncheckedUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUncheckedUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUncheckedUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUncheckedUpdateManyWithoutStoreNestedInput
    devices?: StoreDeviceConfigUncheckedUpdateManyWithoutStoreNestedInput
    integrations?: StoreIntegrationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreCreateWithoutDevicesInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeCreateNestedManyWithoutStoreInput
    products?: StoreProductCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigCreateNestedOneWithoutStoreInput
    integrations?: StoreIntegrationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutDevicesInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeUncheckedCreateNestedManyWithoutStoreInput
    products?: StoreProductUncheckedCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderUncheckedCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierUncheckedCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerUncheckedCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleUncheckedCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderUncheckedCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderUncheckedCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigUncheckedCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigUncheckedCreateNestedOneWithoutStoreInput
    integrations?: StoreIntegrationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutDevicesInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutDevicesInput, StoreUncheckedCreateWithoutDevicesInput>
  }

  export type StoreUpsertWithoutDevicesInput = {
    update: XOR<StoreUpdateWithoutDevicesInput, StoreUncheckedUpdateWithoutDevicesInput>
    create: XOR<StoreCreateWithoutDevicesInput, StoreUncheckedCreateWithoutDevicesInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutDevicesInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutDevicesInput, StoreUncheckedUpdateWithoutDevicesInput>
  }

  export type StoreUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUpdateManyWithoutStoreNestedInput
    products?: StoreProductUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUpdateOneWithoutStoreNestedInput
    integrations?: StoreIntegrationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUncheckedUpdateManyWithoutStoreNestedInput
    products?: StoreProductUncheckedUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUncheckedUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUncheckedUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUncheckedUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUncheckedUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUncheckedUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUncheckedUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUncheckedUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUncheckedUpdateOneWithoutStoreNestedInput
    integrations?: StoreIntegrationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreCreateWithoutIntegrationsInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeCreateNestedManyWithoutStoreInput
    products?: StoreProductCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryCreateNestedManyWithoutStoreInput
    sales?: SaleCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutIntegrationsInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    currency?: string
    timezone?: string
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: StoreEmployeeUncheckedCreateNestedManyWithoutStoreInput
    products?: StoreProductUncheckedCreateNestedManyWithoutStoreInput
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutStoreInput
    sales?: SaleUncheckedCreateNestedManyWithoutStoreInput
    purchases?: StorePurchaseOrderUncheckedCreateNestedManyWithoutStoreInput
    suppliers?: StoreSupplierUncheckedCreateNestedManyWithoutStoreInput
    customers?: StoreCustomerUncheckedCreateNestedManyWithoutStoreInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutStoreInput
    taxRules?: StoreTaxRuleUncheckedCreateNestedManyWithoutStoreInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedCreateNestedOneWithoutStoreInput
    transferOrdersOut?: TransferOrderUncheckedCreateNestedManyWithoutFromStoreInput
    transferOrdersIn?: TransferOrderUncheckedCreateNestedManyWithoutToStoreInput
    paymentMethods?: StorePaymentConfigUncheckedCreateNestedManyWithoutStoreInput
    receiptConfig?: StoreReceiptConfigUncheckedCreateNestedOneWithoutStoreInput
    devices?: StoreDeviceConfigUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutIntegrationsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutIntegrationsInput, StoreUncheckedCreateWithoutIntegrationsInput>
  }

  export type StoreUpsertWithoutIntegrationsInput = {
    update: XOR<StoreUpdateWithoutIntegrationsInput, StoreUncheckedUpdateWithoutIntegrationsInput>
    create: XOR<StoreCreateWithoutIntegrationsInput, StoreUncheckedCreateWithoutIntegrationsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutIntegrationsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutIntegrationsInput, StoreUncheckedUpdateWithoutIntegrationsInput>
  }

  export type StoreUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUpdateManyWithoutStoreNestedInput
    products?: StoreProductUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUpdateManyWithoutStoreNestedInput
    sales?: SaleUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: StoreEmployeeUncheckedUpdateManyWithoutStoreNestedInput
    products?: StoreProductUncheckedUpdateManyWithoutStoreNestedInput
    categories?: ProductCategoryUncheckedUpdateManyWithoutStoreNestedInput
    sales?: SaleUncheckedUpdateManyWithoutStoreNestedInput
    purchases?: StorePurchaseOrderUncheckedUpdateManyWithoutStoreNestedInput
    suppliers?: StoreSupplierUncheckedUpdateManyWithoutStoreNestedInput
    customers?: StoreCustomerUncheckedUpdateManyWithoutStoreNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutStoreNestedInput
    taxRules?: StoreTaxRuleUncheckedUpdateManyWithoutStoreNestedInput
    loyaltyConfig?: StoreLoyaltyConfigUncheckedUpdateOneWithoutStoreNestedInput
    transferOrdersOut?: TransferOrderUncheckedUpdateManyWithoutFromStoreNestedInput
    transferOrdersIn?: TransferOrderUncheckedUpdateManyWithoutToStoreNestedInput
    paymentMethods?: StorePaymentConfigUncheckedUpdateManyWithoutStoreNestedInput
    receiptConfig?: StoreReceiptConfigUncheckedUpdateOneWithoutStoreNestedInput
    devices?: StoreDeviceConfigUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type UserCreateManyOrganizationInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    avatar?: string | null
    emailVerified?: Date | string | null
    lastLoginAt?: Date | string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreEmployeeCreateManyStoreInput = {
    id?: string
    userId?: string | null
    firstName: string
    lastName: string
    phone?: string | null
    email?: string | null
    role?: string
    pin?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreProductCreateManyStoreInput = {
    id?: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    taxRuleId?: string | null
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryCreateManyStoreInput = {
    id?: string
    name: string
    nameKa?: string | null
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    sortOrder?: number
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleCreateManyStoreInput = {
    id?: string
    saleNumber: string
    customerId?: string | null
    employeeId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.StoreDiscountType | null
    total: Decimal | DecimalJsLike | number | string
    paidAmount: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.StoreSaleStatus
    notes?: string | null
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorePurchaseOrderCreateManyStoreInput = {
    id?: string
    supplierId: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.StorePurchaseStatus
    notes?: string | null
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreSupplierCreateManyStoreInput = {
    id?: string
    name: string
    contactPerson?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreCustomerCreateManyStoreInput = {
    id?: string
    firstName: string
    lastName?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    taxId?: string | null
    notes?: string | null
    totalPurchases?: Decimal | DecimalJsLike | number | string
    loyaltyPoints?: number
    loyaltyTier?: $Enums.LoyaltyTier
    totalLifetimePurchases?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockMovementCreateManyStoreInput = {
    id?: string
    productId: string
    type: $Enums.StoreMovementType
    quantity: Decimal | DecimalJsLike | number | string
    previousStock: Decimal | DecimalJsLike | number | string
    newStock: Decimal | DecimalJsLike | number | string
    reason?: string | null
    referenceType?: string | null
    referenceId?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type StoreTaxRuleCreateManyStoreInput = {
    id?: string
    name: string
    rate: Decimal | DecimalJsLike | number | string
    isDefault?: boolean
    isActive?: boolean
  }

  export type TransferOrderCreateManyFromStoreInput = {
    id?: string
    toStoreId: string
    transferNumber: string
    status?: $Enums.TransferOrderStatus
    notes?: string | null
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferOrderCreateManyToStoreInput = {
    id?: string
    fromStoreId: string
    transferNumber: string
    status?: $Enums.TransferOrderStatus
    notes?: string | null
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorePaymentConfigCreateManyStoreInput = {
    id?: string
    name: string
    type: $Enums.PaymentMethod
    isActive?: boolean
    sortOrder?: number
  }

  export type StoreDeviceConfigCreateManyStoreInput = {
    id?: string
    deviceType: $Enums.StoreDeviceType
    name: string
    connectionType: string
    settings: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreIntegrationCreateManyStoreInput = {
    id?: string
    type: $Enums.StoreIntegrationType
    name: string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreEmployeeUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUpdateManyWithoutEmployeeNestedInput
  }

  export type StoreEmployeeUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type StoreEmployeeUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreProductUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    taxRule?: StoreTaxRuleUpdateOneWithoutProductsNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    saleReturnItems?: SaleReturnItemUpdateManyWithoutProductNestedInput
    purchaseItems?: StorePurchaseItemUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    priceHistory?: StorePriceHistoryUpdateManyWithoutProductNestedInput
    transferOrderItems?: TransferOrderItemUpdateManyWithoutProductNestedInput
  }

  export type StoreProductUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    taxRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    saleReturnItems?: SaleReturnItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: StorePurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: StorePriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    transferOrderItems?: TransferOrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StoreProductUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    taxRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ProductCategoryUpdateOneWithoutChildrenNestedInput
    children?: ProductCategoryUpdateManyWithoutParentNestedInput
    products?: StoreProductUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ProductCategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: StoreProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumStoreDiscountTypeFieldUpdateOperationsInput | $Enums.StoreDiscountType | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFieldUpdateOperationsInput | $Enums.StoreSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: StoreCustomerUpdateOneWithoutSalesNestedInput
    employee?: StoreEmployeeUpdateOneWithoutSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUpdateManyWithoutSaleNestedInput
    returns?: SaleReturnUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumStoreDiscountTypeFieldUpdateOperationsInput | $Enums.StoreDiscountType | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFieldUpdateOperationsInput | $Enums.StoreSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUncheckedUpdateManyWithoutSaleNestedInput
    returns?: SaleReturnUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumStoreDiscountTypeFieldUpdateOperationsInput | $Enums.StoreDiscountType | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFieldUpdateOperationsInput | $Enums.StoreSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorePurchaseOrderUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStorePurchaseStatusFieldUpdateOperationsInput | $Enums.StorePurchaseStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: StoreSupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: StorePurchaseItemUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type StorePurchaseOrderUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStorePurchaseStatusFieldUpdateOperationsInput | $Enums.StorePurchaseStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: StorePurchaseItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type StorePurchaseOrderUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStorePurchaseStatusFieldUpdateOperationsInput | $Enums.StorePurchaseStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreSupplierUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: StorePurchaseOrderUpdateManyWithoutSupplierNestedInput
  }

  export type StoreSupplierUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: StorePurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type StoreSupplierUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreCustomerUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    totalLifetimePurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: StoreLoyaltyTransactionUpdateManyWithoutCustomerNestedInput
  }

  export type StoreCustomerUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    totalLifetimePurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
    loyaltyTransactions?: StoreLoyaltyTransactionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type StoreCustomerUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalPurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: EnumLoyaltyTierFieldUpdateOperationsInput | $Enums.LoyaltyTier
    totalLifetimePurchases?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStoreMovementTypeFieldUpdateOperationsInput | $Enums.StoreMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    previousStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: StoreProductUpdateOneRequiredWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    type?: EnumStoreMovementTypeFieldUpdateOperationsInput | $Enums.StoreMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    previousStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    type?: EnumStoreMovementTypeFieldUpdateOperationsInput | $Enums.StoreMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    previousStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreTaxRuleUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    products?: StoreProductUpdateManyWithoutTaxRuleNestedInput
  }

  export type StoreTaxRuleUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    products?: StoreProductUncheckedUpdateManyWithoutTaxRuleNestedInput
  }

  export type StoreTaxRuleUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransferOrderUpdateWithoutFromStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferOrderStatusFieldUpdateOperationsInput | $Enums.TransferOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toStore?: StoreUpdateOneRequiredWithoutTransferOrdersInNestedInput
    items?: TransferOrderItemUpdateManyWithoutTransferOrderNestedInput
  }

  export type TransferOrderUncheckedUpdateWithoutFromStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    toStoreId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferOrderStatusFieldUpdateOperationsInput | $Enums.TransferOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferOrderItemUncheckedUpdateManyWithoutTransferOrderNestedInput
  }

  export type TransferOrderUncheckedUpdateManyWithoutFromStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    toStoreId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferOrderStatusFieldUpdateOperationsInput | $Enums.TransferOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferOrderUpdateWithoutToStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferOrderStatusFieldUpdateOperationsInput | $Enums.TransferOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromStore?: StoreUpdateOneRequiredWithoutTransferOrdersOutNestedInput
    items?: TransferOrderItemUpdateManyWithoutTransferOrderNestedInput
  }

  export type TransferOrderUncheckedUpdateWithoutToStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromStoreId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferOrderStatusFieldUpdateOperationsInput | $Enums.TransferOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TransferOrderItemUncheckedUpdateManyWithoutTransferOrderNestedInput
  }

  export type TransferOrderUncheckedUpdateManyWithoutToStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromStoreId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferOrderStatusFieldUpdateOperationsInput | $Enums.TransferOrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorePaymentConfigUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type StorePaymentConfigUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type StorePaymentConfigUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type StoreDeviceConfigUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumStoreDeviceTypeFieldUpdateOperationsInput | $Enums.StoreDeviceType
    name?: StringFieldUpdateOperationsInput | string
    connectionType?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreDeviceConfigUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumStoreDeviceTypeFieldUpdateOperationsInput | $Enums.StoreDeviceType
    name?: StringFieldUpdateOperationsInput | string
    connectionType?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreDeviceConfigUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumStoreDeviceTypeFieldUpdateOperationsInput | $Enums.StoreDeviceType
    name?: StringFieldUpdateOperationsInput | string
    connectionType?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreIntegrationUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStoreIntegrationTypeFieldUpdateOperationsInput | $Enums.StoreIntegrationType
    name?: StringFieldUpdateOperationsInput | string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreIntegrationUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStoreIntegrationTypeFieldUpdateOperationsInput | $Enums.StoreIntegrationType
    name?: StringFieldUpdateOperationsInput | string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreIntegrationUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStoreIntegrationTypeFieldUpdateOperationsInput | $Enums.StoreIntegrationType
    name?: StringFieldUpdateOperationsInput | string
    credentials?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateManyEmployeeInput = {
    id?: string
    storeId: string
    saleNumber: string
    customerId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.StoreDiscountType | null
    total: Decimal | DecimalJsLike | number | string
    paidAmount: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.StoreSaleStatus
    notes?: string | null
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumStoreDiscountTypeFieldUpdateOperationsInput | $Enums.StoreDiscountType | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFieldUpdateOperationsInput | $Enums.StoreSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSalesNestedInput
    customer?: StoreCustomerUpdateOneWithoutSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUpdateManyWithoutSaleNestedInput
    returns?: SaleReturnUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumStoreDiscountTypeFieldUpdateOperationsInput | $Enums.StoreDiscountType | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFieldUpdateOperationsInput | $Enums.StoreSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUncheckedUpdateManyWithoutSaleNestedInput
    returns?: SaleReturnUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumStoreDiscountTypeFieldUpdateOperationsInput | $Enums.StoreDiscountType | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFieldUpdateOperationsInput | $Enums.StoreSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryCreateManyParentInput = {
    id?: string
    storeId: string
    name: string
    nameKa?: string | null
    slug: string
    description?: string | null
    color?: string | null
    icon?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreProductCreateManyCategoryInput = {
    id?: string
    storeId: string
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    taxRuleId?: string | null
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutCategoriesNestedInput
    children?: ProductCategoryUpdateManyWithoutParentNestedInput
    products?: StoreProductUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ProductCategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: StoreProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreProductUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutProductsNestedInput
    taxRule?: StoreTaxRuleUpdateOneWithoutProductsNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    saleReturnItems?: SaleReturnItemUpdateManyWithoutProductNestedInput
    purchaseItems?: StorePurchaseItemUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    priceHistory?: StorePriceHistoryUpdateManyWithoutProductNestedInput
    transferOrderItems?: TransferOrderItemUpdateManyWithoutProductNestedInput
  }

  export type StoreProductUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    taxRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    saleReturnItems?: SaleReturnItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: StorePurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: StorePriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    transferOrderItems?: TransferOrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StoreProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    taxRuleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleItemCreateManyProductInput = {
    id?: string
    saleId: string
    productName: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type SaleReturnItemCreateManyProductInput = {
    id?: string
    returnId: string
    quantity: Decimal | DecimalJsLike | number | string
    refundAmount: Decimal | DecimalJsLike | number | string
  }

  export type StorePurchaseItemCreateManyProductInput = {
    id?: string
    purchaseOrderId: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedQty?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type StockMovementCreateManyProductInput = {
    id?: string
    storeId: string
    type: $Enums.StoreMovementType
    quantity: Decimal | DecimalJsLike | number | string
    previousStock: Decimal | DecimalJsLike | number | string
    newStock: Decimal | DecimalJsLike | number | string
    reason?: string | null
    referenceType?: string | null
    referenceId?: string | null
    performedBy?: string | null
    createdAt?: Date | string
  }

  export type StorePriceHistoryCreateManyProductInput = {
    id?: string
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    changedBy?: string | null
    changedAt?: Date | string
  }

  export type TransferOrderItemCreateManyProductInput = {
    id?: string
    transferOrderId: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type SaleItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale?: SaleUpdateOneRequiredWithoutItemsNestedInput
  }

  export type SaleItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleReturnItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    saleReturn?: SaleReturnUpdateOneRequiredWithoutItemsNestedInput
  }

  export type SaleReturnItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleReturnItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type StorePurchaseItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseOrder?: StorePurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type StorePurchaseItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type StorePurchaseItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type StockMovementUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStoreMovementTypeFieldUpdateOperationsInput | $Enums.StoreMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    previousStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    type?: EnumStoreMovementTypeFieldUpdateOperationsInput | $Enums.StoreMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    previousStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    type?: EnumStoreMovementTypeFieldUpdateOperationsInput | $Enums.StoreMovementType
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    previousStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorePriceHistoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorePriceHistoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorePriceHistoryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferOrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transferOrder?: TransferOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TransferOrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferOrderId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type TransferOrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferOrderId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type SaleItemCreateManySaleInput = {
    id?: string
    productId: string
    productName: string
    quantity: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    costPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type SalePaymentCreateManySaleInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdAt?: Date | string
  }

  export type SaleReturnCreateManySaleInput = {
    id?: string
    reason: string
    refundAmount: Decimal | DecimalJsLike | number | string
    refundMethod: $Enums.PaymentMethod
    status?: $Enums.StoreReturnStatus
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type SaleItemUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product?: StoreProductUpdateOneRequiredWithoutSaleItemsNestedInput
  }

  export type SaleItemUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleItemUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalePaymentUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalePaymentUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalePaymentUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleReturnUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumStoreReturnStatusFieldUpdateOperationsInput | $Enums.StoreReturnStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: SaleReturnItemUpdateManyWithoutSaleReturnNestedInput
  }

  export type SaleReturnUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumStoreReturnStatusFieldUpdateOperationsInput | $Enums.StoreReturnStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: SaleReturnItemUncheckedUpdateManyWithoutSaleReturnNestedInput
  }

  export type SaleReturnUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumStoreReturnStatusFieldUpdateOperationsInput | $Enums.StoreReturnStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SaleReturnItemCreateManySaleReturnInput = {
    id?: string
    productId: string
    quantity: Decimal | DecimalJsLike | number | string
    refundAmount: Decimal | DecimalJsLike | number | string
  }

  export type SaleReturnItemUpdateWithoutSaleReturnInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product?: StoreProductUpdateOneRequiredWithoutSaleReturnItemsNestedInput
  }

  export type SaleReturnItemUncheckedUpdateWithoutSaleReturnInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleReturnItemUncheckedUpdateManyWithoutSaleReturnInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refundAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type StorePurchaseOrderCreateManySupplierInput = {
    id?: string
    storeId: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    status?: $Enums.StorePurchaseStatus
    notes?: string | null
    expectedDate?: Date | string | null
    receivedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorePurchaseOrderUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStorePurchaseStatusFieldUpdateOperationsInput | $Enums.StorePurchaseStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutPurchasesNestedInput
    items?: StorePurchaseItemUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type StorePurchaseOrderUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStorePurchaseStatusFieldUpdateOperationsInput | $Enums.StorePurchaseStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: StorePurchaseItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type StorePurchaseOrderUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStorePurchaseStatusFieldUpdateOperationsInput | $Enums.StorePurchaseStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorePurchaseItemCreateManyPurchaseOrderInput = {
    id?: string
    productId: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedQty?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type StorePurchaseItemUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product?: StoreProductUpdateOneRequiredWithoutPurchaseItemsNestedInput
  }

  export type StorePurchaseItemUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type StorePurchaseItemUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type TransferOrderItemCreateManyTransferOrderInput = {
    id?: string
    productId: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type TransferOrderItemUpdateWithoutTransferOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    product?: StoreProductUpdateOneRequiredWithoutTransferOrderItemsNestedInput
  }

  export type TransferOrderItemUncheckedUpdateWithoutTransferOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type TransferOrderItemUncheckedUpdateManyWithoutTransferOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type SaleCreateManyCustomerInput = {
    id?: string
    storeId: string
    saleNumber: string
    employeeId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountType?: $Enums.StoreDiscountType | null
    total: Decimal | DecimalJsLike | number | string
    paidAmount: Decimal | DecimalJsLike | number | string
    changeAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.StoreSaleStatus
    notes?: string | null
    receiptPrinted?: boolean
    fiscalPrinted?: boolean
    fiscalNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreLoyaltyTransactionCreateManyCustomerInput = {
    id?: string
    type: $Enums.LoyaltyTransactionType
    points: number
    saleId?: string | null
    description?: string | null
    createdAt?: Date | string
  }

  export type SaleUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumStoreDiscountTypeFieldUpdateOperationsInput | $Enums.StoreDiscountType | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFieldUpdateOperationsInput | $Enums.StoreSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSalesNestedInput
    employee?: StoreEmployeeUpdateOneWithoutSalesNestedInput
    items?: SaleItemUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUpdateManyWithoutSaleNestedInput
    returns?: SaleReturnUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumStoreDiscountTypeFieldUpdateOperationsInput | $Enums.StoreDiscountType | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFieldUpdateOperationsInput | $Enums.StoreSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SaleItemUncheckedUpdateManyWithoutSaleNestedInput
    payments?: SalePaymentUncheckedUpdateManyWithoutSaleNestedInput
    returns?: SaleReturnUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    saleNumber?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableEnumStoreDiscountTypeFieldUpdateOperationsInput | $Enums.StoreDiscountType | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    changeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumStoreSaleStatusFieldUpdateOperationsInput | $Enums.StoreSaleStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalPrinted?: BoolFieldUpdateOperationsInput | boolean
    fiscalNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreLoyaltyTransactionUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    points?: IntFieldUpdateOperationsInput | number
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreLoyaltyTransactionUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    points?: IntFieldUpdateOperationsInput | number
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreLoyaltyTransactionUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumLoyaltyTransactionTypeFieldUpdateOperationsInput | $Enums.LoyaltyTransactionType
    points?: IntFieldUpdateOperationsInput | number
    saleId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreProductCreateManyTaxRuleInput = {
    id?: string
    storeId: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    nameKa?: string | null
    description?: string | null
    imageUrl?: string | null
    costPrice: Decimal | DecimalJsLike | number | string
    sellingPrice: Decimal | DecimalJsLike | number | string
    wholesalePrice?: Decimal | DecimalJsLike | number | string | null
    currentStock?: Decimal | DecimalJsLike | number | string
    minStock?: Decimal | DecimalJsLike | number | string
    maxStock?: Decimal | DecimalJsLike | number | string | null
    unit?: string
    isActive?: boolean
    isFavorite?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreProductUpdateWithoutTaxRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneWithoutProductsNestedInput
    saleItems?: SaleItemUpdateManyWithoutProductNestedInput
    saleReturnItems?: SaleReturnItemUpdateManyWithoutProductNestedInput
    purchaseItems?: StorePurchaseItemUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUpdateManyWithoutProductNestedInput
    priceHistory?: StorePriceHistoryUpdateManyWithoutProductNestedInput
    transferOrderItems?: TransferOrderItemUpdateManyWithoutProductNestedInput
  }

  export type StoreProductUncheckedUpdateWithoutTaxRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleItems?: SaleItemUncheckedUpdateManyWithoutProductNestedInput
    saleReturnItems?: SaleReturnItemUncheckedUpdateManyWithoutProductNestedInput
    purchaseItems?: StorePurchaseItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: StorePriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    transferOrderItems?: TransferOrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StoreProductUncheckedUpdateManyWithoutTaxRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    nameKa?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wholesalePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxStock?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use OrganizationCountOutputTypeDefaultArgs instead
     */
    export type OrganizationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreCountOutputTypeDefaultArgs instead
     */
    export type StoreCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreEmployeeCountOutputTypeDefaultArgs instead
     */
    export type StoreEmployeeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreEmployeeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCategoryCountOutputTypeDefaultArgs instead
     */
    export type ProductCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreProductCountOutputTypeDefaultArgs instead
     */
    export type StoreProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleCountOutputTypeDefaultArgs instead
     */
    export type SaleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleReturnCountOutputTypeDefaultArgs instead
     */
    export type SaleReturnCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleReturnCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreSupplierCountOutputTypeDefaultArgs instead
     */
    export type StoreSupplierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreSupplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StorePurchaseOrderCountOutputTypeDefaultArgs instead
     */
    export type StorePurchaseOrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StorePurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransferOrderCountOutputTypeDefaultArgs instead
     */
    export type TransferOrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransferOrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreCustomerCountOutputTypeDefaultArgs instead
     */
    export type StoreCustomerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreCustomerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreTaxRuleCountOutputTypeDefaultArgs instead
     */
    export type StoreTaxRuleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreTaxRuleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationDefaultArgs instead
     */
    export type OrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreDefaultArgs instead
     */
    export type StoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreEmployeeDefaultArgs instead
     */
    export type StoreEmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreEmployeeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCategoryDefaultArgs instead
     */
    export type ProductCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreProductDefaultArgs instead
     */
    export type StoreProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StorePriceHistoryDefaultArgs instead
     */
    export type StorePriceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StorePriceHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleDefaultArgs instead
     */
    export type SaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleItemDefaultArgs instead
     */
    export type SaleItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalePaymentDefaultArgs instead
     */
    export type SalePaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalePaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleReturnDefaultArgs instead
     */
    export type SaleReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleReturnDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleReturnItemDefaultArgs instead
     */
    export type SaleReturnItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleReturnItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreSupplierDefaultArgs instead
     */
    export type StoreSupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreSupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StorePurchaseOrderDefaultArgs instead
     */
    export type StorePurchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StorePurchaseOrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StorePurchaseItemDefaultArgs instead
     */
    export type StorePurchaseItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StorePurchaseItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockMovementDefaultArgs instead
     */
    export type StockMovementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockMovementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransferOrderDefaultArgs instead
     */
    export type TransferOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransferOrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransferOrderItemDefaultArgs instead
     */
    export type TransferOrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransferOrderItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreCustomerDefaultArgs instead
     */
    export type StoreCustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreCustomerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreLoyaltyConfigDefaultArgs instead
     */
    export type StoreLoyaltyConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreLoyaltyConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreLoyaltyTransactionDefaultArgs instead
     */
    export type StoreLoyaltyTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreLoyaltyTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreTaxRuleDefaultArgs instead
     */
    export type StoreTaxRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreTaxRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StorePaymentConfigDefaultArgs instead
     */
    export type StorePaymentConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StorePaymentConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreReceiptConfigDefaultArgs instead
     */
    export type StoreReceiptConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreReceiptConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreDeviceConfigDefaultArgs instead
     */
    export type StoreDeviceConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreDeviceConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreIntegrationDefaultArgs instead
     */
    export type StoreIntegrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreIntegrationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}