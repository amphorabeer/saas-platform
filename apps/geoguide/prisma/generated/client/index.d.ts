
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Recipe
 * 
 */
export type Recipe = $Result.DefaultSelection<Prisma.$RecipePayload>
/**
 * Model RecipeIngredient
 * 
 */
export type RecipeIngredient = $Result.DefaultSelection<Prisma.$RecipeIngredientPayload>
/**
 * Model InventoryItem
 * 
 */
export type InventoryItem = $Result.DefaultSelection<Prisma.$InventoryItemPayload>
/**
 * Model InventoryLedger
 * 
 */
export type InventoryLedger = $Result.DefaultSelection<Prisma.$InventoryLedgerPayload>
/**
 * Model IngredientCatalog
 * 
 */
export type IngredientCatalog = $Result.DefaultSelection<Prisma.$IngredientCatalogPayload>
/**
 * Model Batch
 * 
 */
export type Batch = $Result.DefaultSelection<Prisma.$BatchPayload>
/**
 * Model BatchIngredient
 * 
 */
export type BatchIngredient = $Result.DefaultSelection<Prisma.$BatchIngredientPayload>
/**
 * Model GravityReading
 * 
 */
export type GravityReading = $Result.DefaultSelection<Prisma.$GravityReadingPayload>
/**
 * Model BatchTimeline
 * 
 */
export type BatchTimeline = $Result.DefaultSelection<Prisma.$BatchTimelinePayload>
/**
 * Model Tank
 * 
 */
export type Tank = $Result.DefaultSelection<Prisma.$TankPayload>
/**
 * Model TankOccupation
 * 
 */
export type TankOccupation = $Result.DefaultSelection<Prisma.$TankOccupationPayload>
/**
 * Model PackagingRun
 * 
 */
export type PackagingRun = $Result.DefaultSelection<Prisma.$PackagingRunPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model SalesOrder
 * 
 */
export type SalesOrder = $Result.DefaultSelection<Prisma.$SalesOrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model Budget
 * 
 */
export type Budget = $Result.DefaultSelection<Prisma.$BudgetPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model BlendingConfig
 * 
 */
export type BlendingConfig = $Result.DefaultSelection<Prisma.$BlendingConfigPayload>
/**
 * Model CIPLog
 * 
 */
export type CIPLog = $Result.DefaultSelection<Prisma.$CIPLogPayload>
/**
 * Model Equipment
 * 
 */
export type Equipment = $Result.DefaultSelection<Prisma.$EquipmentPayload>
/**
 * Model Lot
 * 
 */
export type Lot = $Result.DefaultSelection<Prisma.$LotPayload>
/**
 * Model LotBatch
 * 
 */
export type LotBatch = $Result.DefaultSelection<Prisma.$LotBatchPayload>
/**
 * Model LotReading
 * 
 */
export type LotReading = $Result.DefaultSelection<Prisma.$LotReadingPayload>
/**
 * Model MaintenanceLog
 * 
 */
export type MaintenanceLog = $Result.DefaultSelection<Prisma.$MaintenanceLogPayload>
/**
 * Model ProblemReport
 * 
 */
export type ProblemReport = $Result.DefaultSelection<Prisma.$ProblemReportPayload>
/**
 * Model TankAssignment
 * 
 */
export type TankAssignment = $Result.DefaultSelection<Prisma.$TankAssignmentPayload>
/**
 * Model Transfer
 * 
 */
export type Transfer = $Result.DefaultSelection<Prisma.$TransferPayload>
/**
 * Model Keg
 * 
 */
export type Keg = $Result.DefaultSelection<Prisma.$KegPayload>
/**
 * Model KegMovement
 * 
 */
export type KegMovement = $Result.DefaultSelection<Prisma.$KegMovementPayload>
/**
 * Model QCTest
 * 
 */
export type QCTest = $Result.DefaultSelection<Prisma.$QCTestPayload>
/**
 * Model Configuration
 * 
 */
export type Configuration = $Result.DefaultSelection<Prisma.$ConfigurationPayload>
/**
 * Model Museum
 * 
 */
export type Museum = $Result.DefaultSelection<Prisma.$MuseumPayload>
/**
 * Model Tour
 * 
 */
export type Tour = $Result.DefaultSelection<Prisma.$TourPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PlanType: {
  STARTER: 'STARTER',
  PROFESSIONAL: 'PROFESSIONAL',
  ENTERPRISE: 'ENTERPRISE'
};

export type PlanType = (typeof PlanType)[keyof typeof PlanType]


export const UserRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  OPERATOR: 'OPERATOR',
  VIEWER: 'VIEWER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const RecipeStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  ARCHIVED: 'ARCHIVED'
};

export type RecipeStatus = (typeof RecipeStatus)[keyof typeof RecipeStatus]


export const IngredientCategory: {
  MALT: 'MALT',
  HOPS: 'HOPS',
  YEAST: 'YEAST',
  ADJUNCT: 'ADJUNCT',
  WATER_CHEMISTRY: 'WATER_CHEMISTRY'
};

export type IngredientCategory = (typeof IngredientCategory)[keyof typeof IngredientCategory]


export const InventoryCategory: {
  RAW_MATERIAL: 'RAW_MATERIAL',
  PACKAGING: 'PACKAGING',
  FINISHED_GOOD: 'FINISHED_GOOD',
  CONSUMABLE: 'CONSUMABLE'
};

export type InventoryCategory = (typeof InventoryCategory)[keyof typeof InventoryCategory]


export const LedgerEntryType: {
  PURCHASE: 'PURCHASE',
  CONSUMPTION: 'CONSUMPTION',
  PRODUCTION: 'PRODUCTION',
  ADJUSTMENT: 'ADJUSTMENT',
  ADJUSTMENT_ADD: 'ADJUSTMENT_ADD',
  ADJUSTMENT_REMOVE: 'ADJUSTMENT_REMOVE',
  WASTE: 'WASTE',
  SALE: 'SALE',
  RETURN: 'RETURN',
  REVERSAL: 'REVERSAL',
  TRANSFER: 'TRANSFER'
};

export type LedgerEntryType = (typeof LedgerEntryType)[keyof typeof LedgerEntryType]


export const BatchStatus: {
  PLANNED: 'PLANNED',
  BREWING: 'BREWING',
  FERMENTING: 'FERMENTING',
  CONDITIONING: 'CONDITIONING',
  READY: 'READY',
  PACKAGING: 'PACKAGING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type BatchStatus = (typeof BatchStatus)[keyof typeof BatchStatus]


export const TimelineEventType: {
  CREATED: 'CREATED',
  STARTED: 'STARTED',
  MASH: 'MASH',
  BOIL: 'BOIL',
  TRANSFER: 'TRANSFER',
  GRAVITY_READING: 'GRAVITY_READING',
  DRY_HOP: 'DRY_HOP',
  TEMPERATURE_CHANGE: 'TEMPERATURE_CHANGE',
  NOTE: 'NOTE',
  COMPLETED: 'COMPLETED',
  INGREDIENTS_RESERVED: 'INGREDIENTS_RESERVED',
  BREWING_STARTED: 'BREWING_STARTED',
  MASH_COMPLETE: 'MASH_COMPLETE',
  BOIL_COMPLETE: 'BOIL_COMPLETE',
  TRANSFER_TO_FERMENTER: 'TRANSFER_TO_FERMENTER',
  FERMENTATION_STARTED: 'FERMENTATION_STARTED',
  DRY_HOP_ADDED: 'DRY_HOP_ADDED',
  CONDITIONING_STARTED: 'CONDITIONING_STARTED',
  READY_FOR_PACKAGING: 'READY_FOR_PACKAGING',
  PACKAGING_STARTED: 'PACKAGING_STARTED',
  PACKAGING_COMPLETE: 'PACKAGING_COMPLETE',
  CANCELLED: 'CANCELLED'
};

export type TimelineEventType = (typeof TimelineEventType)[keyof typeof TimelineEventType]


export const TankType: {
  FERMENTER: 'FERMENTER',
  BRITE: 'BRITE',
  UNITANK: 'UNITANK',
  KETTLE: 'KETTLE',
  MASH_TUN: 'MASH_TUN',
  HLT: 'HLT'
};

export type TankType = (typeof TankType)[keyof typeof TankType]


export const TankStatus: {
  AVAILABLE: 'AVAILABLE',
  OCCUPIED: 'OCCUPIED',
  CLEANING: 'CLEANING',
  MAINTENANCE: 'MAINTENANCE',
  OUT_OF_SERVICE: 'OUT_OF_SERVICE'
};

export type TankStatus = (typeof TankStatus)[keyof typeof TankStatus]


export const LotPhase: {
  FERMENTATION: 'FERMENTATION',
  CONDITIONING: 'CONDITIONING',
  BRIGHT: 'BRIGHT',
  PACKAGING: 'PACKAGING'
};

export type LotPhase = (typeof LotPhase)[keyof typeof LotPhase]


export const TankCapability: {
  FERMENTING: 'FERMENTING',
  CONDITIONING: 'CONDITIONING',
  BREWING: 'BREWING',
  BRIGHT: 'BRIGHT',
  STORAGE: 'STORAGE'
};

export type TankCapability = (typeof TankCapability)[keyof typeof TankCapability]


export const OccupationPhase: {
  FERMENTATION: 'FERMENTATION',
  CONDITIONING: 'CONDITIONING',
  STORAGE: 'STORAGE'
};

export type OccupationPhase = (typeof OccupationPhase)[keyof typeof OccupationPhase]


export const PackageType: {
  KEG_50: 'KEG_50',
  KEG_30: 'KEG_30',
  KEG_20: 'KEG_20',
  BOTTLE_750: 'BOTTLE_750',
  BOTTLE_500: 'BOTTLE_500',
  BOTTLE_330: 'BOTTLE_330',
  CAN_500: 'CAN_500',
  CAN_330: 'CAN_330'
};

export type PackageType = (typeof PackageType)[keyof typeof PackageType]


export const CustomerType: {
  RETAIL: 'RETAIL',
  WHOLESALE: 'WHOLESALE',
  DISTRIBUTOR: 'DISTRIBUTOR',
  RESTAURANT: 'RESTAURANT',
  BAR: 'BAR',
  EXPORT: 'EXPORT'
};

export type CustomerType = (typeof CustomerType)[keyof typeof CustomerType]


export const OrderStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  PROCESSING: 'PROCESSING',
  READY: 'READY',
  SHIPPED: 'SHIPPED',
  DELIVERED: 'DELIVERED',
  CANCELLED: 'CANCELLED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PARTIAL: 'PARTIAL',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const TransactionType: {
  INCOME: 'INCOME',
  EXPENSE: 'EXPENSE',
  TRANSFER: 'TRANSFER'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const IncomeCategory: {
  SALE: 'SALE',
  DEPOSIT: 'DEPOSIT',
  REFUND: 'REFUND',
  OTHER: 'OTHER'
};

export type IncomeCategory = (typeof IncomeCategory)[keyof typeof IncomeCategory]


export const ExpenseCategory: {
  INGREDIENTS: 'INGREDIENTS',
  PACKAGING: 'PACKAGING',
  EQUIPMENT: 'EQUIPMENT',
  UTILITIES: 'UTILITIES',
  SALARY: 'SALARY',
  RENT: 'RENT',
  MARKETING: 'MARKETING',
  MAINTENANCE: 'MAINTENANCE',
  TRANSPORT: 'TRANSPORT',
  OTHER: 'OTHER'
};

export type ExpenseCategory = (typeof ExpenseCategory)[keyof typeof ExpenseCategory]


export const PaymentMethod: {
  CASH: 'CASH',
  BANK_TRANSFER: 'BANK_TRANSFER',
  CARD: 'CARD',
  CHECK: 'CHECK'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const InvoiceType: {
  OUTGOING: 'OUTGOING',
  INCOMING: 'INCOMING'
};

export type InvoiceType = (typeof InvoiceType)[keyof typeof InvoiceType]


export const InvoiceStatus: {
  DRAFT: 'DRAFT',
  SENT: 'SENT',
  PAID: 'PAID',
  PARTIAL: 'PARTIAL',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const LotStatus: {
  PLANNED: 'PLANNED',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type LotStatus = (typeof LotStatus)[keyof typeof LotStatus]


export const ReadingType: {
  GRAVITY: 'GRAVITY',
  TEMPERATURE: 'TEMPERATURE',
  PH: 'PH',
  PRESSURE: 'PRESSURE',
  DISSOLVED_O2: 'DISSOLVED_O2',
  TURBIDITY: 'TURBIDITY'
};

export type ReadingType = (typeof ReadingType)[keyof typeof ReadingType]


export const AssignmentStatus: {
  PLANNED: 'PLANNED',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type AssignmentStatus = (typeof AssignmentStatus)[keyof typeof AssignmentStatus]


export const TransferType: {
  FERMENT_TO_CONDITION: 'FERMENT_TO_CONDITION',
  CONDITION_TO_BRIGHT: 'CONDITION_TO_BRIGHT',
  TANK_TO_TANK: 'TANK_TO_TANK',
  BLEND: 'BLEND',
  SPLIT: 'SPLIT'
};

export type TransferType = (typeof TransferType)[keyof typeof TransferType]


export const TransferStatus: {
  PLANNED: 'PLANNED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type TransferStatus = (typeof TransferStatus)[keyof typeof TransferStatus]


export const KegStatus: {
  AVAILABLE: 'AVAILABLE',
  FILLED: 'FILLED',
  WITH_CUSTOMER: 'WITH_CUSTOMER',
  IN_TRANSIT: 'IN_TRANSIT',
  CLEANING: 'CLEANING',
  DAMAGED: 'DAMAGED',
  LOST: 'LOST'
};

export type KegStatus = (typeof KegStatus)[keyof typeof KegStatus]


export const KegCondition: {
  GOOD: 'GOOD',
  NEEDS_CLEANING: 'NEEDS_CLEANING',
  DAMAGED: 'DAMAGED'
};

export type KegCondition = (typeof KegCondition)[keyof typeof KegCondition]


export const KegAction: {
  CREATED: 'CREATED',
  FILLED: 'FILLED',
  SHIPPED: 'SHIPPED',
  RETURNED: 'RETURNED',
  CLEANED: 'CLEANED',
  DAMAGED: 'DAMAGED',
  LOST: 'LOST',
  REPAIRED: 'REPAIRED'
};

export type KegAction = (typeof KegAction)[keyof typeof KegAction]


export const QCTestType: {
  GRAVITY: 'GRAVITY',
  TEMPERATURE: 'TEMPERATURE',
  PH: 'PH',
  DISSOLVED_O2: 'DISSOLVED_O2',
  TURBIDITY: 'TURBIDITY',
  COLOR: 'COLOR',
  BITTERNESS: 'BITTERNESS',
  ALCOHOL: 'ALCOHOL',
  CARBONATION: 'CARBONATION',
  APPEARANCE: 'APPEARANCE',
  AROMA: 'AROMA',
  TASTE: 'TASTE',
  MICROBIOLOGICAL: 'MICROBIOLOGICAL'
};

export type QCTestType = (typeof QCTestType)[keyof typeof QCTestType]


export const QCTestStatus: {
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  PASSED: 'PASSED',
  WARNING: 'WARNING',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type QCTestStatus = (typeof QCTestStatus)[keyof typeof QCTestStatus]


export const QCTestPriority: {
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW'
};

export type QCTestPriority = (typeof QCTestPriority)[keyof typeof QCTestPriority]

}

export type PlanType = $Enums.PlanType

export const PlanType: typeof $Enums.PlanType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type RecipeStatus = $Enums.RecipeStatus

export const RecipeStatus: typeof $Enums.RecipeStatus

export type IngredientCategory = $Enums.IngredientCategory

export const IngredientCategory: typeof $Enums.IngredientCategory

export type InventoryCategory = $Enums.InventoryCategory

export const InventoryCategory: typeof $Enums.InventoryCategory

export type LedgerEntryType = $Enums.LedgerEntryType

export const LedgerEntryType: typeof $Enums.LedgerEntryType

export type BatchStatus = $Enums.BatchStatus

export const BatchStatus: typeof $Enums.BatchStatus

export type TimelineEventType = $Enums.TimelineEventType

export const TimelineEventType: typeof $Enums.TimelineEventType

export type TankType = $Enums.TankType

export const TankType: typeof $Enums.TankType

export type TankStatus = $Enums.TankStatus

export const TankStatus: typeof $Enums.TankStatus

export type LotPhase = $Enums.LotPhase

export const LotPhase: typeof $Enums.LotPhase

export type TankCapability = $Enums.TankCapability

export const TankCapability: typeof $Enums.TankCapability

export type OccupationPhase = $Enums.OccupationPhase

export const OccupationPhase: typeof $Enums.OccupationPhase

export type PackageType = $Enums.PackageType

export const PackageType: typeof $Enums.PackageType

export type CustomerType = $Enums.CustomerType

export const CustomerType: typeof $Enums.CustomerType

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type IncomeCategory = $Enums.IncomeCategory

export const IncomeCategory: typeof $Enums.IncomeCategory

export type ExpenseCategory = $Enums.ExpenseCategory

export const ExpenseCategory: typeof $Enums.ExpenseCategory

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type InvoiceType = $Enums.InvoiceType

export const InvoiceType: typeof $Enums.InvoiceType

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type LotStatus = $Enums.LotStatus

export const LotStatus: typeof $Enums.LotStatus

export type ReadingType = $Enums.ReadingType

export const ReadingType: typeof $Enums.ReadingType

export type AssignmentStatus = $Enums.AssignmentStatus

export const AssignmentStatus: typeof $Enums.AssignmentStatus

export type TransferType = $Enums.TransferType

export const TransferType: typeof $Enums.TransferType

export type TransferStatus = $Enums.TransferStatus

export const TransferStatus: typeof $Enums.TransferStatus

export type KegStatus = $Enums.KegStatus

export const KegStatus: typeof $Enums.KegStatus

export type KegCondition = $Enums.KegCondition

export const KegCondition: typeof $Enums.KegCondition

export type KegAction = $Enums.KegAction

export const KegAction: typeof $Enums.KegAction

export type QCTestType = $Enums.QCTestType

export const QCTestType: typeof $Enums.QCTestType

export type QCTestStatus = $Enums.QCTestStatus

export const QCTestStatus: typeof $Enums.QCTestStatus

export type QCTestPriority = $Enums.QCTestPriority

export const QCTestPriority: typeof $Enums.QCTestPriority

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.recipe`: Exposes CRUD operations for the **Recipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recipes
    * const recipes = await prisma.recipe.findMany()
    * ```
    */
  get recipe(): Prisma.RecipeDelegate<ExtArgs>;

  /**
   * `prisma.recipeIngredient`: Exposes CRUD operations for the **RecipeIngredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeIngredients
    * const recipeIngredients = await prisma.recipeIngredient.findMany()
    * ```
    */
  get recipeIngredient(): Prisma.RecipeIngredientDelegate<ExtArgs>;

  /**
   * `prisma.inventoryItem`: Exposes CRUD operations for the **InventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryItems
    * const inventoryItems = await prisma.inventoryItem.findMany()
    * ```
    */
  get inventoryItem(): Prisma.InventoryItemDelegate<ExtArgs>;

  /**
   * `prisma.inventoryLedger`: Exposes CRUD operations for the **InventoryLedger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryLedgers
    * const inventoryLedgers = await prisma.inventoryLedger.findMany()
    * ```
    */
  get inventoryLedger(): Prisma.InventoryLedgerDelegate<ExtArgs>;

  /**
   * `prisma.ingredientCatalog`: Exposes CRUD operations for the **IngredientCatalog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IngredientCatalogs
    * const ingredientCatalogs = await prisma.ingredientCatalog.findMany()
    * ```
    */
  get ingredientCatalog(): Prisma.IngredientCatalogDelegate<ExtArgs>;

  /**
   * `prisma.batch`: Exposes CRUD operations for the **Batch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Batches
    * const batches = await prisma.batch.findMany()
    * ```
    */
  get batch(): Prisma.BatchDelegate<ExtArgs>;

  /**
   * `prisma.batchIngredient`: Exposes CRUD operations for the **BatchIngredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BatchIngredients
    * const batchIngredients = await prisma.batchIngredient.findMany()
    * ```
    */
  get batchIngredient(): Prisma.BatchIngredientDelegate<ExtArgs>;

  /**
   * `prisma.gravityReading`: Exposes CRUD operations for the **GravityReading** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GravityReadings
    * const gravityReadings = await prisma.gravityReading.findMany()
    * ```
    */
  get gravityReading(): Prisma.GravityReadingDelegate<ExtArgs>;

  /**
   * `prisma.batchTimeline`: Exposes CRUD operations for the **BatchTimeline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BatchTimelines
    * const batchTimelines = await prisma.batchTimeline.findMany()
    * ```
    */
  get batchTimeline(): Prisma.BatchTimelineDelegate<ExtArgs>;

  /**
   * `prisma.tank`: Exposes CRUD operations for the **Tank** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tanks
    * const tanks = await prisma.tank.findMany()
    * ```
    */
  get tank(): Prisma.TankDelegate<ExtArgs>;

  /**
   * `prisma.tankOccupation`: Exposes CRUD operations for the **TankOccupation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TankOccupations
    * const tankOccupations = await prisma.tankOccupation.findMany()
    * ```
    */
  get tankOccupation(): Prisma.TankOccupationDelegate<ExtArgs>;

  /**
   * `prisma.packagingRun`: Exposes CRUD operations for the **PackagingRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PackagingRuns
    * const packagingRuns = await prisma.packagingRun.findMany()
    * ```
    */
  get packagingRun(): Prisma.PackagingRunDelegate<ExtArgs>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs>;

  /**
   * `prisma.salesOrder`: Exposes CRUD operations for the **SalesOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesOrders
    * const salesOrders = await prisma.salesOrder.findMany()
    * ```
    */
  get salesOrder(): Prisma.SalesOrderDelegate<ExtArgs>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs>;

  /**
   * `prisma.budget`: Exposes CRUD operations for the **Budget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budgets
    * const budgets = await prisma.budget.findMany()
    * ```
    */
  get budget(): Prisma.BudgetDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.blendingConfig`: Exposes CRUD operations for the **BlendingConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlendingConfigs
    * const blendingConfigs = await prisma.blendingConfig.findMany()
    * ```
    */
  get blendingConfig(): Prisma.BlendingConfigDelegate<ExtArgs>;

  /**
   * `prisma.cIPLog`: Exposes CRUD operations for the **CIPLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CIPLogs
    * const cIPLogs = await prisma.cIPLog.findMany()
    * ```
    */
  get cIPLog(): Prisma.CIPLogDelegate<ExtArgs>;

  /**
   * `prisma.equipment`: Exposes CRUD operations for the **Equipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment
    * const equipment = await prisma.equipment.findMany()
    * ```
    */
  get equipment(): Prisma.EquipmentDelegate<ExtArgs>;

  /**
   * `prisma.lot`: Exposes CRUD operations for the **Lot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lots
    * const lots = await prisma.lot.findMany()
    * ```
    */
  get lot(): Prisma.LotDelegate<ExtArgs>;

  /**
   * `prisma.lotBatch`: Exposes CRUD operations for the **LotBatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LotBatches
    * const lotBatches = await prisma.lotBatch.findMany()
    * ```
    */
  get lotBatch(): Prisma.LotBatchDelegate<ExtArgs>;

  /**
   * `prisma.lotReading`: Exposes CRUD operations for the **LotReading** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LotReadings
    * const lotReadings = await prisma.lotReading.findMany()
    * ```
    */
  get lotReading(): Prisma.LotReadingDelegate<ExtArgs>;

  /**
   * `prisma.maintenanceLog`: Exposes CRUD operations for the **MaintenanceLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenanceLogs
    * const maintenanceLogs = await prisma.maintenanceLog.findMany()
    * ```
    */
  get maintenanceLog(): Prisma.MaintenanceLogDelegate<ExtArgs>;

  /**
   * `prisma.problemReport`: Exposes CRUD operations for the **ProblemReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProblemReports
    * const problemReports = await prisma.problemReport.findMany()
    * ```
    */
  get problemReport(): Prisma.ProblemReportDelegate<ExtArgs>;

  /**
   * `prisma.tankAssignment`: Exposes CRUD operations for the **TankAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TankAssignments
    * const tankAssignments = await prisma.tankAssignment.findMany()
    * ```
    */
  get tankAssignment(): Prisma.TankAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.transfer`: Exposes CRUD operations for the **Transfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transfers
    * const transfers = await prisma.transfer.findMany()
    * ```
    */
  get transfer(): Prisma.TransferDelegate<ExtArgs>;

  /**
   * `prisma.keg`: Exposes CRUD operations for the **Keg** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kegs
    * const kegs = await prisma.keg.findMany()
    * ```
    */
  get keg(): Prisma.KegDelegate<ExtArgs>;

  /**
   * `prisma.kegMovement`: Exposes CRUD operations for the **KegMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KegMovements
    * const kegMovements = await prisma.kegMovement.findMany()
    * ```
    */
  get kegMovement(): Prisma.KegMovementDelegate<ExtArgs>;

  /**
   * `prisma.qCTest`: Exposes CRUD operations for the **QCTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QCTests
    * const qCTests = await prisma.qCTest.findMany()
    * ```
    */
  get qCTest(): Prisma.QCTestDelegate<ExtArgs>;

  /**
   * `prisma.configuration`: Exposes CRUD operations for the **Configuration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configurations
    * const configurations = await prisma.configuration.findMany()
    * ```
    */
  get configuration(): Prisma.ConfigurationDelegate<ExtArgs>;

  /**
   * `prisma.museum`: Exposes CRUD operations for the **Museum** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Museums
    * const museums = await prisma.museum.findMany()
    * ```
    */
  get museum(): Prisma.MuseumDelegate<ExtArgs>;

  /**
   * `prisma.tour`: Exposes CRUD operations for the **Tour** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tours
    * const tours = await prisma.tour.findMany()
    * ```
    */
  get tour(): Prisma.TourDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    Recipe: 'Recipe',
    RecipeIngredient: 'RecipeIngredient',
    InventoryItem: 'InventoryItem',
    InventoryLedger: 'InventoryLedger',
    IngredientCatalog: 'IngredientCatalog',
    Batch: 'Batch',
    BatchIngredient: 'BatchIngredient',
    GravityReading: 'GravityReading',
    BatchTimeline: 'BatchTimeline',
    Tank: 'Tank',
    TankOccupation: 'TankOccupation',
    PackagingRun: 'PackagingRun',
    Customer: 'Customer',
    Supplier: 'Supplier',
    SalesOrder: 'SalesOrder',
    OrderItem: 'OrderItem',
    Transaction: 'Transaction',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    Payment: 'Payment',
    Expense: 'Expense',
    Budget: 'Budget',
    AuditLog: 'AuditLog',
    BlendingConfig: 'BlendingConfig',
    CIPLog: 'CIPLog',
    Equipment: 'Equipment',
    Lot: 'Lot',
    LotBatch: 'LotBatch',
    LotReading: 'LotReading',
    MaintenanceLog: 'MaintenanceLog',
    ProblemReport: 'ProblemReport',
    TankAssignment: 'TankAssignment',
    Transfer: 'Transfer',
    Keg: 'Keg',
    KegMovement: 'KegMovement',
    QCTest: 'QCTest',
    Configuration: 'Configuration',
    Museum: 'Museum',
    Tour: 'Tour'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "tenant" | "user" | "recipe" | "recipeIngredient" | "inventoryItem" | "inventoryLedger" | "ingredientCatalog" | "batch" | "batchIngredient" | "gravityReading" | "batchTimeline" | "tank" | "tankOccupation" | "packagingRun" | "customer" | "supplier" | "salesOrder" | "orderItem" | "transaction" | "invoice" | "invoiceItem" | "payment" | "expense" | "budget" | "auditLog" | "blendingConfig" | "cIPLog" | "equipment" | "lot" | "lotBatch" | "lotReading" | "maintenanceLog" | "problemReport" | "tankAssignment" | "transfer" | "keg" | "kegMovement" | "qCTest" | "configuration" | "museum" | "tour"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Recipe: {
        payload: Prisma.$RecipePayload<ExtArgs>
        fields: Prisma.RecipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findFirst: {
            args: Prisma.RecipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findMany: {
            args: Prisma.RecipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          create: {
            args: Prisma.RecipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          createMany: {
            args: Prisma.RecipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          delete: {
            args: Prisma.RecipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          update: {
            args: Prisma.RecipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          deleteMany: {
            args: Prisma.RecipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          aggregate: {
            args: Prisma.RecipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipe>
          }
          groupBy: {
            args: Prisma.RecipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeCountAggregateOutputType> | number
          }
        }
      }
      RecipeIngredient: {
        payload: Prisma.$RecipeIngredientPayload<ExtArgs>
        fields: Prisma.RecipeIngredientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeIngredientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeIngredientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          findFirst: {
            args: Prisma.RecipeIngredientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeIngredientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          findMany: {
            args: Prisma.RecipeIngredientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>[]
          }
          create: {
            args: Prisma.RecipeIngredientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          createMany: {
            args: Prisma.RecipeIngredientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeIngredientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>[]
          }
          delete: {
            args: Prisma.RecipeIngredientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          update: {
            args: Prisma.RecipeIngredientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          deleteMany: {
            args: Prisma.RecipeIngredientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeIngredientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecipeIngredientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          aggregate: {
            args: Prisma.RecipeIngredientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipeIngredient>
          }
          groupBy: {
            args: Prisma.RecipeIngredientGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeIngredientGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeIngredientCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeIngredientCountAggregateOutputType> | number
          }
        }
      }
      InventoryItem: {
        payload: Prisma.$InventoryItemPayload<ExtArgs>
        fields: Prisma.InventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findMany: {
            args: Prisma.InventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          create: {
            args: Prisma.InventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          createMany: {
            args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          delete: {
            args: Prisma.InventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          update: {
            args: Prisma.InventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryItem>
          }
          groupBy: {
            args: Prisma.InventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemCountAggregateOutputType> | number
          }
        }
      }
      InventoryLedger: {
        payload: Prisma.$InventoryLedgerPayload<ExtArgs>
        fields: Prisma.InventoryLedgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryLedgerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryLedgerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload>
          }
          findFirst: {
            args: Prisma.InventoryLedgerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryLedgerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload>
          }
          findMany: {
            args: Prisma.InventoryLedgerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload>[]
          }
          create: {
            args: Prisma.InventoryLedgerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload>
          }
          createMany: {
            args: Prisma.InventoryLedgerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryLedgerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload>[]
          }
          delete: {
            args: Prisma.InventoryLedgerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload>
          }
          update: {
            args: Prisma.InventoryLedgerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload>
          }
          deleteMany: {
            args: Prisma.InventoryLedgerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryLedgerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryLedgerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload>
          }
          aggregate: {
            args: Prisma.InventoryLedgerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryLedger>
          }
          groupBy: {
            args: Prisma.InventoryLedgerGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryLedgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryLedgerCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryLedgerCountAggregateOutputType> | number
          }
        }
      }
      IngredientCatalog: {
        payload: Prisma.$IngredientCatalogPayload<ExtArgs>
        fields: Prisma.IngredientCatalogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngredientCatalogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientCatalogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngredientCatalogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientCatalogPayload>
          }
          findFirst: {
            args: Prisma.IngredientCatalogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientCatalogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngredientCatalogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientCatalogPayload>
          }
          findMany: {
            args: Prisma.IngredientCatalogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientCatalogPayload>[]
          }
          create: {
            args: Prisma.IngredientCatalogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientCatalogPayload>
          }
          createMany: {
            args: Prisma.IngredientCatalogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IngredientCatalogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientCatalogPayload>[]
          }
          delete: {
            args: Prisma.IngredientCatalogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientCatalogPayload>
          }
          update: {
            args: Prisma.IngredientCatalogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientCatalogPayload>
          }
          deleteMany: {
            args: Prisma.IngredientCatalogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IngredientCatalogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IngredientCatalogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngredientCatalogPayload>
          }
          aggregate: {
            args: Prisma.IngredientCatalogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIngredientCatalog>
          }
          groupBy: {
            args: Prisma.IngredientCatalogGroupByArgs<ExtArgs>
            result: $Utils.Optional<IngredientCatalogGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngredientCatalogCountArgs<ExtArgs>
            result: $Utils.Optional<IngredientCatalogCountAggregateOutputType> | number
          }
        }
      }
      Batch: {
        payload: Prisma.$BatchPayload<ExtArgs>
        fields: Prisma.BatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          findFirst: {
            args: Prisma.BatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          findMany: {
            args: Prisma.BatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          create: {
            args: Prisma.BatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          createMany: {
            args: Prisma.BatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          delete: {
            args: Prisma.BatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          update: {
            args: Prisma.BatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          deleteMany: {
            args: Prisma.BatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          aggregate: {
            args: Prisma.BatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatch>
          }
          groupBy: {
            args: Prisma.BatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchCountArgs<ExtArgs>
            result: $Utils.Optional<BatchCountAggregateOutputType> | number
          }
        }
      }
      BatchIngredient: {
        payload: Prisma.$BatchIngredientPayload<ExtArgs>
        fields: Prisma.BatchIngredientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchIngredientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchIngredientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchIngredientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchIngredientPayload>
          }
          findFirst: {
            args: Prisma.BatchIngredientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchIngredientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchIngredientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchIngredientPayload>
          }
          findMany: {
            args: Prisma.BatchIngredientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchIngredientPayload>[]
          }
          create: {
            args: Prisma.BatchIngredientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchIngredientPayload>
          }
          createMany: {
            args: Prisma.BatchIngredientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchIngredientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchIngredientPayload>[]
          }
          delete: {
            args: Prisma.BatchIngredientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchIngredientPayload>
          }
          update: {
            args: Prisma.BatchIngredientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchIngredientPayload>
          }
          deleteMany: {
            args: Prisma.BatchIngredientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchIngredientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BatchIngredientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchIngredientPayload>
          }
          aggregate: {
            args: Prisma.BatchIngredientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatchIngredient>
          }
          groupBy: {
            args: Prisma.BatchIngredientGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchIngredientGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchIngredientCountArgs<ExtArgs>
            result: $Utils.Optional<BatchIngredientCountAggregateOutputType> | number
          }
        }
      }
      GravityReading: {
        payload: Prisma.$GravityReadingPayload<ExtArgs>
        fields: Prisma.GravityReadingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GravityReadingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GravityReadingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GravityReadingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GravityReadingPayload>
          }
          findFirst: {
            args: Prisma.GravityReadingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GravityReadingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GravityReadingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GravityReadingPayload>
          }
          findMany: {
            args: Prisma.GravityReadingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GravityReadingPayload>[]
          }
          create: {
            args: Prisma.GravityReadingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GravityReadingPayload>
          }
          createMany: {
            args: Prisma.GravityReadingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GravityReadingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GravityReadingPayload>[]
          }
          delete: {
            args: Prisma.GravityReadingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GravityReadingPayload>
          }
          update: {
            args: Prisma.GravityReadingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GravityReadingPayload>
          }
          deleteMany: {
            args: Prisma.GravityReadingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GravityReadingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GravityReadingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GravityReadingPayload>
          }
          aggregate: {
            args: Prisma.GravityReadingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGravityReading>
          }
          groupBy: {
            args: Prisma.GravityReadingGroupByArgs<ExtArgs>
            result: $Utils.Optional<GravityReadingGroupByOutputType>[]
          }
          count: {
            args: Prisma.GravityReadingCountArgs<ExtArgs>
            result: $Utils.Optional<GravityReadingCountAggregateOutputType> | number
          }
        }
      }
      BatchTimeline: {
        payload: Prisma.$BatchTimelinePayload<ExtArgs>
        fields: Prisma.BatchTimelineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchTimelineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchTimelinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchTimelineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchTimelinePayload>
          }
          findFirst: {
            args: Prisma.BatchTimelineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchTimelinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchTimelineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchTimelinePayload>
          }
          findMany: {
            args: Prisma.BatchTimelineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchTimelinePayload>[]
          }
          create: {
            args: Prisma.BatchTimelineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchTimelinePayload>
          }
          createMany: {
            args: Prisma.BatchTimelineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchTimelineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchTimelinePayload>[]
          }
          delete: {
            args: Prisma.BatchTimelineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchTimelinePayload>
          }
          update: {
            args: Prisma.BatchTimelineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchTimelinePayload>
          }
          deleteMany: {
            args: Prisma.BatchTimelineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchTimelineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BatchTimelineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchTimelinePayload>
          }
          aggregate: {
            args: Prisma.BatchTimelineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatchTimeline>
          }
          groupBy: {
            args: Prisma.BatchTimelineGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchTimelineGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchTimelineCountArgs<ExtArgs>
            result: $Utils.Optional<BatchTimelineCountAggregateOutputType> | number
          }
        }
      }
      Tank: {
        payload: Prisma.$TankPayload<ExtArgs>
        fields: Prisma.TankFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TankFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TankFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankPayload>
          }
          findFirst: {
            args: Prisma.TankFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TankFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankPayload>
          }
          findMany: {
            args: Prisma.TankFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankPayload>[]
          }
          create: {
            args: Prisma.TankCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankPayload>
          }
          createMany: {
            args: Prisma.TankCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TankCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankPayload>[]
          }
          delete: {
            args: Prisma.TankDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankPayload>
          }
          update: {
            args: Prisma.TankUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankPayload>
          }
          deleteMany: {
            args: Prisma.TankDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TankUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TankUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankPayload>
          }
          aggregate: {
            args: Prisma.TankAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTank>
          }
          groupBy: {
            args: Prisma.TankGroupByArgs<ExtArgs>
            result: $Utils.Optional<TankGroupByOutputType>[]
          }
          count: {
            args: Prisma.TankCountArgs<ExtArgs>
            result: $Utils.Optional<TankCountAggregateOutputType> | number
          }
        }
      }
      TankOccupation: {
        payload: Prisma.$TankOccupationPayload<ExtArgs>
        fields: Prisma.TankOccupationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TankOccupationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankOccupationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TankOccupationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankOccupationPayload>
          }
          findFirst: {
            args: Prisma.TankOccupationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankOccupationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TankOccupationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankOccupationPayload>
          }
          findMany: {
            args: Prisma.TankOccupationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankOccupationPayload>[]
          }
          create: {
            args: Prisma.TankOccupationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankOccupationPayload>
          }
          createMany: {
            args: Prisma.TankOccupationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TankOccupationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankOccupationPayload>[]
          }
          delete: {
            args: Prisma.TankOccupationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankOccupationPayload>
          }
          update: {
            args: Prisma.TankOccupationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankOccupationPayload>
          }
          deleteMany: {
            args: Prisma.TankOccupationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TankOccupationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TankOccupationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankOccupationPayload>
          }
          aggregate: {
            args: Prisma.TankOccupationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTankOccupation>
          }
          groupBy: {
            args: Prisma.TankOccupationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TankOccupationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TankOccupationCountArgs<ExtArgs>
            result: $Utils.Optional<TankOccupationCountAggregateOutputType> | number
          }
        }
      }
      PackagingRun: {
        payload: Prisma.$PackagingRunPayload<ExtArgs>
        fields: Prisma.PackagingRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackagingRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagingRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackagingRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagingRunPayload>
          }
          findFirst: {
            args: Prisma.PackagingRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagingRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackagingRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagingRunPayload>
          }
          findMany: {
            args: Prisma.PackagingRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagingRunPayload>[]
          }
          create: {
            args: Prisma.PackagingRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagingRunPayload>
          }
          createMany: {
            args: Prisma.PackagingRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PackagingRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagingRunPayload>[]
          }
          delete: {
            args: Prisma.PackagingRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagingRunPayload>
          }
          update: {
            args: Prisma.PackagingRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagingRunPayload>
          }
          deleteMany: {
            args: Prisma.PackagingRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackagingRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PackagingRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagingRunPayload>
          }
          aggregate: {
            args: Prisma.PackagingRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackagingRun>
          }
          groupBy: {
            args: Prisma.PackagingRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackagingRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackagingRunCountArgs<ExtArgs>
            result: $Utils.Optional<PackagingRunCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      SalesOrder: {
        payload: Prisma.$SalesOrderPayload<ExtArgs>
        fields: Prisma.SalesOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          findFirst: {
            args: Prisma.SalesOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          findMany: {
            args: Prisma.SalesOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>[]
          }
          create: {
            args: Prisma.SalesOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          createMany: {
            args: Prisma.SalesOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>[]
          }
          delete: {
            args: Prisma.SalesOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          update: {
            args: Prisma.SalesOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          deleteMany: {
            args: Prisma.SalesOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SalesOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          aggregate: {
            args: Prisma.SalesOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesOrder>
          }
          groupBy: {
            args: Prisma.SalesOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesOrderCountArgs<ExtArgs>
            result: $Utils.Optional<SalesOrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      Budget: {
        payload: Prisma.$BudgetPayload<ExtArgs>
        fields: Prisma.BudgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findFirst: {
            args: Prisma.BudgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findMany: {
            args: Prisma.BudgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          create: {
            args: Prisma.BudgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          createMany: {
            args: Prisma.BudgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          delete: {
            args: Prisma.BudgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          update: {
            args: Prisma.BudgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          deleteMany: {
            args: Prisma.BudgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BudgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          aggregate: {
            args: Prisma.BudgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudget>
          }
          groupBy: {
            args: Prisma.BudgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      BlendingConfig: {
        payload: Prisma.$BlendingConfigPayload<ExtArgs>
        fields: Prisma.BlendingConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlendingConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlendingConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlendingConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlendingConfigPayload>
          }
          findFirst: {
            args: Prisma.BlendingConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlendingConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlendingConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlendingConfigPayload>
          }
          findMany: {
            args: Prisma.BlendingConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlendingConfigPayload>[]
          }
          create: {
            args: Prisma.BlendingConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlendingConfigPayload>
          }
          createMany: {
            args: Prisma.BlendingConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlendingConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlendingConfigPayload>[]
          }
          delete: {
            args: Prisma.BlendingConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlendingConfigPayload>
          }
          update: {
            args: Prisma.BlendingConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlendingConfigPayload>
          }
          deleteMany: {
            args: Prisma.BlendingConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlendingConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlendingConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlendingConfigPayload>
          }
          aggregate: {
            args: Prisma.BlendingConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlendingConfig>
          }
          groupBy: {
            args: Prisma.BlendingConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlendingConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlendingConfigCountArgs<ExtArgs>
            result: $Utils.Optional<BlendingConfigCountAggregateOutputType> | number
          }
        }
      }
      CIPLog: {
        payload: Prisma.$CIPLogPayload<ExtArgs>
        fields: Prisma.CIPLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CIPLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIPLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CIPLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIPLogPayload>
          }
          findFirst: {
            args: Prisma.CIPLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIPLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CIPLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIPLogPayload>
          }
          findMany: {
            args: Prisma.CIPLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIPLogPayload>[]
          }
          create: {
            args: Prisma.CIPLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIPLogPayload>
          }
          createMany: {
            args: Prisma.CIPLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CIPLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIPLogPayload>[]
          }
          delete: {
            args: Prisma.CIPLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIPLogPayload>
          }
          update: {
            args: Prisma.CIPLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIPLogPayload>
          }
          deleteMany: {
            args: Prisma.CIPLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CIPLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CIPLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CIPLogPayload>
          }
          aggregate: {
            args: Prisma.CIPLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCIPLog>
          }
          groupBy: {
            args: Prisma.CIPLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CIPLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CIPLogCountArgs<ExtArgs>
            result: $Utils.Optional<CIPLogCountAggregateOutputType> | number
          }
        }
      }
      Equipment: {
        payload: Prisma.$EquipmentPayload<ExtArgs>
        fields: Prisma.EquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findFirst: {
            args: Prisma.EquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findMany: {
            args: Prisma.EquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          create: {
            args: Prisma.EquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          createMany: {
            args: Prisma.EquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          delete: {
            args: Prisma.EquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          update: {
            args: Prisma.EquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          aggregate: {
            args: Prisma.EquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipment>
          }
          groupBy: {
            args: Prisma.EquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentCountAggregateOutputType> | number
          }
        }
      }
      Lot: {
        payload: Prisma.$LotPayload<ExtArgs>
        fields: Prisma.LotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload>
          }
          findFirst: {
            args: Prisma.LotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload>
          }
          findMany: {
            args: Prisma.LotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload>[]
          }
          create: {
            args: Prisma.LotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload>
          }
          createMany: {
            args: Prisma.LotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload>[]
          }
          delete: {
            args: Prisma.LotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload>
          }
          update: {
            args: Prisma.LotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload>
          }
          deleteMany: {
            args: Prisma.LotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotPayload>
          }
          aggregate: {
            args: Prisma.LotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLot>
          }
          groupBy: {
            args: Prisma.LotGroupByArgs<ExtArgs>
            result: $Utils.Optional<LotGroupByOutputType>[]
          }
          count: {
            args: Prisma.LotCountArgs<ExtArgs>
            result: $Utils.Optional<LotCountAggregateOutputType> | number
          }
        }
      }
      LotBatch: {
        payload: Prisma.$LotBatchPayload<ExtArgs>
        fields: Prisma.LotBatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LotBatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotBatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LotBatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotBatchPayload>
          }
          findFirst: {
            args: Prisma.LotBatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotBatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LotBatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotBatchPayload>
          }
          findMany: {
            args: Prisma.LotBatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotBatchPayload>[]
          }
          create: {
            args: Prisma.LotBatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotBatchPayload>
          }
          createMany: {
            args: Prisma.LotBatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LotBatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotBatchPayload>[]
          }
          delete: {
            args: Prisma.LotBatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotBatchPayload>
          }
          update: {
            args: Prisma.LotBatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotBatchPayload>
          }
          deleteMany: {
            args: Prisma.LotBatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LotBatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LotBatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotBatchPayload>
          }
          aggregate: {
            args: Prisma.LotBatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLotBatch>
          }
          groupBy: {
            args: Prisma.LotBatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<LotBatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.LotBatchCountArgs<ExtArgs>
            result: $Utils.Optional<LotBatchCountAggregateOutputType> | number
          }
        }
      }
      LotReading: {
        payload: Prisma.$LotReadingPayload<ExtArgs>
        fields: Prisma.LotReadingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LotReadingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotReadingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LotReadingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotReadingPayload>
          }
          findFirst: {
            args: Prisma.LotReadingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotReadingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LotReadingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotReadingPayload>
          }
          findMany: {
            args: Prisma.LotReadingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotReadingPayload>[]
          }
          create: {
            args: Prisma.LotReadingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotReadingPayload>
          }
          createMany: {
            args: Prisma.LotReadingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LotReadingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotReadingPayload>[]
          }
          delete: {
            args: Prisma.LotReadingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotReadingPayload>
          }
          update: {
            args: Prisma.LotReadingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotReadingPayload>
          }
          deleteMany: {
            args: Prisma.LotReadingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LotReadingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LotReadingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LotReadingPayload>
          }
          aggregate: {
            args: Prisma.LotReadingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLotReading>
          }
          groupBy: {
            args: Prisma.LotReadingGroupByArgs<ExtArgs>
            result: $Utils.Optional<LotReadingGroupByOutputType>[]
          }
          count: {
            args: Prisma.LotReadingCountArgs<ExtArgs>
            result: $Utils.Optional<LotReadingCountAggregateOutputType> | number
          }
        }
      }
      MaintenanceLog: {
        payload: Prisma.$MaintenanceLogPayload<ExtArgs>
        fields: Prisma.MaintenanceLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>
          }
          findFirst: {
            args: Prisma.MaintenanceLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>
          }
          findMany: {
            args: Prisma.MaintenanceLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>[]
          }
          create: {
            args: Prisma.MaintenanceLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>
          }
          createMany: {
            args: Prisma.MaintenanceLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>[]
          }
          delete: {
            args: Prisma.MaintenanceLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>
          }
          update: {
            args: Prisma.MaintenanceLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaintenanceLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>
          }
          aggregate: {
            args: Prisma.MaintenanceLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenanceLog>
          }
          groupBy: {
            args: Prisma.MaintenanceLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceLogCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceLogCountAggregateOutputType> | number
          }
        }
      }
      ProblemReport: {
        payload: Prisma.$ProblemReportPayload<ExtArgs>
        fields: Prisma.ProblemReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProblemReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProblemReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemReportPayload>
          }
          findFirst: {
            args: Prisma.ProblemReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProblemReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemReportPayload>
          }
          findMany: {
            args: Prisma.ProblemReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemReportPayload>[]
          }
          create: {
            args: Prisma.ProblemReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemReportPayload>
          }
          createMany: {
            args: Prisma.ProblemReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProblemReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemReportPayload>[]
          }
          delete: {
            args: Prisma.ProblemReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemReportPayload>
          }
          update: {
            args: Prisma.ProblemReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemReportPayload>
          }
          deleteMany: {
            args: Prisma.ProblemReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProblemReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProblemReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemReportPayload>
          }
          aggregate: {
            args: Prisma.ProblemReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProblemReport>
          }
          groupBy: {
            args: Prisma.ProblemReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProblemReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProblemReportCountArgs<ExtArgs>
            result: $Utils.Optional<ProblemReportCountAggregateOutputType> | number
          }
        }
      }
      TankAssignment: {
        payload: Prisma.$TankAssignmentPayload<ExtArgs>
        fields: Prisma.TankAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TankAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TankAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankAssignmentPayload>
          }
          findFirst: {
            args: Prisma.TankAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TankAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankAssignmentPayload>
          }
          findMany: {
            args: Prisma.TankAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankAssignmentPayload>[]
          }
          create: {
            args: Prisma.TankAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankAssignmentPayload>
          }
          createMany: {
            args: Prisma.TankAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TankAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankAssignmentPayload>[]
          }
          delete: {
            args: Prisma.TankAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankAssignmentPayload>
          }
          update: {
            args: Prisma.TankAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.TankAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TankAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TankAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TankAssignmentPayload>
          }
          aggregate: {
            args: Prisma.TankAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTankAssignment>
          }
          groupBy: {
            args: Prisma.TankAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TankAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TankAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<TankAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Transfer: {
        payload: Prisma.$TransferPayload<ExtArgs>
        fields: Prisma.TransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findFirst: {
            args: Prisma.TransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          findMany: {
            args: Prisma.TransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          create: {
            args: Prisma.TransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          createMany: {
            args: Prisma.TransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>[]
          }
          delete: {
            args: Prisma.TransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          update: {
            args: Prisma.TransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          deleteMany: {
            args: Prisma.TransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransferPayload>
          }
          aggregate: {
            args: Prisma.TransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransfer>
          }
          groupBy: {
            args: Prisma.TransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransferCountArgs<ExtArgs>
            result: $Utils.Optional<TransferCountAggregateOutputType> | number
          }
        }
      }
      Keg: {
        payload: Prisma.$KegPayload<ExtArgs>
        fields: Prisma.KegFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KegFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KegFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegPayload>
          }
          findFirst: {
            args: Prisma.KegFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KegFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegPayload>
          }
          findMany: {
            args: Prisma.KegFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegPayload>[]
          }
          create: {
            args: Prisma.KegCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegPayload>
          }
          createMany: {
            args: Prisma.KegCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KegCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegPayload>[]
          }
          delete: {
            args: Prisma.KegDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegPayload>
          }
          update: {
            args: Prisma.KegUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegPayload>
          }
          deleteMany: {
            args: Prisma.KegDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KegUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KegUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegPayload>
          }
          aggregate: {
            args: Prisma.KegAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeg>
          }
          groupBy: {
            args: Prisma.KegGroupByArgs<ExtArgs>
            result: $Utils.Optional<KegGroupByOutputType>[]
          }
          count: {
            args: Prisma.KegCountArgs<ExtArgs>
            result: $Utils.Optional<KegCountAggregateOutputType> | number
          }
        }
      }
      KegMovement: {
        payload: Prisma.$KegMovementPayload<ExtArgs>
        fields: Prisma.KegMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KegMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KegMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegMovementPayload>
          }
          findFirst: {
            args: Prisma.KegMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KegMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegMovementPayload>
          }
          findMany: {
            args: Prisma.KegMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegMovementPayload>[]
          }
          create: {
            args: Prisma.KegMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegMovementPayload>
          }
          createMany: {
            args: Prisma.KegMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KegMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegMovementPayload>[]
          }
          delete: {
            args: Prisma.KegMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegMovementPayload>
          }
          update: {
            args: Prisma.KegMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegMovementPayload>
          }
          deleteMany: {
            args: Prisma.KegMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KegMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KegMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KegMovementPayload>
          }
          aggregate: {
            args: Prisma.KegMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKegMovement>
          }
          groupBy: {
            args: Prisma.KegMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<KegMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.KegMovementCountArgs<ExtArgs>
            result: $Utils.Optional<KegMovementCountAggregateOutputType> | number
          }
        }
      }
      QCTest: {
        payload: Prisma.$QCTestPayload<ExtArgs>
        fields: Prisma.QCTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QCTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QCTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCTestPayload>
          }
          findFirst: {
            args: Prisma.QCTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QCTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCTestPayload>
          }
          findMany: {
            args: Prisma.QCTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCTestPayload>[]
          }
          create: {
            args: Prisma.QCTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCTestPayload>
          }
          createMany: {
            args: Prisma.QCTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QCTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCTestPayload>[]
          }
          delete: {
            args: Prisma.QCTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCTestPayload>
          }
          update: {
            args: Prisma.QCTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCTestPayload>
          }
          deleteMany: {
            args: Prisma.QCTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QCTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QCTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QCTestPayload>
          }
          aggregate: {
            args: Prisma.QCTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQCTest>
          }
          groupBy: {
            args: Prisma.QCTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<QCTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.QCTestCountArgs<ExtArgs>
            result: $Utils.Optional<QCTestCountAggregateOutputType> | number
          }
        }
      }
      Configuration: {
        payload: Prisma.$ConfigurationPayload<ExtArgs>
        fields: Prisma.ConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigurationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigurationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          findFirst: {
            args: Prisma.ConfigurationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigurationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          findMany: {
            args: Prisma.ConfigurationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>[]
          }
          create: {
            args: Prisma.ConfigurationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          createMany: {
            args: Prisma.ConfigurationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfigurationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>[]
          }
          delete: {
            args: Prisma.ConfigurationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          update: {
            args: Prisma.ConfigurationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.ConfigurationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigurationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConfigurationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          aggregate: {
            args: Prisma.ConfigurationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfiguration>
          }
          groupBy: {
            args: Prisma.ConfigurationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigurationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfigurationCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigurationCountAggregateOutputType> | number
          }
        }
      }
      Museum: {
        payload: Prisma.$MuseumPayload<ExtArgs>
        fields: Prisma.MuseumFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MuseumFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuseumPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MuseumFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuseumPayload>
          }
          findFirst: {
            args: Prisma.MuseumFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuseumPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MuseumFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuseumPayload>
          }
          findMany: {
            args: Prisma.MuseumFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuseumPayload>[]
          }
          create: {
            args: Prisma.MuseumCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuseumPayload>
          }
          createMany: {
            args: Prisma.MuseumCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MuseumCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuseumPayload>[]
          }
          delete: {
            args: Prisma.MuseumDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuseumPayload>
          }
          update: {
            args: Prisma.MuseumUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuseumPayload>
          }
          deleteMany: {
            args: Prisma.MuseumDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MuseumUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MuseumUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MuseumPayload>
          }
          aggregate: {
            args: Prisma.MuseumAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMuseum>
          }
          groupBy: {
            args: Prisma.MuseumGroupByArgs<ExtArgs>
            result: $Utils.Optional<MuseumGroupByOutputType>[]
          }
          count: {
            args: Prisma.MuseumCountArgs<ExtArgs>
            result: $Utils.Optional<MuseumCountAggregateOutputType> | number
          }
        }
      }
      Tour: {
        payload: Prisma.$TourPayload<ExtArgs>
        fields: Prisma.TourFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TourFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TourFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          findFirst: {
            args: Prisma.TourFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TourFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          findMany: {
            args: Prisma.TourFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>[]
          }
          create: {
            args: Prisma.TourCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          createMany: {
            args: Prisma.TourCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TourCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>[]
          }
          delete: {
            args: Prisma.TourDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          update: {
            args: Prisma.TourUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          deleteMany: {
            args: Prisma.TourDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TourUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TourUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TourPayload>
          }
          aggregate: {
            args: Prisma.TourAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTour>
          }
          groupBy: {
            args: Prisma.TourGroupByArgs<ExtArgs>
            result: $Utils.Optional<TourGroupByOutputType>[]
          }
          count: {
            args: Prisma.TourCountArgs<ExtArgs>
            result: $Utils.Optional<TourCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    batches: number
    budgets: number
    customers: number
    Equipment: number
    expenses: number
    inventory: number
    invoices: number
    Keg: number
    payments: number
    recipes: number
    orders: number
    suppliers: number
    tanks: number
    transactions: number
    users: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | TenantCountOutputTypeCountBatchesArgs
    budgets?: boolean | TenantCountOutputTypeCountBudgetsArgs
    customers?: boolean | TenantCountOutputTypeCountCustomersArgs
    Equipment?: boolean | TenantCountOutputTypeCountEquipmentArgs
    expenses?: boolean | TenantCountOutputTypeCountExpensesArgs
    inventory?: boolean | TenantCountOutputTypeCountInventoryArgs
    invoices?: boolean | TenantCountOutputTypeCountInvoicesArgs
    Keg?: boolean | TenantCountOutputTypeCountKegArgs
    payments?: boolean | TenantCountOutputTypeCountPaymentsArgs
    recipes?: boolean | TenantCountOutputTypeCountRecipesArgs
    orders?: boolean | TenantCountOutputTypeCountOrdersArgs
    suppliers?: boolean | TenantCountOutputTypeCountSuppliersArgs
    tanks?: boolean | TenantCountOutputTypeCountTanksArgs
    transactions?: boolean | TenantCountOutputTypeCountTransactionsArgs
    users?: boolean | TenantCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountKegArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KegWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountRecipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TankWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type RecipeCountOutputType
   */

  export type RecipeCountOutputType = {
    batches: number
    ingredients: number
  }

  export type RecipeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | RecipeCountOutputTypeCountBatchesArgs
    ingredients?: boolean | RecipeCountOutputTypeCountIngredientsArgs
  }

  // Custom InputTypes
  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeCountOutputType
     */
    select?: RecipeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountIngredientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeIngredientWhereInput
  }


  /**
   * Count Type InventoryItemCountOutputType
   */

  export type InventoryItemCountOutputType = {
    ledger: number
    recipeIngredients: number
  }

  export type InventoryItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ledger?: boolean | InventoryItemCountOutputTypeCountLedgerArgs
    recipeIngredients?: boolean | InventoryItemCountOutputTypeCountRecipeIngredientsArgs
  }

  // Custom InputTypes
  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItemCountOutputType
     */
    select?: InventoryItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryLedgerWhereInput
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountRecipeIngredientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeIngredientWhereInput
  }


  /**
   * Count Type BatchCountOutputType
   */

  export type BatchCountOutputType = {
    ingredients: number
    timeline: number
    gravityReadings: number
    ledgerEntries: number
    Keg: number
    LotBatch: number
    packagingRuns: number
    QCTest: number
  }

  export type BatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingredients?: boolean | BatchCountOutputTypeCountIngredientsArgs
    timeline?: boolean | BatchCountOutputTypeCountTimelineArgs
    gravityReadings?: boolean | BatchCountOutputTypeCountGravityReadingsArgs
    ledgerEntries?: boolean | BatchCountOutputTypeCountLedgerEntriesArgs
    Keg?: boolean | BatchCountOutputTypeCountKegArgs
    LotBatch?: boolean | BatchCountOutputTypeCountLotBatchArgs
    packagingRuns?: boolean | BatchCountOutputTypeCountPackagingRunsArgs
    QCTest?: boolean | BatchCountOutputTypeCountQCTestArgs
  }

  // Custom InputTypes
  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCountOutputType
     */
    select?: BatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountIngredientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchIngredientWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchTimelineWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountGravityReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GravityReadingWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryLedgerWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountKegArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KegWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountLotBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotBatchWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountPackagingRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackagingRunWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountQCTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QCTestWhereInput
  }


  /**
   * Count Type TankCountOutputType
   */

  export type TankCountOutputType = {
    batches: number
    LotReading: number
    TankAssignment: number
    occupations: number
    Transfer_Transfer_destTankIdToTank: number
    Transfer_Transfer_sourceTankIdToTank: number
  }

  export type TankCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | TankCountOutputTypeCountBatchesArgs
    LotReading?: boolean | TankCountOutputTypeCountLotReadingArgs
    TankAssignment?: boolean | TankCountOutputTypeCountTankAssignmentArgs
    occupations?: boolean | TankCountOutputTypeCountOccupationsArgs
    Transfer_Transfer_destTankIdToTank?: boolean | TankCountOutputTypeCountTransfer_Transfer_destTankIdToTankArgs
    Transfer_Transfer_sourceTankIdToTank?: boolean | TankCountOutputTypeCountTransfer_Transfer_sourceTankIdToTankArgs
  }

  // Custom InputTypes
  /**
   * TankCountOutputType without action
   */
  export type TankCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankCountOutputType
     */
    select?: TankCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TankCountOutputType without action
   */
  export type TankCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * TankCountOutputType without action
   */
  export type TankCountOutputTypeCountLotReadingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotReadingWhereInput
  }

  /**
   * TankCountOutputType without action
   */
  export type TankCountOutputTypeCountTankAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TankAssignmentWhereInput
  }

  /**
   * TankCountOutputType without action
   */
  export type TankCountOutputTypeCountOccupationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TankOccupationWhereInput
  }

  /**
   * TankCountOutputType without action
   */
  export type TankCountOutputTypeCountTransfer_Transfer_destTankIdToTankArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * TankCountOutputType without action
   */
  export type TankCountOutputTypeCountTransfer_Transfer_sourceTankIdToTankArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    invoices: number
    Keg: number
    orders: number
    transactions: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | CustomerCountOutputTypeCountInvoicesArgs
    Keg?: boolean | CustomerCountOutputTypeCountKegArgs
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
    transactions?: boolean | CustomerCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountKegArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KegWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    expenses: number
    invoices: number
    transactions: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | SupplierCountOutputTypeCountExpensesArgs
    invoices?: boolean | SupplierCountOutputTypeCountInvoicesArgs
    transactions?: boolean | SupplierCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type SalesOrderCountOutputType
   */

  export type SalesOrderCountOutputType = {
    items: number
    payments: number
    transactions: number
  }

  export type SalesOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | SalesOrderCountOutputTypeCountItemsArgs
    payments?: boolean | SalesOrderCountOutputTypeCountPaymentsArgs
    transactions?: boolean | SalesOrderCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * SalesOrderCountOutputType without action
   */
  export type SalesOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderCountOutputType
     */
    select?: SalesOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalesOrderCountOutputType without action
   */
  export type SalesOrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * SalesOrderCountOutputType without action
   */
  export type SalesOrderCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * SalesOrderCountOutputType without action
   */
  export type SalesOrderCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    items: number
    payments: number
    transactions: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InvoiceCountOutputTypeCountItemsArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
    transactions?: boolean | InvoiceCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type ExpenseCountOutputType
   */

  export type ExpenseCountOutputType = {
    transactions: number
  }

  export type ExpenseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | ExpenseCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * ExpenseCountOutputType without action
   */
  export type ExpenseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCountOutputType
     */
    select?: ExpenseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExpenseCountOutputType without action
   */
  export type ExpenseCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type EquipmentCountOutputType
   */

  export type EquipmentCountOutputType = {
    CIPLog: number
    MaintenanceLog: number
    ProblemReport: number
  }

  export type EquipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CIPLog?: boolean | EquipmentCountOutputTypeCountCIPLogArgs
    MaintenanceLog?: boolean | EquipmentCountOutputTypeCountMaintenanceLogArgs
    ProblemReport?: boolean | EquipmentCountOutputTypeCountProblemReportArgs
  }

  // Custom InputTypes
  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCountOutputType
     */
    select?: EquipmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountCIPLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CIPLogWhereInput
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountMaintenanceLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceLogWhereInput
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountProblemReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProblemReportWhereInput
  }


  /**
   * Count Type LotCountOutputType
   */

  export type LotCountOutputType = {
    other_Lot: number
    LotBatch: number
    LotReading: number
    QCTest: number
    TankAssignment: number
    Transfer_Transfer_destLotIdToLot: number
    Transfer_Transfer_sourceLotIdToLot: number
  }

  export type LotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_Lot?: boolean | LotCountOutputTypeCountOther_LotArgs
    LotBatch?: boolean | LotCountOutputTypeCountLotBatchArgs
    LotReading?: boolean | LotCountOutputTypeCountLotReadingArgs
    QCTest?: boolean | LotCountOutputTypeCountQCTestArgs
    TankAssignment?: boolean | LotCountOutputTypeCountTankAssignmentArgs
    Transfer_Transfer_destLotIdToLot?: boolean | LotCountOutputTypeCountTransfer_Transfer_destLotIdToLotArgs
    Transfer_Transfer_sourceLotIdToLot?: boolean | LotCountOutputTypeCountTransfer_Transfer_sourceLotIdToLotArgs
  }

  // Custom InputTypes
  /**
   * LotCountOutputType without action
   */
  export type LotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotCountOutputType
     */
    select?: LotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LotCountOutputType without action
   */
  export type LotCountOutputTypeCountOther_LotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotWhereInput
  }

  /**
   * LotCountOutputType without action
   */
  export type LotCountOutputTypeCountLotBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotBatchWhereInput
  }

  /**
   * LotCountOutputType without action
   */
  export type LotCountOutputTypeCountLotReadingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotReadingWhereInput
  }

  /**
   * LotCountOutputType without action
   */
  export type LotCountOutputTypeCountQCTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QCTestWhereInput
  }

  /**
   * LotCountOutputType without action
   */
  export type LotCountOutputTypeCountTankAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TankAssignmentWhereInput
  }

  /**
   * LotCountOutputType without action
   */
  export type LotCountOutputTypeCountTransfer_Transfer_destLotIdToLotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }

  /**
   * LotCountOutputType without action
   */
  export type LotCountOutputTypeCountTransfer_Transfer_sourceLotIdToLotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
  }


  /**
   * Count Type KegCountOutputType
   */

  export type KegCountOutputType = {
    movements: number
  }

  export type KegCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movements?: boolean | KegCountOutputTypeCountMovementsArgs
  }

  // Custom InputTypes
  /**
   * KegCountOutputType without action
   */
  export type KegCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KegCountOutputType
     */
    select?: KegCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KegCountOutputType without action
   */
  export type KegCountOutputTypeCountMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KegMovementWhereInput
  }


  /**
   * Count Type MuseumCountOutputType
   */

  export type MuseumCountOutputType = {
    tours: number
  }

  export type MuseumCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tours?: boolean | MuseumCountOutputTypeCountToursArgs
  }

  // Custom InputTypes
  /**
   * MuseumCountOutputType without action
   */
  export type MuseumCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MuseumCountOutputType
     */
    select?: MuseumCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MuseumCountOutputType without action
   */
  export type MuseumCountOutputTypeCountToursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    plan: $Enums.PlanType | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    code: string | null
    legalName: string | null
    taxId: string | null
    phone: string | null
    email: string | null
    address: string | null
    website: string | null
    bankName: string | null
    bankAccount: string | null
    bankSwift: string | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    plan: $Enums.PlanType | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    code: string | null
    legalName: string | null
    taxId: string | null
    phone: string | null
    email: string | null
    address: string | null
    website: string | null
    bankName: string | null
    bankAccount: string | null
    bankSwift: string | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    plan: number
    isActive: number
    createdAt: number
    updatedAt: number
    code: number
    legalName: number
    taxId: number
    phone: number
    email: number
    address: number
    website: number
    bankName: number
    bankAccount: number
    bankSwift: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    plan?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    code?: true
    legalName?: true
    taxId?: true
    phone?: true
    email?: true
    address?: true
    website?: true
    bankName?: true
    bankAccount?: true
    bankSwift?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    plan?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    code?: true
    legalName?: true
    taxId?: true
    phone?: true
    email?: true
    address?: true
    website?: true
    bankName?: true
    bankAccount?: true
    bankSwift?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    plan?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    code?: true
    legalName?: true
    taxId?: true
    phone?: true
    email?: true
    address?: true
    website?: true
    bankName?: true
    bankAccount?: true
    bankSwift?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    slug: string
    plan: $Enums.PlanType
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    code: string
    legalName: string | null
    taxId: string | null
    phone: string | null
    email: string | null
    address: string | null
    website: string | null
    bankName: string | null
    bankAccount: string | null
    bankSwift: string | null
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    plan?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    code?: boolean
    legalName?: boolean
    taxId?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    website?: boolean
    bankName?: boolean
    bankAccount?: boolean
    bankSwift?: boolean
    batches?: boolean | Tenant$batchesArgs<ExtArgs>
    budgets?: boolean | Tenant$budgetsArgs<ExtArgs>
    customers?: boolean | Tenant$customersArgs<ExtArgs>
    Equipment?: boolean | Tenant$EquipmentArgs<ExtArgs>
    expenses?: boolean | Tenant$expensesArgs<ExtArgs>
    inventory?: boolean | Tenant$inventoryArgs<ExtArgs>
    invoices?: boolean | Tenant$invoicesArgs<ExtArgs>
    Keg?: boolean | Tenant$KegArgs<ExtArgs>
    payments?: boolean | Tenant$paymentsArgs<ExtArgs>
    recipes?: boolean | Tenant$recipesArgs<ExtArgs>
    orders?: boolean | Tenant$ordersArgs<ExtArgs>
    suppliers?: boolean | Tenant$suppliersArgs<ExtArgs>
    tanks?: boolean | Tenant$tanksArgs<ExtArgs>
    transactions?: boolean | Tenant$transactionsArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    plan?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    code?: boolean
    legalName?: boolean
    taxId?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    website?: boolean
    bankName?: boolean
    bankAccount?: boolean
    bankSwift?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    plan?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    code?: boolean
    legalName?: boolean
    taxId?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    website?: boolean
    bankName?: boolean
    bankAccount?: boolean
    bankSwift?: boolean
  }

  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | Tenant$batchesArgs<ExtArgs>
    budgets?: boolean | Tenant$budgetsArgs<ExtArgs>
    customers?: boolean | Tenant$customersArgs<ExtArgs>
    Equipment?: boolean | Tenant$EquipmentArgs<ExtArgs>
    expenses?: boolean | Tenant$expensesArgs<ExtArgs>
    inventory?: boolean | Tenant$inventoryArgs<ExtArgs>
    invoices?: boolean | Tenant$invoicesArgs<ExtArgs>
    Keg?: boolean | Tenant$KegArgs<ExtArgs>
    payments?: boolean | Tenant$paymentsArgs<ExtArgs>
    recipes?: boolean | Tenant$recipesArgs<ExtArgs>
    orders?: boolean | Tenant$ordersArgs<ExtArgs>
    suppliers?: boolean | Tenant$suppliersArgs<ExtArgs>
    tanks?: boolean | Tenant$tanksArgs<ExtArgs>
    transactions?: boolean | Tenant$transactionsArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      batches: Prisma.$BatchPayload<ExtArgs>[]
      budgets: Prisma.$BudgetPayload<ExtArgs>[]
      customers: Prisma.$CustomerPayload<ExtArgs>[]
      Equipment: Prisma.$EquipmentPayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      inventory: Prisma.$InventoryItemPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      Keg: Prisma.$KegPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      recipes: Prisma.$RecipePayload<ExtArgs>[]
      orders: Prisma.$SalesOrderPayload<ExtArgs>[]
      suppliers: Prisma.$SupplierPayload<ExtArgs>[]
      tanks: Prisma.$TankPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      plan: $Enums.PlanType
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      code: string
      legalName: string | null
      taxId: string | null
      phone: string | null
      email: string | null
      address: string | null
      website: string | null
      bankName: string | null
      bankAccount: string | null
      bankSwift: string | null
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batches<T extends Tenant$batchesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany"> | Null>
    budgets<T extends Tenant$budgetsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$budgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany"> | Null>
    customers<T extends Tenant$customersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany"> | Null>
    Equipment<T extends Tenant$EquipmentArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$EquipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany"> | Null>
    expenses<T extends Tenant$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    inventory<T extends Tenant$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Tenant$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    Keg<T extends Tenant$KegArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$KegArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KegPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Tenant$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    recipes<T extends Tenant$recipesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$recipesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends Tenant$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findMany"> | Null>
    suppliers<T extends Tenant$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany"> | Null>
    tanks<T extends Tenant$tanksArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$tanksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TankPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends Tenant$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */ 
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly slug: FieldRef<"Tenant", 'String'>
    readonly plan: FieldRef<"Tenant", 'PlanType'>
    readonly isActive: FieldRef<"Tenant", 'Boolean'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
    readonly code: FieldRef<"Tenant", 'String'>
    readonly legalName: FieldRef<"Tenant", 'String'>
    readonly taxId: FieldRef<"Tenant", 'String'>
    readonly phone: FieldRef<"Tenant", 'String'>
    readonly email: FieldRef<"Tenant", 'String'>
    readonly address: FieldRef<"Tenant", 'String'>
    readonly website: FieldRef<"Tenant", 'String'>
    readonly bankName: FieldRef<"Tenant", 'String'>
    readonly bankAccount: FieldRef<"Tenant", 'String'>
    readonly bankSwift: FieldRef<"Tenant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant.batches
   */
  export type Tenant$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Tenant.budgets
   */
  export type Tenant$budgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    cursor?: BudgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Tenant.customers
   */
  export type Tenant$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Tenant.Equipment
   */
  export type Tenant$EquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Tenant.expenses
   */
  export type Tenant$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Tenant.inventory
   */
  export type Tenant$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Tenant.invoices
   */
  export type Tenant$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Tenant.Keg
   */
  export type Tenant$KegArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keg
     */
    select?: KegSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegInclude<ExtArgs> | null
    where?: KegWhereInput
    orderBy?: KegOrderByWithRelationInput | KegOrderByWithRelationInput[]
    cursor?: KegWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KegScalarFieldEnum | KegScalarFieldEnum[]
  }

  /**
   * Tenant.payments
   */
  export type Tenant$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Tenant.recipes
   */
  export type Tenant$recipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    cursor?: RecipeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Tenant.orders
   */
  export type Tenant$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    where?: SalesOrderWhereInput
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    cursor?: SalesOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * Tenant.suppliers
   */
  export type Tenant$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    cursor?: SupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Tenant.tanks
   */
  export type Tenant$tanksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tank
     */
    select?: TankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankInclude<ExtArgs> | null
    where?: TankWhereInput
    orderBy?: TankOrderByWithRelationInput | TankOrderByWithRelationInput[]
    cursor?: TankWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TankScalarFieldEnum | TankScalarFieldEnum[]
  }

  /**
   * Tenant.transactions
   */
  export type Tenant$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    name: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    password: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    name: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    password: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    tenantId: number
    email: number
    name: number
    role: number
    isActive: number
    createdAt: number
    updatedAt: number
    password: number
    resetToken: number
    resetTokenExpiry: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    name?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    password?: true
    resetToken?: true
    resetTokenExpiry?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    name?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    password?: true
    resetToken?: true
    resetTokenExpiry?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    name?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    password?: true
    resetToken?: true
    resetTokenExpiry?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    tenantId: string
    email: string
    name: string
    role: $Enums.UserRole
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    password: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    tenantId?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      email: string
      name: string
      role: $Enums.UserRole
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      password: string | null
      resetToken: string | null
      resetTokenExpiry: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly password: FieldRef<"User", 'String'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpiry: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Recipe
   */

  export type AggregateRecipe = {
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  export type RecipeAvgAggregateOutputType = {
    abv: Decimal | null
    ibu: number | null
    color: number | null
    og: Decimal | null
    fg: Decimal | null
    batchSize: Decimal | null
    boilTime: number | null
    efficiency: Decimal | null
  }

  export type RecipeSumAggregateOutputType = {
    abv: Decimal | null
    ibu: number | null
    color: number | null
    og: Decimal | null
    fg: Decimal | null
    batchSize: Decimal | null
    boilTime: number | null
    efficiency: Decimal | null
  }

  export type RecipeMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    createdBy: string | null
    name: string | null
    style: string | null
    abv: Decimal | null
    ibu: number | null
    color: number | null
    og: Decimal | null
    fg: Decimal | null
    batchSize: Decimal | null
    boilTime: number | null
    efficiency: Decimal | null
    description: string | null
    notes: string | null
    status: $Enums.RecipeStatus | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    yeastStrain: string | null
  }

  export type RecipeMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    createdBy: string | null
    name: string | null
    style: string | null
    abv: Decimal | null
    ibu: number | null
    color: number | null
    og: Decimal | null
    fg: Decimal | null
    batchSize: Decimal | null
    boilTime: number | null
    efficiency: Decimal | null
    description: string | null
    notes: string | null
    status: $Enums.RecipeStatus | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    yeastStrain: string | null
  }

  export type RecipeCountAggregateOutputType = {
    id: number
    tenantId: number
    createdBy: number
    name: number
    style: number
    abv: number
    ibu: number
    color: number
    og: number
    fg: number
    batchSize: number
    boilTime: number
    efficiency: number
    description: number
    notes: number
    process: number
    status: number
    isActive: number
    createdAt: number
    updatedAt: number
    yeastStrain: number
    _all: number
  }


  export type RecipeAvgAggregateInputType = {
    abv?: true
    ibu?: true
    color?: true
    og?: true
    fg?: true
    batchSize?: true
    boilTime?: true
    efficiency?: true
  }

  export type RecipeSumAggregateInputType = {
    abv?: true
    ibu?: true
    color?: true
    og?: true
    fg?: true
    batchSize?: true
    boilTime?: true
    efficiency?: true
  }

  export type RecipeMinAggregateInputType = {
    id?: true
    tenantId?: true
    createdBy?: true
    name?: true
    style?: true
    abv?: true
    ibu?: true
    color?: true
    og?: true
    fg?: true
    batchSize?: true
    boilTime?: true
    efficiency?: true
    description?: true
    notes?: true
    status?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    yeastStrain?: true
  }

  export type RecipeMaxAggregateInputType = {
    id?: true
    tenantId?: true
    createdBy?: true
    name?: true
    style?: true
    abv?: true
    ibu?: true
    color?: true
    og?: true
    fg?: true
    batchSize?: true
    boilTime?: true
    efficiency?: true
    description?: true
    notes?: true
    status?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    yeastStrain?: true
  }

  export type RecipeCountAggregateInputType = {
    id?: true
    tenantId?: true
    createdBy?: true
    name?: true
    style?: true
    abv?: true
    ibu?: true
    color?: true
    og?: true
    fg?: true
    batchSize?: true
    boilTime?: true
    efficiency?: true
    description?: true
    notes?: true
    process?: true
    status?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    yeastStrain?: true
    _all?: true
  }

  export type RecipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipe to aggregate.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recipes
    **/
    _count?: true | RecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeMaxAggregateInputType
  }

  export type GetRecipeAggregateType<T extends RecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipe[P]>
      : GetScalarType<T[P], AggregateRecipe[P]>
  }




  export type RecipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithAggregationInput | RecipeOrderByWithAggregationInput[]
    by: RecipeScalarFieldEnum[] | RecipeScalarFieldEnum
    having?: RecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeCountAggregateInputType | true
    _avg?: RecipeAvgAggregateInputType
    _sum?: RecipeSumAggregateInputType
    _min?: RecipeMinAggregateInputType
    _max?: RecipeMaxAggregateInputType
  }

  export type RecipeGroupByOutputType = {
    id: string
    tenantId: string
    createdBy: string | null
    name: string
    style: string | null
    abv: Decimal | null
    ibu: number | null
    color: number | null
    og: Decimal | null
    fg: Decimal | null
    batchSize: Decimal | null
    boilTime: number | null
    efficiency: Decimal | null
    description: string | null
    notes: string | null
    process: JsonValue | null
    status: $Enums.RecipeStatus
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    yeastStrain: string | null
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  type GetRecipeGroupByPayload<T extends RecipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeGroupByOutputType[P]>
        }
      >
    >


  export type RecipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    createdBy?: boolean
    name?: boolean
    style?: boolean
    abv?: boolean
    ibu?: boolean
    color?: boolean
    og?: boolean
    fg?: boolean
    batchSize?: boolean
    boilTime?: boolean
    efficiency?: boolean
    description?: boolean
    notes?: boolean
    process?: boolean
    status?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yeastStrain?: boolean
    batches?: boolean | Recipe$batchesArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    ingredients?: boolean | Recipe$ingredientsArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    createdBy?: boolean
    name?: boolean
    style?: boolean
    abv?: boolean
    ibu?: boolean
    color?: boolean
    og?: boolean
    fg?: boolean
    batchSize?: boolean
    boilTime?: boolean
    efficiency?: boolean
    description?: boolean
    notes?: boolean
    process?: boolean
    status?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yeastStrain?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectScalar = {
    id?: boolean
    tenantId?: boolean
    createdBy?: boolean
    name?: boolean
    style?: boolean
    abv?: boolean
    ibu?: boolean
    color?: boolean
    og?: boolean
    fg?: boolean
    batchSize?: boolean
    boilTime?: boolean
    efficiency?: boolean
    description?: boolean
    notes?: boolean
    process?: boolean
    status?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yeastStrain?: boolean
  }

  export type RecipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | Recipe$batchesArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    ingredients?: boolean | Recipe$ingredientsArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RecipeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $RecipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recipe"
    objects: {
      batches: Prisma.$BatchPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
      ingredients: Prisma.$RecipeIngredientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      createdBy: string | null
      name: string
      style: string | null
      abv: Prisma.Decimal | null
      ibu: number | null
      color: number | null
      og: Prisma.Decimal | null
      fg: Prisma.Decimal | null
      batchSize: Prisma.Decimal | null
      boilTime: number | null
      efficiency: Prisma.Decimal | null
      description: string | null
      notes: string | null
      process: Prisma.JsonValue | null
      status: $Enums.RecipeStatus
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      yeastStrain: string | null
    }, ExtArgs["result"]["recipe"]>
    composites: {}
  }

  type RecipeGetPayload<S extends boolean | null | undefined | RecipeDefaultArgs> = $Result.GetResult<Prisma.$RecipePayload, S>

  type RecipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecipeCountAggregateInputType | true
    }

  export interface RecipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recipe'], meta: { name: 'Recipe' } }
    /**
     * Find zero or one Recipe that matches the filter.
     * @param {RecipeFindUniqueArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeFindUniqueArgs>(args: SelectSubset<T, RecipeFindUniqueArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Recipe that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecipeFindUniqueOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Recipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeFindFirstArgs>(args?: SelectSubset<T, RecipeFindFirstArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Recipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Recipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recipes
     * const recipes = await prisma.recipe.findMany()
     * 
     * // Get first 10 Recipes
     * const recipes = await prisma.recipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeWithIdOnly = await prisma.recipe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeFindManyArgs>(args?: SelectSubset<T, RecipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Recipe.
     * @param {RecipeCreateArgs} args - Arguments to create a Recipe.
     * @example
     * // Create one Recipe
     * const Recipe = await prisma.recipe.create({
     *   data: {
     *     // ... data to create a Recipe
     *   }
     * })
     * 
     */
    create<T extends RecipeCreateArgs>(args: SelectSubset<T, RecipeCreateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Recipes.
     * @param {RecipeCreateManyArgs} args - Arguments to create many Recipes.
     * @example
     * // Create many Recipes
     * const recipe = await prisma.recipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeCreateManyArgs>(args?: SelectSubset<T, RecipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recipes and returns the data saved in the database.
     * @param {RecipeCreateManyAndReturnArgs} args - Arguments to create many Recipes.
     * @example
     * // Create many Recipes
     * const recipe = await prisma.recipe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recipes and only return the `id`
     * const recipeWithIdOnly = await prisma.recipe.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Recipe.
     * @param {RecipeDeleteArgs} args - Arguments to delete one Recipe.
     * @example
     * // Delete one Recipe
     * const Recipe = await prisma.recipe.delete({
     *   where: {
     *     // ... filter to delete one Recipe
     *   }
     * })
     * 
     */
    delete<T extends RecipeDeleteArgs>(args: SelectSubset<T, RecipeDeleteArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Recipe.
     * @param {RecipeUpdateArgs} args - Arguments to update one Recipe.
     * @example
     * // Update one Recipe
     * const recipe = await prisma.recipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeUpdateArgs>(args: SelectSubset<T, RecipeUpdateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Recipes.
     * @param {RecipeDeleteManyArgs} args - Arguments to filter Recipes to delete.
     * @example
     * // Delete a few Recipes
     * const { count } = await prisma.recipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeDeleteManyArgs>(args?: SelectSubset<T, RecipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeUpdateManyArgs>(args: SelectSubset<T, RecipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recipe.
     * @param {RecipeUpsertArgs} args - Arguments to update or create a Recipe.
     * @example
     * // Update or create a Recipe
     * const recipe = await prisma.recipe.upsert({
     *   create: {
     *     // ... data to create a Recipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recipe we want to update
     *   }
     * })
     */
    upsert<T extends RecipeUpsertArgs>(args: SelectSubset<T, RecipeUpsertArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeCountArgs} args - Arguments to filter Recipes to count.
     * @example
     * // Count the number of Recipes
     * const count = await prisma.recipe.count({
     *   where: {
     *     // ... the filter for the Recipes we want to count
     *   }
     * })
    **/
    count<T extends RecipeCountArgs>(
      args?: Subset<T, RecipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeAggregateArgs>(args: Subset<T, RecipeAggregateArgs>): Prisma.PrismaPromise<GetRecipeAggregateType<T>>

    /**
     * Group by Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeGroupByArgs['orderBy'] }
        : { orderBy?: RecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recipe model
   */
  readonly fields: RecipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batches<T extends Recipe$batchesArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany"> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ingredients<T extends Recipe$ingredientsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$ingredientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recipe model
   */ 
  interface RecipeFieldRefs {
    readonly id: FieldRef<"Recipe", 'String'>
    readonly tenantId: FieldRef<"Recipe", 'String'>
    readonly createdBy: FieldRef<"Recipe", 'String'>
    readonly name: FieldRef<"Recipe", 'String'>
    readonly style: FieldRef<"Recipe", 'String'>
    readonly abv: FieldRef<"Recipe", 'Decimal'>
    readonly ibu: FieldRef<"Recipe", 'Int'>
    readonly color: FieldRef<"Recipe", 'Int'>
    readonly og: FieldRef<"Recipe", 'Decimal'>
    readonly fg: FieldRef<"Recipe", 'Decimal'>
    readonly batchSize: FieldRef<"Recipe", 'Decimal'>
    readonly boilTime: FieldRef<"Recipe", 'Int'>
    readonly efficiency: FieldRef<"Recipe", 'Decimal'>
    readonly description: FieldRef<"Recipe", 'String'>
    readonly notes: FieldRef<"Recipe", 'String'>
    readonly process: FieldRef<"Recipe", 'Json'>
    readonly status: FieldRef<"Recipe", 'RecipeStatus'>
    readonly isActive: FieldRef<"Recipe", 'Boolean'>
    readonly createdAt: FieldRef<"Recipe", 'DateTime'>
    readonly updatedAt: FieldRef<"Recipe", 'DateTime'>
    readonly yeastStrain: FieldRef<"Recipe", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Recipe findUnique
   */
  export type RecipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findUniqueOrThrow
   */
  export type RecipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findFirst
   */
  export type RecipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findFirstOrThrow
   */
  export type RecipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findMany
   */
  export type RecipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipes to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe create
   */
  export type RecipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to create a Recipe.
     */
    data: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
  }

  /**
   * Recipe createMany
   */
  export type RecipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Recipe createManyAndReturn
   */
  export type RecipeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Recipe update
   */
  export type RecipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to update a Recipe.
     */
    data: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
    /**
     * Choose, which Recipe to update.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe updateMany
   */
  export type RecipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recipes.
     */
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     */
    where?: RecipeWhereInput
  }

  /**
   * Recipe upsert
   */
  export type RecipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The filter to search for the Recipe to update in case it exists.
     */
    where: RecipeWhereUniqueInput
    /**
     * In case the Recipe found by the `where` argument doesn't exist, create a new Recipe with this data.
     */
    create: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
    /**
     * In case the Recipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
  }

  /**
   * Recipe delete
   */
  export type RecipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter which Recipe to delete.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe deleteMany
   */
  export type RecipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipes to delete
     */
    where?: RecipeWhereInput
  }

  /**
   * Recipe.batches
   */
  export type Recipe$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Recipe.ingredients
   */
  export type Recipe$ingredientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    where?: RecipeIngredientWhereInput
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    cursor?: RecipeIngredientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }

  /**
   * Recipe without action
   */
  export type RecipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
  }


  /**
   * Model RecipeIngredient
   */

  export type AggregateRecipeIngredient = {
    _count: RecipeIngredientCountAggregateOutputType | null
    _avg: RecipeIngredientAvgAggregateOutputType | null
    _sum: RecipeIngredientSumAggregateOutputType | null
    _min: RecipeIngredientMinAggregateOutputType | null
    _max: RecipeIngredientMaxAggregateOutputType | null
  }

  export type RecipeIngredientAvgAggregateOutputType = {
    amount: Decimal | null
    additionTime: number | null
  }

  export type RecipeIngredientSumAggregateOutputType = {
    amount: Decimal | null
    additionTime: number | null
  }

  export type RecipeIngredientMinAggregateOutputType = {
    id: string | null
    recipeId: string | null
    inventoryItemId: string | null
    name: string | null
    category: $Enums.IngredientCategory | null
    amount: Decimal | null
    unit: string | null
    additionTime: number | null
  }

  export type RecipeIngredientMaxAggregateOutputType = {
    id: string | null
    recipeId: string | null
    inventoryItemId: string | null
    name: string | null
    category: $Enums.IngredientCategory | null
    amount: Decimal | null
    unit: string | null
    additionTime: number | null
  }

  export type RecipeIngredientCountAggregateOutputType = {
    id: number
    recipeId: number
    inventoryItemId: number
    name: number
    category: number
    amount: number
    unit: number
    additionTime: number
    specs: number
    _all: number
  }


  export type RecipeIngredientAvgAggregateInputType = {
    amount?: true
    additionTime?: true
  }

  export type RecipeIngredientSumAggregateInputType = {
    amount?: true
    additionTime?: true
  }

  export type RecipeIngredientMinAggregateInputType = {
    id?: true
    recipeId?: true
    inventoryItemId?: true
    name?: true
    category?: true
    amount?: true
    unit?: true
    additionTime?: true
  }

  export type RecipeIngredientMaxAggregateInputType = {
    id?: true
    recipeId?: true
    inventoryItemId?: true
    name?: true
    category?: true
    amount?: true
    unit?: true
    additionTime?: true
  }

  export type RecipeIngredientCountAggregateInputType = {
    id?: true
    recipeId?: true
    inventoryItemId?: true
    name?: true
    category?: true
    amount?: true
    unit?: true
    additionTime?: true
    specs?: true
    _all?: true
  }

  export type RecipeIngredientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeIngredient to aggregate.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeIngredients
    **/
    _count?: true | RecipeIngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeIngredientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeIngredientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeIngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeIngredientMaxAggregateInputType
  }

  export type GetRecipeIngredientAggregateType<T extends RecipeIngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeIngredient[P]>
      : GetScalarType<T[P], AggregateRecipeIngredient[P]>
  }




  export type RecipeIngredientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeIngredientWhereInput
    orderBy?: RecipeIngredientOrderByWithAggregationInput | RecipeIngredientOrderByWithAggregationInput[]
    by: RecipeIngredientScalarFieldEnum[] | RecipeIngredientScalarFieldEnum
    having?: RecipeIngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeIngredientCountAggregateInputType | true
    _avg?: RecipeIngredientAvgAggregateInputType
    _sum?: RecipeIngredientSumAggregateInputType
    _min?: RecipeIngredientMinAggregateInputType
    _max?: RecipeIngredientMaxAggregateInputType
  }

  export type RecipeIngredientGroupByOutputType = {
    id: string
    recipeId: string
    inventoryItemId: string | null
    name: string
    category: $Enums.IngredientCategory
    amount: Decimal
    unit: string
    additionTime: number | null
    specs: JsonValue | null
    _count: RecipeIngredientCountAggregateOutputType | null
    _avg: RecipeIngredientAvgAggregateOutputType | null
    _sum: RecipeIngredientSumAggregateOutputType | null
    _min: RecipeIngredientMinAggregateOutputType | null
    _max: RecipeIngredientMaxAggregateOutputType | null
  }

  type GetRecipeIngredientGroupByPayload<T extends RecipeIngredientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeIngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeIngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeIngredientGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeIngredientGroupByOutputType[P]>
        }
      >
    >


  export type RecipeIngredientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    inventoryItemId?: boolean
    name?: boolean
    category?: boolean
    amount?: boolean
    unit?: boolean
    additionTime?: boolean
    specs?: boolean
    inventoryItem?: boolean | RecipeIngredient$inventoryItemArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeIngredient"]>

  export type RecipeIngredientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    inventoryItemId?: boolean
    name?: boolean
    category?: boolean
    amount?: boolean
    unit?: boolean
    additionTime?: boolean
    specs?: boolean
    inventoryItem?: boolean | RecipeIngredient$inventoryItemArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeIngredient"]>

  export type RecipeIngredientSelectScalar = {
    id?: boolean
    recipeId?: boolean
    inventoryItemId?: boolean
    name?: boolean
    category?: boolean
    amount?: boolean
    unit?: boolean
    additionTime?: boolean
    specs?: boolean
  }

  export type RecipeIngredientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItem?: boolean | RecipeIngredient$inventoryItemArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }
  export type RecipeIngredientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItem?: boolean | RecipeIngredient$inventoryItemArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }

  export type $RecipeIngredientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeIngredient"
    objects: {
      inventoryItem: Prisma.$InventoryItemPayload<ExtArgs> | null
      recipe: Prisma.$RecipePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipeId: string
      inventoryItemId: string | null
      name: string
      category: $Enums.IngredientCategory
      amount: Prisma.Decimal
      unit: string
      additionTime: number | null
      specs: Prisma.JsonValue | null
    }, ExtArgs["result"]["recipeIngredient"]>
    composites: {}
  }

  type RecipeIngredientGetPayload<S extends boolean | null | undefined | RecipeIngredientDefaultArgs> = $Result.GetResult<Prisma.$RecipeIngredientPayload, S>

  type RecipeIngredientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeIngredientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecipeIngredientCountAggregateInputType | true
    }

  export interface RecipeIngredientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeIngredient'], meta: { name: 'RecipeIngredient' } }
    /**
     * Find zero or one RecipeIngredient that matches the filter.
     * @param {RecipeIngredientFindUniqueArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeIngredientFindUniqueArgs>(args: SelectSubset<T, RecipeIngredientFindUniqueArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RecipeIngredient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecipeIngredientFindUniqueOrThrowArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeIngredientFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeIngredientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RecipeIngredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientFindFirstArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeIngredientFindFirstArgs>(args?: SelectSubset<T, RecipeIngredientFindFirstArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RecipeIngredient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientFindFirstOrThrowArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeIngredientFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeIngredientFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RecipeIngredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeIngredients
     * const recipeIngredients = await prisma.recipeIngredient.findMany()
     * 
     * // Get first 10 RecipeIngredients
     * const recipeIngredients = await prisma.recipeIngredient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeIngredientWithIdOnly = await prisma.recipeIngredient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeIngredientFindManyArgs>(args?: SelectSubset<T, RecipeIngredientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RecipeIngredient.
     * @param {RecipeIngredientCreateArgs} args - Arguments to create a RecipeIngredient.
     * @example
     * // Create one RecipeIngredient
     * const RecipeIngredient = await prisma.recipeIngredient.create({
     *   data: {
     *     // ... data to create a RecipeIngredient
     *   }
     * })
     * 
     */
    create<T extends RecipeIngredientCreateArgs>(args: SelectSubset<T, RecipeIngredientCreateArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RecipeIngredients.
     * @param {RecipeIngredientCreateManyArgs} args - Arguments to create many RecipeIngredients.
     * @example
     * // Create many RecipeIngredients
     * const recipeIngredient = await prisma.recipeIngredient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeIngredientCreateManyArgs>(args?: SelectSubset<T, RecipeIngredientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecipeIngredients and returns the data saved in the database.
     * @param {RecipeIngredientCreateManyAndReturnArgs} args - Arguments to create many RecipeIngredients.
     * @example
     * // Create many RecipeIngredients
     * const recipeIngredient = await prisma.recipeIngredient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecipeIngredients and only return the `id`
     * const recipeIngredientWithIdOnly = await prisma.recipeIngredient.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeIngredientCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeIngredientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RecipeIngredient.
     * @param {RecipeIngredientDeleteArgs} args - Arguments to delete one RecipeIngredient.
     * @example
     * // Delete one RecipeIngredient
     * const RecipeIngredient = await prisma.recipeIngredient.delete({
     *   where: {
     *     // ... filter to delete one RecipeIngredient
     *   }
     * })
     * 
     */
    delete<T extends RecipeIngredientDeleteArgs>(args: SelectSubset<T, RecipeIngredientDeleteArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RecipeIngredient.
     * @param {RecipeIngredientUpdateArgs} args - Arguments to update one RecipeIngredient.
     * @example
     * // Update one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeIngredientUpdateArgs>(args: SelectSubset<T, RecipeIngredientUpdateArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RecipeIngredients.
     * @param {RecipeIngredientDeleteManyArgs} args - Arguments to filter RecipeIngredients to delete.
     * @example
     * // Delete a few RecipeIngredients
     * const { count } = await prisma.recipeIngredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeIngredientDeleteManyArgs>(args?: SelectSubset<T, RecipeIngredientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeIngredients
     * const recipeIngredient = await prisma.recipeIngredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeIngredientUpdateManyArgs>(args: SelectSubset<T, RecipeIngredientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecipeIngredient.
     * @param {RecipeIngredientUpsertArgs} args - Arguments to update or create a RecipeIngredient.
     * @example
     * // Update or create a RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.upsert({
     *   create: {
     *     // ... data to create a RecipeIngredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeIngredient we want to update
     *   }
     * })
     */
    upsert<T extends RecipeIngredientUpsertArgs>(args: SelectSubset<T, RecipeIngredientUpsertArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RecipeIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientCountArgs} args - Arguments to filter RecipeIngredients to count.
     * @example
     * // Count the number of RecipeIngredients
     * const count = await prisma.recipeIngredient.count({
     *   where: {
     *     // ... the filter for the RecipeIngredients we want to count
     *   }
     * })
    **/
    count<T extends RecipeIngredientCountArgs>(
      args?: Subset<T, RecipeIngredientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeIngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeIngredientAggregateArgs>(args: Subset<T, RecipeIngredientAggregateArgs>): Prisma.PrismaPromise<GetRecipeIngredientAggregateType<T>>

    /**
     * Group by RecipeIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeIngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeIngredientGroupByArgs['orderBy'] }
        : { orderBy?: RecipeIngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeIngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeIngredientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeIngredient model
   */
  readonly fields: RecipeIngredientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeIngredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeIngredientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventoryItem<T extends RecipeIngredient$inventoryItemArgs<ExtArgs> = {}>(args?: Subset<T, RecipeIngredient$inventoryItemArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecipeIngredient model
   */ 
  interface RecipeIngredientFieldRefs {
    readonly id: FieldRef<"RecipeIngredient", 'String'>
    readonly recipeId: FieldRef<"RecipeIngredient", 'String'>
    readonly inventoryItemId: FieldRef<"RecipeIngredient", 'String'>
    readonly name: FieldRef<"RecipeIngredient", 'String'>
    readonly category: FieldRef<"RecipeIngredient", 'IngredientCategory'>
    readonly amount: FieldRef<"RecipeIngredient", 'Decimal'>
    readonly unit: FieldRef<"RecipeIngredient", 'String'>
    readonly additionTime: FieldRef<"RecipeIngredient", 'Int'>
    readonly specs: FieldRef<"RecipeIngredient", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * RecipeIngredient findUnique
   */
  export type RecipeIngredientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where: RecipeIngredientWhereUniqueInput
  }

  /**
   * RecipeIngredient findUniqueOrThrow
   */
  export type RecipeIngredientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where: RecipeIngredientWhereUniqueInput
  }

  /**
   * RecipeIngredient findFirst
   */
  export type RecipeIngredientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeIngredients.
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeIngredients.
     */
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }

  /**
   * RecipeIngredient findFirstOrThrow
   */
  export type RecipeIngredientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeIngredients.
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeIngredients.
     */
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }

  /**
   * RecipeIngredient findMany
   */
  export type RecipeIngredientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredients to fetch.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeIngredients.
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }

  /**
   * RecipeIngredient create
   */
  export type RecipeIngredientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeIngredient.
     */
    data: XOR<RecipeIngredientCreateInput, RecipeIngredientUncheckedCreateInput>
  }

  /**
   * RecipeIngredient createMany
   */
  export type RecipeIngredientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeIngredients.
     */
    data: RecipeIngredientCreateManyInput | RecipeIngredientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecipeIngredient createManyAndReturn
   */
  export type RecipeIngredientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RecipeIngredients.
     */
    data: RecipeIngredientCreateManyInput | RecipeIngredientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeIngredient update
   */
  export type RecipeIngredientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeIngredient.
     */
    data: XOR<RecipeIngredientUpdateInput, RecipeIngredientUncheckedUpdateInput>
    /**
     * Choose, which RecipeIngredient to update.
     */
    where: RecipeIngredientWhereUniqueInput
  }

  /**
   * RecipeIngredient updateMany
   */
  export type RecipeIngredientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeIngredients.
     */
    data: XOR<RecipeIngredientUpdateManyMutationInput, RecipeIngredientUncheckedUpdateManyInput>
    /**
     * Filter which RecipeIngredients to update
     */
    where?: RecipeIngredientWhereInput
  }

  /**
   * RecipeIngredient upsert
   */
  export type RecipeIngredientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeIngredient to update in case it exists.
     */
    where: RecipeIngredientWhereUniqueInput
    /**
     * In case the RecipeIngredient found by the `where` argument doesn't exist, create a new RecipeIngredient with this data.
     */
    create: XOR<RecipeIngredientCreateInput, RecipeIngredientUncheckedCreateInput>
    /**
     * In case the RecipeIngredient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeIngredientUpdateInput, RecipeIngredientUncheckedUpdateInput>
  }

  /**
   * RecipeIngredient delete
   */
  export type RecipeIngredientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter which RecipeIngredient to delete.
     */
    where: RecipeIngredientWhereUniqueInput
  }

  /**
   * RecipeIngredient deleteMany
   */
  export type RecipeIngredientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeIngredients to delete
     */
    where?: RecipeIngredientWhereInput
  }

  /**
   * RecipeIngredient.inventoryItem
   */
  export type RecipeIngredient$inventoryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
  }

  /**
   * RecipeIngredient without action
   */
  export type RecipeIngredientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
  }


  /**
   * Model InventoryItem
   */

  export type AggregateInventoryItem = {
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  export type InventoryItemAvgAggregateOutputType = {
    reorderPoint: Decimal | null
    cachedBalance: Decimal | null
    costPerUnit: Decimal | null
  }

  export type InventoryItemSumAggregateOutputType = {
    reorderPoint: Decimal | null
    cachedBalance: Decimal | null
    costPerUnit: Decimal | null
  }

  export type InventoryItemMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    sku: string | null
    name: string | null
    category: $Enums.InventoryCategory | null
    ingredientType: string | null
    unit: string | null
    reorderPoint: Decimal | null
    supplier: string | null
    location: string | null
    cachedBalance: Decimal | null
    costPerUnit: Decimal | null
    balanceUpdatedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryItemMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    sku: string | null
    name: string | null
    category: $Enums.InventoryCategory | null
    ingredientType: string | null
    unit: string | null
    reorderPoint: Decimal | null
    supplier: string | null
    location: string | null
    cachedBalance: Decimal | null
    costPerUnit: Decimal | null
    balanceUpdatedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryItemCountAggregateOutputType = {
    id: number
    tenantId: number
    sku: number
    name: number
    category: number
    ingredientType: number
    unit: number
    reorderPoint: number
    supplier: number
    location: number
    specs: number
    cachedBalance: number
    costPerUnit: number
    balanceUpdatedAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryItemAvgAggregateInputType = {
    reorderPoint?: true
    cachedBalance?: true
    costPerUnit?: true
  }

  export type InventoryItemSumAggregateInputType = {
    reorderPoint?: true
    cachedBalance?: true
    costPerUnit?: true
  }

  export type InventoryItemMinAggregateInputType = {
    id?: true
    tenantId?: true
    sku?: true
    name?: true
    category?: true
    ingredientType?: true
    unit?: true
    reorderPoint?: true
    supplier?: true
    location?: true
    cachedBalance?: true
    costPerUnit?: true
    balanceUpdatedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryItemMaxAggregateInputType = {
    id?: true
    tenantId?: true
    sku?: true
    name?: true
    category?: true
    ingredientType?: true
    unit?: true
    reorderPoint?: true
    supplier?: true
    location?: true
    cachedBalance?: true
    costPerUnit?: true
    balanceUpdatedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryItemCountAggregateInputType = {
    id?: true
    tenantId?: true
    sku?: true
    name?: true
    category?: true
    ingredientType?: true
    unit?: true
    reorderPoint?: true
    supplier?: true
    location?: true
    specs?: true
    cachedBalance?: true
    costPerUnit?: true
    balanceUpdatedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItem to aggregate.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryItems
    **/
    _count?: true | InventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryItemMaxAggregateInputType
  }

  export type GetInventoryItemAggregateType<T extends InventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryItem[P]>
      : GetScalarType<T[P], AggregateInventoryItem[P]>
  }




  export type InventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithAggregationInput | InventoryItemOrderByWithAggregationInput[]
    by: InventoryItemScalarFieldEnum[] | InventoryItemScalarFieldEnum
    having?: InventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryItemCountAggregateInputType | true
    _avg?: InventoryItemAvgAggregateInputType
    _sum?: InventoryItemSumAggregateInputType
    _min?: InventoryItemMinAggregateInputType
    _max?: InventoryItemMaxAggregateInputType
  }

  export type InventoryItemGroupByOutputType = {
    id: string
    tenantId: string
    sku: string
    name: string
    category: $Enums.InventoryCategory
    ingredientType: string | null
    unit: string
    reorderPoint: Decimal | null
    supplier: string | null
    location: string | null
    specs: JsonValue | null
    cachedBalance: Decimal
    costPerUnit: Decimal | null
    balanceUpdatedAt: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  type GetInventoryItemGroupByPayload<T extends InventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    sku?: boolean
    name?: boolean
    category?: boolean
    ingredientType?: boolean
    unit?: boolean
    reorderPoint?: boolean
    supplier?: boolean
    location?: boolean
    specs?: boolean
    cachedBalance?: boolean
    costPerUnit?: boolean
    balanceUpdatedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    ledger?: boolean | InventoryItem$ledgerArgs<ExtArgs>
    recipeIngredients?: boolean | InventoryItem$recipeIngredientsArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    sku?: boolean
    name?: boolean
    category?: boolean
    ingredientType?: boolean
    unit?: boolean
    reorderPoint?: boolean
    supplier?: boolean
    location?: boolean
    specs?: boolean
    cachedBalance?: boolean
    costPerUnit?: boolean
    balanceUpdatedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectScalar = {
    id?: boolean
    tenantId?: boolean
    sku?: boolean
    name?: boolean
    category?: boolean
    ingredientType?: boolean
    unit?: boolean
    reorderPoint?: boolean
    supplier?: boolean
    location?: boolean
    specs?: boolean
    cachedBalance?: boolean
    costPerUnit?: boolean
    balanceUpdatedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    ledger?: boolean | InventoryItem$ledgerArgs<ExtArgs>
    recipeIngredients?: boolean | InventoryItem$recipeIngredientsArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $InventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryItem"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      ledger: Prisma.$InventoryLedgerPayload<ExtArgs>[]
      recipeIngredients: Prisma.$RecipeIngredientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      sku: string
      name: string
      category: $Enums.InventoryCategory
      ingredientType: string | null
      unit: string
      reorderPoint: Prisma.Decimal | null
      supplier: string | null
      location: string | null
      specs: Prisma.JsonValue | null
      cachedBalance: Prisma.Decimal
      costPerUnit: Prisma.Decimal | null
      balanceUpdatedAt: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventoryItem"]>
    composites: {}
  }

  type InventoryItemGetPayload<S extends boolean | null | undefined | InventoryItemDefaultArgs> = $Result.GetResult<Prisma.$InventoryItemPayload, S>

  type InventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryItemCountAggregateInputType | true
    }

  export interface InventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryItem'], meta: { name: 'InventoryItem' } }
    /**
     * Find zero or one InventoryItem that matches the filter.
     * @param {InventoryItemFindUniqueArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryItemFindUniqueArgs>(args: SelectSubset<T, InventoryItemFindUniqueArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InventoryItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventoryItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryItemFindFirstArgs>(args?: SelectSubset<T, InventoryItemFindFirstArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany()
     * 
     * // Get first 10 InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryItemFindManyArgs>(args?: SelectSubset<T, InventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InventoryItem.
     * @param {InventoryItemCreateArgs} args - Arguments to create a InventoryItem.
     * @example
     * // Create one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.create({
     *   data: {
     *     // ... data to create a InventoryItem
     *   }
     * })
     * 
     */
    create<T extends InventoryItemCreateArgs>(args: SelectSubset<T, InventoryItemCreateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InventoryItems.
     * @param {InventoryItemCreateManyArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryItemCreateManyArgs>(args?: SelectSubset<T, InventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryItems and returns the data saved in the database.
     * @param {InventoryItemCreateManyAndReturnArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InventoryItem.
     * @param {InventoryItemDeleteArgs} args - Arguments to delete one InventoryItem.
     * @example
     * // Delete one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryItem
     *   }
     * })
     * 
     */
    delete<T extends InventoryItemDeleteArgs>(args: SelectSubset<T, InventoryItemDeleteArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InventoryItem.
     * @param {InventoryItemUpdateArgs} args - Arguments to update one InventoryItem.
     * @example
     * // Update one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryItemUpdateArgs>(args: SelectSubset<T, InventoryItemUpdateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InventoryItems.
     * @param {InventoryItemDeleteManyArgs} args - Arguments to filter InventoryItems to delete.
     * @example
     * // Delete a few InventoryItems
     * const { count } = await prisma.inventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryItemDeleteManyArgs>(args?: SelectSubset<T, InventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryItemUpdateManyArgs>(args: SelectSubset<T, InventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryItem.
     * @param {InventoryItemUpsertArgs} args - Arguments to update or create a InventoryItem.
     * @example
     * // Update or create a InventoryItem
     * const inventoryItem = await prisma.inventoryItem.upsert({
     *   create: {
     *     // ... data to create a InventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends InventoryItemUpsertArgs>(args: SelectSubset<T, InventoryItemUpsertArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemCountArgs} args - Arguments to filter InventoryItems to count.
     * @example
     * // Count the number of InventoryItems
     * const count = await prisma.inventoryItem.count({
     *   where: {
     *     // ... the filter for the InventoryItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryItemCountArgs>(
      args?: Subset<T, InventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryItemAggregateArgs>(args: Subset<T, InventoryItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryItemAggregateType<T>>

    /**
     * Group by InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryItem model
   */
  readonly fields: InventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ledger<T extends InventoryItem$ledgerArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$ledgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "findMany"> | Null>
    recipeIngredients<T extends InventoryItem$recipeIngredientsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$recipeIngredientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryItem model
   */ 
  interface InventoryItemFieldRefs {
    readonly id: FieldRef<"InventoryItem", 'String'>
    readonly tenantId: FieldRef<"InventoryItem", 'String'>
    readonly sku: FieldRef<"InventoryItem", 'String'>
    readonly name: FieldRef<"InventoryItem", 'String'>
    readonly category: FieldRef<"InventoryItem", 'InventoryCategory'>
    readonly ingredientType: FieldRef<"InventoryItem", 'String'>
    readonly unit: FieldRef<"InventoryItem", 'String'>
    readonly reorderPoint: FieldRef<"InventoryItem", 'Decimal'>
    readonly supplier: FieldRef<"InventoryItem", 'String'>
    readonly location: FieldRef<"InventoryItem", 'String'>
    readonly specs: FieldRef<"InventoryItem", 'Json'>
    readonly cachedBalance: FieldRef<"InventoryItem", 'Decimal'>
    readonly costPerUnit: FieldRef<"InventoryItem", 'Decimal'>
    readonly balanceUpdatedAt: FieldRef<"InventoryItem", 'DateTime'>
    readonly isActive: FieldRef<"InventoryItem", 'Boolean'>
    readonly createdAt: FieldRef<"InventoryItem", 'DateTime'>
    readonly updatedAt: FieldRef<"InventoryItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryItem findUnique
   */
  export type InventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findUniqueOrThrow
   */
  export type InventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findFirst
   */
  export type InventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findFirstOrThrow
   */
  export type InventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findMany
   */
  export type InventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItems to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem create
   */
  export type InventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryItem.
     */
    data: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
  }

  /**
   * InventoryItem createMany
   */
  export type InventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryItem createManyAndReturn
   */
  export type InventoryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem update
   */
  export type InventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryItem.
     */
    data: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryItem to update.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem updateMany
   */
  export type InventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
  }

  /**
   * InventoryItem upsert
   */
  export type InventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryItem to update in case it exists.
     */
    where: InventoryItemWhereUniqueInput
    /**
     * In case the InventoryItem found by the `where` argument doesn't exist, create a new InventoryItem with this data.
     */
    create: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
    /**
     * In case the InventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
  }

  /**
   * InventoryItem delete
   */
  export type InventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter which InventoryItem to delete.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem deleteMany
   */
  export type InventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItems to delete
     */
    where?: InventoryItemWhereInput
  }

  /**
   * InventoryItem.ledger
   */
  export type InventoryItem$ledgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    where?: InventoryLedgerWhereInput
    orderBy?: InventoryLedgerOrderByWithRelationInput | InventoryLedgerOrderByWithRelationInput[]
    cursor?: InventoryLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryLedgerScalarFieldEnum | InventoryLedgerScalarFieldEnum[]
  }

  /**
   * InventoryItem.recipeIngredients
   */
  export type InventoryItem$recipeIngredientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    where?: RecipeIngredientWhereInput
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    cursor?: RecipeIngredientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }

  /**
   * InventoryItem without action
   */
  export type InventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model InventoryLedger
   */

  export type AggregateInventoryLedger = {
    _count: InventoryLedgerCountAggregateOutputType | null
    _avg: InventoryLedgerAvgAggregateOutputType | null
    _sum: InventoryLedgerSumAggregateOutputType | null
    _min: InventoryLedgerMinAggregateOutputType | null
    _max: InventoryLedgerMaxAggregateOutputType | null
  }

  export type InventoryLedgerAvgAggregateOutputType = {
    quantity: Decimal | null
  }

  export type InventoryLedgerSumAggregateOutputType = {
    quantity: Decimal | null
  }

  export type InventoryLedgerMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    itemId: string | null
    quantity: Decimal | null
    type: $Enums.LedgerEntryType | null
    batchId: string | null
    orderId: string | null
    packagingId: string | null
    notes: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type InventoryLedgerMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    itemId: string | null
    quantity: Decimal | null
    type: $Enums.LedgerEntryType | null
    batchId: string | null
    orderId: string | null
    packagingId: string | null
    notes: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type InventoryLedgerCountAggregateOutputType = {
    id: number
    tenantId: number
    itemId: number
    quantity: number
    type: number
    batchId: number
    orderId: number
    packagingId: number
    notes: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type InventoryLedgerAvgAggregateInputType = {
    quantity?: true
  }

  export type InventoryLedgerSumAggregateInputType = {
    quantity?: true
  }

  export type InventoryLedgerMinAggregateInputType = {
    id?: true
    tenantId?: true
    itemId?: true
    quantity?: true
    type?: true
    batchId?: true
    orderId?: true
    packagingId?: true
    notes?: true
    createdBy?: true
    createdAt?: true
  }

  export type InventoryLedgerMaxAggregateInputType = {
    id?: true
    tenantId?: true
    itemId?: true
    quantity?: true
    type?: true
    batchId?: true
    orderId?: true
    packagingId?: true
    notes?: true
    createdBy?: true
    createdAt?: true
  }

  export type InventoryLedgerCountAggregateInputType = {
    id?: true
    tenantId?: true
    itemId?: true
    quantity?: true
    type?: true
    batchId?: true
    orderId?: true
    packagingId?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type InventoryLedgerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryLedger to aggregate.
     */
    where?: InventoryLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryLedgers to fetch.
     */
    orderBy?: InventoryLedgerOrderByWithRelationInput | InventoryLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryLedgers
    **/
    _count?: true | InventoryLedgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryLedgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryLedgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryLedgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryLedgerMaxAggregateInputType
  }

  export type GetInventoryLedgerAggregateType<T extends InventoryLedgerAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryLedger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryLedger[P]>
      : GetScalarType<T[P], AggregateInventoryLedger[P]>
  }




  export type InventoryLedgerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryLedgerWhereInput
    orderBy?: InventoryLedgerOrderByWithAggregationInput | InventoryLedgerOrderByWithAggregationInput[]
    by: InventoryLedgerScalarFieldEnum[] | InventoryLedgerScalarFieldEnum
    having?: InventoryLedgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryLedgerCountAggregateInputType | true
    _avg?: InventoryLedgerAvgAggregateInputType
    _sum?: InventoryLedgerSumAggregateInputType
    _min?: InventoryLedgerMinAggregateInputType
    _max?: InventoryLedgerMaxAggregateInputType
  }

  export type InventoryLedgerGroupByOutputType = {
    id: string
    tenantId: string
    itemId: string
    quantity: Decimal
    type: $Enums.LedgerEntryType
    batchId: string | null
    orderId: string | null
    packagingId: string | null
    notes: string | null
    createdBy: string
    createdAt: Date
    _count: InventoryLedgerCountAggregateOutputType | null
    _avg: InventoryLedgerAvgAggregateOutputType | null
    _sum: InventoryLedgerSumAggregateOutputType | null
    _min: InventoryLedgerMinAggregateOutputType | null
    _max: InventoryLedgerMaxAggregateOutputType | null
  }

  type GetInventoryLedgerGroupByPayload<T extends InventoryLedgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryLedgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryLedgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryLedgerGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryLedgerGroupByOutputType[P]>
        }
      >
    >


  export type InventoryLedgerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    itemId?: boolean
    quantity?: boolean
    type?: boolean
    batchId?: boolean
    orderId?: boolean
    packagingId?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    batch?: boolean | InventoryLedger$batchArgs<ExtArgs>
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryLedger"]>

  export type InventoryLedgerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    itemId?: boolean
    quantity?: boolean
    type?: boolean
    batchId?: boolean
    orderId?: boolean
    packagingId?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    batch?: boolean | InventoryLedger$batchArgs<ExtArgs>
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryLedger"]>

  export type InventoryLedgerSelectScalar = {
    id?: boolean
    tenantId?: boolean
    itemId?: boolean
    quantity?: boolean
    type?: boolean
    batchId?: boolean
    orderId?: boolean
    packagingId?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type InventoryLedgerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | InventoryLedger$batchArgs<ExtArgs>
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }
  export type InventoryLedgerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | InventoryLedger$batchArgs<ExtArgs>
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }

  export type $InventoryLedgerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryLedger"
    objects: {
      batch: Prisma.$BatchPayload<ExtArgs> | null
      item: Prisma.$InventoryItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      itemId: string
      quantity: Prisma.Decimal
      type: $Enums.LedgerEntryType
      batchId: string | null
      orderId: string | null
      packagingId: string | null
      notes: string | null
      createdBy: string
      createdAt: Date
    }, ExtArgs["result"]["inventoryLedger"]>
    composites: {}
  }

  type InventoryLedgerGetPayload<S extends boolean | null | undefined | InventoryLedgerDefaultArgs> = $Result.GetResult<Prisma.$InventoryLedgerPayload, S>

  type InventoryLedgerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryLedgerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryLedgerCountAggregateInputType | true
    }

  export interface InventoryLedgerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryLedger'], meta: { name: 'InventoryLedger' } }
    /**
     * Find zero or one InventoryLedger that matches the filter.
     * @param {InventoryLedgerFindUniqueArgs} args - Arguments to find a InventoryLedger
     * @example
     * // Get one InventoryLedger
     * const inventoryLedger = await prisma.inventoryLedger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryLedgerFindUniqueArgs>(args: SelectSubset<T, InventoryLedgerFindUniqueArgs<ExtArgs>>): Prisma__InventoryLedgerClient<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InventoryLedger that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventoryLedgerFindUniqueOrThrowArgs} args - Arguments to find a InventoryLedger
     * @example
     * // Get one InventoryLedger
     * const inventoryLedger = await prisma.inventoryLedger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryLedgerFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryLedgerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryLedgerClient<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InventoryLedger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLedgerFindFirstArgs} args - Arguments to find a InventoryLedger
     * @example
     * // Get one InventoryLedger
     * const inventoryLedger = await prisma.inventoryLedger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryLedgerFindFirstArgs>(args?: SelectSubset<T, InventoryLedgerFindFirstArgs<ExtArgs>>): Prisma__InventoryLedgerClient<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InventoryLedger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLedgerFindFirstOrThrowArgs} args - Arguments to find a InventoryLedger
     * @example
     * // Get one InventoryLedger
     * const inventoryLedger = await prisma.inventoryLedger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryLedgerFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryLedgerFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryLedgerClient<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InventoryLedgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLedgerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryLedgers
     * const inventoryLedgers = await prisma.inventoryLedger.findMany()
     * 
     * // Get first 10 InventoryLedgers
     * const inventoryLedgers = await prisma.inventoryLedger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryLedgerWithIdOnly = await prisma.inventoryLedger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryLedgerFindManyArgs>(args?: SelectSubset<T, InventoryLedgerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InventoryLedger.
     * @param {InventoryLedgerCreateArgs} args - Arguments to create a InventoryLedger.
     * @example
     * // Create one InventoryLedger
     * const InventoryLedger = await prisma.inventoryLedger.create({
     *   data: {
     *     // ... data to create a InventoryLedger
     *   }
     * })
     * 
     */
    create<T extends InventoryLedgerCreateArgs>(args: SelectSubset<T, InventoryLedgerCreateArgs<ExtArgs>>): Prisma__InventoryLedgerClient<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InventoryLedgers.
     * @param {InventoryLedgerCreateManyArgs} args - Arguments to create many InventoryLedgers.
     * @example
     * // Create many InventoryLedgers
     * const inventoryLedger = await prisma.inventoryLedger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryLedgerCreateManyArgs>(args?: SelectSubset<T, InventoryLedgerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryLedgers and returns the data saved in the database.
     * @param {InventoryLedgerCreateManyAndReturnArgs} args - Arguments to create many InventoryLedgers.
     * @example
     * // Create many InventoryLedgers
     * const inventoryLedger = await prisma.inventoryLedger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryLedgers and only return the `id`
     * const inventoryLedgerWithIdOnly = await prisma.inventoryLedger.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryLedgerCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryLedgerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InventoryLedger.
     * @param {InventoryLedgerDeleteArgs} args - Arguments to delete one InventoryLedger.
     * @example
     * // Delete one InventoryLedger
     * const InventoryLedger = await prisma.inventoryLedger.delete({
     *   where: {
     *     // ... filter to delete one InventoryLedger
     *   }
     * })
     * 
     */
    delete<T extends InventoryLedgerDeleteArgs>(args: SelectSubset<T, InventoryLedgerDeleteArgs<ExtArgs>>): Prisma__InventoryLedgerClient<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InventoryLedger.
     * @param {InventoryLedgerUpdateArgs} args - Arguments to update one InventoryLedger.
     * @example
     * // Update one InventoryLedger
     * const inventoryLedger = await prisma.inventoryLedger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryLedgerUpdateArgs>(args: SelectSubset<T, InventoryLedgerUpdateArgs<ExtArgs>>): Prisma__InventoryLedgerClient<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InventoryLedgers.
     * @param {InventoryLedgerDeleteManyArgs} args - Arguments to filter InventoryLedgers to delete.
     * @example
     * // Delete a few InventoryLedgers
     * const { count } = await prisma.inventoryLedger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryLedgerDeleteManyArgs>(args?: SelectSubset<T, InventoryLedgerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLedgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryLedgers
     * const inventoryLedger = await prisma.inventoryLedger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryLedgerUpdateManyArgs>(args: SelectSubset<T, InventoryLedgerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryLedger.
     * @param {InventoryLedgerUpsertArgs} args - Arguments to update or create a InventoryLedger.
     * @example
     * // Update or create a InventoryLedger
     * const inventoryLedger = await prisma.inventoryLedger.upsert({
     *   create: {
     *     // ... data to create a InventoryLedger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryLedger we want to update
     *   }
     * })
     */
    upsert<T extends InventoryLedgerUpsertArgs>(args: SelectSubset<T, InventoryLedgerUpsertArgs<ExtArgs>>): Prisma__InventoryLedgerClient<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InventoryLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLedgerCountArgs} args - Arguments to filter InventoryLedgers to count.
     * @example
     * // Count the number of InventoryLedgers
     * const count = await prisma.inventoryLedger.count({
     *   where: {
     *     // ... the filter for the InventoryLedgers we want to count
     *   }
     * })
    **/
    count<T extends InventoryLedgerCountArgs>(
      args?: Subset<T, InventoryLedgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryLedgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLedgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryLedgerAggregateArgs>(args: Subset<T, InventoryLedgerAggregateArgs>): Prisma.PrismaPromise<GetInventoryLedgerAggregateType<T>>

    /**
     * Group by InventoryLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLedgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryLedgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryLedgerGroupByArgs['orderBy'] }
        : { orderBy?: InventoryLedgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryLedgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryLedgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryLedger model
   */
  readonly fields: InventoryLedgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryLedger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryLedgerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batch<T extends InventoryLedger$batchArgs<ExtArgs> = {}>(args?: Subset<T, InventoryLedger$batchArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    item<T extends InventoryItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItemDefaultArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryLedger model
   */ 
  interface InventoryLedgerFieldRefs {
    readonly id: FieldRef<"InventoryLedger", 'String'>
    readonly tenantId: FieldRef<"InventoryLedger", 'String'>
    readonly itemId: FieldRef<"InventoryLedger", 'String'>
    readonly quantity: FieldRef<"InventoryLedger", 'Decimal'>
    readonly type: FieldRef<"InventoryLedger", 'LedgerEntryType'>
    readonly batchId: FieldRef<"InventoryLedger", 'String'>
    readonly orderId: FieldRef<"InventoryLedger", 'String'>
    readonly packagingId: FieldRef<"InventoryLedger", 'String'>
    readonly notes: FieldRef<"InventoryLedger", 'String'>
    readonly createdBy: FieldRef<"InventoryLedger", 'String'>
    readonly createdAt: FieldRef<"InventoryLedger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryLedger findUnique
   */
  export type InventoryLedgerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    /**
     * Filter, which InventoryLedger to fetch.
     */
    where: InventoryLedgerWhereUniqueInput
  }

  /**
   * InventoryLedger findUniqueOrThrow
   */
  export type InventoryLedgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    /**
     * Filter, which InventoryLedger to fetch.
     */
    where: InventoryLedgerWhereUniqueInput
  }

  /**
   * InventoryLedger findFirst
   */
  export type InventoryLedgerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    /**
     * Filter, which InventoryLedger to fetch.
     */
    where?: InventoryLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryLedgers to fetch.
     */
    orderBy?: InventoryLedgerOrderByWithRelationInput | InventoryLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryLedgers.
     */
    cursor?: InventoryLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryLedgers.
     */
    distinct?: InventoryLedgerScalarFieldEnum | InventoryLedgerScalarFieldEnum[]
  }

  /**
   * InventoryLedger findFirstOrThrow
   */
  export type InventoryLedgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    /**
     * Filter, which InventoryLedger to fetch.
     */
    where?: InventoryLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryLedgers to fetch.
     */
    orderBy?: InventoryLedgerOrderByWithRelationInput | InventoryLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryLedgers.
     */
    cursor?: InventoryLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryLedgers.
     */
    distinct?: InventoryLedgerScalarFieldEnum | InventoryLedgerScalarFieldEnum[]
  }

  /**
   * InventoryLedger findMany
   */
  export type InventoryLedgerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    /**
     * Filter, which InventoryLedgers to fetch.
     */
    where?: InventoryLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryLedgers to fetch.
     */
    orderBy?: InventoryLedgerOrderByWithRelationInput | InventoryLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryLedgers.
     */
    cursor?: InventoryLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryLedgers.
     */
    skip?: number
    distinct?: InventoryLedgerScalarFieldEnum | InventoryLedgerScalarFieldEnum[]
  }

  /**
   * InventoryLedger create
   */
  export type InventoryLedgerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryLedger.
     */
    data: XOR<InventoryLedgerCreateInput, InventoryLedgerUncheckedCreateInput>
  }

  /**
   * InventoryLedger createMany
   */
  export type InventoryLedgerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryLedgers.
     */
    data: InventoryLedgerCreateManyInput | InventoryLedgerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryLedger createManyAndReturn
   */
  export type InventoryLedgerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InventoryLedgers.
     */
    data: InventoryLedgerCreateManyInput | InventoryLedgerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryLedger update
   */
  export type InventoryLedgerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryLedger.
     */
    data: XOR<InventoryLedgerUpdateInput, InventoryLedgerUncheckedUpdateInput>
    /**
     * Choose, which InventoryLedger to update.
     */
    where: InventoryLedgerWhereUniqueInput
  }

  /**
   * InventoryLedger updateMany
   */
  export type InventoryLedgerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryLedgers.
     */
    data: XOR<InventoryLedgerUpdateManyMutationInput, InventoryLedgerUncheckedUpdateManyInput>
    /**
     * Filter which InventoryLedgers to update
     */
    where?: InventoryLedgerWhereInput
  }

  /**
   * InventoryLedger upsert
   */
  export type InventoryLedgerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryLedger to update in case it exists.
     */
    where: InventoryLedgerWhereUniqueInput
    /**
     * In case the InventoryLedger found by the `where` argument doesn't exist, create a new InventoryLedger with this data.
     */
    create: XOR<InventoryLedgerCreateInput, InventoryLedgerUncheckedCreateInput>
    /**
     * In case the InventoryLedger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryLedgerUpdateInput, InventoryLedgerUncheckedUpdateInput>
  }

  /**
   * InventoryLedger delete
   */
  export type InventoryLedgerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    /**
     * Filter which InventoryLedger to delete.
     */
    where: InventoryLedgerWhereUniqueInput
  }

  /**
   * InventoryLedger deleteMany
   */
  export type InventoryLedgerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryLedgers to delete
     */
    where?: InventoryLedgerWhereInput
  }

  /**
   * InventoryLedger.batch
   */
  export type InventoryLedger$batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
  }

  /**
   * InventoryLedger without action
   */
  export type InventoryLedgerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
  }


  /**
   * Model IngredientCatalog
   */

  export type AggregateIngredientCatalog = {
    _count: IngredientCatalogCountAggregateOutputType | null
    _min: IngredientCatalogMinAggregateOutputType | null
    _max: IngredientCatalogMaxAggregateOutputType | null
  }

  export type IngredientCatalogMinAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    supplier: string | null
    origin: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IngredientCatalogMaxAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    supplier: string | null
    origin: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IngredientCatalogCountAggregateOutputType = {
    id: number
    type: number
    name: number
    supplier: number
    origin: number
    specs: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IngredientCatalogMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    supplier?: true
    origin?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IngredientCatalogMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    supplier?: true
    origin?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IngredientCatalogCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    supplier?: true
    origin?: true
    specs?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IngredientCatalogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngredientCatalog to aggregate.
     */
    where?: IngredientCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientCatalogs to fetch.
     */
    orderBy?: IngredientCatalogOrderByWithRelationInput | IngredientCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngredientCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IngredientCatalogs
    **/
    _count?: true | IngredientCatalogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredientCatalogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredientCatalogMaxAggregateInputType
  }

  export type GetIngredientCatalogAggregateType<T extends IngredientCatalogAggregateArgs> = {
        [P in keyof T & keyof AggregateIngredientCatalog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngredientCatalog[P]>
      : GetScalarType<T[P], AggregateIngredientCatalog[P]>
  }




  export type IngredientCatalogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientCatalogWhereInput
    orderBy?: IngredientCatalogOrderByWithAggregationInput | IngredientCatalogOrderByWithAggregationInput[]
    by: IngredientCatalogScalarFieldEnum[] | IngredientCatalogScalarFieldEnum
    having?: IngredientCatalogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredientCatalogCountAggregateInputType | true
    _min?: IngredientCatalogMinAggregateInputType
    _max?: IngredientCatalogMaxAggregateInputType
  }

  export type IngredientCatalogGroupByOutputType = {
    id: string
    type: string
    name: string
    supplier: string | null
    origin: string | null
    specs: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: IngredientCatalogCountAggregateOutputType | null
    _min: IngredientCatalogMinAggregateOutputType | null
    _max: IngredientCatalogMaxAggregateOutputType | null
  }

  type GetIngredientCatalogGroupByPayload<T extends IngredientCatalogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngredientCatalogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredientCatalogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredientCatalogGroupByOutputType[P]>
            : GetScalarType<T[P], IngredientCatalogGroupByOutputType[P]>
        }
      >
    >


  export type IngredientCatalogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    supplier?: boolean
    origin?: boolean
    specs?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["ingredientCatalog"]>

  export type IngredientCatalogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    supplier?: boolean
    origin?: boolean
    specs?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["ingredientCatalog"]>

  export type IngredientCatalogSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    supplier?: boolean
    origin?: boolean
    specs?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $IngredientCatalogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IngredientCatalog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      name: string
      supplier: string | null
      origin: string | null
      specs: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ingredientCatalog"]>
    composites: {}
  }

  type IngredientCatalogGetPayload<S extends boolean | null | undefined | IngredientCatalogDefaultArgs> = $Result.GetResult<Prisma.$IngredientCatalogPayload, S>

  type IngredientCatalogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IngredientCatalogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IngredientCatalogCountAggregateInputType | true
    }

  export interface IngredientCatalogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IngredientCatalog'], meta: { name: 'IngredientCatalog' } }
    /**
     * Find zero or one IngredientCatalog that matches the filter.
     * @param {IngredientCatalogFindUniqueArgs} args - Arguments to find a IngredientCatalog
     * @example
     * // Get one IngredientCatalog
     * const ingredientCatalog = await prisma.ingredientCatalog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IngredientCatalogFindUniqueArgs>(args: SelectSubset<T, IngredientCatalogFindUniqueArgs<ExtArgs>>): Prisma__IngredientCatalogClient<$Result.GetResult<Prisma.$IngredientCatalogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IngredientCatalog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IngredientCatalogFindUniqueOrThrowArgs} args - Arguments to find a IngredientCatalog
     * @example
     * // Get one IngredientCatalog
     * const ingredientCatalog = await prisma.ingredientCatalog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IngredientCatalogFindUniqueOrThrowArgs>(args: SelectSubset<T, IngredientCatalogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IngredientCatalogClient<$Result.GetResult<Prisma.$IngredientCatalogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IngredientCatalog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientCatalogFindFirstArgs} args - Arguments to find a IngredientCatalog
     * @example
     * // Get one IngredientCatalog
     * const ingredientCatalog = await prisma.ingredientCatalog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IngredientCatalogFindFirstArgs>(args?: SelectSubset<T, IngredientCatalogFindFirstArgs<ExtArgs>>): Prisma__IngredientCatalogClient<$Result.GetResult<Prisma.$IngredientCatalogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IngredientCatalog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientCatalogFindFirstOrThrowArgs} args - Arguments to find a IngredientCatalog
     * @example
     * // Get one IngredientCatalog
     * const ingredientCatalog = await prisma.ingredientCatalog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IngredientCatalogFindFirstOrThrowArgs>(args?: SelectSubset<T, IngredientCatalogFindFirstOrThrowArgs<ExtArgs>>): Prisma__IngredientCatalogClient<$Result.GetResult<Prisma.$IngredientCatalogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IngredientCatalogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientCatalogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IngredientCatalogs
     * const ingredientCatalogs = await prisma.ingredientCatalog.findMany()
     * 
     * // Get first 10 IngredientCatalogs
     * const ingredientCatalogs = await prisma.ingredientCatalog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ingredientCatalogWithIdOnly = await prisma.ingredientCatalog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IngredientCatalogFindManyArgs>(args?: SelectSubset<T, IngredientCatalogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientCatalogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IngredientCatalog.
     * @param {IngredientCatalogCreateArgs} args - Arguments to create a IngredientCatalog.
     * @example
     * // Create one IngredientCatalog
     * const IngredientCatalog = await prisma.ingredientCatalog.create({
     *   data: {
     *     // ... data to create a IngredientCatalog
     *   }
     * })
     * 
     */
    create<T extends IngredientCatalogCreateArgs>(args: SelectSubset<T, IngredientCatalogCreateArgs<ExtArgs>>): Prisma__IngredientCatalogClient<$Result.GetResult<Prisma.$IngredientCatalogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IngredientCatalogs.
     * @param {IngredientCatalogCreateManyArgs} args - Arguments to create many IngredientCatalogs.
     * @example
     * // Create many IngredientCatalogs
     * const ingredientCatalog = await prisma.ingredientCatalog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IngredientCatalogCreateManyArgs>(args?: SelectSubset<T, IngredientCatalogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IngredientCatalogs and returns the data saved in the database.
     * @param {IngredientCatalogCreateManyAndReturnArgs} args - Arguments to create many IngredientCatalogs.
     * @example
     * // Create many IngredientCatalogs
     * const ingredientCatalog = await prisma.ingredientCatalog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IngredientCatalogs and only return the `id`
     * const ingredientCatalogWithIdOnly = await prisma.ingredientCatalog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IngredientCatalogCreateManyAndReturnArgs>(args?: SelectSubset<T, IngredientCatalogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientCatalogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IngredientCatalog.
     * @param {IngredientCatalogDeleteArgs} args - Arguments to delete one IngredientCatalog.
     * @example
     * // Delete one IngredientCatalog
     * const IngredientCatalog = await prisma.ingredientCatalog.delete({
     *   where: {
     *     // ... filter to delete one IngredientCatalog
     *   }
     * })
     * 
     */
    delete<T extends IngredientCatalogDeleteArgs>(args: SelectSubset<T, IngredientCatalogDeleteArgs<ExtArgs>>): Prisma__IngredientCatalogClient<$Result.GetResult<Prisma.$IngredientCatalogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IngredientCatalog.
     * @param {IngredientCatalogUpdateArgs} args - Arguments to update one IngredientCatalog.
     * @example
     * // Update one IngredientCatalog
     * const ingredientCatalog = await prisma.ingredientCatalog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IngredientCatalogUpdateArgs>(args: SelectSubset<T, IngredientCatalogUpdateArgs<ExtArgs>>): Prisma__IngredientCatalogClient<$Result.GetResult<Prisma.$IngredientCatalogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IngredientCatalogs.
     * @param {IngredientCatalogDeleteManyArgs} args - Arguments to filter IngredientCatalogs to delete.
     * @example
     * // Delete a few IngredientCatalogs
     * const { count } = await prisma.ingredientCatalog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IngredientCatalogDeleteManyArgs>(args?: SelectSubset<T, IngredientCatalogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngredientCatalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientCatalogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IngredientCatalogs
     * const ingredientCatalog = await prisma.ingredientCatalog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IngredientCatalogUpdateManyArgs>(args: SelectSubset<T, IngredientCatalogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IngredientCatalog.
     * @param {IngredientCatalogUpsertArgs} args - Arguments to update or create a IngredientCatalog.
     * @example
     * // Update or create a IngredientCatalog
     * const ingredientCatalog = await prisma.ingredientCatalog.upsert({
     *   create: {
     *     // ... data to create a IngredientCatalog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IngredientCatalog we want to update
     *   }
     * })
     */
    upsert<T extends IngredientCatalogUpsertArgs>(args: SelectSubset<T, IngredientCatalogUpsertArgs<ExtArgs>>): Prisma__IngredientCatalogClient<$Result.GetResult<Prisma.$IngredientCatalogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IngredientCatalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientCatalogCountArgs} args - Arguments to filter IngredientCatalogs to count.
     * @example
     * // Count the number of IngredientCatalogs
     * const count = await prisma.ingredientCatalog.count({
     *   where: {
     *     // ... the filter for the IngredientCatalogs we want to count
     *   }
     * })
    **/
    count<T extends IngredientCatalogCountArgs>(
      args?: Subset<T, IngredientCatalogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredientCatalogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IngredientCatalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientCatalogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredientCatalogAggregateArgs>(args: Subset<T, IngredientCatalogAggregateArgs>): Prisma.PrismaPromise<GetIngredientCatalogAggregateType<T>>

    /**
     * Group by IngredientCatalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientCatalogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredientCatalogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredientCatalogGroupByArgs['orderBy'] }
        : { orderBy?: IngredientCatalogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredientCatalogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredientCatalogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IngredientCatalog model
   */
  readonly fields: IngredientCatalogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IngredientCatalog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngredientCatalogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IngredientCatalog model
   */ 
  interface IngredientCatalogFieldRefs {
    readonly id: FieldRef<"IngredientCatalog", 'String'>
    readonly type: FieldRef<"IngredientCatalog", 'String'>
    readonly name: FieldRef<"IngredientCatalog", 'String'>
    readonly supplier: FieldRef<"IngredientCatalog", 'String'>
    readonly origin: FieldRef<"IngredientCatalog", 'String'>
    readonly specs: FieldRef<"IngredientCatalog", 'Json'>
    readonly isActive: FieldRef<"IngredientCatalog", 'Boolean'>
    readonly createdAt: FieldRef<"IngredientCatalog", 'DateTime'>
    readonly updatedAt: FieldRef<"IngredientCatalog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IngredientCatalog findUnique
   */
  export type IngredientCatalogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientCatalog
     */
    select?: IngredientCatalogSelect<ExtArgs> | null
    /**
     * Filter, which IngredientCatalog to fetch.
     */
    where: IngredientCatalogWhereUniqueInput
  }

  /**
   * IngredientCatalog findUniqueOrThrow
   */
  export type IngredientCatalogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientCatalog
     */
    select?: IngredientCatalogSelect<ExtArgs> | null
    /**
     * Filter, which IngredientCatalog to fetch.
     */
    where: IngredientCatalogWhereUniqueInput
  }

  /**
   * IngredientCatalog findFirst
   */
  export type IngredientCatalogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientCatalog
     */
    select?: IngredientCatalogSelect<ExtArgs> | null
    /**
     * Filter, which IngredientCatalog to fetch.
     */
    where?: IngredientCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientCatalogs to fetch.
     */
    orderBy?: IngredientCatalogOrderByWithRelationInput | IngredientCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientCatalogs.
     */
    cursor?: IngredientCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientCatalogs.
     */
    distinct?: IngredientCatalogScalarFieldEnum | IngredientCatalogScalarFieldEnum[]
  }

  /**
   * IngredientCatalog findFirstOrThrow
   */
  export type IngredientCatalogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientCatalog
     */
    select?: IngredientCatalogSelect<ExtArgs> | null
    /**
     * Filter, which IngredientCatalog to fetch.
     */
    where?: IngredientCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientCatalogs to fetch.
     */
    orderBy?: IngredientCatalogOrderByWithRelationInput | IngredientCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientCatalogs.
     */
    cursor?: IngredientCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientCatalogs.
     */
    distinct?: IngredientCatalogScalarFieldEnum | IngredientCatalogScalarFieldEnum[]
  }

  /**
   * IngredientCatalog findMany
   */
  export type IngredientCatalogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientCatalog
     */
    select?: IngredientCatalogSelect<ExtArgs> | null
    /**
     * Filter, which IngredientCatalogs to fetch.
     */
    where?: IngredientCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientCatalogs to fetch.
     */
    orderBy?: IngredientCatalogOrderByWithRelationInput | IngredientCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IngredientCatalogs.
     */
    cursor?: IngredientCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientCatalogs.
     */
    skip?: number
    distinct?: IngredientCatalogScalarFieldEnum | IngredientCatalogScalarFieldEnum[]
  }

  /**
   * IngredientCatalog create
   */
  export type IngredientCatalogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientCatalog
     */
    select?: IngredientCatalogSelect<ExtArgs> | null
    /**
     * The data needed to create a IngredientCatalog.
     */
    data: XOR<IngredientCatalogCreateInput, IngredientCatalogUncheckedCreateInput>
  }

  /**
   * IngredientCatalog createMany
   */
  export type IngredientCatalogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IngredientCatalogs.
     */
    data: IngredientCatalogCreateManyInput | IngredientCatalogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IngredientCatalog createManyAndReturn
   */
  export type IngredientCatalogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientCatalog
     */
    select?: IngredientCatalogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IngredientCatalogs.
     */
    data: IngredientCatalogCreateManyInput | IngredientCatalogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IngredientCatalog update
   */
  export type IngredientCatalogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientCatalog
     */
    select?: IngredientCatalogSelect<ExtArgs> | null
    /**
     * The data needed to update a IngredientCatalog.
     */
    data: XOR<IngredientCatalogUpdateInput, IngredientCatalogUncheckedUpdateInput>
    /**
     * Choose, which IngredientCatalog to update.
     */
    where: IngredientCatalogWhereUniqueInput
  }

  /**
   * IngredientCatalog updateMany
   */
  export type IngredientCatalogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IngredientCatalogs.
     */
    data: XOR<IngredientCatalogUpdateManyMutationInput, IngredientCatalogUncheckedUpdateManyInput>
    /**
     * Filter which IngredientCatalogs to update
     */
    where?: IngredientCatalogWhereInput
  }

  /**
   * IngredientCatalog upsert
   */
  export type IngredientCatalogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientCatalog
     */
    select?: IngredientCatalogSelect<ExtArgs> | null
    /**
     * The filter to search for the IngredientCatalog to update in case it exists.
     */
    where: IngredientCatalogWhereUniqueInput
    /**
     * In case the IngredientCatalog found by the `where` argument doesn't exist, create a new IngredientCatalog with this data.
     */
    create: XOR<IngredientCatalogCreateInput, IngredientCatalogUncheckedCreateInput>
    /**
     * In case the IngredientCatalog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngredientCatalogUpdateInput, IngredientCatalogUncheckedUpdateInput>
  }

  /**
   * IngredientCatalog delete
   */
  export type IngredientCatalogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientCatalog
     */
    select?: IngredientCatalogSelect<ExtArgs> | null
    /**
     * Filter which IngredientCatalog to delete.
     */
    where: IngredientCatalogWhereUniqueInput
  }

  /**
   * IngredientCatalog deleteMany
   */
  export type IngredientCatalogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngredientCatalogs to delete
     */
    where?: IngredientCatalogWhereInput
  }

  /**
   * IngredientCatalog without action
   */
  export type IngredientCatalogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientCatalog
     */
    select?: IngredientCatalogSelect<ExtArgs> | null
  }


  /**
   * Model Batch
   */

  export type AggregateBatch = {
    _count: BatchCountAggregateOutputType | null
    _avg: BatchAvgAggregateOutputType | null
    _sum: BatchSumAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  export type BatchAvgAggregateOutputType = {
    volume: Decimal | null
    packagedVolume: Decimal | null
    originalGravity: Decimal | null
    currentGravity: Decimal | null
    finalGravity: Decimal | null
    abv: Decimal | null
    targetOg: Decimal | null
  }

  export type BatchSumAggregateOutputType = {
    volume: Decimal | null
    packagedVolume: Decimal | null
    originalGravity: Decimal | null
    currentGravity: Decimal | null
    finalGravity: Decimal | null
    abv: Decimal | null
    targetOg: Decimal | null
  }

  export type BatchMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    batchNumber: string | null
    recipeId: string | null
    status: $Enums.BatchStatus | null
    volume: Decimal | null
    packagedVolume: Decimal | null
    originalGravity: Decimal | null
    currentGravity: Decimal | null
    finalGravity: Decimal | null
    abv: Decimal | null
    tankId: string | null
    plannedDate: Date | null
    brewedAt: Date | null
    fermentationStartedAt: Date | null
    conditioningStartedAt: Date | null
    readyAt: Date | null
    completedAt: Date | null
    createdBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    targetOg: Decimal | null
    fermentationTankId: string | null
  }

  export type BatchMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    batchNumber: string | null
    recipeId: string | null
    status: $Enums.BatchStatus | null
    volume: Decimal | null
    packagedVolume: Decimal | null
    originalGravity: Decimal | null
    currentGravity: Decimal | null
    finalGravity: Decimal | null
    abv: Decimal | null
    tankId: string | null
    plannedDate: Date | null
    brewedAt: Date | null
    fermentationStartedAt: Date | null
    conditioningStartedAt: Date | null
    readyAt: Date | null
    completedAt: Date | null
    createdBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    targetOg: Decimal | null
    fermentationTankId: string | null
  }

  export type BatchCountAggregateOutputType = {
    id: number
    tenantId: number
    batchNumber: number
    recipeId: number
    status: number
    volume: number
    packagedVolume: number
    originalGravity: number
    currentGravity: number
    finalGravity: number
    abv: number
    tankId: number
    plannedDate: number
    brewedAt: number
    fermentationStartedAt: number
    conditioningStartedAt: number
    readyAt: number
    completedAt: number
    createdBy: number
    notes: number
    createdAt: number
    updatedAt: number
    targetOg: number
    fermentationTankId: number
    _all: number
  }


  export type BatchAvgAggregateInputType = {
    volume?: true
    packagedVolume?: true
    originalGravity?: true
    currentGravity?: true
    finalGravity?: true
    abv?: true
    targetOg?: true
  }

  export type BatchSumAggregateInputType = {
    volume?: true
    packagedVolume?: true
    originalGravity?: true
    currentGravity?: true
    finalGravity?: true
    abv?: true
    targetOg?: true
  }

  export type BatchMinAggregateInputType = {
    id?: true
    tenantId?: true
    batchNumber?: true
    recipeId?: true
    status?: true
    volume?: true
    packagedVolume?: true
    originalGravity?: true
    currentGravity?: true
    finalGravity?: true
    abv?: true
    tankId?: true
    plannedDate?: true
    brewedAt?: true
    fermentationStartedAt?: true
    conditioningStartedAt?: true
    readyAt?: true
    completedAt?: true
    createdBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    targetOg?: true
    fermentationTankId?: true
  }

  export type BatchMaxAggregateInputType = {
    id?: true
    tenantId?: true
    batchNumber?: true
    recipeId?: true
    status?: true
    volume?: true
    packagedVolume?: true
    originalGravity?: true
    currentGravity?: true
    finalGravity?: true
    abv?: true
    tankId?: true
    plannedDate?: true
    brewedAt?: true
    fermentationStartedAt?: true
    conditioningStartedAt?: true
    readyAt?: true
    completedAt?: true
    createdBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    targetOg?: true
    fermentationTankId?: true
  }

  export type BatchCountAggregateInputType = {
    id?: true
    tenantId?: true
    batchNumber?: true
    recipeId?: true
    status?: true
    volume?: true
    packagedVolume?: true
    originalGravity?: true
    currentGravity?: true
    finalGravity?: true
    abv?: true
    tankId?: true
    plannedDate?: true
    brewedAt?: true
    fermentationStartedAt?: true
    conditioningStartedAt?: true
    readyAt?: true
    completedAt?: true
    createdBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    targetOg?: true
    fermentationTankId?: true
    _all?: true
  }

  export type BatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batch to aggregate.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Batches
    **/
    _count?: true | BatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchMaxAggregateInputType
  }

  export type GetBatchAggregateType<T extends BatchAggregateArgs> = {
        [P in keyof T & keyof AggregateBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatch[P]>
      : GetScalarType<T[P], AggregateBatch[P]>
  }




  export type BatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithAggregationInput | BatchOrderByWithAggregationInput[]
    by: BatchScalarFieldEnum[] | BatchScalarFieldEnum
    having?: BatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchCountAggregateInputType | true
    _avg?: BatchAvgAggregateInputType
    _sum?: BatchSumAggregateInputType
    _min?: BatchMinAggregateInputType
    _max?: BatchMaxAggregateInputType
  }

  export type BatchGroupByOutputType = {
    id: string
    tenantId: string
    batchNumber: string
    recipeId: string
    status: $Enums.BatchStatus
    volume: Decimal
    packagedVolume: Decimal | null
    originalGravity: Decimal | null
    currentGravity: Decimal | null
    finalGravity: Decimal | null
    abv: Decimal | null
    tankId: string | null
    plannedDate: Date
    brewedAt: Date | null
    fermentationStartedAt: Date | null
    conditioningStartedAt: Date | null
    readyAt: Date | null
    completedAt: Date | null
    createdBy: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    targetOg: Decimal | null
    fermentationTankId: string | null
    _count: BatchCountAggregateOutputType | null
    _avg: BatchAvgAggregateOutputType | null
    _sum: BatchSumAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  type GetBatchGroupByPayload<T extends BatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchGroupByOutputType[P]>
            : GetScalarType<T[P], BatchGroupByOutputType[P]>
        }
      >
    >


  export type BatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    batchNumber?: boolean
    recipeId?: boolean
    status?: boolean
    volume?: boolean
    packagedVolume?: boolean
    originalGravity?: boolean
    currentGravity?: boolean
    finalGravity?: boolean
    abv?: boolean
    tankId?: boolean
    plannedDate?: boolean
    brewedAt?: boolean
    fermentationStartedAt?: boolean
    conditioningStartedAt?: boolean
    readyAt?: boolean
    completedAt?: boolean
    createdBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    targetOg?: boolean
    fermentationTankId?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    tank?: boolean | Batch$tankArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    ingredients?: boolean | Batch$ingredientsArgs<ExtArgs>
    timeline?: boolean | Batch$timelineArgs<ExtArgs>
    gravityReadings?: boolean | Batch$gravityReadingsArgs<ExtArgs>
    ledgerEntries?: boolean | Batch$ledgerEntriesArgs<ExtArgs>
    Keg?: boolean | Batch$KegArgs<ExtArgs>
    LotBatch?: boolean | Batch$LotBatchArgs<ExtArgs>
    packagingRuns?: boolean | Batch$packagingRunsArgs<ExtArgs>
    QCTest?: boolean | Batch$QCTestArgs<ExtArgs>
    _count?: boolean | BatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    batchNumber?: boolean
    recipeId?: boolean
    status?: boolean
    volume?: boolean
    packagedVolume?: boolean
    originalGravity?: boolean
    currentGravity?: boolean
    finalGravity?: boolean
    abv?: boolean
    tankId?: boolean
    plannedDate?: boolean
    brewedAt?: boolean
    fermentationStartedAt?: boolean
    conditioningStartedAt?: boolean
    readyAt?: boolean
    completedAt?: boolean
    createdBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    targetOg?: boolean
    fermentationTankId?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    tank?: boolean | Batch$tankArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectScalar = {
    id?: boolean
    tenantId?: boolean
    batchNumber?: boolean
    recipeId?: boolean
    status?: boolean
    volume?: boolean
    packagedVolume?: boolean
    originalGravity?: boolean
    currentGravity?: boolean
    finalGravity?: boolean
    abv?: boolean
    tankId?: boolean
    plannedDate?: boolean
    brewedAt?: boolean
    fermentationStartedAt?: boolean
    conditioningStartedAt?: boolean
    readyAt?: boolean
    completedAt?: boolean
    createdBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    targetOg?: boolean
    fermentationTankId?: boolean
  }

  export type BatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    tank?: boolean | Batch$tankArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    ingredients?: boolean | Batch$ingredientsArgs<ExtArgs>
    timeline?: boolean | Batch$timelineArgs<ExtArgs>
    gravityReadings?: boolean | Batch$gravityReadingsArgs<ExtArgs>
    ledgerEntries?: boolean | Batch$ledgerEntriesArgs<ExtArgs>
    Keg?: boolean | Batch$KegArgs<ExtArgs>
    LotBatch?: boolean | Batch$LotBatchArgs<ExtArgs>
    packagingRuns?: boolean | Batch$packagingRunsArgs<ExtArgs>
    QCTest?: boolean | Batch$QCTestArgs<ExtArgs>
    _count?: boolean | BatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    tank?: boolean | Batch$tankArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $BatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Batch"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
      tank: Prisma.$TankPayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs>
      ingredients: Prisma.$BatchIngredientPayload<ExtArgs>[]
      timeline: Prisma.$BatchTimelinePayload<ExtArgs>[]
      gravityReadings: Prisma.$GravityReadingPayload<ExtArgs>[]
      ledgerEntries: Prisma.$InventoryLedgerPayload<ExtArgs>[]
      Keg: Prisma.$KegPayload<ExtArgs>[]
      LotBatch: Prisma.$LotBatchPayload<ExtArgs>[]
      packagingRuns: Prisma.$PackagingRunPayload<ExtArgs>[]
      QCTest: Prisma.$QCTestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      batchNumber: string
      recipeId: string
      status: $Enums.BatchStatus
      volume: Prisma.Decimal
      packagedVolume: Prisma.Decimal | null
      originalGravity: Prisma.Decimal | null
      currentGravity: Prisma.Decimal | null
      finalGravity: Prisma.Decimal | null
      abv: Prisma.Decimal | null
      tankId: string | null
      plannedDate: Date
      brewedAt: Date | null
      fermentationStartedAt: Date | null
      conditioningStartedAt: Date | null
      readyAt: Date | null
      completedAt: Date | null
      createdBy: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
      targetOg: Prisma.Decimal | null
      fermentationTankId: string | null
    }, ExtArgs["result"]["batch"]>
    composites: {}
  }

  type BatchGetPayload<S extends boolean | null | undefined | BatchDefaultArgs> = $Result.GetResult<Prisma.$BatchPayload, S>

  type BatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BatchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BatchCountAggregateInputType | true
    }

  export interface BatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Batch'], meta: { name: 'Batch' } }
    /**
     * Find zero or one Batch that matches the filter.
     * @param {BatchFindUniqueArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchFindUniqueArgs>(args: SelectSubset<T, BatchFindUniqueArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Batch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BatchFindUniqueOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Batch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindFirstArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchFindFirstArgs>(args?: SelectSubset<T, BatchFindFirstArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Batch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindFirstOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Batches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Batches
     * const batches = await prisma.batch.findMany()
     * 
     * // Get first 10 Batches
     * const batches = await prisma.batch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchWithIdOnly = await prisma.batch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchFindManyArgs>(args?: SelectSubset<T, BatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Batch.
     * @param {BatchCreateArgs} args - Arguments to create a Batch.
     * @example
     * // Create one Batch
     * const Batch = await prisma.batch.create({
     *   data: {
     *     // ... data to create a Batch
     *   }
     * })
     * 
     */
    create<T extends BatchCreateArgs>(args: SelectSubset<T, BatchCreateArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Batches.
     * @param {BatchCreateManyArgs} args - Arguments to create many Batches.
     * @example
     * // Create many Batches
     * const batch = await prisma.batch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchCreateManyArgs>(args?: SelectSubset<T, BatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Batches and returns the data saved in the database.
     * @param {BatchCreateManyAndReturnArgs} args - Arguments to create many Batches.
     * @example
     * // Create many Batches
     * const batch = await prisma.batch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Batches and only return the `id`
     * const batchWithIdOnly = await prisma.batch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Batch.
     * @param {BatchDeleteArgs} args - Arguments to delete one Batch.
     * @example
     * // Delete one Batch
     * const Batch = await prisma.batch.delete({
     *   where: {
     *     // ... filter to delete one Batch
     *   }
     * })
     * 
     */
    delete<T extends BatchDeleteArgs>(args: SelectSubset<T, BatchDeleteArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Batch.
     * @param {BatchUpdateArgs} args - Arguments to update one Batch.
     * @example
     * // Update one Batch
     * const batch = await prisma.batch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchUpdateArgs>(args: SelectSubset<T, BatchUpdateArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Batches.
     * @param {BatchDeleteManyArgs} args - Arguments to filter Batches to delete.
     * @example
     * // Delete a few Batches
     * const { count } = await prisma.batch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchDeleteManyArgs>(args?: SelectSubset<T, BatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Batches
     * const batch = await prisma.batch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchUpdateManyArgs>(args: SelectSubset<T, BatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Batch.
     * @param {BatchUpsertArgs} args - Arguments to update or create a Batch.
     * @example
     * // Update or create a Batch
     * const batch = await prisma.batch.upsert({
     *   create: {
     *     // ... data to create a Batch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Batch we want to update
     *   }
     * })
     */
    upsert<T extends BatchUpsertArgs>(args: SelectSubset<T, BatchUpsertArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchCountArgs} args - Arguments to filter Batches to count.
     * @example
     * // Count the number of Batches
     * const count = await prisma.batch.count({
     *   where: {
     *     // ... the filter for the Batches we want to count
     *   }
     * })
    **/
    count<T extends BatchCountArgs>(
      args?: Subset<T, BatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchAggregateArgs>(args: Subset<T, BatchAggregateArgs>): Prisma.PrismaPromise<GetBatchAggregateType<T>>

    /**
     * Group by Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchGroupByArgs['orderBy'] }
        : { orderBy?: BatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Batch model
   */
  readonly fields: BatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Batch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tank<T extends Batch$tankArgs<ExtArgs> = {}>(args?: Subset<T, Batch$tankArgs<ExtArgs>>): Prisma__TankClient<$Result.GetResult<Prisma.$TankPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ingredients<T extends Batch$ingredientsArgs<ExtArgs> = {}>(args?: Subset<T, Batch$ingredientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchIngredientPayload<ExtArgs>, T, "findMany"> | Null>
    timeline<T extends Batch$timelineArgs<ExtArgs> = {}>(args?: Subset<T, Batch$timelineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchTimelinePayload<ExtArgs>, T, "findMany"> | Null>
    gravityReadings<T extends Batch$gravityReadingsArgs<ExtArgs> = {}>(args?: Subset<T, Batch$gravityReadingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GravityReadingPayload<ExtArgs>, T, "findMany"> | Null>
    ledgerEntries<T extends Batch$ledgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Batch$ledgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "findMany"> | Null>
    Keg<T extends Batch$KegArgs<ExtArgs> = {}>(args?: Subset<T, Batch$KegArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KegPayload<ExtArgs>, T, "findMany"> | Null>
    LotBatch<T extends Batch$LotBatchArgs<ExtArgs> = {}>(args?: Subset<T, Batch$LotBatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotBatchPayload<ExtArgs>, T, "findMany"> | Null>
    packagingRuns<T extends Batch$packagingRunsArgs<ExtArgs> = {}>(args?: Subset<T, Batch$packagingRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagingRunPayload<ExtArgs>, T, "findMany"> | Null>
    QCTest<T extends Batch$QCTestArgs<ExtArgs> = {}>(args?: Subset<T, Batch$QCTestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QCTestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Batch model
   */ 
  interface BatchFieldRefs {
    readonly id: FieldRef<"Batch", 'String'>
    readonly tenantId: FieldRef<"Batch", 'String'>
    readonly batchNumber: FieldRef<"Batch", 'String'>
    readonly recipeId: FieldRef<"Batch", 'String'>
    readonly status: FieldRef<"Batch", 'BatchStatus'>
    readonly volume: FieldRef<"Batch", 'Decimal'>
    readonly packagedVolume: FieldRef<"Batch", 'Decimal'>
    readonly originalGravity: FieldRef<"Batch", 'Decimal'>
    readonly currentGravity: FieldRef<"Batch", 'Decimal'>
    readonly finalGravity: FieldRef<"Batch", 'Decimal'>
    readonly abv: FieldRef<"Batch", 'Decimal'>
    readonly tankId: FieldRef<"Batch", 'String'>
    readonly plannedDate: FieldRef<"Batch", 'DateTime'>
    readonly brewedAt: FieldRef<"Batch", 'DateTime'>
    readonly fermentationStartedAt: FieldRef<"Batch", 'DateTime'>
    readonly conditioningStartedAt: FieldRef<"Batch", 'DateTime'>
    readonly readyAt: FieldRef<"Batch", 'DateTime'>
    readonly completedAt: FieldRef<"Batch", 'DateTime'>
    readonly createdBy: FieldRef<"Batch", 'String'>
    readonly notes: FieldRef<"Batch", 'String'>
    readonly createdAt: FieldRef<"Batch", 'DateTime'>
    readonly updatedAt: FieldRef<"Batch", 'DateTime'>
    readonly targetOg: FieldRef<"Batch", 'Decimal'>
    readonly fermentationTankId: FieldRef<"Batch", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Batch findUnique
   */
  export type BatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch findUniqueOrThrow
   */
  export type BatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch findFirst
   */
  export type BatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch findFirstOrThrow
   */
  export type BatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch findMany
   */
  export type BatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batches to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch create
   */
  export type BatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Batch.
     */
    data: XOR<BatchCreateInput, BatchUncheckedCreateInput>
  }

  /**
   * Batch createMany
   */
  export type BatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Batches.
     */
    data: BatchCreateManyInput | BatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Batch createManyAndReturn
   */
  export type BatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Batches.
     */
    data: BatchCreateManyInput | BatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Batch update
   */
  export type BatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Batch.
     */
    data: XOR<BatchUpdateInput, BatchUncheckedUpdateInput>
    /**
     * Choose, which Batch to update.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch updateMany
   */
  export type BatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Batches.
     */
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyInput>
    /**
     * Filter which Batches to update
     */
    where?: BatchWhereInput
  }

  /**
   * Batch upsert
   */
  export type BatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Batch to update in case it exists.
     */
    where: BatchWhereUniqueInput
    /**
     * In case the Batch found by the `where` argument doesn't exist, create a new Batch with this data.
     */
    create: XOR<BatchCreateInput, BatchUncheckedCreateInput>
    /**
     * In case the Batch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchUpdateInput, BatchUncheckedUpdateInput>
  }

  /**
   * Batch delete
   */
  export type BatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter which Batch to delete.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch deleteMany
   */
  export type BatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batches to delete
     */
    where?: BatchWhereInput
  }

  /**
   * Batch.tank
   */
  export type Batch$tankArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tank
     */
    select?: TankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankInclude<ExtArgs> | null
    where?: TankWhereInput
  }

  /**
   * Batch.ingredients
   */
  export type Batch$ingredientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchIngredient
     */
    select?: BatchIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIngredientInclude<ExtArgs> | null
    where?: BatchIngredientWhereInput
    orderBy?: BatchIngredientOrderByWithRelationInput | BatchIngredientOrderByWithRelationInput[]
    cursor?: BatchIngredientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchIngredientScalarFieldEnum | BatchIngredientScalarFieldEnum[]
  }

  /**
   * Batch.timeline
   */
  export type Batch$timelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchTimeline
     */
    select?: BatchTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchTimelineInclude<ExtArgs> | null
    where?: BatchTimelineWhereInput
    orderBy?: BatchTimelineOrderByWithRelationInput | BatchTimelineOrderByWithRelationInput[]
    cursor?: BatchTimelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchTimelineScalarFieldEnum | BatchTimelineScalarFieldEnum[]
  }

  /**
   * Batch.gravityReadings
   */
  export type Batch$gravityReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GravityReading
     */
    select?: GravityReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GravityReadingInclude<ExtArgs> | null
    where?: GravityReadingWhereInput
    orderBy?: GravityReadingOrderByWithRelationInput | GravityReadingOrderByWithRelationInput[]
    cursor?: GravityReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GravityReadingScalarFieldEnum | GravityReadingScalarFieldEnum[]
  }

  /**
   * Batch.ledgerEntries
   */
  export type Batch$ledgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    where?: InventoryLedgerWhereInput
    orderBy?: InventoryLedgerOrderByWithRelationInput | InventoryLedgerOrderByWithRelationInput[]
    cursor?: InventoryLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryLedgerScalarFieldEnum | InventoryLedgerScalarFieldEnum[]
  }

  /**
   * Batch.Keg
   */
  export type Batch$KegArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keg
     */
    select?: KegSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegInclude<ExtArgs> | null
    where?: KegWhereInput
    orderBy?: KegOrderByWithRelationInput | KegOrderByWithRelationInput[]
    cursor?: KegWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KegScalarFieldEnum | KegScalarFieldEnum[]
  }

  /**
   * Batch.LotBatch
   */
  export type Batch$LotBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBatch
     */
    select?: LotBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBatchInclude<ExtArgs> | null
    where?: LotBatchWhereInput
    orderBy?: LotBatchOrderByWithRelationInput | LotBatchOrderByWithRelationInput[]
    cursor?: LotBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotBatchScalarFieldEnum | LotBatchScalarFieldEnum[]
  }

  /**
   * Batch.packagingRuns
   */
  export type Batch$packagingRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagingRun
     */
    select?: PackagingRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagingRunInclude<ExtArgs> | null
    where?: PackagingRunWhereInput
    orderBy?: PackagingRunOrderByWithRelationInput | PackagingRunOrderByWithRelationInput[]
    cursor?: PackagingRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackagingRunScalarFieldEnum | PackagingRunScalarFieldEnum[]
  }

  /**
   * Batch.QCTest
   */
  export type Batch$QCTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCTest
     */
    select?: QCTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCTestInclude<ExtArgs> | null
    where?: QCTestWhereInput
    orderBy?: QCTestOrderByWithRelationInput | QCTestOrderByWithRelationInput[]
    cursor?: QCTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QCTestScalarFieldEnum | QCTestScalarFieldEnum[]
  }

  /**
   * Batch without action
   */
  export type BatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
  }


  /**
   * Model BatchIngredient
   */

  export type AggregateBatchIngredient = {
    _count: BatchIngredientCountAggregateOutputType | null
    _avg: BatchIngredientAvgAggregateOutputType | null
    _sum: BatchIngredientSumAggregateOutputType | null
    _min: BatchIngredientMinAggregateOutputType | null
    _max: BatchIngredientMaxAggregateOutputType | null
  }

  export type BatchIngredientAvgAggregateOutputType = {
    plannedAmount: Decimal | null
    actualAmount: Decimal | null
  }

  export type BatchIngredientSumAggregateOutputType = {
    plannedAmount: Decimal | null
    actualAmount: Decimal | null
  }

  export type BatchIngredientMinAggregateOutputType = {
    id: string | null
    batchId: string | null
    inventoryItemId: string | null
    name: string | null
    category: $Enums.IngredientCategory | null
    plannedAmount: Decimal | null
    actualAmount: Decimal | null
    unit: string | null
    lotNumber: string | null
    addedAt: Date | null
  }

  export type BatchIngredientMaxAggregateOutputType = {
    id: string | null
    batchId: string | null
    inventoryItemId: string | null
    name: string | null
    category: $Enums.IngredientCategory | null
    plannedAmount: Decimal | null
    actualAmount: Decimal | null
    unit: string | null
    lotNumber: string | null
    addedAt: Date | null
  }

  export type BatchIngredientCountAggregateOutputType = {
    id: number
    batchId: number
    inventoryItemId: number
    name: number
    category: number
    plannedAmount: number
    actualAmount: number
    unit: number
    lotNumber: number
    addedAt: number
    _all: number
  }


  export type BatchIngredientAvgAggregateInputType = {
    plannedAmount?: true
    actualAmount?: true
  }

  export type BatchIngredientSumAggregateInputType = {
    plannedAmount?: true
    actualAmount?: true
  }

  export type BatchIngredientMinAggregateInputType = {
    id?: true
    batchId?: true
    inventoryItemId?: true
    name?: true
    category?: true
    plannedAmount?: true
    actualAmount?: true
    unit?: true
    lotNumber?: true
    addedAt?: true
  }

  export type BatchIngredientMaxAggregateInputType = {
    id?: true
    batchId?: true
    inventoryItemId?: true
    name?: true
    category?: true
    plannedAmount?: true
    actualAmount?: true
    unit?: true
    lotNumber?: true
    addedAt?: true
  }

  export type BatchIngredientCountAggregateInputType = {
    id?: true
    batchId?: true
    inventoryItemId?: true
    name?: true
    category?: true
    plannedAmount?: true
    actualAmount?: true
    unit?: true
    lotNumber?: true
    addedAt?: true
    _all?: true
  }

  export type BatchIngredientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchIngredient to aggregate.
     */
    where?: BatchIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchIngredients to fetch.
     */
    orderBy?: BatchIngredientOrderByWithRelationInput | BatchIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BatchIngredients
    **/
    _count?: true | BatchIngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BatchIngredientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BatchIngredientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchIngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchIngredientMaxAggregateInputType
  }

  export type GetBatchIngredientAggregateType<T extends BatchIngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateBatchIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatchIngredient[P]>
      : GetScalarType<T[P], AggregateBatchIngredient[P]>
  }




  export type BatchIngredientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchIngredientWhereInput
    orderBy?: BatchIngredientOrderByWithAggregationInput | BatchIngredientOrderByWithAggregationInput[]
    by: BatchIngredientScalarFieldEnum[] | BatchIngredientScalarFieldEnum
    having?: BatchIngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchIngredientCountAggregateInputType | true
    _avg?: BatchIngredientAvgAggregateInputType
    _sum?: BatchIngredientSumAggregateInputType
    _min?: BatchIngredientMinAggregateInputType
    _max?: BatchIngredientMaxAggregateInputType
  }

  export type BatchIngredientGroupByOutputType = {
    id: string
    batchId: string
    inventoryItemId: string | null
    name: string
    category: $Enums.IngredientCategory
    plannedAmount: Decimal
    actualAmount: Decimal | null
    unit: string
    lotNumber: string | null
    addedAt: Date | null
    _count: BatchIngredientCountAggregateOutputType | null
    _avg: BatchIngredientAvgAggregateOutputType | null
    _sum: BatchIngredientSumAggregateOutputType | null
    _min: BatchIngredientMinAggregateOutputType | null
    _max: BatchIngredientMaxAggregateOutputType | null
  }

  type GetBatchIngredientGroupByPayload<T extends BatchIngredientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchIngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchIngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchIngredientGroupByOutputType[P]>
            : GetScalarType<T[P], BatchIngredientGroupByOutputType[P]>
        }
      >
    >


  export type BatchIngredientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    inventoryItemId?: boolean
    name?: boolean
    category?: boolean
    plannedAmount?: boolean
    actualAmount?: boolean
    unit?: boolean
    lotNumber?: boolean
    addedAt?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batchIngredient"]>

  export type BatchIngredientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    inventoryItemId?: boolean
    name?: boolean
    category?: boolean
    plannedAmount?: boolean
    actualAmount?: boolean
    unit?: boolean
    lotNumber?: boolean
    addedAt?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batchIngredient"]>

  export type BatchIngredientSelectScalar = {
    id?: boolean
    batchId?: boolean
    inventoryItemId?: boolean
    name?: boolean
    category?: boolean
    plannedAmount?: boolean
    actualAmount?: boolean
    unit?: boolean
    lotNumber?: boolean
    addedAt?: boolean
  }

  export type BatchIngredientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }
  export type BatchIngredientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }

  export type $BatchIngredientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BatchIngredient"
    objects: {
      batch: Prisma.$BatchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      batchId: string
      inventoryItemId: string | null
      name: string
      category: $Enums.IngredientCategory
      plannedAmount: Prisma.Decimal
      actualAmount: Prisma.Decimal | null
      unit: string
      lotNumber: string | null
      addedAt: Date | null
    }, ExtArgs["result"]["batchIngredient"]>
    composites: {}
  }

  type BatchIngredientGetPayload<S extends boolean | null | undefined | BatchIngredientDefaultArgs> = $Result.GetResult<Prisma.$BatchIngredientPayload, S>

  type BatchIngredientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BatchIngredientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BatchIngredientCountAggregateInputType | true
    }

  export interface BatchIngredientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BatchIngredient'], meta: { name: 'BatchIngredient' } }
    /**
     * Find zero or one BatchIngredient that matches the filter.
     * @param {BatchIngredientFindUniqueArgs} args - Arguments to find a BatchIngredient
     * @example
     * // Get one BatchIngredient
     * const batchIngredient = await prisma.batchIngredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchIngredientFindUniqueArgs>(args: SelectSubset<T, BatchIngredientFindUniqueArgs<ExtArgs>>): Prisma__BatchIngredientClient<$Result.GetResult<Prisma.$BatchIngredientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BatchIngredient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BatchIngredientFindUniqueOrThrowArgs} args - Arguments to find a BatchIngredient
     * @example
     * // Get one BatchIngredient
     * const batchIngredient = await prisma.batchIngredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchIngredientFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchIngredientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchIngredientClient<$Result.GetResult<Prisma.$BatchIngredientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BatchIngredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchIngredientFindFirstArgs} args - Arguments to find a BatchIngredient
     * @example
     * // Get one BatchIngredient
     * const batchIngredient = await prisma.batchIngredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchIngredientFindFirstArgs>(args?: SelectSubset<T, BatchIngredientFindFirstArgs<ExtArgs>>): Prisma__BatchIngredientClient<$Result.GetResult<Prisma.$BatchIngredientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BatchIngredient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchIngredientFindFirstOrThrowArgs} args - Arguments to find a BatchIngredient
     * @example
     * // Get one BatchIngredient
     * const batchIngredient = await prisma.batchIngredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchIngredientFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchIngredientFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchIngredientClient<$Result.GetResult<Prisma.$BatchIngredientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BatchIngredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchIngredientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BatchIngredients
     * const batchIngredients = await prisma.batchIngredient.findMany()
     * 
     * // Get first 10 BatchIngredients
     * const batchIngredients = await prisma.batchIngredient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchIngredientWithIdOnly = await prisma.batchIngredient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchIngredientFindManyArgs>(args?: SelectSubset<T, BatchIngredientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchIngredientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BatchIngredient.
     * @param {BatchIngredientCreateArgs} args - Arguments to create a BatchIngredient.
     * @example
     * // Create one BatchIngredient
     * const BatchIngredient = await prisma.batchIngredient.create({
     *   data: {
     *     // ... data to create a BatchIngredient
     *   }
     * })
     * 
     */
    create<T extends BatchIngredientCreateArgs>(args: SelectSubset<T, BatchIngredientCreateArgs<ExtArgs>>): Prisma__BatchIngredientClient<$Result.GetResult<Prisma.$BatchIngredientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BatchIngredients.
     * @param {BatchIngredientCreateManyArgs} args - Arguments to create many BatchIngredients.
     * @example
     * // Create many BatchIngredients
     * const batchIngredient = await prisma.batchIngredient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchIngredientCreateManyArgs>(args?: SelectSubset<T, BatchIngredientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BatchIngredients and returns the data saved in the database.
     * @param {BatchIngredientCreateManyAndReturnArgs} args - Arguments to create many BatchIngredients.
     * @example
     * // Create many BatchIngredients
     * const batchIngredient = await prisma.batchIngredient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BatchIngredients and only return the `id`
     * const batchIngredientWithIdOnly = await prisma.batchIngredient.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchIngredientCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchIngredientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchIngredientPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BatchIngredient.
     * @param {BatchIngredientDeleteArgs} args - Arguments to delete one BatchIngredient.
     * @example
     * // Delete one BatchIngredient
     * const BatchIngredient = await prisma.batchIngredient.delete({
     *   where: {
     *     // ... filter to delete one BatchIngredient
     *   }
     * })
     * 
     */
    delete<T extends BatchIngredientDeleteArgs>(args: SelectSubset<T, BatchIngredientDeleteArgs<ExtArgs>>): Prisma__BatchIngredientClient<$Result.GetResult<Prisma.$BatchIngredientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BatchIngredient.
     * @param {BatchIngredientUpdateArgs} args - Arguments to update one BatchIngredient.
     * @example
     * // Update one BatchIngredient
     * const batchIngredient = await prisma.batchIngredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchIngredientUpdateArgs>(args: SelectSubset<T, BatchIngredientUpdateArgs<ExtArgs>>): Prisma__BatchIngredientClient<$Result.GetResult<Prisma.$BatchIngredientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BatchIngredients.
     * @param {BatchIngredientDeleteManyArgs} args - Arguments to filter BatchIngredients to delete.
     * @example
     * // Delete a few BatchIngredients
     * const { count } = await prisma.batchIngredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchIngredientDeleteManyArgs>(args?: SelectSubset<T, BatchIngredientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchIngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BatchIngredients
     * const batchIngredient = await prisma.batchIngredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchIngredientUpdateManyArgs>(args: SelectSubset<T, BatchIngredientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BatchIngredient.
     * @param {BatchIngredientUpsertArgs} args - Arguments to update or create a BatchIngredient.
     * @example
     * // Update or create a BatchIngredient
     * const batchIngredient = await prisma.batchIngredient.upsert({
     *   create: {
     *     // ... data to create a BatchIngredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BatchIngredient we want to update
     *   }
     * })
     */
    upsert<T extends BatchIngredientUpsertArgs>(args: SelectSubset<T, BatchIngredientUpsertArgs<ExtArgs>>): Prisma__BatchIngredientClient<$Result.GetResult<Prisma.$BatchIngredientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BatchIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchIngredientCountArgs} args - Arguments to filter BatchIngredients to count.
     * @example
     * // Count the number of BatchIngredients
     * const count = await prisma.batchIngredient.count({
     *   where: {
     *     // ... the filter for the BatchIngredients we want to count
     *   }
     * })
    **/
    count<T extends BatchIngredientCountArgs>(
      args?: Subset<T, BatchIngredientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchIngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BatchIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchIngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchIngredientAggregateArgs>(args: Subset<T, BatchIngredientAggregateArgs>): Prisma.PrismaPromise<GetBatchIngredientAggregateType<T>>

    /**
     * Group by BatchIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchIngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchIngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchIngredientGroupByArgs['orderBy'] }
        : { orderBy?: BatchIngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchIngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchIngredientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BatchIngredient model
   */
  readonly fields: BatchIngredientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BatchIngredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchIngredientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batch<T extends BatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BatchDefaultArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BatchIngredient model
   */ 
  interface BatchIngredientFieldRefs {
    readonly id: FieldRef<"BatchIngredient", 'String'>
    readonly batchId: FieldRef<"BatchIngredient", 'String'>
    readonly inventoryItemId: FieldRef<"BatchIngredient", 'String'>
    readonly name: FieldRef<"BatchIngredient", 'String'>
    readonly category: FieldRef<"BatchIngredient", 'IngredientCategory'>
    readonly plannedAmount: FieldRef<"BatchIngredient", 'Decimal'>
    readonly actualAmount: FieldRef<"BatchIngredient", 'Decimal'>
    readonly unit: FieldRef<"BatchIngredient", 'String'>
    readonly lotNumber: FieldRef<"BatchIngredient", 'String'>
    readonly addedAt: FieldRef<"BatchIngredient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BatchIngredient findUnique
   */
  export type BatchIngredientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchIngredient
     */
    select?: BatchIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIngredientInclude<ExtArgs> | null
    /**
     * Filter, which BatchIngredient to fetch.
     */
    where: BatchIngredientWhereUniqueInput
  }

  /**
   * BatchIngredient findUniqueOrThrow
   */
  export type BatchIngredientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchIngredient
     */
    select?: BatchIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIngredientInclude<ExtArgs> | null
    /**
     * Filter, which BatchIngredient to fetch.
     */
    where: BatchIngredientWhereUniqueInput
  }

  /**
   * BatchIngredient findFirst
   */
  export type BatchIngredientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchIngredient
     */
    select?: BatchIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIngredientInclude<ExtArgs> | null
    /**
     * Filter, which BatchIngredient to fetch.
     */
    where?: BatchIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchIngredients to fetch.
     */
    orderBy?: BatchIngredientOrderByWithRelationInput | BatchIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchIngredients.
     */
    cursor?: BatchIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchIngredients.
     */
    distinct?: BatchIngredientScalarFieldEnum | BatchIngredientScalarFieldEnum[]
  }

  /**
   * BatchIngredient findFirstOrThrow
   */
  export type BatchIngredientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchIngredient
     */
    select?: BatchIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIngredientInclude<ExtArgs> | null
    /**
     * Filter, which BatchIngredient to fetch.
     */
    where?: BatchIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchIngredients to fetch.
     */
    orderBy?: BatchIngredientOrderByWithRelationInput | BatchIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchIngredients.
     */
    cursor?: BatchIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchIngredients.
     */
    distinct?: BatchIngredientScalarFieldEnum | BatchIngredientScalarFieldEnum[]
  }

  /**
   * BatchIngredient findMany
   */
  export type BatchIngredientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchIngredient
     */
    select?: BatchIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIngredientInclude<ExtArgs> | null
    /**
     * Filter, which BatchIngredients to fetch.
     */
    where?: BatchIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchIngredients to fetch.
     */
    orderBy?: BatchIngredientOrderByWithRelationInput | BatchIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BatchIngredients.
     */
    cursor?: BatchIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchIngredients.
     */
    skip?: number
    distinct?: BatchIngredientScalarFieldEnum | BatchIngredientScalarFieldEnum[]
  }

  /**
   * BatchIngredient create
   */
  export type BatchIngredientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchIngredient
     */
    select?: BatchIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIngredientInclude<ExtArgs> | null
    /**
     * The data needed to create a BatchIngredient.
     */
    data: XOR<BatchIngredientCreateInput, BatchIngredientUncheckedCreateInput>
  }

  /**
   * BatchIngredient createMany
   */
  export type BatchIngredientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BatchIngredients.
     */
    data: BatchIngredientCreateManyInput | BatchIngredientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BatchIngredient createManyAndReturn
   */
  export type BatchIngredientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchIngredient
     */
    select?: BatchIngredientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BatchIngredients.
     */
    data: BatchIngredientCreateManyInput | BatchIngredientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIngredientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BatchIngredient update
   */
  export type BatchIngredientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchIngredient
     */
    select?: BatchIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIngredientInclude<ExtArgs> | null
    /**
     * The data needed to update a BatchIngredient.
     */
    data: XOR<BatchIngredientUpdateInput, BatchIngredientUncheckedUpdateInput>
    /**
     * Choose, which BatchIngredient to update.
     */
    where: BatchIngredientWhereUniqueInput
  }

  /**
   * BatchIngredient updateMany
   */
  export type BatchIngredientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BatchIngredients.
     */
    data: XOR<BatchIngredientUpdateManyMutationInput, BatchIngredientUncheckedUpdateManyInput>
    /**
     * Filter which BatchIngredients to update
     */
    where?: BatchIngredientWhereInput
  }

  /**
   * BatchIngredient upsert
   */
  export type BatchIngredientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchIngredient
     */
    select?: BatchIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIngredientInclude<ExtArgs> | null
    /**
     * The filter to search for the BatchIngredient to update in case it exists.
     */
    where: BatchIngredientWhereUniqueInput
    /**
     * In case the BatchIngredient found by the `where` argument doesn't exist, create a new BatchIngredient with this data.
     */
    create: XOR<BatchIngredientCreateInput, BatchIngredientUncheckedCreateInput>
    /**
     * In case the BatchIngredient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchIngredientUpdateInput, BatchIngredientUncheckedUpdateInput>
  }

  /**
   * BatchIngredient delete
   */
  export type BatchIngredientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchIngredient
     */
    select?: BatchIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIngredientInclude<ExtArgs> | null
    /**
     * Filter which BatchIngredient to delete.
     */
    where: BatchIngredientWhereUniqueInput
  }

  /**
   * BatchIngredient deleteMany
   */
  export type BatchIngredientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchIngredients to delete
     */
    where?: BatchIngredientWhereInput
  }

  /**
   * BatchIngredient without action
   */
  export type BatchIngredientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchIngredient
     */
    select?: BatchIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIngredientInclude<ExtArgs> | null
  }


  /**
   * Model GravityReading
   */

  export type AggregateGravityReading = {
    _count: GravityReadingCountAggregateOutputType | null
    _avg: GravityReadingAvgAggregateOutputType | null
    _sum: GravityReadingSumAggregateOutputType | null
    _min: GravityReadingMinAggregateOutputType | null
    _max: GravityReadingMaxAggregateOutputType | null
  }

  export type GravityReadingAvgAggregateOutputType = {
    gravity: Decimal | null
    temperature: Decimal | null
  }

  export type GravityReadingSumAggregateOutputType = {
    gravity: Decimal | null
    temperature: Decimal | null
  }

  export type GravityReadingMinAggregateOutputType = {
    id: string | null
    batchId: string | null
    gravity: Decimal | null
    temperature: Decimal | null
    notes: string | null
    recordedBy: string | null
    recordedAt: Date | null
  }

  export type GravityReadingMaxAggregateOutputType = {
    id: string | null
    batchId: string | null
    gravity: Decimal | null
    temperature: Decimal | null
    notes: string | null
    recordedBy: string | null
    recordedAt: Date | null
  }

  export type GravityReadingCountAggregateOutputType = {
    id: number
    batchId: number
    gravity: number
    temperature: number
    notes: number
    recordedBy: number
    recordedAt: number
    _all: number
  }


  export type GravityReadingAvgAggregateInputType = {
    gravity?: true
    temperature?: true
  }

  export type GravityReadingSumAggregateInputType = {
    gravity?: true
    temperature?: true
  }

  export type GravityReadingMinAggregateInputType = {
    id?: true
    batchId?: true
    gravity?: true
    temperature?: true
    notes?: true
    recordedBy?: true
    recordedAt?: true
  }

  export type GravityReadingMaxAggregateInputType = {
    id?: true
    batchId?: true
    gravity?: true
    temperature?: true
    notes?: true
    recordedBy?: true
    recordedAt?: true
  }

  export type GravityReadingCountAggregateInputType = {
    id?: true
    batchId?: true
    gravity?: true
    temperature?: true
    notes?: true
    recordedBy?: true
    recordedAt?: true
    _all?: true
  }

  export type GravityReadingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GravityReading to aggregate.
     */
    where?: GravityReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GravityReadings to fetch.
     */
    orderBy?: GravityReadingOrderByWithRelationInput | GravityReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GravityReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GravityReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GravityReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GravityReadings
    **/
    _count?: true | GravityReadingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GravityReadingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GravityReadingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GravityReadingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GravityReadingMaxAggregateInputType
  }

  export type GetGravityReadingAggregateType<T extends GravityReadingAggregateArgs> = {
        [P in keyof T & keyof AggregateGravityReading]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGravityReading[P]>
      : GetScalarType<T[P], AggregateGravityReading[P]>
  }




  export type GravityReadingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GravityReadingWhereInput
    orderBy?: GravityReadingOrderByWithAggregationInput | GravityReadingOrderByWithAggregationInput[]
    by: GravityReadingScalarFieldEnum[] | GravityReadingScalarFieldEnum
    having?: GravityReadingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GravityReadingCountAggregateInputType | true
    _avg?: GravityReadingAvgAggregateInputType
    _sum?: GravityReadingSumAggregateInputType
    _min?: GravityReadingMinAggregateInputType
    _max?: GravityReadingMaxAggregateInputType
  }

  export type GravityReadingGroupByOutputType = {
    id: string
    batchId: string
    gravity: Decimal
    temperature: Decimal
    notes: string | null
    recordedBy: string
    recordedAt: Date
    _count: GravityReadingCountAggregateOutputType | null
    _avg: GravityReadingAvgAggregateOutputType | null
    _sum: GravityReadingSumAggregateOutputType | null
    _min: GravityReadingMinAggregateOutputType | null
    _max: GravityReadingMaxAggregateOutputType | null
  }

  type GetGravityReadingGroupByPayload<T extends GravityReadingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GravityReadingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GravityReadingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GravityReadingGroupByOutputType[P]>
            : GetScalarType<T[P], GravityReadingGroupByOutputType[P]>
        }
      >
    >


  export type GravityReadingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    gravity?: boolean
    temperature?: boolean
    notes?: boolean
    recordedBy?: boolean
    recordedAt?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gravityReading"]>

  export type GravityReadingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    gravity?: boolean
    temperature?: boolean
    notes?: boolean
    recordedBy?: boolean
    recordedAt?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gravityReading"]>

  export type GravityReadingSelectScalar = {
    id?: boolean
    batchId?: boolean
    gravity?: boolean
    temperature?: boolean
    notes?: boolean
    recordedBy?: boolean
    recordedAt?: boolean
  }

  export type GravityReadingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }
  export type GravityReadingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }

  export type $GravityReadingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GravityReading"
    objects: {
      batch: Prisma.$BatchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      batchId: string
      gravity: Prisma.Decimal
      temperature: Prisma.Decimal
      notes: string | null
      recordedBy: string
      recordedAt: Date
    }, ExtArgs["result"]["gravityReading"]>
    composites: {}
  }

  type GravityReadingGetPayload<S extends boolean | null | undefined | GravityReadingDefaultArgs> = $Result.GetResult<Prisma.$GravityReadingPayload, S>

  type GravityReadingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GravityReadingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GravityReadingCountAggregateInputType | true
    }

  export interface GravityReadingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GravityReading'], meta: { name: 'GravityReading' } }
    /**
     * Find zero or one GravityReading that matches the filter.
     * @param {GravityReadingFindUniqueArgs} args - Arguments to find a GravityReading
     * @example
     * // Get one GravityReading
     * const gravityReading = await prisma.gravityReading.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GravityReadingFindUniqueArgs>(args: SelectSubset<T, GravityReadingFindUniqueArgs<ExtArgs>>): Prisma__GravityReadingClient<$Result.GetResult<Prisma.$GravityReadingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GravityReading that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GravityReadingFindUniqueOrThrowArgs} args - Arguments to find a GravityReading
     * @example
     * // Get one GravityReading
     * const gravityReading = await prisma.gravityReading.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GravityReadingFindUniqueOrThrowArgs>(args: SelectSubset<T, GravityReadingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GravityReadingClient<$Result.GetResult<Prisma.$GravityReadingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GravityReading that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GravityReadingFindFirstArgs} args - Arguments to find a GravityReading
     * @example
     * // Get one GravityReading
     * const gravityReading = await prisma.gravityReading.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GravityReadingFindFirstArgs>(args?: SelectSubset<T, GravityReadingFindFirstArgs<ExtArgs>>): Prisma__GravityReadingClient<$Result.GetResult<Prisma.$GravityReadingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GravityReading that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GravityReadingFindFirstOrThrowArgs} args - Arguments to find a GravityReading
     * @example
     * // Get one GravityReading
     * const gravityReading = await prisma.gravityReading.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GravityReadingFindFirstOrThrowArgs>(args?: SelectSubset<T, GravityReadingFindFirstOrThrowArgs<ExtArgs>>): Prisma__GravityReadingClient<$Result.GetResult<Prisma.$GravityReadingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GravityReadings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GravityReadingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GravityReadings
     * const gravityReadings = await prisma.gravityReading.findMany()
     * 
     * // Get first 10 GravityReadings
     * const gravityReadings = await prisma.gravityReading.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gravityReadingWithIdOnly = await prisma.gravityReading.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GravityReadingFindManyArgs>(args?: SelectSubset<T, GravityReadingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GravityReadingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GravityReading.
     * @param {GravityReadingCreateArgs} args - Arguments to create a GravityReading.
     * @example
     * // Create one GravityReading
     * const GravityReading = await prisma.gravityReading.create({
     *   data: {
     *     // ... data to create a GravityReading
     *   }
     * })
     * 
     */
    create<T extends GravityReadingCreateArgs>(args: SelectSubset<T, GravityReadingCreateArgs<ExtArgs>>): Prisma__GravityReadingClient<$Result.GetResult<Prisma.$GravityReadingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GravityReadings.
     * @param {GravityReadingCreateManyArgs} args - Arguments to create many GravityReadings.
     * @example
     * // Create many GravityReadings
     * const gravityReading = await prisma.gravityReading.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GravityReadingCreateManyArgs>(args?: SelectSubset<T, GravityReadingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GravityReadings and returns the data saved in the database.
     * @param {GravityReadingCreateManyAndReturnArgs} args - Arguments to create many GravityReadings.
     * @example
     * // Create many GravityReadings
     * const gravityReading = await prisma.gravityReading.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GravityReadings and only return the `id`
     * const gravityReadingWithIdOnly = await prisma.gravityReading.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GravityReadingCreateManyAndReturnArgs>(args?: SelectSubset<T, GravityReadingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GravityReadingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GravityReading.
     * @param {GravityReadingDeleteArgs} args - Arguments to delete one GravityReading.
     * @example
     * // Delete one GravityReading
     * const GravityReading = await prisma.gravityReading.delete({
     *   where: {
     *     // ... filter to delete one GravityReading
     *   }
     * })
     * 
     */
    delete<T extends GravityReadingDeleteArgs>(args: SelectSubset<T, GravityReadingDeleteArgs<ExtArgs>>): Prisma__GravityReadingClient<$Result.GetResult<Prisma.$GravityReadingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GravityReading.
     * @param {GravityReadingUpdateArgs} args - Arguments to update one GravityReading.
     * @example
     * // Update one GravityReading
     * const gravityReading = await prisma.gravityReading.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GravityReadingUpdateArgs>(args: SelectSubset<T, GravityReadingUpdateArgs<ExtArgs>>): Prisma__GravityReadingClient<$Result.GetResult<Prisma.$GravityReadingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GravityReadings.
     * @param {GravityReadingDeleteManyArgs} args - Arguments to filter GravityReadings to delete.
     * @example
     * // Delete a few GravityReadings
     * const { count } = await prisma.gravityReading.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GravityReadingDeleteManyArgs>(args?: SelectSubset<T, GravityReadingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GravityReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GravityReadingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GravityReadings
     * const gravityReading = await prisma.gravityReading.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GravityReadingUpdateManyArgs>(args: SelectSubset<T, GravityReadingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GravityReading.
     * @param {GravityReadingUpsertArgs} args - Arguments to update or create a GravityReading.
     * @example
     * // Update or create a GravityReading
     * const gravityReading = await prisma.gravityReading.upsert({
     *   create: {
     *     // ... data to create a GravityReading
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GravityReading we want to update
     *   }
     * })
     */
    upsert<T extends GravityReadingUpsertArgs>(args: SelectSubset<T, GravityReadingUpsertArgs<ExtArgs>>): Prisma__GravityReadingClient<$Result.GetResult<Prisma.$GravityReadingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GravityReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GravityReadingCountArgs} args - Arguments to filter GravityReadings to count.
     * @example
     * // Count the number of GravityReadings
     * const count = await prisma.gravityReading.count({
     *   where: {
     *     // ... the filter for the GravityReadings we want to count
     *   }
     * })
    **/
    count<T extends GravityReadingCountArgs>(
      args?: Subset<T, GravityReadingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GravityReadingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GravityReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GravityReadingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GravityReadingAggregateArgs>(args: Subset<T, GravityReadingAggregateArgs>): Prisma.PrismaPromise<GetGravityReadingAggregateType<T>>

    /**
     * Group by GravityReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GravityReadingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GravityReadingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GravityReadingGroupByArgs['orderBy'] }
        : { orderBy?: GravityReadingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GravityReadingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGravityReadingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GravityReading model
   */
  readonly fields: GravityReadingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GravityReading.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GravityReadingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batch<T extends BatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BatchDefaultArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GravityReading model
   */ 
  interface GravityReadingFieldRefs {
    readonly id: FieldRef<"GravityReading", 'String'>
    readonly batchId: FieldRef<"GravityReading", 'String'>
    readonly gravity: FieldRef<"GravityReading", 'Decimal'>
    readonly temperature: FieldRef<"GravityReading", 'Decimal'>
    readonly notes: FieldRef<"GravityReading", 'String'>
    readonly recordedBy: FieldRef<"GravityReading", 'String'>
    readonly recordedAt: FieldRef<"GravityReading", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GravityReading findUnique
   */
  export type GravityReadingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GravityReading
     */
    select?: GravityReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GravityReadingInclude<ExtArgs> | null
    /**
     * Filter, which GravityReading to fetch.
     */
    where: GravityReadingWhereUniqueInput
  }

  /**
   * GravityReading findUniqueOrThrow
   */
  export type GravityReadingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GravityReading
     */
    select?: GravityReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GravityReadingInclude<ExtArgs> | null
    /**
     * Filter, which GravityReading to fetch.
     */
    where: GravityReadingWhereUniqueInput
  }

  /**
   * GravityReading findFirst
   */
  export type GravityReadingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GravityReading
     */
    select?: GravityReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GravityReadingInclude<ExtArgs> | null
    /**
     * Filter, which GravityReading to fetch.
     */
    where?: GravityReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GravityReadings to fetch.
     */
    orderBy?: GravityReadingOrderByWithRelationInput | GravityReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GravityReadings.
     */
    cursor?: GravityReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GravityReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GravityReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GravityReadings.
     */
    distinct?: GravityReadingScalarFieldEnum | GravityReadingScalarFieldEnum[]
  }

  /**
   * GravityReading findFirstOrThrow
   */
  export type GravityReadingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GravityReading
     */
    select?: GravityReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GravityReadingInclude<ExtArgs> | null
    /**
     * Filter, which GravityReading to fetch.
     */
    where?: GravityReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GravityReadings to fetch.
     */
    orderBy?: GravityReadingOrderByWithRelationInput | GravityReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GravityReadings.
     */
    cursor?: GravityReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GravityReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GravityReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GravityReadings.
     */
    distinct?: GravityReadingScalarFieldEnum | GravityReadingScalarFieldEnum[]
  }

  /**
   * GravityReading findMany
   */
  export type GravityReadingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GravityReading
     */
    select?: GravityReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GravityReadingInclude<ExtArgs> | null
    /**
     * Filter, which GravityReadings to fetch.
     */
    where?: GravityReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GravityReadings to fetch.
     */
    orderBy?: GravityReadingOrderByWithRelationInput | GravityReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GravityReadings.
     */
    cursor?: GravityReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GravityReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GravityReadings.
     */
    skip?: number
    distinct?: GravityReadingScalarFieldEnum | GravityReadingScalarFieldEnum[]
  }

  /**
   * GravityReading create
   */
  export type GravityReadingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GravityReading
     */
    select?: GravityReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GravityReadingInclude<ExtArgs> | null
    /**
     * The data needed to create a GravityReading.
     */
    data: XOR<GravityReadingCreateInput, GravityReadingUncheckedCreateInput>
  }

  /**
   * GravityReading createMany
   */
  export type GravityReadingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GravityReadings.
     */
    data: GravityReadingCreateManyInput | GravityReadingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GravityReading createManyAndReturn
   */
  export type GravityReadingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GravityReading
     */
    select?: GravityReadingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GravityReadings.
     */
    data: GravityReadingCreateManyInput | GravityReadingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GravityReadingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GravityReading update
   */
  export type GravityReadingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GravityReading
     */
    select?: GravityReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GravityReadingInclude<ExtArgs> | null
    /**
     * The data needed to update a GravityReading.
     */
    data: XOR<GravityReadingUpdateInput, GravityReadingUncheckedUpdateInput>
    /**
     * Choose, which GravityReading to update.
     */
    where: GravityReadingWhereUniqueInput
  }

  /**
   * GravityReading updateMany
   */
  export type GravityReadingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GravityReadings.
     */
    data: XOR<GravityReadingUpdateManyMutationInput, GravityReadingUncheckedUpdateManyInput>
    /**
     * Filter which GravityReadings to update
     */
    where?: GravityReadingWhereInput
  }

  /**
   * GravityReading upsert
   */
  export type GravityReadingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GravityReading
     */
    select?: GravityReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GravityReadingInclude<ExtArgs> | null
    /**
     * The filter to search for the GravityReading to update in case it exists.
     */
    where: GravityReadingWhereUniqueInput
    /**
     * In case the GravityReading found by the `where` argument doesn't exist, create a new GravityReading with this data.
     */
    create: XOR<GravityReadingCreateInput, GravityReadingUncheckedCreateInput>
    /**
     * In case the GravityReading was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GravityReadingUpdateInput, GravityReadingUncheckedUpdateInput>
  }

  /**
   * GravityReading delete
   */
  export type GravityReadingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GravityReading
     */
    select?: GravityReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GravityReadingInclude<ExtArgs> | null
    /**
     * Filter which GravityReading to delete.
     */
    where: GravityReadingWhereUniqueInput
  }

  /**
   * GravityReading deleteMany
   */
  export type GravityReadingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GravityReadings to delete
     */
    where?: GravityReadingWhereInput
  }

  /**
   * GravityReading without action
   */
  export type GravityReadingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GravityReading
     */
    select?: GravityReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GravityReadingInclude<ExtArgs> | null
  }


  /**
   * Model BatchTimeline
   */

  export type AggregateBatchTimeline = {
    _count: BatchTimelineCountAggregateOutputType | null
    _min: BatchTimelineMinAggregateOutputType | null
    _max: BatchTimelineMaxAggregateOutputType | null
  }

  export type BatchTimelineMinAggregateOutputType = {
    id: string | null
    batchId: string | null
    type: $Enums.TimelineEventType | null
    title: string | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type BatchTimelineMaxAggregateOutputType = {
    id: string | null
    batchId: string | null
    type: $Enums.TimelineEventType | null
    title: string | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type BatchTimelineCountAggregateOutputType = {
    id: number
    batchId: number
    type: number
    title: number
    description: number
    data: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type BatchTimelineMinAggregateInputType = {
    id?: true
    batchId?: true
    type?: true
    title?: true
    description?: true
    createdBy?: true
    createdAt?: true
  }

  export type BatchTimelineMaxAggregateInputType = {
    id?: true
    batchId?: true
    type?: true
    title?: true
    description?: true
    createdBy?: true
    createdAt?: true
  }

  export type BatchTimelineCountAggregateInputType = {
    id?: true
    batchId?: true
    type?: true
    title?: true
    description?: true
    data?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type BatchTimelineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchTimeline to aggregate.
     */
    where?: BatchTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchTimelines to fetch.
     */
    orderBy?: BatchTimelineOrderByWithRelationInput | BatchTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BatchTimelines
    **/
    _count?: true | BatchTimelineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchTimelineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchTimelineMaxAggregateInputType
  }

  export type GetBatchTimelineAggregateType<T extends BatchTimelineAggregateArgs> = {
        [P in keyof T & keyof AggregateBatchTimeline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatchTimeline[P]>
      : GetScalarType<T[P], AggregateBatchTimeline[P]>
  }




  export type BatchTimelineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchTimelineWhereInput
    orderBy?: BatchTimelineOrderByWithAggregationInput | BatchTimelineOrderByWithAggregationInput[]
    by: BatchTimelineScalarFieldEnum[] | BatchTimelineScalarFieldEnum
    having?: BatchTimelineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchTimelineCountAggregateInputType | true
    _min?: BatchTimelineMinAggregateInputType
    _max?: BatchTimelineMaxAggregateInputType
  }

  export type BatchTimelineGroupByOutputType = {
    id: string
    batchId: string
    type: $Enums.TimelineEventType
    title: string
    description: string | null
    data: JsonValue | null
    createdBy: string
    createdAt: Date
    _count: BatchTimelineCountAggregateOutputType | null
    _min: BatchTimelineMinAggregateOutputType | null
    _max: BatchTimelineMaxAggregateOutputType | null
  }

  type GetBatchTimelineGroupByPayload<T extends BatchTimelineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchTimelineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchTimelineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchTimelineGroupByOutputType[P]>
            : GetScalarType<T[P], BatchTimelineGroupByOutputType[P]>
        }
      >
    >


  export type BatchTimelineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    data?: boolean
    createdBy?: boolean
    createdAt?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batchTimeline"]>

  export type BatchTimelineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    data?: boolean
    createdBy?: boolean
    createdAt?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batchTimeline"]>

  export type BatchTimelineSelectScalar = {
    id?: boolean
    batchId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    data?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type BatchTimelineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }
  export type BatchTimelineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }

  export type $BatchTimelinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BatchTimeline"
    objects: {
      batch: Prisma.$BatchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      batchId: string
      type: $Enums.TimelineEventType
      title: string
      description: string | null
      data: Prisma.JsonValue | null
      createdBy: string
      createdAt: Date
    }, ExtArgs["result"]["batchTimeline"]>
    composites: {}
  }

  type BatchTimelineGetPayload<S extends boolean | null | undefined | BatchTimelineDefaultArgs> = $Result.GetResult<Prisma.$BatchTimelinePayload, S>

  type BatchTimelineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BatchTimelineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BatchTimelineCountAggregateInputType | true
    }

  export interface BatchTimelineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BatchTimeline'], meta: { name: 'BatchTimeline' } }
    /**
     * Find zero or one BatchTimeline that matches the filter.
     * @param {BatchTimelineFindUniqueArgs} args - Arguments to find a BatchTimeline
     * @example
     * // Get one BatchTimeline
     * const batchTimeline = await prisma.batchTimeline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchTimelineFindUniqueArgs>(args: SelectSubset<T, BatchTimelineFindUniqueArgs<ExtArgs>>): Prisma__BatchTimelineClient<$Result.GetResult<Prisma.$BatchTimelinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BatchTimeline that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BatchTimelineFindUniqueOrThrowArgs} args - Arguments to find a BatchTimeline
     * @example
     * // Get one BatchTimeline
     * const batchTimeline = await prisma.batchTimeline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchTimelineFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchTimelineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchTimelineClient<$Result.GetResult<Prisma.$BatchTimelinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BatchTimeline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchTimelineFindFirstArgs} args - Arguments to find a BatchTimeline
     * @example
     * // Get one BatchTimeline
     * const batchTimeline = await prisma.batchTimeline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchTimelineFindFirstArgs>(args?: SelectSubset<T, BatchTimelineFindFirstArgs<ExtArgs>>): Prisma__BatchTimelineClient<$Result.GetResult<Prisma.$BatchTimelinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BatchTimeline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchTimelineFindFirstOrThrowArgs} args - Arguments to find a BatchTimeline
     * @example
     * // Get one BatchTimeline
     * const batchTimeline = await prisma.batchTimeline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchTimelineFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchTimelineFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchTimelineClient<$Result.GetResult<Prisma.$BatchTimelinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BatchTimelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchTimelineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BatchTimelines
     * const batchTimelines = await prisma.batchTimeline.findMany()
     * 
     * // Get first 10 BatchTimelines
     * const batchTimelines = await prisma.batchTimeline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchTimelineWithIdOnly = await prisma.batchTimeline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchTimelineFindManyArgs>(args?: SelectSubset<T, BatchTimelineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchTimelinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BatchTimeline.
     * @param {BatchTimelineCreateArgs} args - Arguments to create a BatchTimeline.
     * @example
     * // Create one BatchTimeline
     * const BatchTimeline = await prisma.batchTimeline.create({
     *   data: {
     *     // ... data to create a BatchTimeline
     *   }
     * })
     * 
     */
    create<T extends BatchTimelineCreateArgs>(args: SelectSubset<T, BatchTimelineCreateArgs<ExtArgs>>): Prisma__BatchTimelineClient<$Result.GetResult<Prisma.$BatchTimelinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BatchTimelines.
     * @param {BatchTimelineCreateManyArgs} args - Arguments to create many BatchTimelines.
     * @example
     * // Create many BatchTimelines
     * const batchTimeline = await prisma.batchTimeline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchTimelineCreateManyArgs>(args?: SelectSubset<T, BatchTimelineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BatchTimelines and returns the data saved in the database.
     * @param {BatchTimelineCreateManyAndReturnArgs} args - Arguments to create many BatchTimelines.
     * @example
     * // Create many BatchTimelines
     * const batchTimeline = await prisma.batchTimeline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BatchTimelines and only return the `id`
     * const batchTimelineWithIdOnly = await prisma.batchTimeline.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchTimelineCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchTimelineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchTimelinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BatchTimeline.
     * @param {BatchTimelineDeleteArgs} args - Arguments to delete one BatchTimeline.
     * @example
     * // Delete one BatchTimeline
     * const BatchTimeline = await prisma.batchTimeline.delete({
     *   where: {
     *     // ... filter to delete one BatchTimeline
     *   }
     * })
     * 
     */
    delete<T extends BatchTimelineDeleteArgs>(args: SelectSubset<T, BatchTimelineDeleteArgs<ExtArgs>>): Prisma__BatchTimelineClient<$Result.GetResult<Prisma.$BatchTimelinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BatchTimeline.
     * @param {BatchTimelineUpdateArgs} args - Arguments to update one BatchTimeline.
     * @example
     * // Update one BatchTimeline
     * const batchTimeline = await prisma.batchTimeline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchTimelineUpdateArgs>(args: SelectSubset<T, BatchTimelineUpdateArgs<ExtArgs>>): Prisma__BatchTimelineClient<$Result.GetResult<Prisma.$BatchTimelinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BatchTimelines.
     * @param {BatchTimelineDeleteManyArgs} args - Arguments to filter BatchTimelines to delete.
     * @example
     * // Delete a few BatchTimelines
     * const { count } = await prisma.batchTimeline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchTimelineDeleteManyArgs>(args?: SelectSubset<T, BatchTimelineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchTimelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchTimelineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BatchTimelines
     * const batchTimeline = await prisma.batchTimeline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchTimelineUpdateManyArgs>(args: SelectSubset<T, BatchTimelineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BatchTimeline.
     * @param {BatchTimelineUpsertArgs} args - Arguments to update or create a BatchTimeline.
     * @example
     * // Update or create a BatchTimeline
     * const batchTimeline = await prisma.batchTimeline.upsert({
     *   create: {
     *     // ... data to create a BatchTimeline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BatchTimeline we want to update
     *   }
     * })
     */
    upsert<T extends BatchTimelineUpsertArgs>(args: SelectSubset<T, BatchTimelineUpsertArgs<ExtArgs>>): Prisma__BatchTimelineClient<$Result.GetResult<Prisma.$BatchTimelinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BatchTimelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchTimelineCountArgs} args - Arguments to filter BatchTimelines to count.
     * @example
     * // Count the number of BatchTimelines
     * const count = await prisma.batchTimeline.count({
     *   where: {
     *     // ... the filter for the BatchTimelines we want to count
     *   }
     * })
    **/
    count<T extends BatchTimelineCountArgs>(
      args?: Subset<T, BatchTimelineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchTimelineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BatchTimeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchTimelineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchTimelineAggregateArgs>(args: Subset<T, BatchTimelineAggregateArgs>): Prisma.PrismaPromise<GetBatchTimelineAggregateType<T>>

    /**
     * Group by BatchTimeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchTimelineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchTimelineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchTimelineGroupByArgs['orderBy'] }
        : { orderBy?: BatchTimelineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchTimelineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchTimelineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BatchTimeline model
   */
  readonly fields: BatchTimelineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BatchTimeline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchTimelineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batch<T extends BatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BatchDefaultArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BatchTimeline model
   */ 
  interface BatchTimelineFieldRefs {
    readonly id: FieldRef<"BatchTimeline", 'String'>
    readonly batchId: FieldRef<"BatchTimeline", 'String'>
    readonly type: FieldRef<"BatchTimeline", 'TimelineEventType'>
    readonly title: FieldRef<"BatchTimeline", 'String'>
    readonly description: FieldRef<"BatchTimeline", 'String'>
    readonly data: FieldRef<"BatchTimeline", 'Json'>
    readonly createdBy: FieldRef<"BatchTimeline", 'String'>
    readonly createdAt: FieldRef<"BatchTimeline", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BatchTimeline findUnique
   */
  export type BatchTimelineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchTimeline
     */
    select?: BatchTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchTimelineInclude<ExtArgs> | null
    /**
     * Filter, which BatchTimeline to fetch.
     */
    where: BatchTimelineWhereUniqueInput
  }

  /**
   * BatchTimeline findUniqueOrThrow
   */
  export type BatchTimelineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchTimeline
     */
    select?: BatchTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchTimelineInclude<ExtArgs> | null
    /**
     * Filter, which BatchTimeline to fetch.
     */
    where: BatchTimelineWhereUniqueInput
  }

  /**
   * BatchTimeline findFirst
   */
  export type BatchTimelineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchTimeline
     */
    select?: BatchTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchTimelineInclude<ExtArgs> | null
    /**
     * Filter, which BatchTimeline to fetch.
     */
    where?: BatchTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchTimelines to fetch.
     */
    orderBy?: BatchTimelineOrderByWithRelationInput | BatchTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchTimelines.
     */
    cursor?: BatchTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchTimelines.
     */
    distinct?: BatchTimelineScalarFieldEnum | BatchTimelineScalarFieldEnum[]
  }

  /**
   * BatchTimeline findFirstOrThrow
   */
  export type BatchTimelineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchTimeline
     */
    select?: BatchTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchTimelineInclude<ExtArgs> | null
    /**
     * Filter, which BatchTimeline to fetch.
     */
    where?: BatchTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchTimelines to fetch.
     */
    orderBy?: BatchTimelineOrderByWithRelationInput | BatchTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchTimelines.
     */
    cursor?: BatchTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchTimelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchTimelines.
     */
    distinct?: BatchTimelineScalarFieldEnum | BatchTimelineScalarFieldEnum[]
  }

  /**
   * BatchTimeline findMany
   */
  export type BatchTimelineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchTimeline
     */
    select?: BatchTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchTimelineInclude<ExtArgs> | null
    /**
     * Filter, which BatchTimelines to fetch.
     */
    where?: BatchTimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchTimelines to fetch.
     */
    orderBy?: BatchTimelineOrderByWithRelationInput | BatchTimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BatchTimelines.
     */
    cursor?: BatchTimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchTimelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchTimelines.
     */
    skip?: number
    distinct?: BatchTimelineScalarFieldEnum | BatchTimelineScalarFieldEnum[]
  }

  /**
   * BatchTimeline create
   */
  export type BatchTimelineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchTimeline
     */
    select?: BatchTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchTimelineInclude<ExtArgs> | null
    /**
     * The data needed to create a BatchTimeline.
     */
    data: XOR<BatchTimelineCreateInput, BatchTimelineUncheckedCreateInput>
  }

  /**
   * BatchTimeline createMany
   */
  export type BatchTimelineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BatchTimelines.
     */
    data: BatchTimelineCreateManyInput | BatchTimelineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BatchTimeline createManyAndReturn
   */
  export type BatchTimelineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchTimeline
     */
    select?: BatchTimelineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BatchTimelines.
     */
    data: BatchTimelineCreateManyInput | BatchTimelineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchTimelineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BatchTimeline update
   */
  export type BatchTimelineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchTimeline
     */
    select?: BatchTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchTimelineInclude<ExtArgs> | null
    /**
     * The data needed to update a BatchTimeline.
     */
    data: XOR<BatchTimelineUpdateInput, BatchTimelineUncheckedUpdateInput>
    /**
     * Choose, which BatchTimeline to update.
     */
    where: BatchTimelineWhereUniqueInput
  }

  /**
   * BatchTimeline updateMany
   */
  export type BatchTimelineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BatchTimelines.
     */
    data: XOR<BatchTimelineUpdateManyMutationInput, BatchTimelineUncheckedUpdateManyInput>
    /**
     * Filter which BatchTimelines to update
     */
    where?: BatchTimelineWhereInput
  }

  /**
   * BatchTimeline upsert
   */
  export type BatchTimelineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchTimeline
     */
    select?: BatchTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchTimelineInclude<ExtArgs> | null
    /**
     * The filter to search for the BatchTimeline to update in case it exists.
     */
    where: BatchTimelineWhereUniqueInput
    /**
     * In case the BatchTimeline found by the `where` argument doesn't exist, create a new BatchTimeline with this data.
     */
    create: XOR<BatchTimelineCreateInput, BatchTimelineUncheckedCreateInput>
    /**
     * In case the BatchTimeline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchTimelineUpdateInput, BatchTimelineUncheckedUpdateInput>
  }

  /**
   * BatchTimeline delete
   */
  export type BatchTimelineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchTimeline
     */
    select?: BatchTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchTimelineInclude<ExtArgs> | null
    /**
     * Filter which BatchTimeline to delete.
     */
    where: BatchTimelineWhereUniqueInput
  }

  /**
   * BatchTimeline deleteMany
   */
  export type BatchTimelineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchTimelines to delete
     */
    where?: BatchTimelineWhereInput
  }

  /**
   * BatchTimeline without action
   */
  export type BatchTimelineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchTimeline
     */
    select?: BatchTimelineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchTimelineInclude<ExtArgs> | null
  }


  /**
   * Model Tank
   */

  export type AggregateTank = {
    _count: TankCountAggregateOutputType | null
    _avg: TankAvgAggregateOutputType | null
    _sum: TankSumAggregateOutputType | null
    _min: TankMinAggregateOutputType | null
    _max: TankMaxAggregateOutputType | null
  }

  export type TankAvgAggregateOutputType = {
    capacity: Decimal | null
    version: number | null
    defaultTurnaroundHours: number | null
    maxFillPercent: number | null
    minFillPercent: number | null
  }

  export type TankSumAggregateOutputType = {
    capacity: Decimal | null
    version: number | null
    defaultTurnaroundHours: number | null
    maxFillPercent: number | null
    minFillPercent: number | null
  }

  export type TankMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    type: $Enums.TankType | null
    capacity: Decimal | null
    status: $Enums.TankStatus | null
    currentBatchId: string | null
    location: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
    currentLotId: string | null
    currentPhase: $Enums.LotPhase | null
    defaultTurnaroundHours: number | null
    maxFillPercent: number | null
    minFillPercent: number | null
  }

  export type TankMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    type: $Enums.TankType | null
    capacity: Decimal | null
    status: $Enums.TankStatus | null
    currentBatchId: string | null
    location: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
    currentLotId: string | null
    currentPhase: $Enums.LotPhase | null
    defaultTurnaroundHours: number | null
    maxFillPercent: number | null
    minFillPercent: number | null
  }

  export type TankCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    type: number
    capacity: number
    status: number
    currentBatchId: number
    location: number
    version: number
    createdAt: number
    updatedAt: number
    capabilities: number
    currentLotId: number
    currentPhase: number
    defaultTurnaroundHours: number
    maxFillPercent: number
    minFillPercent: number
    _all: number
  }


  export type TankAvgAggregateInputType = {
    capacity?: true
    version?: true
    defaultTurnaroundHours?: true
    maxFillPercent?: true
    minFillPercent?: true
  }

  export type TankSumAggregateInputType = {
    capacity?: true
    version?: true
    defaultTurnaroundHours?: true
    maxFillPercent?: true
    minFillPercent?: true
  }

  export type TankMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    type?: true
    capacity?: true
    status?: true
    currentBatchId?: true
    location?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    currentLotId?: true
    currentPhase?: true
    defaultTurnaroundHours?: true
    maxFillPercent?: true
    minFillPercent?: true
  }

  export type TankMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    type?: true
    capacity?: true
    status?: true
    currentBatchId?: true
    location?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    currentLotId?: true
    currentPhase?: true
    defaultTurnaroundHours?: true
    maxFillPercent?: true
    minFillPercent?: true
  }

  export type TankCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    type?: true
    capacity?: true
    status?: true
    currentBatchId?: true
    location?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    capabilities?: true
    currentLotId?: true
    currentPhase?: true
    defaultTurnaroundHours?: true
    maxFillPercent?: true
    minFillPercent?: true
    _all?: true
  }

  export type TankAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tank to aggregate.
     */
    where?: TankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tanks to fetch.
     */
    orderBy?: TankOrderByWithRelationInput | TankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tanks
    **/
    _count?: true | TankCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TankAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TankSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TankMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TankMaxAggregateInputType
  }

  export type GetTankAggregateType<T extends TankAggregateArgs> = {
        [P in keyof T & keyof AggregateTank]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTank[P]>
      : GetScalarType<T[P], AggregateTank[P]>
  }




  export type TankGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TankWhereInput
    orderBy?: TankOrderByWithAggregationInput | TankOrderByWithAggregationInput[]
    by: TankScalarFieldEnum[] | TankScalarFieldEnum
    having?: TankScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TankCountAggregateInputType | true
    _avg?: TankAvgAggregateInputType
    _sum?: TankSumAggregateInputType
    _min?: TankMinAggregateInputType
    _max?: TankMaxAggregateInputType
  }

  export type TankGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    type: $Enums.TankType
    capacity: Decimal
    status: $Enums.TankStatus
    currentBatchId: string | null
    location: string | null
    version: number
    createdAt: Date
    updatedAt: Date
    capabilities: $Enums.TankCapability[]
    currentLotId: string | null
    currentPhase: $Enums.LotPhase | null
    defaultTurnaroundHours: number | null
    maxFillPercent: number | null
    minFillPercent: number | null
    _count: TankCountAggregateOutputType | null
    _avg: TankAvgAggregateOutputType | null
    _sum: TankSumAggregateOutputType | null
    _min: TankMinAggregateOutputType | null
    _max: TankMaxAggregateOutputType | null
  }

  type GetTankGroupByPayload<T extends TankGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TankGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TankGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TankGroupByOutputType[P]>
            : GetScalarType<T[P], TankGroupByOutputType[P]>
        }
      >
    >


  export type TankSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    type?: boolean
    capacity?: boolean
    status?: boolean
    currentBatchId?: boolean
    location?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    capabilities?: boolean
    currentLotId?: boolean
    currentPhase?: boolean
    defaultTurnaroundHours?: boolean
    maxFillPercent?: boolean
    minFillPercent?: boolean
    batches?: boolean | Tank$batchesArgs<ExtArgs>
    LotReading?: boolean | Tank$LotReadingArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    TankAssignment?: boolean | Tank$TankAssignmentArgs<ExtArgs>
    occupations?: boolean | Tank$occupationsArgs<ExtArgs>
    Transfer_Transfer_destTankIdToTank?: boolean | Tank$Transfer_Transfer_destTankIdToTankArgs<ExtArgs>
    Transfer_Transfer_sourceTankIdToTank?: boolean | Tank$Transfer_Transfer_sourceTankIdToTankArgs<ExtArgs>
    _count?: boolean | TankCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tank"]>

  export type TankSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    type?: boolean
    capacity?: boolean
    status?: boolean
    currentBatchId?: boolean
    location?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    capabilities?: boolean
    currentLotId?: boolean
    currentPhase?: boolean
    defaultTurnaroundHours?: boolean
    maxFillPercent?: boolean
    minFillPercent?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tank"]>

  export type TankSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    type?: boolean
    capacity?: boolean
    status?: boolean
    currentBatchId?: boolean
    location?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    capabilities?: boolean
    currentLotId?: boolean
    currentPhase?: boolean
    defaultTurnaroundHours?: boolean
    maxFillPercent?: boolean
    minFillPercent?: boolean
  }

  export type TankInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | Tank$batchesArgs<ExtArgs>
    LotReading?: boolean | Tank$LotReadingArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    TankAssignment?: boolean | Tank$TankAssignmentArgs<ExtArgs>
    occupations?: boolean | Tank$occupationsArgs<ExtArgs>
    Transfer_Transfer_destTankIdToTank?: boolean | Tank$Transfer_Transfer_destTankIdToTankArgs<ExtArgs>
    Transfer_Transfer_sourceTankIdToTank?: boolean | Tank$Transfer_Transfer_sourceTankIdToTankArgs<ExtArgs>
    _count?: boolean | TankCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TankIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TankPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tank"
    objects: {
      batches: Prisma.$BatchPayload<ExtArgs>[]
      LotReading: Prisma.$LotReadingPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
      TankAssignment: Prisma.$TankAssignmentPayload<ExtArgs>[]
      occupations: Prisma.$TankOccupationPayload<ExtArgs>[]
      Transfer_Transfer_destTankIdToTank: Prisma.$TransferPayload<ExtArgs>[]
      Transfer_Transfer_sourceTankIdToTank: Prisma.$TransferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      type: $Enums.TankType
      capacity: Prisma.Decimal
      status: $Enums.TankStatus
      currentBatchId: string | null
      location: string | null
      version: number
      createdAt: Date
      updatedAt: Date
      capabilities: $Enums.TankCapability[]
      currentLotId: string | null
      currentPhase: $Enums.LotPhase | null
      defaultTurnaroundHours: number | null
      maxFillPercent: number | null
      minFillPercent: number | null
    }, ExtArgs["result"]["tank"]>
    composites: {}
  }

  type TankGetPayload<S extends boolean | null | undefined | TankDefaultArgs> = $Result.GetResult<Prisma.$TankPayload, S>

  type TankCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TankFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TankCountAggregateInputType | true
    }

  export interface TankDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tank'], meta: { name: 'Tank' } }
    /**
     * Find zero or one Tank that matches the filter.
     * @param {TankFindUniqueArgs} args - Arguments to find a Tank
     * @example
     * // Get one Tank
     * const tank = await prisma.tank.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TankFindUniqueArgs>(args: SelectSubset<T, TankFindUniqueArgs<ExtArgs>>): Prisma__TankClient<$Result.GetResult<Prisma.$TankPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tank that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TankFindUniqueOrThrowArgs} args - Arguments to find a Tank
     * @example
     * // Get one Tank
     * const tank = await prisma.tank.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TankFindUniqueOrThrowArgs>(args: SelectSubset<T, TankFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TankClient<$Result.GetResult<Prisma.$TankPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tank that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankFindFirstArgs} args - Arguments to find a Tank
     * @example
     * // Get one Tank
     * const tank = await prisma.tank.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TankFindFirstArgs>(args?: SelectSubset<T, TankFindFirstArgs<ExtArgs>>): Prisma__TankClient<$Result.GetResult<Prisma.$TankPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tank that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankFindFirstOrThrowArgs} args - Arguments to find a Tank
     * @example
     * // Get one Tank
     * const tank = await prisma.tank.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TankFindFirstOrThrowArgs>(args?: SelectSubset<T, TankFindFirstOrThrowArgs<ExtArgs>>): Prisma__TankClient<$Result.GetResult<Prisma.$TankPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tanks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tanks
     * const tanks = await prisma.tank.findMany()
     * 
     * // Get first 10 Tanks
     * const tanks = await prisma.tank.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tankWithIdOnly = await prisma.tank.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TankFindManyArgs>(args?: SelectSubset<T, TankFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TankPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tank.
     * @param {TankCreateArgs} args - Arguments to create a Tank.
     * @example
     * // Create one Tank
     * const Tank = await prisma.tank.create({
     *   data: {
     *     // ... data to create a Tank
     *   }
     * })
     * 
     */
    create<T extends TankCreateArgs>(args: SelectSubset<T, TankCreateArgs<ExtArgs>>): Prisma__TankClient<$Result.GetResult<Prisma.$TankPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tanks.
     * @param {TankCreateManyArgs} args - Arguments to create many Tanks.
     * @example
     * // Create many Tanks
     * const tank = await prisma.tank.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TankCreateManyArgs>(args?: SelectSubset<T, TankCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tanks and returns the data saved in the database.
     * @param {TankCreateManyAndReturnArgs} args - Arguments to create many Tanks.
     * @example
     * // Create many Tanks
     * const tank = await prisma.tank.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tanks and only return the `id`
     * const tankWithIdOnly = await prisma.tank.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TankCreateManyAndReturnArgs>(args?: SelectSubset<T, TankCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TankPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tank.
     * @param {TankDeleteArgs} args - Arguments to delete one Tank.
     * @example
     * // Delete one Tank
     * const Tank = await prisma.tank.delete({
     *   where: {
     *     // ... filter to delete one Tank
     *   }
     * })
     * 
     */
    delete<T extends TankDeleteArgs>(args: SelectSubset<T, TankDeleteArgs<ExtArgs>>): Prisma__TankClient<$Result.GetResult<Prisma.$TankPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tank.
     * @param {TankUpdateArgs} args - Arguments to update one Tank.
     * @example
     * // Update one Tank
     * const tank = await prisma.tank.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TankUpdateArgs>(args: SelectSubset<T, TankUpdateArgs<ExtArgs>>): Prisma__TankClient<$Result.GetResult<Prisma.$TankPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tanks.
     * @param {TankDeleteManyArgs} args - Arguments to filter Tanks to delete.
     * @example
     * // Delete a few Tanks
     * const { count } = await prisma.tank.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TankDeleteManyArgs>(args?: SelectSubset<T, TankDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tanks
     * const tank = await prisma.tank.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TankUpdateManyArgs>(args: SelectSubset<T, TankUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tank.
     * @param {TankUpsertArgs} args - Arguments to update or create a Tank.
     * @example
     * // Update or create a Tank
     * const tank = await prisma.tank.upsert({
     *   create: {
     *     // ... data to create a Tank
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tank we want to update
     *   }
     * })
     */
    upsert<T extends TankUpsertArgs>(args: SelectSubset<T, TankUpsertArgs<ExtArgs>>): Prisma__TankClient<$Result.GetResult<Prisma.$TankPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankCountArgs} args - Arguments to filter Tanks to count.
     * @example
     * // Count the number of Tanks
     * const count = await prisma.tank.count({
     *   where: {
     *     // ... the filter for the Tanks we want to count
     *   }
     * })
    **/
    count<T extends TankCountArgs>(
      args?: Subset<T, TankCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TankCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TankAggregateArgs>(args: Subset<T, TankAggregateArgs>): Prisma.PrismaPromise<GetTankAggregateType<T>>

    /**
     * Group by Tank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TankGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TankGroupByArgs['orderBy'] }
        : { orderBy?: TankGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TankGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTankGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tank model
   */
  readonly fields: TankFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tank.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TankClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batches<T extends Tank$batchesArgs<ExtArgs> = {}>(args?: Subset<T, Tank$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany"> | Null>
    LotReading<T extends Tank$LotReadingArgs<ExtArgs> = {}>(args?: Subset<T, Tank$LotReadingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotReadingPayload<ExtArgs>, T, "findMany"> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    TankAssignment<T extends Tank$TankAssignmentArgs<ExtArgs> = {}>(args?: Subset<T, Tank$TankAssignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TankAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    occupations<T extends Tank$occupationsArgs<ExtArgs> = {}>(args?: Subset<T, Tank$occupationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TankOccupationPayload<ExtArgs>, T, "findMany"> | Null>
    Transfer_Transfer_destTankIdToTank<T extends Tank$Transfer_Transfer_destTankIdToTankArgs<ExtArgs> = {}>(args?: Subset<T, Tank$Transfer_Transfer_destTankIdToTankArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany"> | Null>
    Transfer_Transfer_sourceTankIdToTank<T extends Tank$Transfer_Transfer_sourceTankIdToTankArgs<ExtArgs> = {}>(args?: Subset<T, Tank$Transfer_Transfer_sourceTankIdToTankArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tank model
   */ 
  interface TankFieldRefs {
    readonly id: FieldRef<"Tank", 'String'>
    readonly tenantId: FieldRef<"Tank", 'String'>
    readonly name: FieldRef<"Tank", 'String'>
    readonly type: FieldRef<"Tank", 'TankType'>
    readonly capacity: FieldRef<"Tank", 'Decimal'>
    readonly status: FieldRef<"Tank", 'TankStatus'>
    readonly currentBatchId: FieldRef<"Tank", 'String'>
    readonly location: FieldRef<"Tank", 'String'>
    readonly version: FieldRef<"Tank", 'Int'>
    readonly createdAt: FieldRef<"Tank", 'DateTime'>
    readonly updatedAt: FieldRef<"Tank", 'DateTime'>
    readonly capabilities: FieldRef<"Tank", 'TankCapability[]'>
    readonly currentLotId: FieldRef<"Tank", 'String'>
    readonly currentPhase: FieldRef<"Tank", 'LotPhase'>
    readonly defaultTurnaroundHours: FieldRef<"Tank", 'Int'>
    readonly maxFillPercent: FieldRef<"Tank", 'Int'>
    readonly minFillPercent: FieldRef<"Tank", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Tank findUnique
   */
  export type TankFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tank
     */
    select?: TankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankInclude<ExtArgs> | null
    /**
     * Filter, which Tank to fetch.
     */
    where: TankWhereUniqueInput
  }

  /**
   * Tank findUniqueOrThrow
   */
  export type TankFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tank
     */
    select?: TankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankInclude<ExtArgs> | null
    /**
     * Filter, which Tank to fetch.
     */
    where: TankWhereUniqueInput
  }

  /**
   * Tank findFirst
   */
  export type TankFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tank
     */
    select?: TankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankInclude<ExtArgs> | null
    /**
     * Filter, which Tank to fetch.
     */
    where?: TankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tanks to fetch.
     */
    orderBy?: TankOrderByWithRelationInput | TankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tanks.
     */
    cursor?: TankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tanks.
     */
    distinct?: TankScalarFieldEnum | TankScalarFieldEnum[]
  }

  /**
   * Tank findFirstOrThrow
   */
  export type TankFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tank
     */
    select?: TankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankInclude<ExtArgs> | null
    /**
     * Filter, which Tank to fetch.
     */
    where?: TankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tanks to fetch.
     */
    orderBy?: TankOrderByWithRelationInput | TankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tanks.
     */
    cursor?: TankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tanks.
     */
    distinct?: TankScalarFieldEnum | TankScalarFieldEnum[]
  }

  /**
   * Tank findMany
   */
  export type TankFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tank
     */
    select?: TankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankInclude<ExtArgs> | null
    /**
     * Filter, which Tanks to fetch.
     */
    where?: TankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tanks to fetch.
     */
    orderBy?: TankOrderByWithRelationInput | TankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tanks.
     */
    cursor?: TankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tanks.
     */
    skip?: number
    distinct?: TankScalarFieldEnum | TankScalarFieldEnum[]
  }

  /**
   * Tank create
   */
  export type TankCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tank
     */
    select?: TankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankInclude<ExtArgs> | null
    /**
     * The data needed to create a Tank.
     */
    data: XOR<TankCreateInput, TankUncheckedCreateInput>
  }

  /**
   * Tank createMany
   */
  export type TankCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tanks.
     */
    data: TankCreateManyInput | TankCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tank createManyAndReturn
   */
  export type TankCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tank
     */
    select?: TankSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tanks.
     */
    data: TankCreateManyInput | TankCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tank update
   */
  export type TankUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tank
     */
    select?: TankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankInclude<ExtArgs> | null
    /**
     * The data needed to update a Tank.
     */
    data: XOR<TankUpdateInput, TankUncheckedUpdateInput>
    /**
     * Choose, which Tank to update.
     */
    where: TankWhereUniqueInput
  }

  /**
   * Tank updateMany
   */
  export type TankUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tanks.
     */
    data: XOR<TankUpdateManyMutationInput, TankUncheckedUpdateManyInput>
    /**
     * Filter which Tanks to update
     */
    where?: TankWhereInput
  }

  /**
   * Tank upsert
   */
  export type TankUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tank
     */
    select?: TankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankInclude<ExtArgs> | null
    /**
     * The filter to search for the Tank to update in case it exists.
     */
    where: TankWhereUniqueInput
    /**
     * In case the Tank found by the `where` argument doesn't exist, create a new Tank with this data.
     */
    create: XOR<TankCreateInput, TankUncheckedCreateInput>
    /**
     * In case the Tank was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TankUpdateInput, TankUncheckedUpdateInput>
  }

  /**
   * Tank delete
   */
  export type TankDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tank
     */
    select?: TankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankInclude<ExtArgs> | null
    /**
     * Filter which Tank to delete.
     */
    where: TankWhereUniqueInput
  }

  /**
   * Tank deleteMany
   */
  export type TankDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tanks to delete
     */
    where?: TankWhereInput
  }

  /**
   * Tank.batches
   */
  export type Tank$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Tank.LotReading
   */
  export type Tank$LotReadingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotReading
     */
    select?: LotReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotReadingInclude<ExtArgs> | null
    where?: LotReadingWhereInput
    orderBy?: LotReadingOrderByWithRelationInput | LotReadingOrderByWithRelationInput[]
    cursor?: LotReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotReadingScalarFieldEnum | LotReadingScalarFieldEnum[]
  }

  /**
   * Tank.TankAssignment
   */
  export type Tank$TankAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankAssignment
     */
    select?: TankAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankAssignmentInclude<ExtArgs> | null
    where?: TankAssignmentWhereInput
    orderBy?: TankAssignmentOrderByWithRelationInput | TankAssignmentOrderByWithRelationInput[]
    cursor?: TankAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TankAssignmentScalarFieldEnum | TankAssignmentScalarFieldEnum[]
  }

  /**
   * Tank.occupations
   */
  export type Tank$occupationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankOccupation
     */
    select?: TankOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankOccupationInclude<ExtArgs> | null
    where?: TankOccupationWhereInput
    orderBy?: TankOccupationOrderByWithRelationInput | TankOccupationOrderByWithRelationInput[]
    cursor?: TankOccupationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TankOccupationScalarFieldEnum | TankOccupationScalarFieldEnum[]
  }

  /**
   * Tank.Transfer_Transfer_destTankIdToTank
   */
  export type Tank$Transfer_Transfer_destTankIdToTankArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Tank.Transfer_Transfer_sourceTankIdToTank
   */
  export type Tank$Transfer_Transfer_sourceTankIdToTankArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Tank without action
   */
  export type TankDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tank
     */
    select?: TankSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankInclude<ExtArgs> | null
  }


  /**
   * Model TankOccupation
   */

  export type AggregateTankOccupation = {
    _count: TankOccupationCountAggregateOutputType | null
    _min: TankOccupationMinAggregateOutputType | null
    _max: TankOccupationMaxAggregateOutputType | null
  }

  export type TankOccupationMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    tankId: string | null
    batchId: string | null
    phase: $Enums.OccupationPhase | null
    startedAt: Date | null
    endedAt: Date | null
  }

  export type TankOccupationMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    tankId: string | null
    batchId: string | null
    phase: $Enums.OccupationPhase | null
    startedAt: Date | null
    endedAt: Date | null
  }

  export type TankOccupationCountAggregateOutputType = {
    id: number
    tenantId: number
    tankId: number
    batchId: number
    phase: number
    startedAt: number
    endedAt: number
    _all: number
  }


  export type TankOccupationMinAggregateInputType = {
    id?: true
    tenantId?: true
    tankId?: true
    batchId?: true
    phase?: true
    startedAt?: true
    endedAt?: true
  }

  export type TankOccupationMaxAggregateInputType = {
    id?: true
    tenantId?: true
    tankId?: true
    batchId?: true
    phase?: true
    startedAt?: true
    endedAt?: true
  }

  export type TankOccupationCountAggregateInputType = {
    id?: true
    tenantId?: true
    tankId?: true
    batchId?: true
    phase?: true
    startedAt?: true
    endedAt?: true
    _all?: true
  }

  export type TankOccupationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TankOccupation to aggregate.
     */
    where?: TankOccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TankOccupations to fetch.
     */
    orderBy?: TankOccupationOrderByWithRelationInput | TankOccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TankOccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TankOccupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TankOccupations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TankOccupations
    **/
    _count?: true | TankOccupationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TankOccupationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TankOccupationMaxAggregateInputType
  }

  export type GetTankOccupationAggregateType<T extends TankOccupationAggregateArgs> = {
        [P in keyof T & keyof AggregateTankOccupation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTankOccupation[P]>
      : GetScalarType<T[P], AggregateTankOccupation[P]>
  }




  export type TankOccupationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TankOccupationWhereInput
    orderBy?: TankOccupationOrderByWithAggregationInput | TankOccupationOrderByWithAggregationInput[]
    by: TankOccupationScalarFieldEnum[] | TankOccupationScalarFieldEnum
    having?: TankOccupationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TankOccupationCountAggregateInputType | true
    _min?: TankOccupationMinAggregateInputType
    _max?: TankOccupationMaxAggregateInputType
  }

  export type TankOccupationGroupByOutputType = {
    id: string
    tenantId: string
    tankId: string
    batchId: string
    phase: $Enums.OccupationPhase
    startedAt: Date
    endedAt: Date | null
    _count: TankOccupationCountAggregateOutputType | null
    _min: TankOccupationMinAggregateOutputType | null
    _max: TankOccupationMaxAggregateOutputType | null
  }

  type GetTankOccupationGroupByPayload<T extends TankOccupationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TankOccupationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TankOccupationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TankOccupationGroupByOutputType[P]>
            : GetScalarType<T[P], TankOccupationGroupByOutputType[P]>
        }
      >
    >


  export type TankOccupationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tankId?: boolean
    batchId?: boolean
    phase?: boolean
    startedAt?: boolean
    endedAt?: boolean
    tank?: boolean | TankDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tankOccupation"]>

  export type TankOccupationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tankId?: boolean
    batchId?: boolean
    phase?: boolean
    startedAt?: boolean
    endedAt?: boolean
    tank?: boolean | TankDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tankOccupation"]>

  export type TankOccupationSelectScalar = {
    id?: boolean
    tenantId?: boolean
    tankId?: boolean
    batchId?: boolean
    phase?: boolean
    startedAt?: boolean
    endedAt?: boolean
  }

  export type TankOccupationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tank?: boolean | TankDefaultArgs<ExtArgs>
  }
  export type TankOccupationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tank?: boolean | TankDefaultArgs<ExtArgs>
  }

  export type $TankOccupationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TankOccupation"
    objects: {
      tank: Prisma.$TankPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      tankId: string
      batchId: string
      phase: $Enums.OccupationPhase
      startedAt: Date
      endedAt: Date | null
    }, ExtArgs["result"]["tankOccupation"]>
    composites: {}
  }

  type TankOccupationGetPayload<S extends boolean | null | undefined | TankOccupationDefaultArgs> = $Result.GetResult<Prisma.$TankOccupationPayload, S>

  type TankOccupationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TankOccupationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TankOccupationCountAggregateInputType | true
    }

  export interface TankOccupationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TankOccupation'], meta: { name: 'TankOccupation' } }
    /**
     * Find zero or one TankOccupation that matches the filter.
     * @param {TankOccupationFindUniqueArgs} args - Arguments to find a TankOccupation
     * @example
     * // Get one TankOccupation
     * const tankOccupation = await prisma.tankOccupation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TankOccupationFindUniqueArgs>(args: SelectSubset<T, TankOccupationFindUniqueArgs<ExtArgs>>): Prisma__TankOccupationClient<$Result.GetResult<Prisma.$TankOccupationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TankOccupation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TankOccupationFindUniqueOrThrowArgs} args - Arguments to find a TankOccupation
     * @example
     * // Get one TankOccupation
     * const tankOccupation = await prisma.tankOccupation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TankOccupationFindUniqueOrThrowArgs>(args: SelectSubset<T, TankOccupationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TankOccupationClient<$Result.GetResult<Prisma.$TankOccupationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TankOccupation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankOccupationFindFirstArgs} args - Arguments to find a TankOccupation
     * @example
     * // Get one TankOccupation
     * const tankOccupation = await prisma.tankOccupation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TankOccupationFindFirstArgs>(args?: SelectSubset<T, TankOccupationFindFirstArgs<ExtArgs>>): Prisma__TankOccupationClient<$Result.GetResult<Prisma.$TankOccupationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TankOccupation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankOccupationFindFirstOrThrowArgs} args - Arguments to find a TankOccupation
     * @example
     * // Get one TankOccupation
     * const tankOccupation = await prisma.tankOccupation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TankOccupationFindFirstOrThrowArgs>(args?: SelectSubset<T, TankOccupationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TankOccupationClient<$Result.GetResult<Prisma.$TankOccupationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TankOccupations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankOccupationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TankOccupations
     * const tankOccupations = await prisma.tankOccupation.findMany()
     * 
     * // Get first 10 TankOccupations
     * const tankOccupations = await prisma.tankOccupation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tankOccupationWithIdOnly = await prisma.tankOccupation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TankOccupationFindManyArgs>(args?: SelectSubset<T, TankOccupationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TankOccupationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TankOccupation.
     * @param {TankOccupationCreateArgs} args - Arguments to create a TankOccupation.
     * @example
     * // Create one TankOccupation
     * const TankOccupation = await prisma.tankOccupation.create({
     *   data: {
     *     // ... data to create a TankOccupation
     *   }
     * })
     * 
     */
    create<T extends TankOccupationCreateArgs>(args: SelectSubset<T, TankOccupationCreateArgs<ExtArgs>>): Prisma__TankOccupationClient<$Result.GetResult<Prisma.$TankOccupationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TankOccupations.
     * @param {TankOccupationCreateManyArgs} args - Arguments to create many TankOccupations.
     * @example
     * // Create many TankOccupations
     * const tankOccupation = await prisma.tankOccupation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TankOccupationCreateManyArgs>(args?: SelectSubset<T, TankOccupationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TankOccupations and returns the data saved in the database.
     * @param {TankOccupationCreateManyAndReturnArgs} args - Arguments to create many TankOccupations.
     * @example
     * // Create many TankOccupations
     * const tankOccupation = await prisma.tankOccupation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TankOccupations and only return the `id`
     * const tankOccupationWithIdOnly = await prisma.tankOccupation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TankOccupationCreateManyAndReturnArgs>(args?: SelectSubset<T, TankOccupationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TankOccupationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TankOccupation.
     * @param {TankOccupationDeleteArgs} args - Arguments to delete one TankOccupation.
     * @example
     * // Delete one TankOccupation
     * const TankOccupation = await prisma.tankOccupation.delete({
     *   where: {
     *     // ... filter to delete one TankOccupation
     *   }
     * })
     * 
     */
    delete<T extends TankOccupationDeleteArgs>(args: SelectSubset<T, TankOccupationDeleteArgs<ExtArgs>>): Prisma__TankOccupationClient<$Result.GetResult<Prisma.$TankOccupationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TankOccupation.
     * @param {TankOccupationUpdateArgs} args - Arguments to update one TankOccupation.
     * @example
     * // Update one TankOccupation
     * const tankOccupation = await prisma.tankOccupation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TankOccupationUpdateArgs>(args: SelectSubset<T, TankOccupationUpdateArgs<ExtArgs>>): Prisma__TankOccupationClient<$Result.GetResult<Prisma.$TankOccupationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TankOccupations.
     * @param {TankOccupationDeleteManyArgs} args - Arguments to filter TankOccupations to delete.
     * @example
     * // Delete a few TankOccupations
     * const { count } = await prisma.tankOccupation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TankOccupationDeleteManyArgs>(args?: SelectSubset<T, TankOccupationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TankOccupations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankOccupationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TankOccupations
     * const tankOccupation = await prisma.tankOccupation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TankOccupationUpdateManyArgs>(args: SelectSubset<T, TankOccupationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TankOccupation.
     * @param {TankOccupationUpsertArgs} args - Arguments to update or create a TankOccupation.
     * @example
     * // Update or create a TankOccupation
     * const tankOccupation = await prisma.tankOccupation.upsert({
     *   create: {
     *     // ... data to create a TankOccupation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TankOccupation we want to update
     *   }
     * })
     */
    upsert<T extends TankOccupationUpsertArgs>(args: SelectSubset<T, TankOccupationUpsertArgs<ExtArgs>>): Prisma__TankOccupationClient<$Result.GetResult<Prisma.$TankOccupationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TankOccupations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankOccupationCountArgs} args - Arguments to filter TankOccupations to count.
     * @example
     * // Count the number of TankOccupations
     * const count = await prisma.tankOccupation.count({
     *   where: {
     *     // ... the filter for the TankOccupations we want to count
     *   }
     * })
    **/
    count<T extends TankOccupationCountArgs>(
      args?: Subset<T, TankOccupationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TankOccupationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TankOccupation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankOccupationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TankOccupationAggregateArgs>(args: Subset<T, TankOccupationAggregateArgs>): Prisma.PrismaPromise<GetTankOccupationAggregateType<T>>

    /**
     * Group by TankOccupation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankOccupationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TankOccupationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TankOccupationGroupByArgs['orderBy'] }
        : { orderBy?: TankOccupationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TankOccupationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTankOccupationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TankOccupation model
   */
  readonly fields: TankOccupationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TankOccupation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TankOccupationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tank<T extends TankDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TankDefaultArgs<ExtArgs>>): Prisma__TankClient<$Result.GetResult<Prisma.$TankPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TankOccupation model
   */ 
  interface TankOccupationFieldRefs {
    readonly id: FieldRef<"TankOccupation", 'String'>
    readonly tenantId: FieldRef<"TankOccupation", 'String'>
    readonly tankId: FieldRef<"TankOccupation", 'String'>
    readonly batchId: FieldRef<"TankOccupation", 'String'>
    readonly phase: FieldRef<"TankOccupation", 'OccupationPhase'>
    readonly startedAt: FieldRef<"TankOccupation", 'DateTime'>
    readonly endedAt: FieldRef<"TankOccupation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TankOccupation findUnique
   */
  export type TankOccupationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankOccupation
     */
    select?: TankOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankOccupationInclude<ExtArgs> | null
    /**
     * Filter, which TankOccupation to fetch.
     */
    where: TankOccupationWhereUniqueInput
  }

  /**
   * TankOccupation findUniqueOrThrow
   */
  export type TankOccupationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankOccupation
     */
    select?: TankOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankOccupationInclude<ExtArgs> | null
    /**
     * Filter, which TankOccupation to fetch.
     */
    where: TankOccupationWhereUniqueInput
  }

  /**
   * TankOccupation findFirst
   */
  export type TankOccupationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankOccupation
     */
    select?: TankOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankOccupationInclude<ExtArgs> | null
    /**
     * Filter, which TankOccupation to fetch.
     */
    where?: TankOccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TankOccupations to fetch.
     */
    orderBy?: TankOccupationOrderByWithRelationInput | TankOccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TankOccupations.
     */
    cursor?: TankOccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TankOccupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TankOccupations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TankOccupations.
     */
    distinct?: TankOccupationScalarFieldEnum | TankOccupationScalarFieldEnum[]
  }

  /**
   * TankOccupation findFirstOrThrow
   */
  export type TankOccupationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankOccupation
     */
    select?: TankOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankOccupationInclude<ExtArgs> | null
    /**
     * Filter, which TankOccupation to fetch.
     */
    where?: TankOccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TankOccupations to fetch.
     */
    orderBy?: TankOccupationOrderByWithRelationInput | TankOccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TankOccupations.
     */
    cursor?: TankOccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TankOccupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TankOccupations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TankOccupations.
     */
    distinct?: TankOccupationScalarFieldEnum | TankOccupationScalarFieldEnum[]
  }

  /**
   * TankOccupation findMany
   */
  export type TankOccupationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankOccupation
     */
    select?: TankOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankOccupationInclude<ExtArgs> | null
    /**
     * Filter, which TankOccupations to fetch.
     */
    where?: TankOccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TankOccupations to fetch.
     */
    orderBy?: TankOccupationOrderByWithRelationInput | TankOccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TankOccupations.
     */
    cursor?: TankOccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TankOccupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TankOccupations.
     */
    skip?: number
    distinct?: TankOccupationScalarFieldEnum | TankOccupationScalarFieldEnum[]
  }

  /**
   * TankOccupation create
   */
  export type TankOccupationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankOccupation
     */
    select?: TankOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankOccupationInclude<ExtArgs> | null
    /**
     * The data needed to create a TankOccupation.
     */
    data: XOR<TankOccupationCreateInput, TankOccupationUncheckedCreateInput>
  }

  /**
   * TankOccupation createMany
   */
  export type TankOccupationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TankOccupations.
     */
    data: TankOccupationCreateManyInput | TankOccupationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TankOccupation createManyAndReturn
   */
  export type TankOccupationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankOccupation
     */
    select?: TankOccupationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TankOccupations.
     */
    data: TankOccupationCreateManyInput | TankOccupationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankOccupationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TankOccupation update
   */
  export type TankOccupationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankOccupation
     */
    select?: TankOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankOccupationInclude<ExtArgs> | null
    /**
     * The data needed to update a TankOccupation.
     */
    data: XOR<TankOccupationUpdateInput, TankOccupationUncheckedUpdateInput>
    /**
     * Choose, which TankOccupation to update.
     */
    where: TankOccupationWhereUniqueInput
  }

  /**
   * TankOccupation updateMany
   */
  export type TankOccupationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TankOccupations.
     */
    data: XOR<TankOccupationUpdateManyMutationInput, TankOccupationUncheckedUpdateManyInput>
    /**
     * Filter which TankOccupations to update
     */
    where?: TankOccupationWhereInput
  }

  /**
   * TankOccupation upsert
   */
  export type TankOccupationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankOccupation
     */
    select?: TankOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankOccupationInclude<ExtArgs> | null
    /**
     * The filter to search for the TankOccupation to update in case it exists.
     */
    where: TankOccupationWhereUniqueInput
    /**
     * In case the TankOccupation found by the `where` argument doesn't exist, create a new TankOccupation with this data.
     */
    create: XOR<TankOccupationCreateInput, TankOccupationUncheckedCreateInput>
    /**
     * In case the TankOccupation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TankOccupationUpdateInput, TankOccupationUncheckedUpdateInput>
  }

  /**
   * TankOccupation delete
   */
  export type TankOccupationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankOccupation
     */
    select?: TankOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankOccupationInclude<ExtArgs> | null
    /**
     * Filter which TankOccupation to delete.
     */
    where: TankOccupationWhereUniqueInput
  }

  /**
   * TankOccupation deleteMany
   */
  export type TankOccupationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TankOccupations to delete
     */
    where?: TankOccupationWhereInput
  }

  /**
   * TankOccupation without action
   */
  export type TankOccupationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankOccupation
     */
    select?: TankOccupationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankOccupationInclude<ExtArgs> | null
  }


  /**
   * Model PackagingRun
   */

  export type AggregatePackagingRun = {
    _count: PackagingRunCountAggregateOutputType | null
    _avg: PackagingRunAvgAggregateOutputType | null
    _sum: PackagingRunSumAggregateOutputType | null
    _min: PackagingRunMinAggregateOutputType | null
    _max: PackagingRunMaxAggregateOutputType | null
  }

  export type PackagingRunAvgAggregateOutputType = {
    quantity: number | null
    volumeTotal: Decimal | null
  }

  export type PackagingRunSumAggregateOutputType = {
    quantity: number | null
    volumeTotal: Decimal | null
  }

  export type PackagingRunMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    batchId: string | null
    packageType: $Enums.PackageType | null
    quantity: number | null
    volumeTotal: Decimal | null
    lotNumber: string | null
    performedBy: string | null
    notes: string | null
    performedAt: Date | null
  }

  export type PackagingRunMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    batchId: string | null
    packageType: $Enums.PackageType | null
    quantity: number | null
    volumeTotal: Decimal | null
    lotNumber: string | null
    performedBy: string | null
    notes: string | null
    performedAt: Date | null
  }

  export type PackagingRunCountAggregateOutputType = {
    id: number
    tenantId: number
    batchId: number
    packageType: number
    quantity: number
    volumeTotal: number
    lotNumber: number
    performedBy: number
    notes: number
    performedAt: number
    _all: number
  }


  export type PackagingRunAvgAggregateInputType = {
    quantity?: true
    volumeTotal?: true
  }

  export type PackagingRunSumAggregateInputType = {
    quantity?: true
    volumeTotal?: true
  }

  export type PackagingRunMinAggregateInputType = {
    id?: true
    tenantId?: true
    batchId?: true
    packageType?: true
    quantity?: true
    volumeTotal?: true
    lotNumber?: true
    performedBy?: true
    notes?: true
    performedAt?: true
  }

  export type PackagingRunMaxAggregateInputType = {
    id?: true
    tenantId?: true
    batchId?: true
    packageType?: true
    quantity?: true
    volumeTotal?: true
    lotNumber?: true
    performedBy?: true
    notes?: true
    performedAt?: true
  }

  export type PackagingRunCountAggregateInputType = {
    id?: true
    tenantId?: true
    batchId?: true
    packageType?: true
    quantity?: true
    volumeTotal?: true
    lotNumber?: true
    performedBy?: true
    notes?: true
    performedAt?: true
    _all?: true
  }

  export type PackagingRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackagingRun to aggregate.
     */
    where?: PackagingRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackagingRuns to fetch.
     */
    orderBy?: PackagingRunOrderByWithRelationInput | PackagingRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackagingRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackagingRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackagingRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PackagingRuns
    **/
    _count?: true | PackagingRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackagingRunAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackagingRunSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackagingRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackagingRunMaxAggregateInputType
  }

  export type GetPackagingRunAggregateType<T extends PackagingRunAggregateArgs> = {
        [P in keyof T & keyof AggregatePackagingRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackagingRun[P]>
      : GetScalarType<T[P], AggregatePackagingRun[P]>
  }




  export type PackagingRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackagingRunWhereInput
    orderBy?: PackagingRunOrderByWithAggregationInput | PackagingRunOrderByWithAggregationInput[]
    by: PackagingRunScalarFieldEnum[] | PackagingRunScalarFieldEnum
    having?: PackagingRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackagingRunCountAggregateInputType | true
    _avg?: PackagingRunAvgAggregateInputType
    _sum?: PackagingRunSumAggregateInputType
    _min?: PackagingRunMinAggregateInputType
    _max?: PackagingRunMaxAggregateInputType
  }

  export type PackagingRunGroupByOutputType = {
    id: string
    tenantId: string
    batchId: string
    packageType: $Enums.PackageType
    quantity: number
    volumeTotal: Decimal
    lotNumber: string | null
    performedBy: string
    notes: string | null
    performedAt: Date
    _count: PackagingRunCountAggregateOutputType | null
    _avg: PackagingRunAvgAggregateOutputType | null
    _sum: PackagingRunSumAggregateOutputType | null
    _min: PackagingRunMinAggregateOutputType | null
    _max: PackagingRunMaxAggregateOutputType | null
  }

  type GetPackagingRunGroupByPayload<T extends PackagingRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackagingRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackagingRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackagingRunGroupByOutputType[P]>
            : GetScalarType<T[P], PackagingRunGroupByOutputType[P]>
        }
      >
    >


  export type PackagingRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    batchId?: boolean
    packageType?: boolean
    quantity?: boolean
    volumeTotal?: boolean
    lotNumber?: boolean
    performedBy?: boolean
    notes?: boolean
    performedAt?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packagingRun"]>

  export type PackagingRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    batchId?: boolean
    packageType?: boolean
    quantity?: boolean
    volumeTotal?: boolean
    lotNumber?: boolean
    performedBy?: boolean
    notes?: boolean
    performedAt?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packagingRun"]>

  export type PackagingRunSelectScalar = {
    id?: boolean
    tenantId?: boolean
    batchId?: boolean
    packageType?: boolean
    quantity?: boolean
    volumeTotal?: boolean
    lotNumber?: boolean
    performedBy?: boolean
    notes?: boolean
    performedAt?: boolean
  }

  export type PackagingRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }
  export type PackagingRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
  }

  export type $PackagingRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PackagingRun"
    objects: {
      batch: Prisma.$BatchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      batchId: string
      packageType: $Enums.PackageType
      quantity: number
      volumeTotal: Prisma.Decimal
      lotNumber: string | null
      performedBy: string
      notes: string | null
      performedAt: Date
    }, ExtArgs["result"]["packagingRun"]>
    composites: {}
  }

  type PackagingRunGetPayload<S extends boolean | null | undefined | PackagingRunDefaultArgs> = $Result.GetResult<Prisma.$PackagingRunPayload, S>

  type PackagingRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PackagingRunFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PackagingRunCountAggregateInputType | true
    }

  export interface PackagingRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PackagingRun'], meta: { name: 'PackagingRun' } }
    /**
     * Find zero or one PackagingRun that matches the filter.
     * @param {PackagingRunFindUniqueArgs} args - Arguments to find a PackagingRun
     * @example
     * // Get one PackagingRun
     * const packagingRun = await prisma.packagingRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackagingRunFindUniqueArgs>(args: SelectSubset<T, PackagingRunFindUniqueArgs<ExtArgs>>): Prisma__PackagingRunClient<$Result.GetResult<Prisma.$PackagingRunPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PackagingRun that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PackagingRunFindUniqueOrThrowArgs} args - Arguments to find a PackagingRun
     * @example
     * // Get one PackagingRun
     * const packagingRun = await prisma.packagingRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackagingRunFindUniqueOrThrowArgs>(args: SelectSubset<T, PackagingRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackagingRunClient<$Result.GetResult<Prisma.$PackagingRunPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PackagingRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagingRunFindFirstArgs} args - Arguments to find a PackagingRun
     * @example
     * // Get one PackagingRun
     * const packagingRun = await prisma.packagingRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackagingRunFindFirstArgs>(args?: SelectSubset<T, PackagingRunFindFirstArgs<ExtArgs>>): Prisma__PackagingRunClient<$Result.GetResult<Prisma.$PackagingRunPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PackagingRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagingRunFindFirstOrThrowArgs} args - Arguments to find a PackagingRun
     * @example
     * // Get one PackagingRun
     * const packagingRun = await prisma.packagingRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackagingRunFindFirstOrThrowArgs>(args?: SelectSubset<T, PackagingRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackagingRunClient<$Result.GetResult<Prisma.$PackagingRunPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PackagingRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagingRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PackagingRuns
     * const packagingRuns = await prisma.packagingRun.findMany()
     * 
     * // Get first 10 PackagingRuns
     * const packagingRuns = await prisma.packagingRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packagingRunWithIdOnly = await prisma.packagingRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackagingRunFindManyArgs>(args?: SelectSubset<T, PackagingRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagingRunPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PackagingRun.
     * @param {PackagingRunCreateArgs} args - Arguments to create a PackagingRun.
     * @example
     * // Create one PackagingRun
     * const PackagingRun = await prisma.packagingRun.create({
     *   data: {
     *     // ... data to create a PackagingRun
     *   }
     * })
     * 
     */
    create<T extends PackagingRunCreateArgs>(args: SelectSubset<T, PackagingRunCreateArgs<ExtArgs>>): Prisma__PackagingRunClient<$Result.GetResult<Prisma.$PackagingRunPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PackagingRuns.
     * @param {PackagingRunCreateManyArgs} args - Arguments to create many PackagingRuns.
     * @example
     * // Create many PackagingRuns
     * const packagingRun = await prisma.packagingRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackagingRunCreateManyArgs>(args?: SelectSubset<T, PackagingRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PackagingRuns and returns the data saved in the database.
     * @param {PackagingRunCreateManyAndReturnArgs} args - Arguments to create many PackagingRuns.
     * @example
     * // Create many PackagingRuns
     * const packagingRun = await prisma.packagingRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PackagingRuns and only return the `id`
     * const packagingRunWithIdOnly = await prisma.packagingRun.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PackagingRunCreateManyAndReturnArgs>(args?: SelectSubset<T, PackagingRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagingRunPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PackagingRun.
     * @param {PackagingRunDeleteArgs} args - Arguments to delete one PackagingRun.
     * @example
     * // Delete one PackagingRun
     * const PackagingRun = await prisma.packagingRun.delete({
     *   where: {
     *     // ... filter to delete one PackagingRun
     *   }
     * })
     * 
     */
    delete<T extends PackagingRunDeleteArgs>(args: SelectSubset<T, PackagingRunDeleteArgs<ExtArgs>>): Prisma__PackagingRunClient<$Result.GetResult<Prisma.$PackagingRunPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PackagingRun.
     * @param {PackagingRunUpdateArgs} args - Arguments to update one PackagingRun.
     * @example
     * // Update one PackagingRun
     * const packagingRun = await prisma.packagingRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackagingRunUpdateArgs>(args: SelectSubset<T, PackagingRunUpdateArgs<ExtArgs>>): Prisma__PackagingRunClient<$Result.GetResult<Prisma.$PackagingRunPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PackagingRuns.
     * @param {PackagingRunDeleteManyArgs} args - Arguments to filter PackagingRuns to delete.
     * @example
     * // Delete a few PackagingRuns
     * const { count } = await prisma.packagingRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackagingRunDeleteManyArgs>(args?: SelectSubset<T, PackagingRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackagingRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagingRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PackagingRuns
     * const packagingRun = await prisma.packagingRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackagingRunUpdateManyArgs>(args: SelectSubset<T, PackagingRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PackagingRun.
     * @param {PackagingRunUpsertArgs} args - Arguments to update or create a PackagingRun.
     * @example
     * // Update or create a PackagingRun
     * const packagingRun = await prisma.packagingRun.upsert({
     *   create: {
     *     // ... data to create a PackagingRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PackagingRun we want to update
     *   }
     * })
     */
    upsert<T extends PackagingRunUpsertArgs>(args: SelectSubset<T, PackagingRunUpsertArgs<ExtArgs>>): Prisma__PackagingRunClient<$Result.GetResult<Prisma.$PackagingRunPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PackagingRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagingRunCountArgs} args - Arguments to filter PackagingRuns to count.
     * @example
     * // Count the number of PackagingRuns
     * const count = await prisma.packagingRun.count({
     *   where: {
     *     // ... the filter for the PackagingRuns we want to count
     *   }
     * })
    **/
    count<T extends PackagingRunCountArgs>(
      args?: Subset<T, PackagingRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackagingRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PackagingRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagingRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackagingRunAggregateArgs>(args: Subset<T, PackagingRunAggregateArgs>): Prisma.PrismaPromise<GetPackagingRunAggregateType<T>>

    /**
     * Group by PackagingRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagingRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackagingRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackagingRunGroupByArgs['orderBy'] }
        : { orderBy?: PackagingRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackagingRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackagingRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PackagingRun model
   */
  readonly fields: PackagingRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PackagingRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackagingRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batch<T extends BatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BatchDefaultArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PackagingRun model
   */ 
  interface PackagingRunFieldRefs {
    readonly id: FieldRef<"PackagingRun", 'String'>
    readonly tenantId: FieldRef<"PackagingRun", 'String'>
    readonly batchId: FieldRef<"PackagingRun", 'String'>
    readonly packageType: FieldRef<"PackagingRun", 'PackageType'>
    readonly quantity: FieldRef<"PackagingRun", 'Int'>
    readonly volumeTotal: FieldRef<"PackagingRun", 'Decimal'>
    readonly lotNumber: FieldRef<"PackagingRun", 'String'>
    readonly performedBy: FieldRef<"PackagingRun", 'String'>
    readonly notes: FieldRef<"PackagingRun", 'String'>
    readonly performedAt: FieldRef<"PackagingRun", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PackagingRun findUnique
   */
  export type PackagingRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagingRun
     */
    select?: PackagingRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagingRunInclude<ExtArgs> | null
    /**
     * Filter, which PackagingRun to fetch.
     */
    where: PackagingRunWhereUniqueInput
  }

  /**
   * PackagingRun findUniqueOrThrow
   */
  export type PackagingRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagingRun
     */
    select?: PackagingRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagingRunInclude<ExtArgs> | null
    /**
     * Filter, which PackagingRun to fetch.
     */
    where: PackagingRunWhereUniqueInput
  }

  /**
   * PackagingRun findFirst
   */
  export type PackagingRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagingRun
     */
    select?: PackagingRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagingRunInclude<ExtArgs> | null
    /**
     * Filter, which PackagingRun to fetch.
     */
    where?: PackagingRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackagingRuns to fetch.
     */
    orderBy?: PackagingRunOrderByWithRelationInput | PackagingRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackagingRuns.
     */
    cursor?: PackagingRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackagingRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackagingRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackagingRuns.
     */
    distinct?: PackagingRunScalarFieldEnum | PackagingRunScalarFieldEnum[]
  }

  /**
   * PackagingRun findFirstOrThrow
   */
  export type PackagingRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagingRun
     */
    select?: PackagingRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagingRunInclude<ExtArgs> | null
    /**
     * Filter, which PackagingRun to fetch.
     */
    where?: PackagingRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackagingRuns to fetch.
     */
    orderBy?: PackagingRunOrderByWithRelationInput | PackagingRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackagingRuns.
     */
    cursor?: PackagingRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackagingRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackagingRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackagingRuns.
     */
    distinct?: PackagingRunScalarFieldEnum | PackagingRunScalarFieldEnum[]
  }

  /**
   * PackagingRun findMany
   */
  export type PackagingRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagingRun
     */
    select?: PackagingRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagingRunInclude<ExtArgs> | null
    /**
     * Filter, which PackagingRuns to fetch.
     */
    where?: PackagingRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackagingRuns to fetch.
     */
    orderBy?: PackagingRunOrderByWithRelationInput | PackagingRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PackagingRuns.
     */
    cursor?: PackagingRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackagingRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackagingRuns.
     */
    skip?: number
    distinct?: PackagingRunScalarFieldEnum | PackagingRunScalarFieldEnum[]
  }

  /**
   * PackagingRun create
   */
  export type PackagingRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagingRun
     */
    select?: PackagingRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagingRunInclude<ExtArgs> | null
    /**
     * The data needed to create a PackagingRun.
     */
    data: XOR<PackagingRunCreateInput, PackagingRunUncheckedCreateInput>
  }

  /**
   * PackagingRun createMany
   */
  export type PackagingRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PackagingRuns.
     */
    data: PackagingRunCreateManyInput | PackagingRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PackagingRun createManyAndReturn
   */
  export type PackagingRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagingRun
     */
    select?: PackagingRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PackagingRuns.
     */
    data: PackagingRunCreateManyInput | PackagingRunCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagingRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PackagingRun update
   */
  export type PackagingRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagingRun
     */
    select?: PackagingRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagingRunInclude<ExtArgs> | null
    /**
     * The data needed to update a PackagingRun.
     */
    data: XOR<PackagingRunUpdateInput, PackagingRunUncheckedUpdateInput>
    /**
     * Choose, which PackagingRun to update.
     */
    where: PackagingRunWhereUniqueInput
  }

  /**
   * PackagingRun updateMany
   */
  export type PackagingRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PackagingRuns.
     */
    data: XOR<PackagingRunUpdateManyMutationInput, PackagingRunUncheckedUpdateManyInput>
    /**
     * Filter which PackagingRuns to update
     */
    where?: PackagingRunWhereInput
  }

  /**
   * PackagingRun upsert
   */
  export type PackagingRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagingRun
     */
    select?: PackagingRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagingRunInclude<ExtArgs> | null
    /**
     * The filter to search for the PackagingRun to update in case it exists.
     */
    where: PackagingRunWhereUniqueInput
    /**
     * In case the PackagingRun found by the `where` argument doesn't exist, create a new PackagingRun with this data.
     */
    create: XOR<PackagingRunCreateInput, PackagingRunUncheckedCreateInput>
    /**
     * In case the PackagingRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackagingRunUpdateInput, PackagingRunUncheckedUpdateInput>
  }

  /**
   * PackagingRun delete
   */
  export type PackagingRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagingRun
     */
    select?: PackagingRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagingRunInclude<ExtArgs> | null
    /**
     * Filter which PackagingRun to delete.
     */
    where: PackagingRunWhereUniqueInput
  }

  /**
   * PackagingRun deleteMany
   */
  export type PackagingRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackagingRuns to delete
     */
    where?: PackagingRunWhereInput
  }

  /**
   * PackagingRun without action
   */
  export type PackagingRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagingRun
     */
    select?: PackagingRunSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackagingRunInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    kegReturnDays: number | null
  }

  export type CustomerSumAggregateOutputType = {
    kegReturnDays: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    type: $Enums.CustomerType | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    taxId: string | null
    kegReturnDays: number | null
    kegDepositRequired: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    type: $Enums.CustomerType | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    taxId: string | null
    kegReturnDays: number | null
    kegDepositRequired: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    type: number
    email: number
    phone: number
    address: number
    city: number
    taxId: number
    kegReturnDays: number
    kegDepositRequired: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    kegReturnDays?: true
  }

  export type CustomerSumAggregateInputType = {
    kegReturnDays?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    type?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    taxId?: true
    kegReturnDays?: true
    kegDepositRequired?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    type?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    taxId?: true
    kegReturnDays?: true
    kegDepositRequired?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    type?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    taxId?: true
    kegReturnDays?: true
    kegDepositRequired?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    type: $Enums.CustomerType
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    taxId: string | null
    kegReturnDays: number
    kegDepositRequired: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    type?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    taxId?: boolean
    kegReturnDays?: boolean
    kegDepositRequired?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoices?: boolean | Customer$invoicesArgs<ExtArgs>
    Keg?: boolean | Customer$KegArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    transactions?: boolean | Customer$transactionsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    type?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    taxId?: boolean
    kegReturnDays?: boolean
    kegDepositRequired?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    type?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    taxId?: boolean
    kegReturnDays?: boolean
    kegDepositRequired?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoices?: boolean | Customer$invoicesArgs<ExtArgs>
    Keg?: boolean | Customer$KegArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    transactions?: boolean | Customer$transactionsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      Keg: Prisma.$KegPayload<ExtArgs>[]
      orders: Prisma.$SalesOrderPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      type: $Enums.CustomerType
      email: string | null
      phone: string | null
      address: string | null
      city: string | null
      taxId: string | null
      kegReturnDays: number
      kegDepositRequired: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoices<T extends Customer$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    Keg<T extends Customer$KegArgs<ExtArgs> = {}>(args?: Subset<T, Customer$KegArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KegPayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends Customer$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */ 
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly tenantId: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly type: FieldRef<"Customer", 'CustomerType'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly city: FieldRef<"Customer", 'String'>
    readonly taxId: FieldRef<"Customer", 'String'>
    readonly kegReturnDays: FieldRef<"Customer", 'Int'>
    readonly kegDepositRequired: FieldRef<"Customer", 'Boolean'>
    readonly isActive: FieldRef<"Customer", 'Boolean'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer.invoices
   */
  export type Customer$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Customer.Keg
   */
  export type Customer$KegArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keg
     */
    select?: KegSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegInclude<ExtArgs> | null
    where?: KegWhereInput
    orderBy?: KegOrderByWithRelationInput | KegOrderByWithRelationInput[]
    cursor?: KegWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KegScalarFieldEnum | KegScalarFieldEnum[]
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    where?: SalesOrderWhereInput
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    cursor?: SalesOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * Customer.transactions
   */
  export type Customer$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    category: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    taxId: string | null
    bankAccount: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    category: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    taxId: string | null
    bankAccount: string | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    category: number
    email: number
    phone: number
    address: number
    city: number
    taxId: number
    bankAccount: number
    notes: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    category?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    taxId?: true
    bankAccount?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    category?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    taxId?: true
    bankAccount?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    category?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    taxId?: true
    bankAccount?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    category: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    taxId: string | null
    bankAccount: string | null
    notes: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    category?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    taxId?: boolean
    bankAccount?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expenses?: boolean | Supplier$expensesArgs<ExtArgs>
    invoices?: boolean | Supplier$invoicesArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    transactions?: boolean | Supplier$transactionsArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    category?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    taxId?: boolean
    bankAccount?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    category?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    taxId?: boolean
    bankAccount?: boolean
    notes?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | Supplier$expensesArgs<ExtArgs>
    invoices?: boolean | Supplier$invoicesArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    transactions?: boolean | Supplier$transactionsArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      category: string | null
      email: string | null
      phone: string | null
      address: string | null
      city: string | null
      taxId: string | null
      bankAccount: string | null
      notes: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    expenses<T extends Supplier$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Supplier$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends Supplier$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */ 
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'String'>
    readonly tenantId: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly category: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly phone: FieldRef<"Supplier", 'String'>
    readonly address: FieldRef<"Supplier", 'String'>
    readonly city: FieldRef<"Supplier", 'String'>
    readonly taxId: FieldRef<"Supplier", 'String'>
    readonly bankAccount: FieldRef<"Supplier", 'String'>
    readonly notes: FieldRef<"Supplier", 'String'>
    readonly isActive: FieldRef<"Supplier", 'Boolean'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier.expenses
   */
  export type Supplier$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Supplier.invoices
   */
  export type Supplier$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Supplier.transactions
   */
  export type Supplier$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model SalesOrder
   */

  export type AggregateSalesOrder = {
    _count: SalesOrderCountAggregateOutputType | null
    _avg: SalesOrderAvgAggregateOutputType | null
    _sum: SalesOrderSumAggregateOutputType | null
    _min: SalesOrderMinAggregateOutputType | null
    _max: SalesOrderMaxAggregateOutputType | null
  }

  export type SalesOrderAvgAggregateOutputType = {
    totalAmount: Decimal | null
    paidAmount: Decimal | null
  }

  export type SalesOrderSumAggregateOutputType = {
    totalAmount: Decimal | null
    paidAmount: Decimal | null
  }

  export type SalesOrderMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    orderNumber: string | null
    customerId: string | null
    status: $Enums.OrderStatus | null
    paymentStatus: $Enums.PaymentStatus | null
    totalAmount: Decimal | null
    paidAmount: Decimal | null
    notes: string | null
    orderedAt: Date | null
    shippedAt: Date | null
    deliveredAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
  }

  export type SalesOrderMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    orderNumber: string | null
    customerId: string | null
    status: $Enums.OrderStatus | null
    paymentStatus: $Enums.PaymentStatus | null
    totalAmount: Decimal | null
    paidAmount: Decimal | null
    notes: string | null
    orderedAt: Date | null
    shippedAt: Date | null
    deliveredAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
  }

  export type SalesOrderCountAggregateOutputType = {
    id: number
    tenantId: number
    orderNumber: number
    customerId: number
    status: number
    paymentStatus: number
    totalAmount: number
    paidAmount: number
    notes: number
    orderedAt: number
    shippedAt: number
    deliveredAt: number
    createdBy: number
    updatedAt: number
    _all: number
  }


  export type SalesOrderAvgAggregateInputType = {
    totalAmount?: true
    paidAmount?: true
  }

  export type SalesOrderSumAggregateInputType = {
    totalAmount?: true
    paidAmount?: true
  }

  export type SalesOrderMinAggregateInputType = {
    id?: true
    tenantId?: true
    orderNumber?: true
    customerId?: true
    status?: true
    paymentStatus?: true
    totalAmount?: true
    paidAmount?: true
    notes?: true
    orderedAt?: true
    shippedAt?: true
    deliveredAt?: true
    createdBy?: true
    updatedAt?: true
  }

  export type SalesOrderMaxAggregateInputType = {
    id?: true
    tenantId?: true
    orderNumber?: true
    customerId?: true
    status?: true
    paymentStatus?: true
    totalAmount?: true
    paidAmount?: true
    notes?: true
    orderedAt?: true
    shippedAt?: true
    deliveredAt?: true
    createdBy?: true
    updatedAt?: true
  }

  export type SalesOrderCountAggregateInputType = {
    id?: true
    tenantId?: true
    orderNumber?: true
    customerId?: true
    status?: true
    paymentStatus?: true
    totalAmount?: true
    paidAmount?: true
    notes?: true
    orderedAt?: true
    shippedAt?: true
    deliveredAt?: true
    createdBy?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesOrder to aggregate.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesOrders
    **/
    _count?: true | SalesOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesOrderMaxAggregateInputType
  }

  export type GetSalesOrderAggregateType<T extends SalesOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesOrder[P]>
      : GetScalarType<T[P], AggregateSalesOrder[P]>
  }




  export type SalesOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderWhereInput
    orderBy?: SalesOrderOrderByWithAggregationInput | SalesOrderOrderByWithAggregationInput[]
    by: SalesOrderScalarFieldEnum[] | SalesOrderScalarFieldEnum
    having?: SalesOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesOrderCountAggregateInputType | true
    _avg?: SalesOrderAvgAggregateInputType
    _sum?: SalesOrderSumAggregateInputType
    _min?: SalesOrderMinAggregateInputType
    _max?: SalesOrderMaxAggregateInputType
  }

  export type SalesOrderGroupByOutputType = {
    id: string
    tenantId: string
    orderNumber: string
    customerId: string
    status: $Enums.OrderStatus
    paymentStatus: $Enums.PaymentStatus
    totalAmount: Decimal
    paidAmount: Decimal
    notes: string | null
    orderedAt: Date
    shippedAt: Date | null
    deliveredAt: Date | null
    createdBy: string
    updatedAt: Date
    _count: SalesOrderCountAggregateOutputType | null
    _avg: SalesOrderAvgAggregateOutputType | null
    _sum: SalesOrderSumAggregateOutputType | null
    _min: SalesOrderMinAggregateOutputType | null
    _max: SalesOrderMaxAggregateOutputType | null
  }

  type GetSalesOrderGroupByPayload<T extends SalesOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesOrderGroupByOutputType[P]>
            : GetScalarType<T[P], SalesOrderGroupByOutputType[P]>
        }
      >
    >


  export type SalesOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    orderNumber?: boolean
    customerId?: boolean
    status?: boolean
    paymentStatus?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    notes?: boolean
    orderedAt?: boolean
    shippedAt?: boolean
    deliveredAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    invoice?: boolean | SalesOrder$invoiceArgs<ExtArgs>
    items?: boolean | SalesOrder$itemsArgs<ExtArgs>
    payments?: boolean | SalesOrder$paymentsArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    transactions?: boolean | SalesOrder$transactionsArgs<ExtArgs>
    _count?: boolean | SalesOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesOrder"]>

  export type SalesOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    orderNumber?: boolean
    customerId?: boolean
    status?: boolean
    paymentStatus?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    notes?: boolean
    orderedAt?: boolean
    shippedAt?: boolean
    deliveredAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesOrder"]>

  export type SalesOrderSelectScalar = {
    id?: boolean
    tenantId?: boolean
    orderNumber?: boolean
    customerId?: boolean
    status?: boolean
    paymentStatus?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    notes?: boolean
    orderedAt?: boolean
    shippedAt?: boolean
    deliveredAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
  }

  export type SalesOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | SalesOrder$invoiceArgs<ExtArgs>
    items?: boolean | SalesOrder$itemsArgs<ExtArgs>
    payments?: boolean | SalesOrder$paymentsArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    transactions?: boolean | SalesOrder$transactionsArgs<ExtArgs>
    _count?: boolean | SalesOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalesOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $SalesOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesOrder"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      customer: Prisma.$CustomerPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      orderNumber: string
      customerId: string
      status: $Enums.OrderStatus
      paymentStatus: $Enums.PaymentStatus
      totalAmount: Prisma.Decimal
      paidAmount: Prisma.Decimal
      notes: string | null
      orderedAt: Date
      shippedAt: Date | null
      deliveredAt: Date | null
      createdBy: string
      updatedAt: Date
    }, ExtArgs["result"]["salesOrder"]>
    composites: {}
  }

  type SalesOrderGetPayload<S extends boolean | null | undefined | SalesOrderDefaultArgs> = $Result.GetResult<Prisma.$SalesOrderPayload, S>

  type SalesOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SalesOrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalesOrderCountAggregateInputType | true
    }

  export interface SalesOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesOrder'], meta: { name: 'SalesOrder' } }
    /**
     * Find zero or one SalesOrder that matches the filter.
     * @param {SalesOrderFindUniqueArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesOrderFindUniqueArgs>(args: SelectSubset<T, SalesOrderFindUniqueArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SalesOrder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SalesOrderFindUniqueOrThrowArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SalesOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderFindFirstArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesOrderFindFirstArgs>(args?: SelectSubset<T, SalesOrderFindFirstArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SalesOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderFindFirstOrThrowArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SalesOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesOrders
     * const salesOrders = await prisma.salesOrder.findMany()
     * 
     * // Get first 10 SalesOrders
     * const salesOrders = await prisma.salesOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesOrderWithIdOnly = await prisma.salesOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesOrderFindManyArgs>(args?: SelectSubset<T, SalesOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SalesOrder.
     * @param {SalesOrderCreateArgs} args - Arguments to create a SalesOrder.
     * @example
     * // Create one SalesOrder
     * const SalesOrder = await prisma.salesOrder.create({
     *   data: {
     *     // ... data to create a SalesOrder
     *   }
     * })
     * 
     */
    create<T extends SalesOrderCreateArgs>(args: SelectSubset<T, SalesOrderCreateArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SalesOrders.
     * @param {SalesOrderCreateManyArgs} args - Arguments to create many SalesOrders.
     * @example
     * // Create many SalesOrders
     * const salesOrder = await prisma.salesOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesOrderCreateManyArgs>(args?: SelectSubset<T, SalesOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesOrders and returns the data saved in the database.
     * @param {SalesOrderCreateManyAndReturnArgs} args - Arguments to create many SalesOrders.
     * @example
     * // Create many SalesOrders
     * const salesOrder = await prisma.salesOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesOrders and only return the `id`
     * const salesOrderWithIdOnly = await prisma.salesOrder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SalesOrder.
     * @param {SalesOrderDeleteArgs} args - Arguments to delete one SalesOrder.
     * @example
     * // Delete one SalesOrder
     * const SalesOrder = await prisma.salesOrder.delete({
     *   where: {
     *     // ... filter to delete one SalesOrder
     *   }
     * })
     * 
     */
    delete<T extends SalesOrderDeleteArgs>(args: SelectSubset<T, SalesOrderDeleteArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SalesOrder.
     * @param {SalesOrderUpdateArgs} args - Arguments to update one SalesOrder.
     * @example
     * // Update one SalesOrder
     * const salesOrder = await prisma.salesOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesOrderUpdateArgs>(args: SelectSubset<T, SalesOrderUpdateArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SalesOrders.
     * @param {SalesOrderDeleteManyArgs} args - Arguments to filter SalesOrders to delete.
     * @example
     * // Delete a few SalesOrders
     * const { count } = await prisma.salesOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesOrderDeleteManyArgs>(args?: SelectSubset<T, SalesOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesOrders
     * const salesOrder = await prisma.salesOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesOrderUpdateManyArgs>(args: SelectSubset<T, SalesOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalesOrder.
     * @param {SalesOrderUpsertArgs} args - Arguments to update or create a SalesOrder.
     * @example
     * // Update or create a SalesOrder
     * const salesOrder = await prisma.salesOrder.upsert({
     *   create: {
     *     // ... data to create a SalesOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesOrder we want to update
     *   }
     * })
     */
    upsert<T extends SalesOrderUpsertArgs>(args: SelectSubset<T, SalesOrderUpsertArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SalesOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderCountArgs} args - Arguments to filter SalesOrders to count.
     * @example
     * // Count the number of SalesOrders
     * const count = await prisma.salesOrder.count({
     *   where: {
     *     // ... the filter for the SalesOrders we want to count
     *   }
     * })
    **/
    count<T extends SalesOrderCountArgs>(
      args?: Subset<T, SalesOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesOrderAggregateArgs>(args: Subset<T, SalesOrderAggregateArgs>): Prisma.PrismaPromise<GetSalesOrderAggregateType<T>>

    /**
     * Group by SalesOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesOrderGroupByArgs['orderBy'] }
        : { orderBy?: SalesOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesOrder model
   */
  readonly fields: SalesOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends SalesOrder$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrder$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    items<T extends SalesOrder$itemsArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrder$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends SalesOrder$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrder$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends SalesOrder$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrder$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesOrder model
   */ 
  interface SalesOrderFieldRefs {
    readonly id: FieldRef<"SalesOrder", 'String'>
    readonly tenantId: FieldRef<"SalesOrder", 'String'>
    readonly orderNumber: FieldRef<"SalesOrder", 'String'>
    readonly customerId: FieldRef<"SalesOrder", 'String'>
    readonly status: FieldRef<"SalesOrder", 'OrderStatus'>
    readonly paymentStatus: FieldRef<"SalesOrder", 'PaymentStatus'>
    readonly totalAmount: FieldRef<"SalesOrder", 'Decimal'>
    readonly paidAmount: FieldRef<"SalesOrder", 'Decimal'>
    readonly notes: FieldRef<"SalesOrder", 'String'>
    readonly orderedAt: FieldRef<"SalesOrder", 'DateTime'>
    readonly shippedAt: FieldRef<"SalesOrder", 'DateTime'>
    readonly deliveredAt: FieldRef<"SalesOrder", 'DateTime'>
    readonly createdBy: FieldRef<"SalesOrder", 'String'>
    readonly updatedAt: FieldRef<"SalesOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesOrder findUnique
   */
  export type SalesOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where: SalesOrderWhereUniqueInput
  }

  /**
   * SalesOrder findUniqueOrThrow
   */
  export type SalesOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where: SalesOrderWhereUniqueInput
  }

  /**
   * SalesOrder findFirst
   */
  export type SalesOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesOrders.
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesOrders.
     */
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * SalesOrder findFirstOrThrow
   */
  export type SalesOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesOrders.
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesOrders.
     */
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * SalesOrder findMany
   */
  export type SalesOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrders to fetch.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesOrders.
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * SalesOrder create
   */
  export type SalesOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesOrder.
     */
    data: XOR<SalesOrderCreateInput, SalesOrderUncheckedCreateInput>
  }

  /**
   * SalesOrder createMany
   */
  export type SalesOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesOrders.
     */
    data: SalesOrderCreateManyInput | SalesOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesOrder createManyAndReturn
   */
  export type SalesOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SalesOrders.
     */
    data: SalesOrderCreateManyInput | SalesOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesOrder update
   */
  export type SalesOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesOrder.
     */
    data: XOR<SalesOrderUpdateInput, SalesOrderUncheckedUpdateInput>
    /**
     * Choose, which SalesOrder to update.
     */
    where: SalesOrderWhereUniqueInput
  }

  /**
   * SalesOrder updateMany
   */
  export type SalesOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesOrders.
     */
    data: XOR<SalesOrderUpdateManyMutationInput, SalesOrderUncheckedUpdateManyInput>
    /**
     * Filter which SalesOrders to update
     */
    where?: SalesOrderWhereInput
  }

  /**
   * SalesOrder upsert
   */
  export type SalesOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesOrder to update in case it exists.
     */
    where: SalesOrderWhereUniqueInput
    /**
     * In case the SalesOrder found by the `where` argument doesn't exist, create a new SalesOrder with this data.
     */
    create: XOR<SalesOrderCreateInput, SalesOrderUncheckedCreateInput>
    /**
     * In case the SalesOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesOrderUpdateInput, SalesOrderUncheckedUpdateInput>
  }

  /**
   * SalesOrder delete
   */
  export type SalesOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter which SalesOrder to delete.
     */
    where: SalesOrderWhereUniqueInput
  }

  /**
   * SalesOrder deleteMany
   */
  export type SalesOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesOrders to delete
     */
    where?: SalesOrderWhereInput
  }

  /**
   * SalesOrder.invoice
   */
  export type SalesOrder$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * SalesOrder.items
   */
  export type SalesOrder$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * SalesOrder.payments
   */
  export type SalesOrder$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * SalesOrder.transactions
   */
  export type SalesOrder$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * SalesOrder without action
   */
  export type SalesOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    productName: string | null
    packageType: $Enums.PackageType | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    batchId: string | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    productName: string | null
    packageType: $Enums.PackageType | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
    batchId: string | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productName: number
    packageType: number
    quantity: number
    unitPrice: number
    totalPrice: number
    batchId: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productName?: true
    packageType?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    batchId?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productName?: true
    packageType?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    batchId?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productName?: true
    packageType?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    batchId?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    productName: string
    packageType: $Enums.PackageType
    quantity: number
    unitPrice: Decimal
    totalPrice: Decimal
    batchId: string | null
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productName?: boolean
    packageType?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    batchId?: boolean
    order?: boolean | SalesOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productName?: boolean
    packageType?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    batchId?: boolean
    order?: boolean | SalesOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productName?: boolean
    packageType?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    batchId?: boolean
  }

  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SalesOrderDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SalesOrderDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$SalesOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      productName: string
      packageType: $Enums.PackageType
      quantity: number
      unitPrice: Prisma.Decimal
      totalPrice: Prisma.Decimal
      batchId: string | null
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends SalesOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrderDefaultArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */ 
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly productName: FieldRef<"OrderItem", 'String'>
    readonly packageType: FieldRef<"OrderItem", 'PackageType'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly unitPrice: FieldRef<"OrderItem", 'Decimal'>
    readonly totalPrice: FieldRef<"OrderItem", 'Decimal'>
    readonly batchId: FieldRef<"OrderItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: $Enums.TransactionType | null
    date: Date | null
    amount: Decimal | null
    incomeCategory: $Enums.IncomeCategory | null
    expenseCategory: $Enums.ExpenseCategory | null
    description: string | null
    customerId: string | null
    supplierId: string | null
    orderId: string | null
    invoiceId: string | null
    expenseId: string | null
    paymentId: string | null
    paymentMethod: $Enums.PaymentMethod | null
    reference: string | null
    notes: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    type: $Enums.TransactionType | null
    date: Date | null
    amount: Decimal | null
    incomeCategory: $Enums.IncomeCategory | null
    expenseCategory: $Enums.ExpenseCategory | null
    description: string | null
    customerId: string | null
    supplierId: string | null
    orderId: string | null
    invoiceId: string | null
    expenseId: string | null
    paymentId: string | null
    paymentMethod: $Enums.PaymentMethod | null
    reference: string | null
    notes: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    tenantId: number
    type: number
    date: number
    amount: number
    incomeCategory: number
    expenseCategory: number
    description: number
    customerId: number
    supplierId: number
    orderId: number
    invoiceId: number
    expenseId: number
    paymentId: number
    paymentMethod: number
    reference: number
    notes: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    date?: true
    amount?: true
    incomeCategory?: true
    expenseCategory?: true
    description?: true
    customerId?: true
    supplierId?: true
    orderId?: true
    invoiceId?: true
    expenseId?: true
    paymentId?: true
    paymentMethod?: true
    reference?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    date?: true
    amount?: true
    incomeCategory?: true
    expenseCategory?: true
    description?: true
    customerId?: true
    supplierId?: true
    orderId?: true
    invoiceId?: true
    expenseId?: true
    paymentId?: true
    paymentMethod?: true
    reference?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    tenantId?: true
    type?: true
    date?: true
    amount?: true
    incomeCategory?: true
    expenseCategory?: true
    description?: true
    customerId?: true
    supplierId?: true
    orderId?: true
    invoiceId?: true
    expenseId?: true
    paymentId?: true
    paymentMethod?: true
    reference?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    tenantId: string
    type: $Enums.TransactionType
    date: Date
    amount: Decimal
    incomeCategory: $Enums.IncomeCategory | null
    expenseCategory: $Enums.ExpenseCategory | null
    description: string | null
    customerId: string | null
    supplierId: string | null
    orderId: string | null
    invoiceId: string | null
    expenseId: string | null
    paymentId: string | null
    paymentMethod: $Enums.PaymentMethod | null
    reference: string | null
    notes: string | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    date?: boolean
    amount?: boolean
    incomeCategory?: boolean
    expenseCategory?: boolean
    description?: boolean
    customerId?: boolean
    supplierId?: boolean
    orderId?: boolean
    invoiceId?: boolean
    expenseId?: boolean
    paymentId?: boolean
    paymentMethod?: boolean
    reference?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    expense?: boolean | Transaction$expenseArgs<ExtArgs>
    invoice?: boolean | Transaction$invoiceArgs<ExtArgs>
    order?: boolean | Transaction$orderArgs<ExtArgs>
    supplier?: boolean | Transaction$supplierArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    type?: boolean
    date?: boolean
    amount?: boolean
    incomeCategory?: boolean
    expenseCategory?: boolean
    description?: boolean
    customerId?: boolean
    supplierId?: boolean
    orderId?: boolean
    invoiceId?: boolean
    expenseId?: boolean
    paymentId?: boolean
    paymentMethod?: boolean
    reference?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    expense?: boolean | Transaction$expenseArgs<ExtArgs>
    invoice?: boolean | Transaction$invoiceArgs<ExtArgs>
    order?: boolean | Transaction$orderArgs<ExtArgs>
    supplier?: boolean | Transaction$supplierArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    tenantId?: boolean
    type?: boolean
    date?: boolean
    amount?: boolean
    incomeCategory?: boolean
    expenseCategory?: boolean
    description?: boolean
    customerId?: boolean
    supplierId?: boolean
    orderId?: boolean
    invoiceId?: boolean
    expenseId?: boolean
    paymentId?: boolean
    paymentMethod?: boolean
    reference?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    expense?: boolean | Transaction$expenseArgs<ExtArgs>
    invoice?: boolean | Transaction$invoiceArgs<ExtArgs>
    order?: boolean | Transaction$orderArgs<ExtArgs>
    supplier?: boolean | Transaction$supplierArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Transaction$customerArgs<ExtArgs>
    expense?: boolean | Transaction$expenseArgs<ExtArgs>
    invoice?: boolean | Transaction$invoiceArgs<ExtArgs>
    order?: boolean | Transaction$orderArgs<ExtArgs>
    supplier?: boolean | Transaction$supplierArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      expense: Prisma.$ExpensePayload<ExtArgs> | null
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      order: Prisma.$SalesOrderPayload<ExtArgs> | null
      supplier: Prisma.$SupplierPayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      type: $Enums.TransactionType
      date: Date
      amount: Prisma.Decimal
      incomeCategory: $Enums.IncomeCategory | null
      expenseCategory: $Enums.ExpenseCategory | null
      description: string | null
      customerId: string | null
      supplierId: string | null
      orderId: string | null
      invoiceId: string | null
      expenseId: string | null
      paymentId: string | null
      paymentMethod: $Enums.PaymentMethod | null
      reference: string | null
      notes: string | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends Transaction$customerArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    expense<T extends Transaction$expenseArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$expenseArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    invoice<T extends Transaction$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    order<T extends Transaction$orderArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$orderArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    supplier<T extends Transaction$supplierArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$supplierArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly tenantId: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly date: FieldRef<"Transaction", 'DateTime'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly incomeCategory: FieldRef<"Transaction", 'IncomeCategory'>
    readonly expenseCategory: FieldRef<"Transaction", 'ExpenseCategory'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly customerId: FieldRef<"Transaction", 'String'>
    readonly supplierId: FieldRef<"Transaction", 'String'>
    readonly orderId: FieldRef<"Transaction", 'String'>
    readonly invoiceId: FieldRef<"Transaction", 'String'>
    readonly expenseId: FieldRef<"Transaction", 'String'>
    readonly paymentId: FieldRef<"Transaction", 'String'>
    readonly paymentMethod: FieldRef<"Transaction", 'PaymentMethod'>
    readonly reference: FieldRef<"Transaction", 'String'>
    readonly notes: FieldRef<"Transaction", 'String'>
    readonly createdBy: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction.customer
   */
  export type Transaction$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Transaction.expense
   */
  export type Transaction$expenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
  }

  /**
   * Transaction.invoice
   */
  export type Transaction$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Transaction.order
   */
  export type Transaction$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    where?: SalesOrderWhereInput
  }

  /**
   * Transaction.supplier
   */
  export type Transaction$supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    paidAmount: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    paidAmount: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    invoiceNumber: string | null
    type: $Enums.InvoiceType | null
    status: $Enums.InvoiceStatus | null
    issueDate: Date | null
    dueDate: Date | null
    paidAt: Date | null
    customerId: string | null
    supplierId: string | null
    orderId: string | null
    subtotal: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    paidAmount: Decimal | null
    notes: string | null
    terms: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    invoiceNumber: string | null
    type: $Enums.InvoiceType | null
    status: $Enums.InvoiceStatus | null
    issueDate: Date | null
    dueDate: Date | null
    paidAt: Date | null
    customerId: string | null
    supplierId: string | null
    orderId: string | null
    subtotal: Decimal | null
    discount: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    paidAmount: Decimal | null
    notes: string | null
    terms: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    tenantId: number
    invoiceNumber: number
    type: number
    status: number
    issueDate: number
    dueDate: number
    paidAt: number
    customerId: number
    supplierId: number
    orderId: number
    subtotal: number
    discount: number
    tax: number
    total: number
    paidAmount: number
    notes: number
    terms: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    paidAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    paidAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceNumber?: true
    type?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidAt?: true
    customerId?: true
    supplierId?: true
    orderId?: true
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    paidAmount?: true
    notes?: true
    terms?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceNumber?: true
    type?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidAt?: true
    customerId?: true
    supplierId?: true
    orderId?: true
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    paidAmount?: true
    notes?: true
    terms?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceNumber?: true
    type?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidAt?: true
    customerId?: true
    supplierId?: true
    orderId?: true
    subtotal?: true
    discount?: true
    tax?: true
    total?: true
    paidAmount?: true
    notes?: true
    terms?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    tenantId: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status: $Enums.InvoiceStatus
    issueDate: Date
    dueDate: Date | null
    paidAt: Date | null
    customerId: string | null
    supplierId: string | null
    orderId: string | null
    subtotal: Decimal
    discount: Decimal
    tax: Decimal
    total: Decimal
    paidAmount: Decimal
    notes: string | null
    terms: string | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceNumber?: boolean
    type?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidAt?: boolean
    customerId?: boolean
    supplierId?: boolean
    orderId?: boolean
    subtotal?: boolean
    discount?: boolean
    tax?: boolean
    total?: boolean
    paidAmount?: boolean
    notes?: boolean
    terms?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | Invoice$customerArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
    supplier?: boolean | Invoice$supplierArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    transactions?: boolean | Invoice$transactionsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceNumber?: boolean
    type?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidAt?: boolean
    customerId?: boolean
    supplierId?: boolean
    orderId?: boolean
    subtotal?: boolean
    discount?: boolean
    tax?: boolean
    total?: boolean
    paidAmount?: boolean
    notes?: boolean
    terms?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | Invoice$customerArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
    supplier?: boolean | Invoice$supplierArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    tenantId?: boolean
    invoiceNumber?: boolean
    type?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidAt?: boolean
    customerId?: boolean
    supplierId?: boolean
    orderId?: boolean
    subtotal?: boolean
    discount?: boolean
    tax?: boolean
    total?: boolean
    paidAmount?: boolean
    notes?: boolean
    terms?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Invoice$customerArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
    supplier?: boolean | Invoice$supplierArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    transactions?: boolean | Invoice$transactionsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Invoice$customerArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
    supplier?: boolean | Invoice$supplierArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      order: Prisma.$SalesOrderPayload<ExtArgs> | null
      supplier: Prisma.$SupplierPayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs>
      items: Prisma.$InvoiceItemPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      invoiceNumber: string
      type: $Enums.InvoiceType
      status: $Enums.InvoiceStatus
      issueDate: Date
      dueDate: Date | null
      paidAt: Date | null
      customerId: string | null
      supplierId: string | null
      orderId: string | null
      subtotal: Prisma.Decimal
      discount: Prisma.Decimal
      tax: Prisma.Decimal
      total: Prisma.Decimal
      paidAmount: Prisma.Decimal
      notes: string | null
      terms: string | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends Invoice$customerArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    order<T extends Invoice$orderArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$orderArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    supplier<T extends Invoice$supplierArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$supplierArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends Invoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends Invoice$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly tenantId: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly type: FieldRef<"Invoice", 'InvoiceType'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly issueDate: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly paidAt: FieldRef<"Invoice", 'DateTime'>
    readonly customerId: FieldRef<"Invoice", 'String'>
    readonly supplierId: FieldRef<"Invoice", 'String'>
    readonly orderId: FieldRef<"Invoice", 'String'>
    readonly subtotal: FieldRef<"Invoice", 'Decimal'>
    readonly discount: FieldRef<"Invoice", 'Decimal'>
    readonly tax: FieldRef<"Invoice", 'Decimal'>
    readonly total: FieldRef<"Invoice", 'Decimal'>
    readonly paidAmount: FieldRef<"Invoice", 'Decimal'>
    readonly notes: FieldRef<"Invoice", 'String'>
    readonly terms: FieldRef<"Invoice", 'String'>
    readonly createdBy: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.customer
   */
  export type Invoice$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Invoice.order
   */
  export type Invoice$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    where?: SalesOrderWhereInput
  }

  /**
   * Invoice.supplier
   */
  export type Invoice$supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
  }

  /**
   * Invoice.items
   */
  export type Invoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice.transactions
   */
  export type Invoice$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    quantity: Decimal | null
    unitPrice: Decimal | null
    total: Decimal | null
    sortOrder: number | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    quantity: Decimal | null
    unitPrice: Decimal | null
    total: Decimal | null
    sortOrder: number | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    quantity: Decimal | null
    unit: string | null
    unitPrice: Decimal | null
    total: Decimal | null
    productName: string | null
    packageType: $Enums.PackageType | null
    batchId: string | null
    sortOrder: number | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    quantity: Decimal | null
    unit: string | null
    unitPrice: Decimal | null
    total: Decimal | null
    productName: string | null
    packageType: $Enums.PackageType | null
    batchId: string | null
    sortOrder: number | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    description: number
    quantity: number
    unit: number
    unitPrice: number
    total: number
    productName: number
    packageType: number
    batchId: number
    sortOrder: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
    sortOrder?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
    sortOrder?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unit?: true
    unitPrice?: true
    total?: true
    productName?: true
    packageType?: true
    batchId?: true
    sortOrder?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unit?: true
    unitPrice?: true
    total?: true
    productName?: true
    packageType?: true
    batchId?: true
    sortOrder?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unit?: true
    unitPrice?: true
    total?: true
    productName?: true
    packageType?: true
    batchId?: true
    sortOrder?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: string
    invoiceId: string
    description: string
    quantity: Decimal
    unit: string | null
    unitPrice: Decimal
    total: Decimal
    productName: string | null
    packageType: $Enums.PackageType | null
    batchId: string | null
    sortOrder: number
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unit?: boolean
    unitPrice?: boolean
    total?: boolean
    productName?: boolean
    packageType?: boolean
    batchId?: boolean
    sortOrder?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unit?: boolean
    unitPrice?: boolean
    total?: boolean
    productName?: boolean
    packageType?: boolean
    batchId?: boolean
    sortOrder?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unit?: boolean
    unitPrice?: boolean
    total?: boolean
    productName?: boolean
    packageType?: boolean
    batchId?: boolean
    sortOrder?: boolean
  }

  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      description: string
      quantity: Prisma.Decimal
      unit: string | null
      unitPrice: Prisma.Decimal
      total: Prisma.Decimal
      productName: string | null
      packageType: $Enums.PackageType | null
      batchId: string | null
      sortOrder: number
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */ 
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'String'>
    readonly invoiceId: FieldRef<"InvoiceItem", 'String'>
    readonly description: FieldRef<"InvoiceItem", 'String'>
    readonly quantity: FieldRef<"InvoiceItem", 'Decimal'>
    readonly unit: FieldRef<"InvoiceItem", 'String'>
    readonly unitPrice: FieldRef<"InvoiceItem", 'Decimal'>
    readonly total: FieldRef<"InvoiceItem", 'Decimal'>
    readonly productName: FieldRef<"InvoiceItem", 'String'>
    readonly packageType: FieldRef<"InvoiceItem", 'PackageType'>
    readonly batchId: FieldRef<"InvoiceItem", 'String'>
    readonly sortOrder: FieldRef<"InvoiceItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    invoiceId: string | null
    orderId: string | null
    amount: Decimal | null
    method: $Enums.PaymentMethod | null
    date: Date | null
    reference: string | null
    notes: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    invoiceId: string | null
    orderId: string | null
    amount: Decimal | null
    method: $Enums.PaymentMethod | null
    date: Date | null
    reference: string | null
    notes: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    tenantId: number
    invoiceId: number
    orderId: number
    amount: number
    method: number
    date: number
    reference: number
    notes: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceId?: true
    orderId?: true
    amount?: true
    method?: true
    date?: true
    reference?: true
    notes?: true
    createdBy?: true
    createdAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceId?: true
    orderId?: true
    amount?: true
    method?: true
    date?: true
    reference?: true
    notes?: true
    createdBy?: true
    createdAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceId?: true
    orderId?: true
    amount?: true
    method?: true
    date?: true
    reference?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    tenantId: string
    invoiceId: string | null
    orderId: string | null
    amount: Decimal
    method: $Enums.PaymentMethod
    date: Date
    reference: string | null
    notes: string | null
    createdBy: string
    createdAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceId?: boolean
    orderId?: boolean
    amount?: boolean
    method?: boolean
    date?: boolean
    reference?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    order?: boolean | Payment$orderArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceId?: boolean
    orderId?: boolean
    amount?: boolean
    method?: boolean
    date?: boolean
    reference?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    order?: boolean | Payment$orderArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    invoiceId?: boolean
    orderId?: boolean
    amount?: boolean
    method?: boolean
    date?: boolean
    reference?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    order?: boolean | Payment$orderArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    order?: boolean | Payment$orderArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      order: Prisma.$SalesOrderPayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      invoiceId: string | null
      orderId: string | null
      amount: Prisma.Decimal
      method: $Enums.PaymentMethod
      date: Date
      reference: string | null
      notes: string | null
      createdBy: string
      createdAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends Payment$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Payment$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    order<T extends Payment$orderArgs<ExtArgs> = {}>(args?: Subset<T, Payment$orderArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly tenantId: FieldRef<"Payment", 'String'>
    readonly invoiceId: FieldRef<"Payment", 'String'>
    readonly orderId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly method: FieldRef<"Payment", 'PaymentMethod'>
    readonly date: FieldRef<"Payment", 'DateTime'>
    readonly reference: FieldRef<"Payment", 'String'>
    readonly notes: FieldRef<"Payment", 'String'>
    readonly createdBy: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment.invoice
   */
  export type Payment$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Payment.order
   */
  export type Payment$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    where?: SalesOrderWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type ExpenseSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    category: $Enums.ExpenseCategory | null
    supplierId: string | null
    amount: Decimal | null
    date: Date | null
    description: string | null
    invoiceNumber: string | null
    invoiceId: string | null
    isPaid: boolean | null
    paidAt: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    receiptUrl: string | null
    notes: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    category: $Enums.ExpenseCategory | null
    supplierId: string | null
    amount: Decimal | null
    date: Date | null
    description: string | null
    invoiceNumber: string | null
    invoiceId: string | null
    isPaid: boolean | null
    paidAt: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    receiptUrl: string | null
    notes: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    tenantId: number
    category: number
    supplierId: number
    amount: number
    date: number
    description: number
    invoiceNumber: number
    invoiceId: number
    isPaid: number
    paidAt: number
    paymentMethod: number
    receiptUrl: number
    notes: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    amount?: true
  }

  export type ExpenseSumAggregateInputType = {
    amount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    tenantId?: true
    category?: true
    supplierId?: true
    amount?: true
    date?: true
    description?: true
    invoiceNumber?: true
    invoiceId?: true
    isPaid?: true
    paidAt?: true
    paymentMethod?: true
    receiptUrl?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    tenantId?: true
    category?: true
    supplierId?: true
    amount?: true
    date?: true
    description?: true
    invoiceNumber?: true
    invoiceId?: true
    isPaid?: true
    paidAt?: true
    paymentMethod?: true
    receiptUrl?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    tenantId?: true
    category?: true
    supplierId?: true
    amount?: true
    date?: true
    description?: true
    invoiceNumber?: true
    invoiceId?: true
    isPaid?: true
    paidAt?: true
    paymentMethod?: true
    receiptUrl?: true
    notes?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: string
    tenantId: string
    category: $Enums.ExpenseCategory
    supplierId: string | null
    amount: Decimal
    date: Date
    description: string | null
    invoiceNumber: string | null
    invoiceId: string | null
    isPaid: boolean
    paidAt: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    receiptUrl: string | null
    notes: string | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    category?: boolean
    supplierId?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    invoiceNumber?: boolean
    invoiceId?: boolean
    isPaid?: boolean
    paidAt?: boolean
    paymentMethod?: boolean
    receiptUrl?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | Expense$supplierArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    transactions?: boolean | Expense$transactionsArgs<ExtArgs>
    _count?: boolean | ExpenseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    category?: boolean
    supplierId?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    invoiceNumber?: boolean
    invoiceId?: boolean
    isPaid?: boolean
    paidAt?: boolean
    paymentMethod?: boolean
    receiptUrl?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | Expense$supplierArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    tenantId?: boolean
    category?: boolean
    supplierId?: boolean
    amount?: boolean
    date?: boolean
    description?: boolean
    invoiceNumber?: boolean
    invoiceId?: boolean
    isPaid?: boolean
    paidAt?: boolean
    paymentMethod?: boolean
    receiptUrl?: boolean
    notes?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | Expense$supplierArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    transactions?: boolean | Expense$transactionsArgs<ExtArgs>
    _count?: boolean | ExpenseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | Expense$supplierArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      supplier: Prisma.$SupplierPayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs>
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      category: $Enums.ExpenseCategory
      supplierId: string | null
      amount: Prisma.Decimal
      date: Date
      description: string | null
      invoiceNumber: string | null
      invoiceId: string | null
      isPaid: boolean
      paidAt: Date | null
      paymentMethod: $Enums.PaymentMethod | null
      receiptUrl: string | null
      notes: string | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplier<T extends Expense$supplierArgs<ExtArgs> = {}>(args?: Subset<T, Expense$supplierArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends Expense$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Expense$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */ 
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'String'>
    readonly tenantId: FieldRef<"Expense", 'String'>
    readonly category: FieldRef<"Expense", 'ExpenseCategory'>
    readonly supplierId: FieldRef<"Expense", 'String'>
    readonly amount: FieldRef<"Expense", 'Decimal'>
    readonly date: FieldRef<"Expense", 'DateTime'>
    readonly description: FieldRef<"Expense", 'String'>
    readonly invoiceNumber: FieldRef<"Expense", 'String'>
    readonly invoiceId: FieldRef<"Expense", 'String'>
    readonly isPaid: FieldRef<"Expense", 'Boolean'>
    readonly paidAt: FieldRef<"Expense", 'DateTime'>
    readonly paymentMethod: FieldRef<"Expense", 'PaymentMethod'>
    readonly receiptUrl: FieldRef<"Expense", 'String'>
    readonly notes: FieldRef<"Expense", 'String'>
    readonly createdBy: FieldRef<"Expense", 'String'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
    readonly updatedAt: FieldRef<"Expense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense.supplier
   */
  export type Expense$supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
  }

  /**
   * Expense.transactions
   */
  export type Expense$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Model Budget
   */

  export type AggregateBudget = {
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  export type BudgetAvgAggregateOutputType = {
    year: number | null
    month: number | null
    amount: Decimal | null
  }

  export type BudgetSumAggregateOutputType = {
    year: number | null
    month: number | null
    amount: Decimal | null
  }

  export type BudgetMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    category: $Enums.ExpenseCategory | null
    year: number | null
    month: number | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    category: $Enums.ExpenseCategory | null
    year: number | null
    month: number | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetCountAggregateOutputType = {
    id: number
    tenantId: number
    category: number
    year: number
    month: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BudgetAvgAggregateInputType = {
    year?: true
    month?: true
    amount?: true
  }

  export type BudgetSumAggregateInputType = {
    year?: true
    month?: true
    amount?: true
  }

  export type BudgetMinAggregateInputType = {
    id?: true
    tenantId?: true
    category?: true
    year?: true
    month?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetMaxAggregateInputType = {
    id?: true
    tenantId?: true
    category?: true
    year?: true
    month?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetCountAggregateInputType = {
    id?: true
    tenantId?: true
    category?: true
    year?: true
    month?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BudgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budget to aggregate.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Budgets
    **/
    _count?: true | BudgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetMaxAggregateInputType
  }

  export type GetBudgetAggregateType<T extends BudgetAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget[P]>
      : GetScalarType<T[P], AggregateBudget[P]>
  }




  export type BudgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithAggregationInput | BudgetOrderByWithAggregationInput[]
    by: BudgetScalarFieldEnum[] | BudgetScalarFieldEnum
    having?: BudgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetCountAggregateInputType | true
    _avg?: BudgetAvgAggregateInputType
    _sum?: BudgetSumAggregateInputType
    _min?: BudgetMinAggregateInputType
    _max?: BudgetMaxAggregateInputType
  }

  export type BudgetGroupByOutputType = {
    id: string
    tenantId: string
    category: $Enums.ExpenseCategory
    year: number
    month: number | null
    amount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  type GetBudgetGroupByPayload<T extends BudgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetGroupByOutputType[P]>
        }
      >
    >


  export type BudgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    category?: boolean
    year?: boolean
    month?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    category?: boolean
    year?: boolean
    month?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectScalar = {
    id?: boolean
    tenantId?: boolean
    category?: boolean
    year?: boolean
    month?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BudgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $BudgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Budget"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      category: $Enums.ExpenseCategory
      year: number
      month: number | null
      amount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["budget"]>
    composites: {}
  }

  type BudgetGetPayload<S extends boolean | null | undefined | BudgetDefaultArgs> = $Result.GetResult<Prisma.$BudgetPayload, S>

  type BudgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BudgetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BudgetCountAggregateInputType | true
    }

  export interface BudgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Budget'], meta: { name: 'Budget' } }
    /**
     * Find zero or one Budget that matches the filter.
     * @param {BudgetFindUniqueArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetFindUniqueArgs>(args: SelectSubset<T, BudgetFindUniqueArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Budget that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BudgetFindUniqueOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Budget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetFindFirstArgs>(args?: SelectSubset<T, BudgetFindFirstArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Budget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Budgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budgets
     * const budgets = await prisma.budget.findMany()
     * 
     * // Get first 10 Budgets
     * const budgets = await prisma.budget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetWithIdOnly = await prisma.budget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetFindManyArgs>(args?: SelectSubset<T, BudgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Budget.
     * @param {BudgetCreateArgs} args - Arguments to create a Budget.
     * @example
     * // Create one Budget
     * const Budget = await prisma.budget.create({
     *   data: {
     *     // ... data to create a Budget
     *   }
     * })
     * 
     */
    create<T extends BudgetCreateArgs>(args: SelectSubset<T, BudgetCreateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Budgets.
     * @param {BudgetCreateManyArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetCreateManyArgs>(args?: SelectSubset<T, BudgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Budgets and returns the data saved in the database.
     * @param {BudgetCreateManyAndReturnArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Budget.
     * @param {BudgetDeleteArgs} args - Arguments to delete one Budget.
     * @example
     * // Delete one Budget
     * const Budget = await prisma.budget.delete({
     *   where: {
     *     // ... filter to delete one Budget
     *   }
     * })
     * 
     */
    delete<T extends BudgetDeleteArgs>(args: SelectSubset<T, BudgetDeleteArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Budget.
     * @param {BudgetUpdateArgs} args - Arguments to update one Budget.
     * @example
     * // Update one Budget
     * const budget = await prisma.budget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetUpdateArgs>(args: SelectSubset<T, BudgetUpdateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Budgets.
     * @param {BudgetDeleteManyArgs} args - Arguments to filter Budgets to delete.
     * @example
     * // Delete a few Budgets
     * const { count } = await prisma.budget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetDeleteManyArgs>(args?: SelectSubset<T, BudgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetUpdateManyArgs>(args: SelectSubset<T, BudgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Budget.
     * @param {BudgetUpsertArgs} args - Arguments to update or create a Budget.
     * @example
     * // Update or create a Budget
     * const budget = await prisma.budget.upsert({
     *   create: {
     *     // ... data to create a Budget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget we want to update
     *   }
     * })
     */
    upsert<T extends BudgetUpsertArgs>(args: SelectSubset<T, BudgetUpsertArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCountArgs} args - Arguments to filter Budgets to count.
     * @example
     * // Count the number of Budgets
     * const count = await prisma.budget.count({
     *   where: {
     *     // ... the filter for the Budgets we want to count
     *   }
     * })
    **/
    count<T extends BudgetCountArgs>(
      args?: Subset<T, BudgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetAggregateArgs>(args: Subset<T, BudgetAggregateArgs>): Prisma.PrismaPromise<GetBudgetAggregateType<T>>

    /**
     * Group by Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetGroupByArgs['orderBy'] }
        : { orderBy?: BudgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Budget model
   */
  readonly fields: BudgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Budget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Budget model
   */ 
  interface BudgetFieldRefs {
    readonly id: FieldRef<"Budget", 'String'>
    readonly tenantId: FieldRef<"Budget", 'String'>
    readonly category: FieldRef<"Budget", 'ExpenseCategory'>
    readonly year: FieldRef<"Budget", 'Int'>
    readonly month: FieldRef<"Budget", 'Int'>
    readonly amount: FieldRef<"Budget", 'Decimal'>
    readonly createdAt: FieldRef<"Budget", 'DateTime'>
    readonly updatedAt: FieldRef<"Budget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Budget findUnique
   */
  export type BudgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findUniqueOrThrow
   */
  export type BudgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findFirst
   */
  export type BudgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findFirstOrThrow
   */
  export type BudgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findMany
   */
  export type BudgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budgets to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget create
   */
  export type BudgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to create a Budget.
     */
    data: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
  }

  /**
   * Budget createMany
   */
  export type BudgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Budget createManyAndReturn
   */
  export type BudgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget update
   */
  export type BudgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to update a Budget.
     */
    data: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
    /**
     * Choose, which Budget to update.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget updateMany
   */
  export type BudgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
  }

  /**
   * Budget upsert
   */
  export type BudgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The filter to search for the Budget to update in case it exists.
     */
    where: BudgetWhereUniqueInput
    /**
     * In case the Budget found by the `where` argument doesn't exist, create a new Budget with this data.
     */
    create: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
    /**
     * In case the Budget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
  }

  /**
   * Budget delete
   */
  export type BudgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter which Budget to delete.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget deleteMany
   */
  export type BudgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budgets to delete
     */
    where?: BudgetWhereInput
  }

  /**
   * Budget without action
   */
  export type BudgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    correlationId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    correlationId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    action: number
    entityType: number
    entityId: number
    oldData: number
    newData: number
    metadata: number
    correlationId: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    correlationId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    correlationId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    oldData?: true
    newData?: true
    metadata?: true
    correlationId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    action: string
    entityType: string
    entityId: string
    oldData: JsonValue | null
    newData: JsonValue | null
    metadata: JsonValue | null
    correlationId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldData?: boolean
    newData?: boolean
    metadata?: boolean
    correlationId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldData?: boolean
    newData?: boolean
    metadata?: boolean
    correlationId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldData?: boolean
    newData?: boolean
    metadata?: boolean
    correlationId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      action: string
      entityType: string
      entityId: string
      oldData: Prisma.JsonValue | null
      newData: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      correlationId: string | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly tenantId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly oldData: FieldRef<"AuditLog", 'Json'>
    readonly newData: FieldRef<"AuditLog", 'Json'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly correlationId: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
  }


  /**
   * Model BlendingConfig
   */

  export type AggregateBlendingConfig = {
    _count: BlendingConfigCountAggregateOutputType | null
    _avg: BlendingConfigAvgAggregateOutputType | null
    _sum: BlendingConfigSumAggregateOutputType | null
    _min: BlendingConfigMinAggregateOutputType | null
    _max: BlendingConfigMaxAggregateOutputType | null
  }

  export type BlendingConfigAvgAggregateOutputType = {
    maxBlendSources: number | null
    maxAgeDifferenceHours: number | null
  }

  export type BlendingConfigSumAggregateOutputType = {
    maxBlendSources: number | null
    maxAgeDifferenceHours: number | null
  }

  export type BlendingConfigMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    requireRecipeMatch: boolean | null
    requireYeastMatch: boolean | null
    requirePhaseMatch: boolean | null
    requireStyleMatch: boolean | null
    maxBlendSources: number | null
    allowOverCapacity: boolean | null
    maxAgeDifferenceHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlendingConfigMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    requireRecipeMatch: boolean | null
    requireYeastMatch: boolean | null
    requirePhaseMatch: boolean | null
    requireStyleMatch: boolean | null
    maxBlendSources: number | null
    allowOverCapacity: boolean | null
    maxAgeDifferenceHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlendingConfigCountAggregateOutputType = {
    id: number
    tenantId: number
    requireRecipeMatch: number
    requireYeastMatch: number
    requirePhaseMatch: number
    requireStyleMatch: number
    maxBlendSources: number
    allowOverCapacity: number
    maxAgeDifferenceHours: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlendingConfigAvgAggregateInputType = {
    maxBlendSources?: true
    maxAgeDifferenceHours?: true
  }

  export type BlendingConfigSumAggregateInputType = {
    maxBlendSources?: true
    maxAgeDifferenceHours?: true
  }

  export type BlendingConfigMinAggregateInputType = {
    id?: true
    tenantId?: true
    requireRecipeMatch?: true
    requireYeastMatch?: true
    requirePhaseMatch?: true
    requireStyleMatch?: true
    maxBlendSources?: true
    allowOverCapacity?: true
    maxAgeDifferenceHours?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlendingConfigMaxAggregateInputType = {
    id?: true
    tenantId?: true
    requireRecipeMatch?: true
    requireYeastMatch?: true
    requirePhaseMatch?: true
    requireStyleMatch?: true
    maxBlendSources?: true
    allowOverCapacity?: true
    maxAgeDifferenceHours?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlendingConfigCountAggregateInputType = {
    id?: true
    tenantId?: true
    requireRecipeMatch?: true
    requireYeastMatch?: true
    requirePhaseMatch?: true
    requireStyleMatch?: true
    maxBlendSources?: true
    allowOverCapacity?: true
    maxAgeDifferenceHours?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlendingConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlendingConfig to aggregate.
     */
    where?: BlendingConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlendingConfigs to fetch.
     */
    orderBy?: BlendingConfigOrderByWithRelationInput | BlendingConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlendingConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlendingConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlendingConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlendingConfigs
    **/
    _count?: true | BlendingConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlendingConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlendingConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlendingConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlendingConfigMaxAggregateInputType
  }

  export type GetBlendingConfigAggregateType<T extends BlendingConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateBlendingConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlendingConfig[P]>
      : GetScalarType<T[P], AggregateBlendingConfig[P]>
  }




  export type BlendingConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlendingConfigWhereInput
    orderBy?: BlendingConfigOrderByWithAggregationInput | BlendingConfigOrderByWithAggregationInput[]
    by: BlendingConfigScalarFieldEnum[] | BlendingConfigScalarFieldEnum
    having?: BlendingConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlendingConfigCountAggregateInputType | true
    _avg?: BlendingConfigAvgAggregateInputType
    _sum?: BlendingConfigSumAggregateInputType
    _min?: BlendingConfigMinAggregateInputType
    _max?: BlendingConfigMaxAggregateInputType
  }

  export type BlendingConfigGroupByOutputType = {
    id: string
    tenantId: string
    requireRecipeMatch: boolean
    requireYeastMatch: boolean
    requirePhaseMatch: boolean
    requireStyleMatch: boolean
    maxBlendSources: number
    allowOverCapacity: boolean
    maxAgeDifferenceHours: number
    createdAt: Date
    updatedAt: Date
    _count: BlendingConfigCountAggregateOutputType | null
    _avg: BlendingConfigAvgAggregateOutputType | null
    _sum: BlendingConfigSumAggregateOutputType | null
    _min: BlendingConfigMinAggregateOutputType | null
    _max: BlendingConfigMaxAggregateOutputType | null
  }

  type GetBlendingConfigGroupByPayload<T extends BlendingConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlendingConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlendingConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlendingConfigGroupByOutputType[P]>
            : GetScalarType<T[P], BlendingConfigGroupByOutputType[P]>
        }
      >
    >


  export type BlendingConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    requireRecipeMatch?: boolean
    requireYeastMatch?: boolean
    requirePhaseMatch?: boolean
    requireStyleMatch?: boolean
    maxBlendSources?: boolean
    allowOverCapacity?: boolean
    maxAgeDifferenceHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["blendingConfig"]>

  export type BlendingConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    requireRecipeMatch?: boolean
    requireYeastMatch?: boolean
    requirePhaseMatch?: boolean
    requireStyleMatch?: boolean
    maxBlendSources?: boolean
    allowOverCapacity?: boolean
    maxAgeDifferenceHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["blendingConfig"]>

  export type BlendingConfigSelectScalar = {
    id?: boolean
    tenantId?: boolean
    requireRecipeMatch?: boolean
    requireYeastMatch?: boolean
    requirePhaseMatch?: boolean
    requireStyleMatch?: boolean
    maxBlendSources?: boolean
    allowOverCapacity?: boolean
    maxAgeDifferenceHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $BlendingConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlendingConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      requireRecipeMatch: boolean
      requireYeastMatch: boolean
      requirePhaseMatch: boolean
      requireStyleMatch: boolean
      maxBlendSources: number
      allowOverCapacity: boolean
      maxAgeDifferenceHours: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blendingConfig"]>
    composites: {}
  }

  type BlendingConfigGetPayload<S extends boolean | null | undefined | BlendingConfigDefaultArgs> = $Result.GetResult<Prisma.$BlendingConfigPayload, S>

  type BlendingConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlendingConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlendingConfigCountAggregateInputType | true
    }

  export interface BlendingConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlendingConfig'], meta: { name: 'BlendingConfig' } }
    /**
     * Find zero or one BlendingConfig that matches the filter.
     * @param {BlendingConfigFindUniqueArgs} args - Arguments to find a BlendingConfig
     * @example
     * // Get one BlendingConfig
     * const blendingConfig = await prisma.blendingConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlendingConfigFindUniqueArgs>(args: SelectSubset<T, BlendingConfigFindUniqueArgs<ExtArgs>>): Prisma__BlendingConfigClient<$Result.GetResult<Prisma.$BlendingConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlendingConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlendingConfigFindUniqueOrThrowArgs} args - Arguments to find a BlendingConfig
     * @example
     * // Get one BlendingConfig
     * const blendingConfig = await prisma.blendingConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlendingConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, BlendingConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlendingConfigClient<$Result.GetResult<Prisma.$BlendingConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlendingConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlendingConfigFindFirstArgs} args - Arguments to find a BlendingConfig
     * @example
     * // Get one BlendingConfig
     * const blendingConfig = await prisma.blendingConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlendingConfigFindFirstArgs>(args?: SelectSubset<T, BlendingConfigFindFirstArgs<ExtArgs>>): Prisma__BlendingConfigClient<$Result.GetResult<Prisma.$BlendingConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlendingConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlendingConfigFindFirstOrThrowArgs} args - Arguments to find a BlendingConfig
     * @example
     * // Get one BlendingConfig
     * const blendingConfig = await prisma.blendingConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlendingConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, BlendingConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlendingConfigClient<$Result.GetResult<Prisma.$BlendingConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlendingConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlendingConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlendingConfigs
     * const blendingConfigs = await prisma.blendingConfig.findMany()
     * 
     * // Get first 10 BlendingConfigs
     * const blendingConfigs = await prisma.blendingConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blendingConfigWithIdOnly = await prisma.blendingConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlendingConfigFindManyArgs>(args?: SelectSubset<T, BlendingConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlendingConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlendingConfig.
     * @param {BlendingConfigCreateArgs} args - Arguments to create a BlendingConfig.
     * @example
     * // Create one BlendingConfig
     * const BlendingConfig = await prisma.blendingConfig.create({
     *   data: {
     *     // ... data to create a BlendingConfig
     *   }
     * })
     * 
     */
    create<T extends BlendingConfigCreateArgs>(args: SelectSubset<T, BlendingConfigCreateArgs<ExtArgs>>): Prisma__BlendingConfigClient<$Result.GetResult<Prisma.$BlendingConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlendingConfigs.
     * @param {BlendingConfigCreateManyArgs} args - Arguments to create many BlendingConfigs.
     * @example
     * // Create many BlendingConfigs
     * const blendingConfig = await prisma.blendingConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlendingConfigCreateManyArgs>(args?: SelectSubset<T, BlendingConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlendingConfigs and returns the data saved in the database.
     * @param {BlendingConfigCreateManyAndReturnArgs} args - Arguments to create many BlendingConfigs.
     * @example
     * // Create many BlendingConfigs
     * const blendingConfig = await prisma.blendingConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlendingConfigs and only return the `id`
     * const blendingConfigWithIdOnly = await prisma.blendingConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlendingConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, BlendingConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlendingConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlendingConfig.
     * @param {BlendingConfigDeleteArgs} args - Arguments to delete one BlendingConfig.
     * @example
     * // Delete one BlendingConfig
     * const BlendingConfig = await prisma.blendingConfig.delete({
     *   where: {
     *     // ... filter to delete one BlendingConfig
     *   }
     * })
     * 
     */
    delete<T extends BlendingConfigDeleteArgs>(args: SelectSubset<T, BlendingConfigDeleteArgs<ExtArgs>>): Prisma__BlendingConfigClient<$Result.GetResult<Prisma.$BlendingConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlendingConfig.
     * @param {BlendingConfigUpdateArgs} args - Arguments to update one BlendingConfig.
     * @example
     * // Update one BlendingConfig
     * const blendingConfig = await prisma.blendingConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlendingConfigUpdateArgs>(args: SelectSubset<T, BlendingConfigUpdateArgs<ExtArgs>>): Prisma__BlendingConfigClient<$Result.GetResult<Prisma.$BlendingConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlendingConfigs.
     * @param {BlendingConfigDeleteManyArgs} args - Arguments to filter BlendingConfigs to delete.
     * @example
     * // Delete a few BlendingConfigs
     * const { count } = await prisma.blendingConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlendingConfigDeleteManyArgs>(args?: SelectSubset<T, BlendingConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlendingConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlendingConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlendingConfigs
     * const blendingConfig = await prisma.blendingConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlendingConfigUpdateManyArgs>(args: SelectSubset<T, BlendingConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlendingConfig.
     * @param {BlendingConfigUpsertArgs} args - Arguments to update or create a BlendingConfig.
     * @example
     * // Update or create a BlendingConfig
     * const blendingConfig = await prisma.blendingConfig.upsert({
     *   create: {
     *     // ... data to create a BlendingConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlendingConfig we want to update
     *   }
     * })
     */
    upsert<T extends BlendingConfigUpsertArgs>(args: SelectSubset<T, BlendingConfigUpsertArgs<ExtArgs>>): Prisma__BlendingConfigClient<$Result.GetResult<Prisma.$BlendingConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlendingConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlendingConfigCountArgs} args - Arguments to filter BlendingConfigs to count.
     * @example
     * // Count the number of BlendingConfigs
     * const count = await prisma.blendingConfig.count({
     *   where: {
     *     // ... the filter for the BlendingConfigs we want to count
     *   }
     * })
    **/
    count<T extends BlendingConfigCountArgs>(
      args?: Subset<T, BlendingConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlendingConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlendingConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlendingConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlendingConfigAggregateArgs>(args: Subset<T, BlendingConfigAggregateArgs>): Prisma.PrismaPromise<GetBlendingConfigAggregateType<T>>

    /**
     * Group by BlendingConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlendingConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlendingConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlendingConfigGroupByArgs['orderBy'] }
        : { orderBy?: BlendingConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlendingConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlendingConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlendingConfig model
   */
  readonly fields: BlendingConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlendingConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlendingConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlendingConfig model
   */ 
  interface BlendingConfigFieldRefs {
    readonly id: FieldRef<"BlendingConfig", 'String'>
    readonly tenantId: FieldRef<"BlendingConfig", 'String'>
    readonly requireRecipeMatch: FieldRef<"BlendingConfig", 'Boolean'>
    readonly requireYeastMatch: FieldRef<"BlendingConfig", 'Boolean'>
    readonly requirePhaseMatch: FieldRef<"BlendingConfig", 'Boolean'>
    readonly requireStyleMatch: FieldRef<"BlendingConfig", 'Boolean'>
    readonly maxBlendSources: FieldRef<"BlendingConfig", 'Int'>
    readonly allowOverCapacity: FieldRef<"BlendingConfig", 'Boolean'>
    readonly maxAgeDifferenceHours: FieldRef<"BlendingConfig", 'Int'>
    readonly createdAt: FieldRef<"BlendingConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"BlendingConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlendingConfig findUnique
   */
  export type BlendingConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlendingConfig
     */
    select?: BlendingConfigSelect<ExtArgs> | null
    /**
     * Filter, which BlendingConfig to fetch.
     */
    where: BlendingConfigWhereUniqueInput
  }

  /**
   * BlendingConfig findUniqueOrThrow
   */
  export type BlendingConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlendingConfig
     */
    select?: BlendingConfigSelect<ExtArgs> | null
    /**
     * Filter, which BlendingConfig to fetch.
     */
    where: BlendingConfigWhereUniqueInput
  }

  /**
   * BlendingConfig findFirst
   */
  export type BlendingConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlendingConfig
     */
    select?: BlendingConfigSelect<ExtArgs> | null
    /**
     * Filter, which BlendingConfig to fetch.
     */
    where?: BlendingConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlendingConfigs to fetch.
     */
    orderBy?: BlendingConfigOrderByWithRelationInput | BlendingConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlendingConfigs.
     */
    cursor?: BlendingConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlendingConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlendingConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlendingConfigs.
     */
    distinct?: BlendingConfigScalarFieldEnum | BlendingConfigScalarFieldEnum[]
  }

  /**
   * BlendingConfig findFirstOrThrow
   */
  export type BlendingConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlendingConfig
     */
    select?: BlendingConfigSelect<ExtArgs> | null
    /**
     * Filter, which BlendingConfig to fetch.
     */
    where?: BlendingConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlendingConfigs to fetch.
     */
    orderBy?: BlendingConfigOrderByWithRelationInput | BlendingConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlendingConfigs.
     */
    cursor?: BlendingConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlendingConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlendingConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlendingConfigs.
     */
    distinct?: BlendingConfigScalarFieldEnum | BlendingConfigScalarFieldEnum[]
  }

  /**
   * BlendingConfig findMany
   */
  export type BlendingConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlendingConfig
     */
    select?: BlendingConfigSelect<ExtArgs> | null
    /**
     * Filter, which BlendingConfigs to fetch.
     */
    where?: BlendingConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlendingConfigs to fetch.
     */
    orderBy?: BlendingConfigOrderByWithRelationInput | BlendingConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlendingConfigs.
     */
    cursor?: BlendingConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlendingConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlendingConfigs.
     */
    skip?: number
    distinct?: BlendingConfigScalarFieldEnum | BlendingConfigScalarFieldEnum[]
  }

  /**
   * BlendingConfig create
   */
  export type BlendingConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlendingConfig
     */
    select?: BlendingConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a BlendingConfig.
     */
    data: XOR<BlendingConfigCreateInput, BlendingConfigUncheckedCreateInput>
  }

  /**
   * BlendingConfig createMany
   */
  export type BlendingConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlendingConfigs.
     */
    data: BlendingConfigCreateManyInput | BlendingConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlendingConfig createManyAndReturn
   */
  export type BlendingConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlendingConfig
     */
    select?: BlendingConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlendingConfigs.
     */
    data: BlendingConfigCreateManyInput | BlendingConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlendingConfig update
   */
  export type BlendingConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlendingConfig
     */
    select?: BlendingConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a BlendingConfig.
     */
    data: XOR<BlendingConfigUpdateInput, BlendingConfigUncheckedUpdateInput>
    /**
     * Choose, which BlendingConfig to update.
     */
    where: BlendingConfigWhereUniqueInput
  }

  /**
   * BlendingConfig updateMany
   */
  export type BlendingConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlendingConfigs.
     */
    data: XOR<BlendingConfigUpdateManyMutationInput, BlendingConfigUncheckedUpdateManyInput>
    /**
     * Filter which BlendingConfigs to update
     */
    where?: BlendingConfigWhereInput
  }

  /**
   * BlendingConfig upsert
   */
  export type BlendingConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlendingConfig
     */
    select?: BlendingConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the BlendingConfig to update in case it exists.
     */
    where: BlendingConfigWhereUniqueInput
    /**
     * In case the BlendingConfig found by the `where` argument doesn't exist, create a new BlendingConfig with this data.
     */
    create: XOR<BlendingConfigCreateInput, BlendingConfigUncheckedCreateInput>
    /**
     * In case the BlendingConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlendingConfigUpdateInput, BlendingConfigUncheckedUpdateInput>
  }

  /**
   * BlendingConfig delete
   */
  export type BlendingConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlendingConfig
     */
    select?: BlendingConfigSelect<ExtArgs> | null
    /**
     * Filter which BlendingConfig to delete.
     */
    where: BlendingConfigWhereUniqueInput
  }

  /**
   * BlendingConfig deleteMany
   */
  export type BlendingConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlendingConfigs to delete
     */
    where?: BlendingConfigWhereInput
  }

  /**
   * BlendingConfig without action
   */
  export type BlendingConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlendingConfig
     */
    select?: BlendingConfigSelect<ExtArgs> | null
  }


  /**
   * Model CIPLog
   */

  export type AggregateCIPLog = {
    _count: CIPLogCountAggregateOutputType | null
    _avg: CIPLogAvgAggregateOutputType | null
    _sum: CIPLogSumAggregateOutputType | null
    _min: CIPLogMinAggregateOutputType | null
    _max: CIPLogMaxAggregateOutputType | null
  }

  export type CIPLogAvgAggregateOutputType = {
    duration: number | null
    temperature: number | null
    causticConcentration: number | null
  }

  export type CIPLogSumAggregateOutputType = {
    duration: number | null
    temperature: number | null
    causticConcentration: number | null
  }

  export type CIPLogMinAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    cipType: string | null
    date: Date | null
    duration: number | null
    temperature: number | null
    causticConcentration: number | null
    performedBy: string | null
    result: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type CIPLogMaxAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    cipType: string | null
    date: Date | null
    duration: number | null
    temperature: number | null
    causticConcentration: number | null
    performedBy: string | null
    result: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type CIPLogCountAggregateOutputType = {
    id: number
    equipmentId: number
    cipType: number
    date: number
    duration: number
    temperature: number
    causticConcentration: number
    performedBy: number
    result: number
    notes: number
    createdAt: number
    _all: number
  }


  export type CIPLogAvgAggregateInputType = {
    duration?: true
    temperature?: true
    causticConcentration?: true
  }

  export type CIPLogSumAggregateInputType = {
    duration?: true
    temperature?: true
    causticConcentration?: true
  }

  export type CIPLogMinAggregateInputType = {
    id?: true
    equipmentId?: true
    cipType?: true
    date?: true
    duration?: true
    temperature?: true
    causticConcentration?: true
    performedBy?: true
    result?: true
    notes?: true
    createdAt?: true
  }

  export type CIPLogMaxAggregateInputType = {
    id?: true
    equipmentId?: true
    cipType?: true
    date?: true
    duration?: true
    temperature?: true
    causticConcentration?: true
    performedBy?: true
    result?: true
    notes?: true
    createdAt?: true
  }

  export type CIPLogCountAggregateInputType = {
    id?: true
    equipmentId?: true
    cipType?: true
    date?: true
    duration?: true
    temperature?: true
    causticConcentration?: true
    performedBy?: true
    result?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type CIPLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CIPLog to aggregate.
     */
    where?: CIPLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CIPLogs to fetch.
     */
    orderBy?: CIPLogOrderByWithRelationInput | CIPLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CIPLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CIPLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CIPLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CIPLogs
    **/
    _count?: true | CIPLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CIPLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CIPLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CIPLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CIPLogMaxAggregateInputType
  }

  export type GetCIPLogAggregateType<T extends CIPLogAggregateArgs> = {
        [P in keyof T & keyof AggregateCIPLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCIPLog[P]>
      : GetScalarType<T[P], AggregateCIPLog[P]>
  }




  export type CIPLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CIPLogWhereInput
    orderBy?: CIPLogOrderByWithAggregationInput | CIPLogOrderByWithAggregationInput[]
    by: CIPLogScalarFieldEnum[] | CIPLogScalarFieldEnum
    having?: CIPLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CIPLogCountAggregateInputType | true
    _avg?: CIPLogAvgAggregateInputType
    _sum?: CIPLogSumAggregateInputType
    _min?: CIPLogMinAggregateInputType
    _max?: CIPLogMaxAggregateInputType
  }

  export type CIPLogGroupByOutputType = {
    id: string
    equipmentId: string
    cipType: string
    date: Date
    duration: number
    temperature: number | null
    causticConcentration: number | null
    performedBy: string
    result: string
    notes: string | null
    createdAt: Date
    _count: CIPLogCountAggregateOutputType | null
    _avg: CIPLogAvgAggregateOutputType | null
    _sum: CIPLogSumAggregateOutputType | null
    _min: CIPLogMinAggregateOutputType | null
    _max: CIPLogMaxAggregateOutputType | null
  }

  type GetCIPLogGroupByPayload<T extends CIPLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CIPLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CIPLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CIPLogGroupByOutputType[P]>
            : GetScalarType<T[P], CIPLogGroupByOutputType[P]>
        }
      >
    >


  export type CIPLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    cipType?: boolean
    date?: boolean
    duration?: boolean
    temperature?: boolean
    causticConcentration?: boolean
    performedBy?: boolean
    result?: boolean
    notes?: boolean
    createdAt?: boolean
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cIPLog"]>

  export type CIPLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    cipType?: boolean
    date?: boolean
    duration?: boolean
    temperature?: boolean
    causticConcentration?: boolean
    performedBy?: boolean
    result?: boolean
    notes?: boolean
    createdAt?: boolean
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cIPLog"]>

  export type CIPLogSelectScalar = {
    id?: boolean
    equipmentId?: boolean
    cipType?: boolean
    date?: boolean
    duration?: boolean
    temperature?: boolean
    causticConcentration?: boolean
    performedBy?: boolean
    result?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type CIPLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type CIPLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }

  export type $CIPLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CIPLog"
    objects: {
      Equipment: Prisma.$EquipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      equipmentId: string
      cipType: string
      date: Date
      duration: number
      temperature: number | null
      causticConcentration: number | null
      performedBy: string
      result: string
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["cIPLog"]>
    composites: {}
  }

  type CIPLogGetPayload<S extends boolean | null | undefined | CIPLogDefaultArgs> = $Result.GetResult<Prisma.$CIPLogPayload, S>

  type CIPLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CIPLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CIPLogCountAggregateInputType | true
    }

  export interface CIPLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CIPLog'], meta: { name: 'CIPLog' } }
    /**
     * Find zero or one CIPLog that matches the filter.
     * @param {CIPLogFindUniqueArgs} args - Arguments to find a CIPLog
     * @example
     * // Get one CIPLog
     * const cIPLog = await prisma.cIPLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CIPLogFindUniqueArgs>(args: SelectSubset<T, CIPLogFindUniqueArgs<ExtArgs>>): Prisma__CIPLogClient<$Result.GetResult<Prisma.$CIPLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CIPLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CIPLogFindUniqueOrThrowArgs} args - Arguments to find a CIPLog
     * @example
     * // Get one CIPLog
     * const cIPLog = await prisma.cIPLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CIPLogFindUniqueOrThrowArgs>(args: SelectSubset<T, CIPLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CIPLogClient<$Result.GetResult<Prisma.$CIPLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CIPLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CIPLogFindFirstArgs} args - Arguments to find a CIPLog
     * @example
     * // Get one CIPLog
     * const cIPLog = await prisma.cIPLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CIPLogFindFirstArgs>(args?: SelectSubset<T, CIPLogFindFirstArgs<ExtArgs>>): Prisma__CIPLogClient<$Result.GetResult<Prisma.$CIPLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CIPLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CIPLogFindFirstOrThrowArgs} args - Arguments to find a CIPLog
     * @example
     * // Get one CIPLog
     * const cIPLog = await prisma.cIPLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CIPLogFindFirstOrThrowArgs>(args?: SelectSubset<T, CIPLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CIPLogClient<$Result.GetResult<Prisma.$CIPLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CIPLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CIPLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CIPLogs
     * const cIPLogs = await prisma.cIPLog.findMany()
     * 
     * // Get first 10 CIPLogs
     * const cIPLogs = await prisma.cIPLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cIPLogWithIdOnly = await prisma.cIPLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CIPLogFindManyArgs>(args?: SelectSubset<T, CIPLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CIPLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CIPLog.
     * @param {CIPLogCreateArgs} args - Arguments to create a CIPLog.
     * @example
     * // Create one CIPLog
     * const CIPLog = await prisma.cIPLog.create({
     *   data: {
     *     // ... data to create a CIPLog
     *   }
     * })
     * 
     */
    create<T extends CIPLogCreateArgs>(args: SelectSubset<T, CIPLogCreateArgs<ExtArgs>>): Prisma__CIPLogClient<$Result.GetResult<Prisma.$CIPLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CIPLogs.
     * @param {CIPLogCreateManyArgs} args - Arguments to create many CIPLogs.
     * @example
     * // Create many CIPLogs
     * const cIPLog = await prisma.cIPLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CIPLogCreateManyArgs>(args?: SelectSubset<T, CIPLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CIPLogs and returns the data saved in the database.
     * @param {CIPLogCreateManyAndReturnArgs} args - Arguments to create many CIPLogs.
     * @example
     * // Create many CIPLogs
     * const cIPLog = await prisma.cIPLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CIPLogs and only return the `id`
     * const cIPLogWithIdOnly = await prisma.cIPLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CIPLogCreateManyAndReturnArgs>(args?: SelectSubset<T, CIPLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CIPLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CIPLog.
     * @param {CIPLogDeleteArgs} args - Arguments to delete one CIPLog.
     * @example
     * // Delete one CIPLog
     * const CIPLog = await prisma.cIPLog.delete({
     *   where: {
     *     // ... filter to delete one CIPLog
     *   }
     * })
     * 
     */
    delete<T extends CIPLogDeleteArgs>(args: SelectSubset<T, CIPLogDeleteArgs<ExtArgs>>): Prisma__CIPLogClient<$Result.GetResult<Prisma.$CIPLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CIPLog.
     * @param {CIPLogUpdateArgs} args - Arguments to update one CIPLog.
     * @example
     * // Update one CIPLog
     * const cIPLog = await prisma.cIPLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CIPLogUpdateArgs>(args: SelectSubset<T, CIPLogUpdateArgs<ExtArgs>>): Prisma__CIPLogClient<$Result.GetResult<Prisma.$CIPLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CIPLogs.
     * @param {CIPLogDeleteManyArgs} args - Arguments to filter CIPLogs to delete.
     * @example
     * // Delete a few CIPLogs
     * const { count } = await prisma.cIPLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CIPLogDeleteManyArgs>(args?: SelectSubset<T, CIPLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CIPLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CIPLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CIPLogs
     * const cIPLog = await prisma.cIPLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CIPLogUpdateManyArgs>(args: SelectSubset<T, CIPLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CIPLog.
     * @param {CIPLogUpsertArgs} args - Arguments to update or create a CIPLog.
     * @example
     * // Update or create a CIPLog
     * const cIPLog = await prisma.cIPLog.upsert({
     *   create: {
     *     // ... data to create a CIPLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CIPLog we want to update
     *   }
     * })
     */
    upsert<T extends CIPLogUpsertArgs>(args: SelectSubset<T, CIPLogUpsertArgs<ExtArgs>>): Prisma__CIPLogClient<$Result.GetResult<Prisma.$CIPLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CIPLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CIPLogCountArgs} args - Arguments to filter CIPLogs to count.
     * @example
     * // Count the number of CIPLogs
     * const count = await prisma.cIPLog.count({
     *   where: {
     *     // ... the filter for the CIPLogs we want to count
     *   }
     * })
    **/
    count<T extends CIPLogCountArgs>(
      args?: Subset<T, CIPLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CIPLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CIPLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CIPLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CIPLogAggregateArgs>(args: Subset<T, CIPLogAggregateArgs>): Prisma.PrismaPromise<GetCIPLogAggregateType<T>>

    /**
     * Group by CIPLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CIPLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CIPLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CIPLogGroupByArgs['orderBy'] }
        : { orderBy?: CIPLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CIPLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCIPLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CIPLog model
   */
  readonly fields: CIPLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CIPLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CIPLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Equipment<T extends EquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentDefaultArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CIPLog model
   */ 
  interface CIPLogFieldRefs {
    readonly id: FieldRef<"CIPLog", 'String'>
    readonly equipmentId: FieldRef<"CIPLog", 'String'>
    readonly cipType: FieldRef<"CIPLog", 'String'>
    readonly date: FieldRef<"CIPLog", 'DateTime'>
    readonly duration: FieldRef<"CIPLog", 'Int'>
    readonly temperature: FieldRef<"CIPLog", 'Float'>
    readonly causticConcentration: FieldRef<"CIPLog", 'Float'>
    readonly performedBy: FieldRef<"CIPLog", 'String'>
    readonly result: FieldRef<"CIPLog", 'String'>
    readonly notes: FieldRef<"CIPLog", 'String'>
    readonly createdAt: FieldRef<"CIPLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CIPLog findUnique
   */
  export type CIPLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CIPLog
     */
    select?: CIPLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CIPLogInclude<ExtArgs> | null
    /**
     * Filter, which CIPLog to fetch.
     */
    where: CIPLogWhereUniqueInput
  }

  /**
   * CIPLog findUniqueOrThrow
   */
  export type CIPLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CIPLog
     */
    select?: CIPLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CIPLogInclude<ExtArgs> | null
    /**
     * Filter, which CIPLog to fetch.
     */
    where: CIPLogWhereUniqueInput
  }

  /**
   * CIPLog findFirst
   */
  export type CIPLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CIPLog
     */
    select?: CIPLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CIPLogInclude<ExtArgs> | null
    /**
     * Filter, which CIPLog to fetch.
     */
    where?: CIPLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CIPLogs to fetch.
     */
    orderBy?: CIPLogOrderByWithRelationInput | CIPLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CIPLogs.
     */
    cursor?: CIPLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CIPLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CIPLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CIPLogs.
     */
    distinct?: CIPLogScalarFieldEnum | CIPLogScalarFieldEnum[]
  }

  /**
   * CIPLog findFirstOrThrow
   */
  export type CIPLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CIPLog
     */
    select?: CIPLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CIPLogInclude<ExtArgs> | null
    /**
     * Filter, which CIPLog to fetch.
     */
    where?: CIPLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CIPLogs to fetch.
     */
    orderBy?: CIPLogOrderByWithRelationInput | CIPLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CIPLogs.
     */
    cursor?: CIPLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CIPLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CIPLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CIPLogs.
     */
    distinct?: CIPLogScalarFieldEnum | CIPLogScalarFieldEnum[]
  }

  /**
   * CIPLog findMany
   */
  export type CIPLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CIPLog
     */
    select?: CIPLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CIPLogInclude<ExtArgs> | null
    /**
     * Filter, which CIPLogs to fetch.
     */
    where?: CIPLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CIPLogs to fetch.
     */
    orderBy?: CIPLogOrderByWithRelationInput | CIPLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CIPLogs.
     */
    cursor?: CIPLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CIPLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CIPLogs.
     */
    skip?: number
    distinct?: CIPLogScalarFieldEnum | CIPLogScalarFieldEnum[]
  }

  /**
   * CIPLog create
   */
  export type CIPLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CIPLog
     */
    select?: CIPLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CIPLogInclude<ExtArgs> | null
    /**
     * The data needed to create a CIPLog.
     */
    data: XOR<CIPLogCreateInput, CIPLogUncheckedCreateInput>
  }

  /**
   * CIPLog createMany
   */
  export type CIPLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CIPLogs.
     */
    data: CIPLogCreateManyInput | CIPLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CIPLog createManyAndReturn
   */
  export type CIPLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CIPLog
     */
    select?: CIPLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CIPLogs.
     */
    data: CIPLogCreateManyInput | CIPLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CIPLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CIPLog update
   */
  export type CIPLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CIPLog
     */
    select?: CIPLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CIPLogInclude<ExtArgs> | null
    /**
     * The data needed to update a CIPLog.
     */
    data: XOR<CIPLogUpdateInput, CIPLogUncheckedUpdateInput>
    /**
     * Choose, which CIPLog to update.
     */
    where: CIPLogWhereUniqueInput
  }

  /**
   * CIPLog updateMany
   */
  export type CIPLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CIPLogs.
     */
    data: XOR<CIPLogUpdateManyMutationInput, CIPLogUncheckedUpdateManyInput>
    /**
     * Filter which CIPLogs to update
     */
    where?: CIPLogWhereInput
  }

  /**
   * CIPLog upsert
   */
  export type CIPLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CIPLog
     */
    select?: CIPLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CIPLogInclude<ExtArgs> | null
    /**
     * The filter to search for the CIPLog to update in case it exists.
     */
    where: CIPLogWhereUniqueInput
    /**
     * In case the CIPLog found by the `where` argument doesn't exist, create a new CIPLog with this data.
     */
    create: XOR<CIPLogCreateInput, CIPLogUncheckedCreateInput>
    /**
     * In case the CIPLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CIPLogUpdateInput, CIPLogUncheckedUpdateInput>
  }

  /**
   * CIPLog delete
   */
  export type CIPLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CIPLog
     */
    select?: CIPLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CIPLogInclude<ExtArgs> | null
    /**
     * Filter which CIPLog to delete.
     */
    where: CIPLogWhereUniqueInput
  }

  /**
   * CIPLog deleteMany
   */
  export type CIPLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CIPLogs to delete
     */
    where?: CIPLogWhereInput
  }

  /**
   * CIPLog without action
   */
  export type CIPLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CIPLog
     */
    select?: CIPLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CIPLogInclude<ExtArgs> | null
  }


  /**
   * Model Equipment
   */

  export type AggregateEquipment = {
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  export type EquipmentAvgAggregateOutputType = {
    capacity: number | null
    workingPressure: number | null
    currentTemp: number | null
    currentPressure: number | null
    cipIntervalDays: number | null
    inspectionIntervalDays: number | null
    annualMaintenanceDays: number | null
  }

  export type EquipmentSumAggregateOutputType = {
    capacity: number | null
    workingPressure: number | null
    currentTemp: number | null
    currentPressure: number | null
    cipIntervalDays: number | null
    inspectionIntervalDays: number | null
    annualMaintenanceDays: number | null
  }

  export type EquipmentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    type: string | null
    status: string | null
    capacity: number | null
    model: string | null
    manufacturer: string | null
    serialNumber: string | null
    location: string | null
    workingPressure: number | null
    currentTemp: number | null
    currentPressure: number | null
    installationDate: Date | null
    warrantyDate: Date | null
    lastCIP: Date | null
    nextCIP: Date | null
    lastMaintenance: Date | null
    nextMaintenance: Date | null
    cipIntervalDays: number | null
    inspectionIntervalDays: number | null
    annualMaintenanceDays: number | null
    currentBatchId: string | null
    currentBatchNumber: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    purchaseDate: Date | null
  }

  export type EquipmentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    type: string | null
    status: string | null
    capacity: number | null
    model: string | null
    manufacturer: string | null
    serialNumber: string | null
    location: string | null
    workingPressure: number | null
    currentTemp: number | null
    currentPressure: number | null
    installationDate: Date | null
    warrantyDate: Date | null
    lastCIP: Date | null
    nextCIP: Date | null
    lastMaintenance: Date | null
    nextMaintenance: Date | null
    cipIntervalDays: number | null
    inspectionIntervalDays: number | null
    annualMaintenanceDays: number | null
    currentBatchId: string | null
    currentBatchNumber: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    purchaseDate: Date | null
  }

  export type EquipmentCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    type: number
    status: number
    capacity: number
    model: number
    manufacturer: number
    serialNumber: number
    location: number
    workingPressure: number
    currentTemp: number
    currentPressure: number
    installationDate: number
    warrantyDate: number
    lastCIP: number
    nextCIP: number
    lastMaintenance: number
    nextMaintenance: number
    cipIntervalDays: number
    inspectionIntervalDays: number
    annualMaintenanceDays: number
    currentBatchId: number
    currentBatchNumber: number
    notes: number
    createdAt: number
    updatedAt: number
    purchaseDate: number
    capabilities: number
    _all: number
  }


  export type EquipmentAvgAggregateInputType = {
    capacity?: true
    workingPressure?: true
    currentTemp?: true
    currentPressure?: true
    cipIntervalDays?: true
    inspectionIntervalDays?: true
    annualMaintenanceDays?: true
  }

  export type EquipmentSumAggregateInputType = {
    capacity?: true
    workingPressure?: true
    currentTemp?: true
    currentPressure?: true
    cipIntervalDays?: true
    inspectionIntervalDays?: true
    annualMaintenanceDays?: true
  }

  export type EquipmentMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    type?: true
    status?: true
    capacity?: true
    model?: true
    manufacturer?: true
    serialNumber?: true
    location?: true
    workingPressure?: true
    currentTemp?: true
    currentPressure?: true
    installationDate?: true
    warrantyDate?: true
    lastCIP?: true
    nextCIP?: true
    lastMaintenance?: true
    nextMaintenance?: true
    cipIntervalDays?: true
    inspectionIntervalDays?: true
    annualMaintenanceDays?: true
    currentBatchId?: true
    currentBatchNumber?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    purchaseDate?: true
  }

  export type EquipmentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    type?: true
    status?: true
    capacity?: true
    model?: true
    manufacturer?: true
    serialNumber?: true
    location?: true
    workingPressure?: true
    currentTemp?: true
    currentPressure?: true
    installationDate?: true
    warrantyDate?: true
    lastCIP?: true
    nextCIP?: true
    lastMaintenance?: true
    nextMaintenance?: true
    cipIntervalDays?: true
    inspectionIntervalDays?: true
    annualMaintenanceDays?: true
    currentBatchId?: true
    currentBatchNumber?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    purchaseDate?: true
  }

  export type EquipmentCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    type?: true
    status?: true
    capacity?: true
    model?: true
    manufacturer?: true
    serialNumber?: true
    location?: true
    workingPressure?: true
    currentTemp?: true
    currentPressure?: true
    installationDate?: true
    warrantyDate?: true
    lastCIP?: true
    nextCIP?: true
    lastMaintenance?: true
    nextMaintenance?: true
    cipIntervalDays?: true
    inspectionIntervalDays?: true
    annualMaintenanceDays?: true
    currentBatchId?: true
    currentBatchNumber?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    purchaseDate?: true
    capabilities?: true
    _all?: true
  }

  export type EquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to aggregate.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equipment
    **/
    _count?: true | EquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentMaxAggregateInputType
  }

  export type GetEquipmentAggregateType<T extends EquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment[P]>
      : GetScalarType<T[P], AggregateEquipment[P]>
  }




  export type EquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithAggregationInput | EquipmentOrderByWithAggregationInput[]
    by: EquipmentScalarFieldEnum[] | EquipmentScalarFieldEnum
    having?: EquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCountAggregateInputType | true
    _avg?: EquipmentAvgAggregateInputType
    _sum?: EquipmentSumAggregateInputType
    _min?: EquipmentMinAggregateInputType
    _max?: EquipmentMaxAggregateInputType
  }

  export type EquipmentGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    type: string
    status: string
    capacity: number | null
    model: string | null
    manufacturer: string | null
    serialNumber: string | null
    location: string | null
    workingPressure: number | null
    currentTemp: number | null
    currentPressure: number | null
    installationDate: Date | null
    warrantyDate: Date | null
    lastCIP: Date | null
    nextCIP: Date | null
    lastMaintenance: Date | null
    nextMaintenance: Date | null
    cipIntervalDays: number
    inspectionIntervalDays: number
    annualMaintenanceDays: number
    currentBatchId: string | null
    currentBatchNumber: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    purchaseDate: Date | null
    capabilities: string[]
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  type GetEquipmentGroupByPayload<T extends EquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    capacity?: boolean
    model?: boolean
    manufacturer?: boolean
    serialNumber?: boolean
    location?: boolean
    workingPressure?: boolean
    currentTemp?: boolean
    currentPressure?: boolean
    installationDate?: boolean
    warrantyDate?: boolean
    lastCIP?: boolean
    nextCIP?: boolean
    lastMaintenance?: boolean
    nextMaintenance?: boolean
    cipIntervalDays?: boolean
    inspectionIntervalDays?: boolean
    annualMaintenanceDays?: boolean
    currentBatchId?: boolean
    currentBatchNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseDate?: boolean
    capabilities?: boolean
    CIPLog?: boolean | Equipment$CIPLogArgs<ExtArgs>
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
    MaintenanceLog?: boolean | Equipment$MaintenanceLogArgs<ExtArgs>
    ProblemReport?: boolean | Equipment$ProblemReportArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    capacity?: boolean
    model?: boolean
    manufacturer?: boolean
    serialNumber?: boolean
    location?: boolean
    workingPressure?: boolean
    currentTemp?: boolean
    currentPressure?: boolean
    installationDate?: boolean
    warrantyDate?: boolean
    lastCIP?: boolean
    nextCIP?: boolean
    lastMaintenance?: boolean
    nextMaintenance?: boolean
    cipIntervalDays?: boolean
    inspectionIntervalDays?: boolean
    annualMaintenanceDays?: boolean
    currentBatchId?: boolean
    currentBatchNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseDate?: boolean
    capabilities?: boolean
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    capacity?: boolean
    model?: boolean
    manufacturer?: boolean
    serialNumber?: boolean
    location?: boolean
    workingPressure?: boolean
    currentTemp?: boolean
    currentPressure?: boolean
    installationDate?: boolean
    warrantyDate?: boolean
    lastCIP?: boolean
    nextCIP?: boolean
    lastMaintenance?: boolean
    nextMaintenance?: boolean
    cipIntervalDays?: boolean
    inspectionIntervalDays?: boolean
    annualMaintenanceDays?: boolean
    currentBatchId?: boolean
    currentBatchNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseDate?: boolean
    capabilities?: boolean
  }

  export type EquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CIPLog?: boolean | Equipment$CIPLogArgs<ExtArgs>
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
    MaintenanceLog?: boolean | Equipment$MaintenanceLogArgs<ExtArgs>
    ProblemReport?: boolean | Equipment$ProblemReportArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $EquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Equipment"
    objects: {
      CIPLog: Prisma.$CIPLogPayload<ExtArgs>[]
      Tenant: Prisma.$TenantPayload<ExtArgs>
      MaintenanceLog: Prisma.$MaintenanceLogPayload<ExtArgs>[]
      ProblemReport: Prisma.$ProblemReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      type: string
      status: string
      capacity: number | null
      model: string | null
      manufacturer: string | null
      serialNumber: string | null
      location: string | null
      workingPressure: number | null
      currentTemp: number | null
      currentPressure: number | null
      installationDate: Date | null
      warrantyDate: Date | null
      lastCIP: Date | null
      nextCIP: Date | null
      lastMaintenance: Date | null
      nextMaintenance: Date | null
      cipIntervalDays: number
      inspectionIntervalDays: number
      annualMaintenanceDays: number
      currentBatchId: string | null
      currentBatchNumber: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      purchaseDate: Date | null
      capabilities: string[]
    }, ExtArgs["result"]["equipment"]>
    composites: {}
  }

  type EquipmentGetPayload<S extends boolean | null | undefined | EquipmentDefaultArgs> = $Result.GetResult<Prisma.$EquipmentPayload, S>

  type EquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EquipmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EquipmentCountAggregateInputType | true
    }

  export interface EquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Equipment'], meta: { name: 'Equipment' } }
    /**
     * Find zero or one Equipment that matches the filter.
     * @param {EquipmentFindUniqueArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentFindUniqueArgs>(args: SelectSubset<T, EquipmentFindUniqueArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Equipment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EquipmentFindUniqueOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentFindFirstArgs>(args?: SelectSubset<T, EquipmentFindFirstArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Equipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment
     * const equipment = await prisma.equipment.findMany()
     * 
     * // Get first 10 Equipment
     * const equipment = await prisma.equipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentWithIdOnly = await prisma.equipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentFindManyArgs>(args?: SelectSubset<T, EquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Equipment.
     * @param {EquipmentCreateArgs} args - Arguments to create a Equipment.
     * @example
     * // Create one Equipment
     * const Equipment = await prisma.equipment.create({
     *   data: {
     *     // ... data to create a Equipment
     *   }
     * })
     * 
     */
    create<T extends EquipmentCreateArgs>(args: SelectSubset<T, EquipmentCreateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Equipment.
     * @param {EquipmentCreateManyArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentCreateManyArgs>(args?: SelectSubset<T, EquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Equipment and returns the data saved in the database.
     * @param {EquipmentCreateManyAndReturnArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Equipment and only return the `id`
     * const equipmentWithIdOnly = await prisma.equipment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Equipment.
     * @param {EquipmentDeleteArgs} args - Arguments to delete one Equipment.
     * @example
     * // Delete one Equipment
     * const Equipment = await prisma.equipment.delete({
     *   where: {
     *     // ... filter to delete one Equipment
     *   }
     * })
     * 
     */
    delete<T extends EquipmentDeleteArgs>(args: SelectSubset<T, EquipmentDeleteArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Equipment.
     * @param {EquipmentUpdateArgs} args - Arguments to update one Equipment.
     * @example
     * // Update one Equipment
     * const equipment = await prisma.equipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentUpdateArgs>(args: SelectSubset<T, EquipmentUpdateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Equipment.
     * @param {EquipmentDeleteManyArgs} args - Arguments to filter Equipment to delete.
     * @example
     * // Delete a few Equipment
     * const { count } = await prisma.equipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentDeleteManyArgs>(args?: SelectSubset<T, EquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentUpdateManyArgs>(args: SelectSubset<T, EquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Equipment.
     * @param {EquipmentUpsertArgs} args - Arguments to update or create a Equipment.
     * @example
     * // Update or create a Equipment
     * const equipment = await prisma.equipment.upsert({
     *   create: {
     *     // ... data to create a Equipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentUpsertArgs>(args: SelectSubset<T, EquipmentUpsertArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCountArgs} args - Arguments to filter Equipment to count.
     * @example
     * // Count the number of Equipment
     * const count = await prisma.equipment.count({
     *   where: {
     *     // ... the filter for the Equipment we want to count
     *   }
     * })
    **/
    count<T extends EquipmentCountArgs>(
      args?: Subset<T, EquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentAggregateArgs>(args: Subset<T, EquipmentAggregateArgs>): Prisma.PrismaPromise<GetEquipmentAggregateType<T>>

    /**
     * Group by Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Equipment model
   */
  readonly fields: EquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Equipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CIPLog<T extends Equipment$CIPLogArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$CIPLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CIPLogPayload<ExtArgs>, T, "findMany"> | Null>
    Tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    MaintenanceLog<T extends Equipment$MaintenanceLogArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$MaintenanceLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findMany"> | Null>
    ProblemReport<T extends Equipment$ProblemReportArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$ProblemReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProblemReportPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Equipment model
   */ 
  interface EquipmentFieldRefs {
    readonly id: FieldRef<"Equipment", 'String'>
    readonly tenantId: FieldRef<"Equipment", 'String'>
    readonly name: FieldRef<"Equipment", 'String'>
    readonly type: FieldRef<"Equipment", 'String'>
    readonly status: FieldRef<"Equipment", 'String'>
    readonly capacity: FieldRef<"Equipment", 'Int'>
    readonly model: FieldRef<"Equipment", 'String'>
    readonly manufacturer: FieldRef<"Equipment", 'String'>
    readonly serialNumber: FieldRef<"Equipment", 'String'>
    readonly location: FieldRef<"Equipment", 'String'>
    readonly workingPressure: FieldRef<"Equipment", 'Float'>
    readonly currentTemp: FieldRef<"Equipment", 'Float'>
    readonly currentPressure: FieldRef<"Equipment", 'Float'>
    readonly installationDate: FieldRef<"Equipment", 'DateTime'>
    readonly warrantyDate: FieldRef<"Equipment", 'DateTime'>
    readonly lastCIP: FieldRef<"Equipment", 'DateTime'>
    readonly nextCIP: FieldRef<"Equipment", 'DateTime'>
    readonly lastMaintenance: FieldRef<"Equipment", 'DateTime'>
    readonly nextMaintenance: FieldRef<"Equipment", 'DateTime'>
    readonly cipIntervalDays: FieldRef<"Equipment", 'Int'>
    readonly inspectionIntervalDays: FieldRef<"Equipment", 'Int'>
    readonly annualMaintenanceDays: FieldRef<"Equipment", 'Int'>
    readonly currentBatchId: FieldRef<"Equipment", 'String'>
    readonly currentBatchNumber: FieldRef<"Equipment", 'String'>
    readonly notes: FieldRef<"Equipment", 'String'>
    readonly createdAt: FieldRef<"Equipment", 'DateTime'>
    readonly updatedAt: FieldRef<"Equipment", 'DateTime'>
    readonly purchaseDate: FieldRef<"Equipment", 'DateTime'>
    readonly capabilities: FieldRef<"Equipment", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Equipment findUnique
   */
  export type EquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findUniqueOrThrow
   */
  export type EquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findFirst
   */
  export type EquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findFirstOrThrow
   */
  export type EquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findMany
   */
  export type EquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment create
   */
  export type EquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Equipment.
     */
    data: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
  }

  /**
   * Equipment createMany
   */
  export type EquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equipment createManyAndReturn
   */
  export type EquipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Equipment update
   */
  export type EquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Equipment.
     */
    data: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
    /**
     * Choose, which Equipment to update.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment updateMany
   */
  export type EquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
  }

  /**
   * Equipment upsert
   */
  export type EquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Equipment to update in case it exists.
     */
    where: EquipmentWhereUniqueInput
    /**
     * In case the Equipment found by the `where` argument doesn't exist, create a new Equipment with this data.
     */
    create: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
    /**
     * In case the Equipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
  }

  /**
   * Equipment delete
   */
  export type EquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter which Equipment to delete.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment deleteMany
   */
  export type EquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to delete
     */
    where?: EquipmentWhereInput
  }

  /**
   * Equipment.CIPLog
   */
  export type Equipment$CIPLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CIPLog
     */
    select?: CIPLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CIPLogInclude<ExtArgs> | null
    where?: CIPLogWhereInput
    orderBy?: CIPLogOrderByWithRelationInput | CIPLogOrderByWithRelationInput[]
    cursor?: CIPLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CIPLogScalarFieldEnum | CIPLogScalarFieldEnum[]
  }

  /**
   * Equipment.MaintenanceLog
   */
  export type Equipment$MaintenanceLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    where?: MaintenanceLogWhereInput
    orderBy?: MaintenanceLogOrderByWithRelationInput | MaintenanceLogOrderByWithRelationInput[]
    cursor?: MaintenanceLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceLogScalarFieldEnum | MaintenanceLogScalarFieldEnum[]
  }

  /**
   * Equipment.ProblemReport
   */
  export type Equipment$ProblemReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProblemReport
     */
    select?: ProblemReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemReportInclude<ExtArgs> | null
    where?: ProblemReportWhereInput
    orderBy?: ProblemReportOrderByWithRelationInput | ProblemReportOrderByWithRelationInput[]
    cursor?: ProblemReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProblemReportScalarFieldEnum | ProblemReportScalarFieldEnum[]
  }

  /**
   * Equipment without action
   */
  export type EquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
  }


  /**
   * Model Lot
   */

  export type AggregateLot = {
    _count: LotCountAggregateOutputType | null
    _avg: LotAvgAggregateOutputType | null
    _sum: LotSumAggregateOutputType | null
    _min: LotMinAggregateOutputType | null
    _max: LotMaxAggregateOutputType | null
  }

  export type LotAvgAggregateOutputType = {
    plannedVolume: Decimal | null
    actualVolume: Decimal | null
    splitRatio: Decimal | null
  }

  export type LotSumAggregateOutputType = {
    plannedVolume: Decimal | null
    actualVolume: Decimal | null
    splitRatio: Decimal | null
  }

  export type LotMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    lotCode: string | null
    phase: $Enums.LotPhase | null
    status: $Enums.LotStatus | null
    plannedVolume: Decimal | null
    actualVolume: Decimal | null
    notes: string | null
    parentLotId: string | null
    splitRatio: Decimal | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    lotNumber: string | null
    blendedAt: Date | null
    isBlendResult: boolean | null
    splitAt: Date | null
  }

  export type LotMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    lotCode: string | null
    phase: $Enums.LotPhase | null
    status: $Enums.LotStatus | null
    plannedVolume: Decimal | null
    actualVolume: Decimal | null
    notes: string | null
    parentLotId: string | null
    splitRatio: Decimal | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
    lotNumber: string | null
    blendedAt: Date | null
    isBlendResult: boolean | null
    splitAt: Date | null
  }

  export type LotCountAggregateOutputType = {
    id: number
    tenantId: number
    lotCode: number
    phase: number
    status: number
    plannedVolume: number
    actualVolume: number
    notes: number
    parentLotId: number
    splitRatio: number
    createdBy: number
    createdAt: number
    updatedAt: number
    completedAt: number
    lotNumber: number
    blendedAt: number
    isBlendResult: number
    splitAt: number
    _all: number
  }


  export type LotAvgAggregateInputType = {
    plannedVolume?: true
    actualVolume?: true
    splitRatio?: true
  }

  export type LotSumAggregateInputType = {
    plannedVolume?: true
    actualVolume?: true
    splitRatio?: true
  }

  export type LotMinAggregateInputType = {
    id?: true
    tenantId?: true
    lotCode?: true
    phase?: true
    status?: true
    plannedVolume?: true
    actualVolume?: true
    notes?: true
    parentLotId?: true
    splitRatio?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    lotNumber?: true
    blendedAt?: true
    isBlendResult?: true
    splitAt?: true
  }

  export type LotMaxAggregateInputType = {
    id?: true
    tenantId?: true
    lotCode?: true
    phase?: true
    status?: true
    plannedVolume?: true
    actualVolume?: true
    notes?: true
    parentLotId?: true
    splitRatio?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    lotNumber?: true
    blendedAt?: true
    isBlendResult?: true
    splitAt?: true
  }

  export type LotCountAggregateInputType = {
    id?: true
    tenantId?: true
    lotCode?: true
    phase?: true
    status?: true
    plannedVolume?: true
    actualVolume?: true
    notes?: true
    parentLotId?: true
    splitRatio?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    lotNumber?: true
    blendedAt?: true
    isBlendResult?: true
    splitAt?: true
    _all?: true
  }

  export type LotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lot to aggregate.
     */
    where?: LotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lots to fetch.
     */
    orderBy?: LotOrderByWithRelationInput | LotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lots
    **/
    _count?: true | LotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LotMaxAggregateInputType
  }

  export type GetLotAggregateType<T extends LotAggregateArgs> = {
        [P in keyof T & keyof AggregateLot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLot[P]>
      : GetScalarType<T[P], AggregateLot[P]>
  }




  export type LotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotWhereInput
    orderBy?: LotOrderByWithAggregationInput | LotOrderByWithAggregationInput[]
    by: LotScalarFieldEnum[] | LotScalarFieldEnum
    having?: LotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LotCountAggregateInputType | true
    _avg?: LotAvgAggregateInputType
    _sum?: LotSumAggregateInputType
    _min?: LotMinAggregateInputType
    _max?: LotMaxAggregateInputType
  }

  export type LotGroupByOutputType = {
    id: string
    tenantId: string
    lotCode: string | null
    phase: $Enums.LotPhase
    status: $Enums.LotStatus
    plannedVolume: Decimal
    actualVolume: Decimal | null
    notes: string | null
    parentLotId: string | null
    splitRatio: Decimal | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    lotNumber: string | null
    blendedAt: Date | null
    isBlendResult: boolean | null
    splitAt: Date | null
    _count: LotCountAggregateOutputType | null
    _avg: LotAvgAggregateOutputType | null
    _sum: LotSumAggregateOutputType | null
    _min: LotMinAggregateOutputType | null
    _max: LotMaxAggregateOutputType | null
  }

  type GetLotGroupByPayload<T extends LotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LotGroupByOutputType[P]>
            : GetScalarType<T[P], LotGroupByOutputType[P]>
        }
      >
    >


  export type LotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    lotCode?: boolean
    phase?: boolean
    status?: boolean
    plannedVolume?: boolean
    actualVolume?: boolean
    notes?: boolean
    parentLotId?: boolean
    splitRatio?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    lotNumber?: boolean
    blendedAt?: boolean
    isBlendResult?: boolean
    splitAt?: boolean
    Lot?: boolean | Lot$LotArgs<ExtArgs>
    other_Lot?: boolean | Lot$other_LotArgs<ExtArgs>
    LotBatch?: boolean | Lot$LotBatchArgs<ExtArgs>
    LotReading?: boolean | Lot$LotReadingArgs<ExtArgs>
    QCTest?: boolean | Lot$QCTestArgs<ExtArgs>
    TankAssignment?: boolean | Lot$TankAssignmentArgs<ExtArgs>
    Transfer_Transfer_destLotIdToLot?: boolean | Lot$Transfer_Transfer_destLotIdToLotArgs<ExtArgs>
    Transfer_Transfer_sourceLotIdToLot?: boolean | Lot$Transfer_Transfer_sourceLotIdToLotArgs<ExtArgs>
    _count?: boolean | LotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lot"]>

  export type LotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    lotCode?: boolean
    phase?: boolean
    status?: boolean
    plannedVolume?: boolean
    actualVolume?: boolean
    notes?: boolean
    parentLotId?: boolean
    splitRatio?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    lotNumber?: boolean
    blendedAt?: boolean
    isBlendResult?: boolean
    splitAt?: boolean
    Lot?: boolean | Lot$LotArgs<ExtArgs>
  }, ExtArgs["result"]["lot"]>

  export type LotSelectScalar = {
    id?: boolean
    tenantId?: boolean
    lotCode?: boolean
    phase?: boolean
    status?: boolean
    plannedVolume?: boolean
    actualVolume?: boolean
    notes?: boolean
    parentLotId?: boolean
    splitRatio?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    lotNumber?: boolean
    blendedAt?: boolean
    isBlendResult?: boolean
    splitAt?: boolean
  }

  export type LotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lot?: boolean | Lot$LotArgs<ExtArgs>
    other_Lot?: boolean | Lot$other_LotArgs<ExtArgs>
    LotBatch?: boolean | Lot$LotBatchArgs<ExtArgs>
    LotReading?: boolean | Lot$LotReadingArgs<ExtArgs>
    QCTest?: boolean | Lot$QCTestArgs<ExtArgs>
    TankAssignment?: boolean | Lot$TankAssignmentArgs<ExtArgs>
    Transfer_Transfer_destLotIdToLot?: boolean | Lot$Transfer_Transfer_destLotIdToLotArgs<ExtArgs>
    Transfer_Transfer_sourceLotIdToLot?: boolean | Lot$Transfer_Transfer_sourceLotIdToLotArgs<ExtArgs>
    _count?: boolean | LotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lot?: boolean | Lot$LotArgs<ExtArgs>
  }

  export type $LotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lot"
    objects: {
      Lot: Prisma.$LotPayload<ExtArgs> | null
      other_Lot: Prisma.$LotPayload<ExtArgs>[]
      LotBatch: Prisma.$LotBatchPayload<ExtArgs>[]
      LotReading: Prisma.$LotReadingPayload<ExtArgs>[]
      QCTest: Prisma.$QCTestPayload<ExtArgs>[]
      TankAssignment: Prisma.$TankAssignmentPayload<ExtArgs>[]
      Transfer_Transfer_destLotIdToLot: Prisma.$TransferPayload<ExtArgs>[]
      Transfer_Transfer_sourceLotIdToLot: Prisma.$TransferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      lotCode: string | null
      phase: $Enums.LotPhase
      status: $Enums.LotStatus
      plannedVolume: Prisma.Decimal
      actualVolume: Prisma.Decimal | null
      notes: string | null
      parentLotId: string | null
      splitRatio: Prisma.Decimal | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
      lotNumber: string | null
      blendedAt: Date | null
      isBlendResult: boolean | null
      splitAt: Date | null
    }, ExtArgs["result"]["lot"]>
    composites: {}
  }

  type LotGetPayload<S extends boolean | null | undefined | LotDefaultArgs> = $Result.GetResult<Prisma.$LotPayload, S>

  type LotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LotCountAggregateInputType | true
    }

  export interface LotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lot'], meta: { name: 'Lot' } }
    /**
     * Find zero or one Lot that matches the filter.
     * @param {LotFindUniqueArgs} args - Arguments to find a Lot
     * @example
     * // Get one Lot
     * const lot = await prisma.lot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LotFindUniqueArgs>(args: SelectSubset<T, LotFindUniqueArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lot that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LotFindUniqueOrThrowArgs} args - Arguments to find a Lot
     * @example
     * // Get one Lot
     * const lot = await prisma.lot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LotFindUniqueOrThrowArgs>(args: SelectSubset<T, LotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotFindFirstArgs} args - Arguments to find a Lot
     * @example
     * // Get one Lot
     * const lot = await prisma.lot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LotFindFirstArgs>(args?: SelectSubset<T, LotFindFirstArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotFindFirstOrThrowArgs} args - Arguments to find a Lot
     * @example
     * // Get one Lot
     * const lot = await prisma.lot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LotFindFirstOrThrowArgs>(args?: SelectSubset<T, LotFindFirstOrThrowArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lots
     * const lots = await prisma.lot.findMany()
     * 
     * // Get first 10 Lots
     * const lots = await prisma.lot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lotWithIdOnly = await prisma.lot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LotFindManyArgs>(args?: SelectSubset<T, LotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lot.
     * @param {LotCreateArgs} args - Arguments to create a Lot.
     * @example
     * // Create one Lot
     * const Lot = await prisma.lot.create({
     *   data: {
     *     // ... data to create a Lot
     *   }
     * })
     * 
     */
    create<T extends LotCreateArgs>(args: SelectSubset<T, LotCreateArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lots.
     * @param {LotCreateManyArgs} args - Arguments to create many Lots.
     * @example
     * // Create many Lots
     * const lot = await prisma.lot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LotCreateManyArgs>(args?: SelectSubset<T, LotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lots and returns the data saved in the database.
     * @param {LotCreateManyAndReturnArgs} args - Arguments to create many Lots.
     * @example
     * // Create many Lots
     * const lot = await prisma.lot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lots and only return the `id`
     * const lotWithIdOnly = await prisma.lot.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LotCreateManyAndReturnArgs>(args?: SelectSubset<T, LotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Lot.
     * @param {LotDeleteArgs} args - Arguments to delete one Lot.
     * @example
     * // Delete one Lot
     * const Lot = await prisma.lot.delete({
     *   where: {
     *     // ... filter to delete one Lot
     *   }
     * })
     * 
     */
    delete<T extends LotDeleteArgs>(args: SelectSubset<T, LotDeleteArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lot.
     * @param {LotUpdateArgs} args - Arguments to update one Lot.
     * @example
     * // Update one Lot
     * const lot = await prisma.lot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LotUpdateArgs>(args: SelectSubset<T, LotUpdateArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lots.
     * @param {LotDeleteManyArgs} args - Arguments to filter Lots to delete.
     * @example
     * // Delete a few Lots
     * const { count } = await prisma.lot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LotDeleteManyArgs>(args?: SelectSubset<T, LotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lots
     * const lot = await prisma.lot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LotUpdateManyArgs>(args: SelectSubset<T, LotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lot.
     * @param {LotUpsertArgs} args - Arguments to update or create a Lot.
     * @example
     * // Update or create a Lot
     * const lot = await prisma.lot.upsert({
     *   create: {
     *     // ... data to create a Lot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lot we want to update
     *   }
     * })
     */
    upsert<T extends LotUpsertArgs>(args: SelectSubset<T, LotUpsertArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotCountArgs} args - Arguments to filter Lots to count.
     * @example
     * // Count the number of Lots
     * const count = await prisma.lot.count({
     *   where: {
     *     // ... the filter for the Lots we want to count
     *   }
     * })
    **/
    count<T extends LotCountArgs>(
      args?: Subset<T, LotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LotAggregateArgs>(args: Subset<T, LotAggregateArgs>): Prisma.PrismaPromise<GetLotAggregateType<T>>

    /**
     * Group by Lot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LotGroupByArgs['orderBy'] }
        : { orderBy?: LotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lot model
   */
  readonly fields: LotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Lot<T extends Lot$LotArgs<ExtArgs> = {}>(args?: Subset<T, Lot$LotArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    other_Lot<T extends Lot$other_LotArgs<ExtArgs> = {}>(args?: Subset<T, Lot$other_LotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findMany"> | Null>
    LotBatch<T extends Lot$LotBatchArgs<ExtArgs> = {}>(args?: Subset<T, Lot$LotBatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotBatchPayload<ExtArgs>, T, "findMany"> | Null>
    LotReading<T extends Lot$LotReadingArgs<ExtArgs> = {}>(args?: Subset<T, Lot$LotReadingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotReadingPayload<ExtArgs>, T, "findMany"> | Null>
    QCTest<T extends Lot$QCTestArgs<ExtArgs> = {}>(args?: Subset<T, Lot$QCTestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QCTestPayload<ExtArgs>, T, "findMany"> | Null>
    TankAssignment<T extends Lot$TankAssignmentArgs<ExtArgs> = {}>(args?: Subset<T, Lot$TankAssignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TankAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    Transfer_Transfer_destLotIdToLot<T extends Lot$Transfer_Transfer_destLotIdToLotArgs<ExtArgs> = {}>(args?: Subset<T, Lot$Transfer_Transfer_destLotIdToLotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany"> | Null>
    Transfer_Transfer_sourceLotIdToLot<T extends Lot$Transfer_Transfer_sourceLotIdToLotArgs<ExtArgs> = {}>(args?: Subset<T, Lot$Transfer_Transfer_sourceLotIdToLotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lot model
   */ 
  interface LotFieldRefs {
    readonly id: FieldRef<"Lot", 'String'>
    readonly tenantId: FieldRef<"Lot", 'String'>
    readonly lotCode: FieldRef<"Lot", 'String'>
    readonly phase: FieldRef<"Lot", 'LotPhase'>
    readonly status: FieldRef<"Lot", 'LotStatus'>
    readonly plannedVolume: FieldRef<"Lot", 'Decimal'>
    readonly actualVolume: FieldRef<"Lot", 'Decimal'>
    readonly notes: FieldRef<"Lot", 'String'>
    readonly parentLotId: FieldRef<"Lot", 'String'>
    readonly splitRatio: FieldRef<"Lot", 'Decimal'>
    readonly createdBy: FieldRef<"Lot", 'String'>
    readonly createdAt: FieldRef<"Lot", 'DateTime'>
    readonly updatedAt: FieldRef<"Lot", 'DateTime'>
    readonly completedAt: FieldRef<"Lot", 'DateTime'>
    readonly lotNumber: FieldRef<"Lot", 'String'>
    readonly blendedAt: FieldRef<"Lot", 'DateTime'>
    readonly isBlendResult: FieldRef<"Lot", 'Boolean'>
    readonly splitAt: FieldRef<"Lot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lot findUnique
   */
  export type LotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    /**
     * Filter, which Lot to fetch.
     */
    where: LotWhereUniqueInput
  }

  /**
   * Lot findUniqueOrThrow
   */
  export type LotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    /**
     * Filter, which Lot to fetch.
     */
    where: LotWhereUniqueInput
  }

  /**
   * Lot findFirst
   */
  export type LotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    /**
     * Filter, which Lot to fetch.
     */
    where?: LotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lots to fetch.
     */
    orderBy?: LotOrderByWithRelationInput | LotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lots.
     */
    cursor?: LotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lots.
     */
    distinct?: LotScalarFieldEnum | LotScalarFieldEnum[]
  }

  /**
   * Lot findFirstOrThrow
   */
  export type LotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    /**
     * Filter, which Lot to fetch.
     */
    where?: LotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lots to fetch.
     */
    orderBy?: LotOrderByWithRelationInput | LotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lots.
     */
    cursor?: LotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lots.
     */
    distinct?: LotScalarFieldEnum | LotScalarFieldEnum[]
  }

  /**
   * Lot findMany
   */
  export type LotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    /**
     * Filter, which Lots to fetch.
     */
    where?: LotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lots to fetch.
     */
    orderBy?: LotOrderByWithRelationInput | LotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lots.
     */
    cursor?: LotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lots.
     */
    skip?: number
    distinct?: LotScalarFieldEnum | LotScalarFieldEnum[]
  }

  /**
   * Lot create
   */
  export type LotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    /**
     * The data needed to create a Lot.
     */
    data: XOR<LotCreateInput, LotUncheckedCreateInput>
  }

  /**
   * Lot createMany
   */
  export type LotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lots.
     */
    data: LotCreateManyInput | LotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lot createManyAndReturn
   */
  export type LotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Lots.
     */
    data: LotCreateManyInput | LotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lot update
   */
  export type LotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    /**
     * The data needed to update a Lot.
     */
    data: XOR<LotUpdateInput, LotUncheckedUpdateInput>
    /**
     * Choose, which Lot to update.
     */
    where: LotWhereUniqueInput
  }

  /**
   * Lot updateMany
   */
  export type LotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lots.
     */
    data: XOR<LotUpdateManyMutationInput, LotUncheckedUpdateManyInput>
    /**
     * Filter which Lots to update
     */
    where?: LotWhereInput
  }

  /**
   * Lot upsert
   */
  export type LotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    /**
     * The filter to search for the Lot to update in case it exists.
     */
    where: LotWhereUniqueInput
    /**
     * In case the Lot found by the `where` argument doesn't exist, create a new Lot with this data.
     */
    create: XOR<LotCreateInput, LotUncheckedCreateInput>
    /**
     * In case the Lot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LotUpdateInput, LotUncheckedUpdateInput>
  }

  /**
   * Lot delete
   */
  export type LotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    /**
     * Filter which Lot to delete.
     */
    where: LotWhereUniqueInput
  }

  /**
   * Lot deleteMany
   */
  export type LotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lots to delete
     */
    where?: LotWhereInput
  }

  /**
   * Lot.Lot
   */
  export type Lot$LotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    where?: LotWhereInput
  }

  /**
   * Lot.other_Lot
   */
  export type Lot$other_LotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    where?: LotWhereInput
    orderBy?: LotOrderByWithRelationInput | LotOrderByWithRelationInput[]
    cursor?: LotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotScalarFieldEnum | LotScalarFieldEnum[]
  }

  /**
   * Lot.LotBatch
   */
  export type Lot$LotBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBatch
     */
    select?: LotBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBatchInclude<ExtArgs> | null
    where?: LotBatchWhereInput
    orderBy?: LotBatchOrderByWithRelationInput | LotBatchOrderByWithRelationInput[]
    cursor?: LotBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotBatchScalarFieldEnum | LotBatchScalarFieldEnum[]
  }

  /**
   * Lot.LotReading
   */
  export type Lot$LotReadingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotReading
     */
    select?: LotReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotReadingInclude<ExtArgs> | null
    where?: LotReadingWhereInput
    orderBy?: LotReadingOrderByWithRelationInput | LotReadingOrderByWithRelationInput[]
    cursor?: LotReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LotReadingScalarFieldEnum | LotReadingScalarFieldEnum[]
  }

  /**
   * Lot.QCTest
   */
  export type Lot$QCTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCTest
     */
    select?: QCTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCTestInclude<ExtArgs> | null
    where?: QCTestWhereInput
    orderBy?: QCTestOrderByWithRelationInput | QCTestOrderByWithRelationInput[]
    cursor?: QCTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QCTestScalarFieldEnum | QCTestScalarFieldEnum[]
  }

  /**
   * Lot.TankAssignment
   */
  export type Lot$TankAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankAssignment
     */
    select?: TankAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankAssignmentInclude<ExtArgs> | null
    where?: TankAssignmentWhereInput
    orderBy?: TankAssignmentOrderByWithRelationInput | TankAssignmentOrderByWithRelationInput[]
    cursor?: TankAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TankAssignmentScalarFieldEnum | TankAssignmentScalarFieldEnum[]
  }

  /**
   * Lot.Transfer_Transfer_destLotIdToLot
   */
  export type Lot$Transfer_Transfer_destLotIdToLotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Lot.Transfer_Transfer_sourceLotIdToLot
   */
  export type Lot$Transfer_Transfer_sourceLotIdToLotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    cursor?: TransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Lot without action
   */
  export type LotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
  }


  /**
   * Model LotBatch
   */

  export type AggregateLotBatch = {
    _count: LotBatchCountAggregateOutputType | null
    _avg: LotBatchAvgAggregateOutputType | null
    _sum: LotBatchSumAggregateOutputType | null
    _min: LotBatchMinAggregateOutputType | null
    _max: LotBatchMaxAggregateOutputType | null
  }

  export type LotBatchAvgAggregateOutputType = {
    volumeContribution: Decimal | null
    batchPercentage: Decimal | null
  }

  export type LotBatchSumAggregateOutputType = {
    volumeContribution: Decimal | null
    batchPercentage: Decimal | null
  }

  export type LotBatchMinAggregateOutputType = {
    id: string | null
    lotId: string | null
    batchId: string | null
    volumeContribution: Decimal | null
    batchPercentage: Decimal | null
    addedAt: Date | null
  }

  export type LotBatchMaxAggregateOutputType = {
    id: string | null
    lotId: string | null
    batchId: string | null
    volumeContribution: Decimal | null
    batchPercentage: Decimal | null
    addedAt: Date | null
  }

  export type LotBatchCountAggregateOutputType = {
    id: number
    lotId: number
    batchId: number
    volumeContribution: number
    batchPercentage: number
    addedAt: number
    _all: number
  }


  export type LotBatchAvgAggregateInputType = {
    volumeContribution?: true
    batchPercentage?: true
  }

  export type LotBatchSumAggregateInputType = {
    volumeContribution?: true
    batchPercentage?: true
  }

  export type LotBatchMinAggregateInputType = {
    id?: true
    lotId?: true
    batchId?: true
    volumeContribution?: true
    batchPercentage?: true
    addedAt?: true
  }

  export type LotBatchMaxAggregateInputType = {
    id?: true
    lotId?: true
    batchId?: true
    volumeContribution?: true
    batchPercentage?: true
    addedAt?: true
  }

  export type LotBatchCountAggregateInputType = {
    id?: true
    lotId?: true
    batchId?: true
    volumeContribution?: true
    batchPercentage?: true
    addedAt?: true
    _all?: true
  }

  export type LotBatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LotBatch to aggregate.
     */
    where?: LotBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotBatches to fetch.
     */
    orderBy?: LotBatchOrderByWithRelationInput | LotBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LotBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LotBatches
    **/
    _count?: true | LotBatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LotBatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LotBatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LotBatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LotBatchMaxAggregateInputType
  }

  export type GetLotBatchAggregateType<T extends LotBatchAggregateArgs> = {
        [P in keyof T & keyof AggregateLotBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLotBatch[P]>
      : GetScalarType<T[P], AggregateLotBatch[P]>
  }




  export type LotBatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotBatchWhereInput
    orderBy?: LotBatchOrderByWithAggregationInput | LotBatchOrderByWithAggregationInput[]
    by: LotBatchScalarFieldEnum[] | LotBatchScalarFieldEnum
    having?: LotBatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LotBatchCountAggregateInputType | true
    _avg?: LotBatchAvgAggregateInputType
    _sum?: LotBatchSumAggregateInputType
    _min?: LotBatchMinAggregateInputType
    _max?: LotBatchMaxAggregateInputType
  }

  export type LotBatchGroupByOutputType = {
    id: string
    lotId: string
    batchId: string
    volumeContribution: Decimal
    batchPercentage: Decimal
    addedAt: Date
    _count: LotBatchCountAggregateOutputType | null
    _avg: LotBatchAvgAggregateOutputType | null
    _sum: LotBatchSumAggregateOutputType | null
    _min: LotBatchMinAggregateOutputType | null
    _max: LotBatchMaxAggregateOutputType | null
  }

  type GetLotBatchGroupByPayload<T extends LotBatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LotBatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LotBatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LotBatchGroupByOutputType[P]>
            : GetScalarType<T[P], LotBatchGroupByOutputType[P]>
        }
      >
    >


  export type LotBatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lotId?: boolean
    batchId?: boolean
    volumeContribution?: boolean
    batchPercentage?: boolean
    addedAt?: boolean
    Batch?: boolean | BatchDefaultArgs<ExtArgs>
    Lot?: boolean | LotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lotBatch"]>

  export type LotBatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lotId?: boolean
    batchId?: boolean
    volumeContribution?: boolean
    batchPercentage?: boolean
    addedAt?: boolean
    Batch?: boolean | BatchDefaultArgs<ExtArgs>
    Lot?: boolean | LotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lotBatch"]>

  export type LotBatchSelectScalar = {
    id?: boolean
    lotId?: boolean
    batchId?: boolean
    volumeContribution?: boolean
    batchPercentage?: boolean
    addedAt?: boolean
  }

  export type LotBatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | BatchDefaultArgs<ExtArgs>
    Lot?: boolean | LotDefaultArgs<ExtArgs>
  }
  export type LotBatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | BatchDefaultArgs<ExtArgs>
    Lot?: boolean | LotDefaultArgs<ExtArgs>
  }

  export type $LotBatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LotBatch"
    objects: {
      Batch: Prisma.$BatchPayload<ExtArgs>
      Lot: Prisma.$LotPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lotId: string
      batchId: string
      volumeContribution: Prisma.Decimal
      batchPercentage: Prisma.Decimal
      addedAt: Date
    }, ExtArgs["result"]["lotBatch"]>
    composites: {}
  }

  type LotBatchGetPayload<S extends boolean | null | undefined | LotBatchDefaultArgs> = $Result.GetResult<Prisma.$LotBatchPayload, S>

  type LotBatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LotBatchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LotBatchCountAggregateInputType | true
    }

  export interface LotBatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LotBatch'], meta: { name: 'LotBatch' } }
    /**
     * Find zero or one LotBatch that matches the filter.
     * @param {LotBatchFindUniqueArgs} args - Arguments to find a LotBatch
     * @example
     * // Get one LotBatch
     * const lotBatch = await prisma.lotBatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LotBatchFindUniqueArgs>(args: SelectSubset<T, LotBatchFindUniqueArgs<ExtArgs>>): Prisma__LotBatchClient<$Result.GetResult<Prisma.$LotBatchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LotBatch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LotBatchFindUniqueOrThrowArgs} args - Arguments to find a LotBatch
     * @example
     * // Get one LotBatch
     * const lotBatch = await prisma.lotBatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LotBatchFindUniqueOrThrowArgs>(args: SelectSubset<T, LotBatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LotBatchClient<$Result.GetResult<Prisma.$LotBatchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LotBatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotBatchFindFirstArgs} args - Arguments to find a LotBatch
     * @example
     * // Get one LotBatch
     * const lotBatch = await prisma.lotBatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LotBatchFindFirstArgs>(args?: SelectSubset<T, LotBatchFindFirstArgs<ExtArgs>>): Prisma__LotBatchClient<$Result.GetResult<Prisma.$LotBatchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LotBatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotBatchFindFirstOrThrowArgs} args - Arguments to find a LotBatch
     * @example
     * // Get one LotBatch
     * const lotBatch = await prisma.lotBatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LotBatchFindFirstOrThrowArgs>(args?: SelectSubset<T, LotBatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__LotBatchClient<$Result.GetResult<Prisma.$LotBatchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LotBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotBatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LotBatches
     * const lotBatches = await prisma.lotBatch.findMany()
     * 
     * // Get first 10 LotBatches
     * const lotBatches = await prisma.lotBatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lotBatchWithIdOnly = await prisma.lotBatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LotBatchFindManyArgs>(args?: SelectSubset<T, LotBatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotBatchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LotBatch.
     * @param {LotBatchCreateArgs} args - Arguments to create a LotBatch.
     * @example
     * // Create one LotBatch
     * const LotBatch = await prisma.lotBatch.create({
     *   data: {
     *     // ... data to create a LotBatch
     *   }
     * })
     * 
     */
    create<T extends LotBatchCreateArgs>(args: SelectSubset<T, LotBatchCreateArgs<ExtArgs>>): Prisma__LotBatchClient<$Result.GetResult<Prisma.$LotBatchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LotBatches.
     * @param {LotBatchCreateManyArgs} args - Arguments to create many LotBatches.
     * @example
     * // Create many LotBatches
     * const lotBatch = await prisma.lotBatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LotBatchCreateManyArgs>(args?: SelectSubset<T, LotBatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LotBatches and returns the data saved in the database.
     * @param {LotBatchCreateManyAndReturnArgs} args - Arguments to create many LotBatches.
     * @example
     * // Create many LotBatches
     * const lotBatch = await prisma.lotBatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LotBatches and only return the `id`
     * const lotBatchWithIdOnly = await prisma.lotBatch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LotBatchCreateManyAndReturnArgs>(args?: SelectSubset<T, LotBatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotBatchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LotBatch.
     * @param {LotBatchDeleteArgs} args - Arguments to delete one LotBatch.
     * @example
     * // Delete one LotBatch
     * const LotBatch = await prisma.lotBatch.delete({
     *   where: {
     *     // ... filter to delete one LotBatch
     *   }
     * })
     * 
     */
    delete<T extends LotBatchDeleteArgs>(args: SelectSubset<T, LotBatchDeleteArgs<ExtArgs>>): Prisma__LotBatchClient<$Result.GetResult<Prisma.$LotBatchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LotBatch.
     * @param {LotBatchUpdateArgs} args - Arguments to update one LotBatch.
     * @example
     * // Update one LotBatch
     * const lotBatch = await prisma.lotBatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LotBatchUpdateArgs>(args: SelectSubset<T, LotBatchUpdateArgs<ExtArgs>>): Prisma__LotBatchClient<$Result.GetResult<Prisma.$LotBatchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LotBatches.
     * @param {LotBatchDeleteManyArgs} args - Arguments to filter LotBatches to delete.
     * @example
     * // Delete a few LotBatches
     * const { count } = await prisma.lotBatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LotBatchDeleteManyArgs>(args?: SelectSubset<T, LotBatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LotBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotBatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LotBatches
     * const lotBatch = await prisma.lotBatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LotBatchUpdateManyArgs>(args: SelectSubset<T, LotBatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LotBatch.
     * @param {LotBatchUpsertArgs} args - Arguments to update or create a LotBatch.
     * @example
     * // Update or create a LotBatch
     * const lotBatch = await prisma.lotBatch.upsert({
     *   create: {
     *     // ... data to create a LotBatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LotBatch we want to update
     *   }
     * })
     */
    upsert<T extends LotBatchUpsertArgs>(args: SelectSubset<T, LotBatchUpsertArgs<ExtArgs>>): Prisma__LotBatchClient<$Result.GetResult<Prisma.$LotBatchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LotBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotBatchCountArgs} args - Arguments to filter LotBatches to count.
     * @example
     * // Count the number of LotBatches
     * const count = await prisma.lotBatch.count({
     *   where: {
     *     // ... the filter for the LotBatches we want to count
     *   }
     * })
    **/
    count<T extends LotBatchCountArgs>(
      args?: Subset<T, LotBatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LotBatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LotBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotBatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LotBatchAggregateArgs>(args: Subset<T, LotBatchAggregateArgs>): Prisma.PrismaPromise<GetLotBatchAggregateType<T>>

    /**
     * Group by LotBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotBatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LotBatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LotBatchGroupByArgs['orderBy'] }
        : { orderBy?: LotBatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LotBatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLotBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LotBatch model
   */
  readonly fields: LotBatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LotBatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LotBatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Batch<T extends BatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BatchDefaultArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Lot<T extends LotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LotDefaultArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LotBatch model
   */ 
  interface LotBatchFieldRefs {
    readonly id: FieldRef<"LotBatch", 'String'>
    readonly lotId: FieldRef<"LotBatch", 'String'>
    readonly batchId: FieldRef<"LotBatch", 'String'>
    readonly volumeContribution: FieldRef<"LotBatch", 'Decimal'>
    readonly batchPercentage: FieldRef<"LotBatch", 'Decimal'>
    readonly addedAt: FieldRef<"LotBatch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LotBatch findUnique
   */
  export type LotBatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBatch
     */
    select?: LotBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBatchInclude<ExtArgs> | null
    /**
     * Filter, which LotBatch to fetch.
     */
    where: LotBatchWhereUniqueInput
  }

  /**
   * LotBatch findUniqueOrThrow
   */
  export type LotBatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBatch
     */
    select?: LotBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBatchInclude<ExtArgs> | null
    /**
     * Filter, which LotBatch to fetch.
     */
    where: LotBatchWhereUniqueInput
  }

  /**
   * LotBatch findFirst
   */
  export type LotBatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBatch
     */
    select?: LotBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBatchInclude<ExtArgs> | null
    /**
     * Filter, which LotBatch to fetch.
     */
    where?: LotBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotBatches to fetch.
     */
    orderBy?: LotBatchOrderByWithRelationInput | LotBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LotBatches.
     */
    cursor?: LotBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LotBatches.
     */
    distinct?: LotBatchScalarFieldEnum | LotBatchScalarFieldEnum[]
  }

  /**
   * LotBatch findFirstOrThrow
   */
  export type LotBatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBatch
     */
    select?: LotBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBatchInclude<ExtArgs> | null
    /**
     * Filter, which LotBatch to fetch.
     */
    where?: LotBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotBatches to fetch.
     */
    orderBy?: LotBatchOrderByWithRelationInput | LotBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LotBatches.
     */
    cursor?: LotBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LotBatches.
     */
    distinct?: LotBatchScalarFieldEnum | LotBatchScalarFieldEnum[]
  }

  /**
   * LotBatch findMany
   */
  export type LotBatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBatch
     */
    select?: LotBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBatchInclude<ExtArgs> | null
    /**
     * Filter, which LotBatches to fetch.
     */
    where?: LotBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotBatches to fetch.
     */
    orderBy?: LotBatchOrderByWithRelationInput | LotBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LotBatches.
     */
    cursor?: LotBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotBatches.
     */
    skip?: number
    distinct?: LotBatchScalarFieldEnum | LotBatchScalarFieldEnum[]
  }

  /**
   * LotBatch create
   */
  export type LotBatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBatch
     */
    select?: LotBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBatchInclude<ExtArgs> | null
    /**
     * The data needed to create a LotBatch.
     */
    data: XOR<LotBatchCreateInput, LotBatchUncheckedCreateInput>
  }

  /**
   * LotBatch createMany
   */
  export type LotBatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LotBatches.
     */
    data: LotBatchCreateManyInput | LotBatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LotBatch createManyAndReturn
   */
  export type LotBatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBatch
     */
    select?: LotBatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LotBatches.
     */
    data: LotBatchCreateManyInput | LotBatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LotBatch update
   */
  export type LotBatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBatch
     */
    select?: LotBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBatchInclude<ExtArgs> | null
    /**
     * The data needed to update a LotBatch.
     */
    data: XOR<LotBatchUpdateInput, LotBatchUncheckedUpdateInput>
    /**
     * Choose, which LotBatch to update.
     */
    where: LotBatchWhereUniqueInput
  }

  /**
   * LotBatch updateMany
   */
  export type LotBatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LotBatches.
     */
    data: XOR<LotBatchUpdateManyMutationInput, LotBatchUncheckedUpdateManyInput>
    /**
     * Filter which LotBatches to update
     */
    where?: LotBatchWhereInput
  }

  /**
   * LotBatch upsert
   */
  export type LotBatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBatch
     */
    select?: LotBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBatchInclude<ExtArgs> | null
    /**
     * The filter to search for the LotBatch to update in case it exists.
     */
    where: LotBatchWhereUniqueInput
    /**
     * In case the LotBatch found by the `where` argument doesn't exist, create a new LotBatch with this data.
     */
    create: XOR<LotBatchCreateInput, LotBatchUncheckedCreateInput>
    /**
     * In case the LotBatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LotBatchUpdateInput, LotBatchUncheckedUpdateInput>
  }

  /**
   * LotBatch delete
   */
  export type LotBatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBatch
     */
    select?: LotBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBatchInclude<ExtArgs> | null
    /**
     * Filter which LotBatch to delete.
     */
    where: LotBatchWhereUniqueInput
  }

  /**
   * LotBatch deleteMany
   */
  export type LotBatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LotBatches to delete
     */
    where?: LotBatchWhereInput
  }

  /**
   * LotBatch without action
   */
  export type LotBatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotBatch
     */
    select?: LotBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotBatchInclude<ExtArgs> | null
  }


  /**
   * Model LotReading
   */

  export type AggregateLotReading = {
    _count: LotReadingCountAggregateOutputType | null
    _avg: LotReadingAvgAggregateOutputType | null
    _sum: LotReadingSumAggregateOutputType | null
    _min: LotReadingMinAggregateOutputType | null
    _max: LotReadingMaxAggregateOutputType | null
  }

  export type LotReadingAvgAggregateOutputType = {
    value: Decimal | null
  }

  export type LotReadingSumAggregateOutputType = {
    value: Decimal | null
  }

  export type LotReadingMinAggregateOutputType = {
    id: string | null
    lotId: string | null
    tankId: string | null
    readingType: $Enums.ReadingType | null
    value: Decimal | null
    unit: string | null
    notes: string | null
    recordedBy: string | null
    recordedAt: Date | null
  }

  export type LotReadingMaxAggregateOutputType = {
    id: string | null
    lotId: string | null
    tankId: string | null
    readingType: $Enums.ReadingType | null
    value: Decimal | null
    unit: string | null
    notes: string | null
    recordedBy: string | null
    recordedAt: Date | null
  }

  export type LotReadingCountAggregateOutputType = {
    id: number
    lotId: number
    tankId: number
    readingType: number
    value: number
    unit: number
    notes: number
    recordedBy: number
    recordedAt: number
    _all: number
  }


  export type LotReadingAvgAggregateInputType = {
    value?: true
  }

  export type LotReadingSumAggregateInputType = {
    value?: true
  }

  export type LotReadingMinAggregateInputType = {
    id?: true
    lotId?: true
    tankId?: true
    readingType?: true
    value?: true
    unit?: true
    notes?: true
    recordedBy?: true
    recordedAt?: true
  }

  export type LotReadingMaxAggregateInputType = {
    id?: true
    lotId?: true
    tankId?: true
    readingType?: true
    value?: true
    unit?: true
    notes?: true
    recordedBy?: true
    recordedAt?: true
  }

  export type LotReadingCountAggregateInputType = {
    id?: true
    lotId?: true
    tankId?: true
    readingType?: true
    value?: true
    unit?: true
    notes?: true
    recordedBy?: true
    recordedAt?: true
    _all?: true
  }

  export type LotReadingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LotReading to aggregate.
     */
    where?: LotReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotReadings to fetch.
     */
    orderBy?: LotReadingOrderByWithRelationInput | LotReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LotReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LotReadings
    **/
    _count?: true | LotReadingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LotReadingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LotReadingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LotReadingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LotReadingMaxAggregateInputType
  }

  export type GetLotReadingAggregateType<T extends LotReadingAggregateArgs> = {
        [P in keyof T & keyof AggregateLotReading]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLotReading[P]>
      : GetScalarType<T[P], AggregateLotReading[P]>
  }




  export type LotReadingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LotReadingWhereInput
    orderBy?: LotReadingOrderByWithAggregationInput | LotReadingOrderByWithAggregationInput[]
    by: LotReadingScalarFieldEnum[] | LotReadingScalarFieldEnum
    having?: LotReadingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LotReadingCountAggregateInputType | true
    _avg?: LotReadingAvgAggregateInputType
    _sum?: LotReadingSumAggregateInputType
    _min?: LotReadingMinAggregateInputType
    _max?: LotReadingMaxAggregateInputType
  }

  export type LotReadingGroupByOutputType = {
    id: string
    lotId: string
    tankId: string
    readingType: $Enums.ReadingType
    value: Decimal
    unit: string
    notes: string | null
    recordedBy: string
    recordedAt: Date
    _count: LotReadingCountAggregateOutputType | null
    _avg: LotReadingAvgAggregateOutputType | null
    _sum: LotReadingSumAggregateOutputType | null
    _min: LotReadingMinAggregateOutputType | null
    _max: LotReadingMaxAggregateOutputType | null
  }

  type GetLotReadingGroupByPayload<T extends LotReadingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LotReadingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LotReadingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LotReadingGroupByOutputType[P]>
            : GetScalarType<T[P], LotReadingGroupByOutputType[P]>
        }
      >
    >


  export type LotReadingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lotId?: boolean
    tankId?: boolean
    readingType?: boolean
    value?: boolean
    unit?: boolean
    notes?: boolean
    recordedBy?: boolean
    recordedAt?: boolean
    Lot?: boolean | LotDefaultArgs<ExtArgs>
    Tank?: boolean | TankDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lotReading"]>

  export type LotReadingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lotId?: boolean
    tankId?: boolean
    readingType?: boolean
    value?: boolean
    unit?: boolean
    notes?: boolean
    recordedBy?: boolean
    recordedAt?: boolean
    Lot?: boolean | LotDefaultArgs<ExtArgs>
    Tank?: boolean | TankDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lotReading"]>

  export type LotReadingSelectScalar = {
    id?: boolean
    lotId?: boolean
    tankId?: boolean
    readingType?: boolean
    value?: boolean
    unit?: boolean
    notes?: boolean
    recordedBy?: boolean
    recordedAt?: boolean
  }

  export type LotReadingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lot?: boolean | LotDefaultArgs<ExtArgs>
    Tank?: boolean | TankDefaultArgs<ExtArgs>
  }
  export type LotReadingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lot?: boolean | LotDefaultArgs<ExtArgs>
    Tank?: boolean | TankDefaultArgs<ExtArgs>
  }

  export type $LotReadingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LotReading"
    objects: {
      Lot: Prisma.$LotPayload<ExtArgs>
      Tank: Prisma.$TankPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lotId: string
      tankId: string
      readingType: $Enums.ReadingType
      value: Prisma.Decimal
      unit: string
      notes: string | null
      recordedBy: string
      recordedAt: Date
    }, ExtArgs["result"]["lotReading"]>
    composites: {}
  }

  type LotReadingGetPayload<S extends boolean | null | undefined | LotReadingDefaultArgs> = $Result.GetResult<Prisma.$LotReadingPayload, S>

  type LotReadingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LotReadingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LotReadingCountAggregateInputType | true
    }

  export interface LotReadingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LotReading'], meta: { name: 'LotReading' } }
    /**
     * Find zero or one LotReading that matches the filter.
     * @param {LotReadingFindUniqueArgs} args - Arguments to find a LotReading
     * @example
     * // Get one LotReading
     * const lotReading = await prisma.lotReading.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LotReadingFindUniqueArgs>(args: SelectSubset<T, LotReadingFindUniqueArgs<ExtArgs>>): Prisma__LotReadingClient<$Result.GetResult<Prisma.$LotReadingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LotReading that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LotReadingFindUniqueOrThrowArgs} args - Arguments to find a LotReading
     * @example
     * // Get one LotReading
     * const lotReading = await prisma.lotReading.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LotReadingFindUniqueOrThrowArgs>(args: SelectSubset<T, LotReadingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LotReadingClient<$Result.GetResult<Prisma.$LotReadingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LotReading that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotReadingFindFirstArgs} args - Arguments to find a LotReading
     * @example
     * // Get one LotReading
     * const lotReading = await prisma.lotReading.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LotReadingFindFirstArgs>(args?: SelectSubset<T, LotReadingFindFirstArgs<ExtArgs>>): Prisma__LotReadingClient<$Result.GetResult<Prisma.$LotReadingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LotReading that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotReadingFindFirstOrThrowArgs} args - Arguments to find a LotReading
     * @example
     * // Get one LotReading
     * const lotReading = await prisma.lotReading.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LotReadingFindFirstOrThrowArgs>(args?: SelectSubset<T, LotReadingFindFirstOrThrowArgs<ExtArgs>>): Prisma__LotReadingClient<$Result.GetResult<Prisma.$LotReadingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LotReadings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotReadingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LotReadings
     * const lotReadings = await prisma.lotReading.findMany()
     * 
     * // Get first 10 LotReadings
     * const lotReadings = await prisma.lotReading.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lotReadingWithIdOnly = await prisma.lotReading.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LotReadingFindManyArgs>(args?: SelectSubset<T, LotReadingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotReadingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LotReading.
     * @param {LotReadingCreateArgs} args - Arguments to create a LotReading.
     * @example
     * // Create one LotReading
     * const LotReading = await prisma.lotReading.create({
     *   data: {
     *     // ... data to create a LotReading
     *   }
     * })
     * 
     */
    create<T extends LotReadingCreateArgs>(args: SelectSubset<T, LotReadingCreateArgs<ExtArgs>>): Prisma__LotReadingClient<$Result.GetResult<Prisma.$LotReadingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LotReadings.
     * @param {LotReadingCreateManyArgs} args - Arguments to create many LotReadings.
     * @example
     * // Create many LotReadings
     * const lotReading = await prisma.lotReading.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LotReadingCreateManyArgs>(args?: SelectSubset<T, LotReadingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LotReadings and returns the data saved in the database.
     * @param {LotReadingCreateManyAndReturnArgs} args - Arguments to create many LotReadings.
     * @example
     * // Create many LotReadings
     * const lotReading = await prisma.lotReading.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LotReadings and only return the `id`
     * const lotReadingWithIdOnly = await prisma.lotReading.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LotReadingCreateManyAndReturnArgs>(args?: SelectSubset<T, LotReadingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LotReadingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LotReading.
     * @param {LotReadingDeleteArgs} args - Arguments to delete one LotReading.
     * @example
     * // Delete one LotReading
     * const LotReading = await prisma.lotReading.delete({
     *   where: {
     *     // ... filter to delete one LotReading
     *   }
     * })
     * 
     */
    delete<T extends LotReadingDeleteArgs>(args: SelectSubset<T, LotReadingDeleteArgs<ExtArgs>>): Prisma__LotReadingClient<$Result.GetResult<Prisma.$LotReadingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LotReading.
     * @param {LotReadingUpdateArgs} args - Arguments to update one LotReading.
     * @example
     * // Update one LotReading
     * const lotReading = await prisma.lotReading.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LotReadingUpdateArgs>(args: SelectSubset<T, LotReadingUpdateArgs<ExtArgs>>): Prisma__LotReadingClient<$Result.GetResult<Prisma.$LotReadingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LotReadings.
     * @param {LotReadingDeleteManyArgs} args - Arguments to filter LotReadings to delete.
     * @example
     * // Delete a few LotReadings
     * const { count } = await prisma.lotReading.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LotReadingDeleteManyArgs>(args?: SelectSubset<T, LotReadingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LotReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotReadingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LotReadings
     * const lotReading = await prisma.lotReading.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LotReadingUpdateManyArgs>(args: SelectSubset<T, LotReadingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LotReading.
     * @param {LotReadingUpsertArgs} args - Arguments to update or create a LotReading.
     * @example
     * // Update or create a LotReading
     * const lotReading = await prisma.lotReading.upsert({
     *   create: {
     *     // ... data to create a LotReading
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LotReading we want to update
     *   }
     * })
     */
    upsert<T extends LotReadingUpsertArgs>(args: SelectSubset<T, LotReadingUpsertArgs<ExtArgs>>): Prisma__LotReadingClient<$Result.GetResult<Prisma.$LotReadingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LotReadings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotReadingCountArgs} args - Arguments to filter LotReadings to count.
     * @example
     * // Count the number of LotReadings
     * const count = await prisma.lotReading.count({
     *   where: {
     *     // ... the filter for the LotReadings we want to count
     *   }
     * })
    **/
    count<T extends LotReadingCountArgs>(
      args?: Subset<T, LotReadingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LotReadingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LotReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotReadingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LotReadingAggregateArgs>(args: Subset<T, LotReadingAggregateArgs>): Prisma.PrismaPromise<GetLotReadingAggregateType<T>>

    /**
     * Group by LotReading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LotReadingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LotReadingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LotReadingGroupByArgs['orderBy'] }
        : { orderBy?: LotReadingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LotReadingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLotReadingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LotReading model
   */
  readonly fields: LotReadingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LotReading.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LotReadingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Lot<T extends LotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LotDefaultArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Tank<T extends TankDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TankDefaultArgs<ExtArgs>>): Prisma__TankClient<$Result.GetResult<Prisma.$TankPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LotReading model
   */ 
  interface LotReadingFieldRefs {
    readonly id: FieldRef<"LotReading", 'String'>
    readonly lotId: FieldRef<"LotReading", 'String'>
    readonly tankId: FieldRef<"LotReading", 'String'>
    readonly readingType: FieldRef<"LotReading", 'ReadingType'>
    readonly value: FieldRef<"LotReading", 'Decimal'>
    readonly unit: FieldRef<"LotReading", 'String'>
    readonly notes: FieldRef<"LotReading", 'String'>
    readonly recordedBy: FieldRef<"LotReading", 'String'>
    readonly recordedAt: FieldRef<"LotReading", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LotReading findUnique
   */
  export type LotReadingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotReading
     */
    select?: LotReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotReadingInclude<ExtArgs> | null
    /**
     * Filter, which LotReading to fetch.
     */
    where: LotReadingWhereUniqueInput
  }

  /**
   * LotReading findUniqueOrThrow
   */
  export type LotReadingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotReading
     */
    select?: LotReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotReadingInclude<ExtArgs> | null
    /**
     * Filter, which LotReading to fetch.
     */
    where: LotReadingWhereUniqueInput
  }

  /**
   * LotReading findFirst
   */
  export type LotReadingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotReading
     */
    select?: LotReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotReadingInclude<ExtArgs> | null
    /**
     * Filter, which LotReading to fetch.
     */
    where?: LotReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotReadings to fetch.
     */
    orderBy?: LotReadingOrderByWithRelationInput | LotReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LotReadings.
     */
    cursor?: LotReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LotReadings.
     */
    distinct?: LotReadingScalarFieldEnum | LotReadingScalarFieldEnum[]
  }

  /**
   * LotReading findFirstOrThrow
   */
  export type LotReadingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotReading
     */
    select?: LotReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotReadingInclude<ExtArgs> | null
    /**
     * Filter, which LotReading to fetch.
     */
    where?: LotReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotReadings to fetch.
     */
    orderBy?: LotReadingOrderByWithRelationInput | LotReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LotReadings.
     */
    cursor?: LotReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotReadings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LotReadings.
     */
    distinct?: LotReadingScalarFieldEnum | LotReadingScalarFieldEnum[]
  }

  /**
   * LotReading findMany
   */
  export type LotReadingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotReading
     */
    select?: LotReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotReadingInclude<ExtArgs> | null
    /**
     * Filter, which LotReadings to fetch.
     */
    where?: LotReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LotReadings to fetch.
     */
    orderBy?: LotReadingOrderByWithRelationInput | LotReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LotReadings.
     */
    cursor?: LotReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LotReadings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LotReadings.
     */
    skip?: number
    distinct?: LotReadingScalarFieldEnum | LotReadingScalarFieldEnum[]
  }

  /**
   * LotReading create
   */
  export type LotReadingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotReading
     */
    select?: LotReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotReadingInclude<ExtArgs> | null
    /**
     * The data needed to create a LotReading.
     */
    data: XOR<LotReadingCreateInput, LotReadingUncheckedCreateInput>
  }

  /**
   * LotReading createMany
   */
  export type LotReadingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LotReadings.
     */
    data: LotReadingCreateManyInput | LotReadingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LotReading createManyAndReturn
   */
  export type LotReadingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotReading
     */
    select?: LotReadingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LotReadings.
     */
    data: LotReadingCreateManyInput | LotReadingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotReadingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LotReading update
   */
  export type LotReadingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotReading
     */
    select?: LotReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotReadingInclude<ExtArgs> | null
    /**
     * The data needed to update a LotReading.
     */
    data: XOR<LotReadingUpdateInput, LotReadingUncheckedUpdateInput>
    /**
     * Choose, which LotReading to update.
     */
    where: LotReadingWhereUniqueInput
  }

  /**
   * LotReading updateMany
   */
  export type LotReadingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LotReadings.
     */
    data: XOR<LotReadingUpdateManyMutationInput, LotReadingUncheckedUpdateManyInput>
    /**
     * Filter which LotReadings to update
     */
    where?: LotReadingWhereInput
  }

  /**
   * LotReading upsert
   */
  export type LotReadingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotReading
     */
    select?: LotReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotReadingInclude<ExtArgs> | null
    /**
     * The filter to search for the LotReading to update in case it exists.
     */
    where: LotReadingWhereUniqueInput
    /**
     * In case the LotReading found by the `where` argument doesn't exist, create a new LotReading with this data.
     */
    create: XOR<LotReadingCreateInput, LotReadingUncheckedCreateInput>
    /**
     * In case the LotReading was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LotReadingUpdateInput, LotReadingUncheckedUpdateInput>
  }

  /**
   * LotReading delete
   */
  export type LotReadingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotReading
     */
    select?: LotReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotReadingInclude<ExtArgs> | null
    /**
     * Filter which LotReading to delete.
     */
    where: LotReadingWhereUniqueInput
  }

  /**
   * LotReading deleteMany
   */
  export type LotReadingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LotReadings to delete
     */
    where?: LotReadingWhereInput
  }

  /**
   * LotReading without action
   */
  export type LotReadingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LotReading
     */
    select?: LotReadingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotReadingInclude<ExtArgs> | null
  }


  /**
   * Model MaintenanceLog
   */

  export type AggregateMaintenanceLog = {
    _count: MaintenanceLogCountAggregateOutputType | null
    _avg: MaintenanceLogAvgAggregateOutputType | null
    _sum: MaintenanceLogSumAggregateOutputType | null
    _min: MaintenanceLogMinAggregateOutputType | null
    _max: MaintenanceLogMaxAggregateOutputType | null
  }

  export type MaintenanceLogAvgAggregateOutputType = {
    duration: number | null
    cost: number | null
  }

  export type MaintenanceLogSumAggregateOutputType = {
    duration: number | null
    cost: number | null
  }

  export type MaintenanceLogMinAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    type: string | null
    status: string | null
    priority: string | null
    scheduledDate: Date | null
    completedDate: Date | null
    duration: number | null
    performedBy: string | null
    cost: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceLogMaxAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    type: string | null
    status: string | null
    priority: string | null
    scheduledDate: Date | null
    completedDate: Date | null
    duration: number | null
    performedBy: string | null
    cost: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceLogCountAggregateOutputType = {
    id: number
    equipmentId: number
    type: number
    status: number
    priority: number
    scheduledDate: number
    completedDate: number
    duration: number
    performedBy: number
    cost: number
    partsUsed: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaintenanceLogAvgAggregateInputType = {
    duration?: true
    cost?: true
  }

  export type MaintenanceLogSumAggregateInputType = {
    duration?: true
    cost?: true
  }

  export type MaintenanceLogMinAggregateInputType = {
    id?: true
    equipmentId?: true
    type?: true
    status?: true
    priority?: true
    scheduledDate?: true
    completedDate?: true
    duration?: true
    performedBy?: true
    cost?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceLogMaxAggregateInputType = {
    id?: true
    equipmentId?: true
    type?: true
    status?: true
    priority?: true
    scheduledDate?: true
    completedDate?: true
    duration?: true
    performedBy?: true
    cost?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceLogCountAggregateInputType = {
    id?: true
    equipmentId?: true
    type?: true
    status?: true
    priority?: true
    scheduledDate?: true
    completedDate?: true
    duration?: true
    performedBy?: true
    cost?: true
    partsUsed?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaintenanceLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceLog to aggregate.
     */
    where?: MaintenanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceLogs to fetch.
     */
    orderBy?: MaintenanceLogOrderByWithRelationInput | MaintenanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenanceLogs
    **/
    _count?: true | MaintenanceLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaintenanceLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaintenanceLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceLogMaxAggregateInputType
  }

  export type GetMaintenanceLogAggregateType<T extends MaintenanceLogAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenanceLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceLog[P]>
      : GetScalarType<T[P], AggregateMaintenanceLog[P]>
  }




  export type MaintenanceLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceLogWhereInput
    orderBy?: MaintenanceLogOrderByWithAggregationInput | MaintenanceLogOrderByWithAggregationInput[]
    by: MaintenanceLogScalarFieldEnum[] | MaintenanceLogScalarFieldEnum
    having?: MaintenanceLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceLogCountAggregateInputType | true
    _avg?: MaintenanceLogAvgAggregateInputType
    _sum?: MaintenanceLogSumAggregateInputType
    _min?: MaintenanceLogMinAggregateInputType
    _max?: MaintenanceLogMaxAggregateInputType
  }

  export type MaintenanceLogGroupByOutputType = {
    id: string
    equipmentId: string
    type: string
    status: string
    priority: string | null
    scheduledDate: Date | null
    completedDate: Date | null
    duration: number | null
    performedBy: string | null
    cost: number | null
    partsUsed: string[]
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: MaintenanceLogCountAggregateOutputType | null
    _avg: MaintenanceLogAvgAggregateOutputType | null
    _sum: MaintenanceLogSumAggregateOutputType | null
    _min: MaintenanceLogMinAggregateOutputType | null
    _max: MaintenanceLogMaxAggregateOutputType | null
  }

  type GetMaintenanceLogGroupByPayload<T extends MaintenanceLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceLogGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceLogGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    duration?: boolean
    performedBy?: boolean
    cost?: boolean
    partsUsed?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceLog"]>

  export type MaintenanceLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    duration?: boolean
    performedBy?: boolean
    cost?: boolean
    partsUsed?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceLog"]>

  export type MaintenanceLogSelectScalar = {
    id?: boolean
    equipmentId?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    duration?: boolean
    performedBy?: boolean
    cost?: boolean
    partsUsed?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaintenanceLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type MaintenanceLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }

  export type $MaintenanceLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenanceLog"
    objects: {
      Equipment: Prisma.$EquipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      equipmentId: string
      type: string
      status: string
      priority: string | null
      scheduledDate: Date | null
      completedDate: Date | null
      duration: number | null
      performedBy: string | null
      cost: number | null
      partsUsed: string[]
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["maintenanceLog"]>
    composites: {}
  }

  type MaintenanceLogGetPayload<S extends boolean | null | undefined | MaintenanceLogDefaultArgs> = $Result.GetResult<Prisma.$MaintenanceLogPayload, S>

  type MaintenanceLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaintenanceLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaintenanceLogCountAggregateInputType | true
    }

  export interface MaintenanceLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenanceLog'], meta: { name: 'MaintenanceLog' } }
    /**
     * Find zero or one MaintenanceLog that matches the filter.
     * @param {MaintenanceLogFindUniqueArgs} args - Arguments to find a MaintenanceLog
     * @example
     * // Get one MaintenanceLog
     * const maintenanceLog = await prisma.maintenanceLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceLogFindUniqueArgs>(args: SelectSubset<T, MaintenanceLogFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MaintenanceLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaintenanceLogFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceLog
     * @example
     * // Get one MaintenanceLog
     * const maintenanceLog = await prisma.maintenanceLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceLogFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MaintenanceLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogFindFirstArgs} args - Arguments to find a MaintenanceLog
     * @example
     * // Get one MaintenanceLog
     * const maintenanceLog = await prisma.maintenanceLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceLogFindFirstArgs>(args?: SelectSubset<T, MaintenanceLogFindFirstArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MaintenanceLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogFindFirstOrThrowArgs} args - Arguments to find a MaintenanceLog
     * @example
     * // Get one MaintenanceLog
     * const maintenanceLog = await prisma.maintenanceLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceLogFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MaintenanceLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceLogs
     * const maintenanceLogs = await prisma.maintenanceLog.findMany()
     * 
     * // Get first 10 MaintenanceLogs
     * const maintenanceLogs = await prisma.maintenanceLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceLogWithIdOnly = await prisma.maintenanceLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceLogFindManyArgs>(args?: SelectSubset<T, MaintenanceLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MaintenanceLog.
     * @param {MaintenanceLogCreateArgs} args - Arguments to create a MaintenanceLog.
     * @example
     * // Create one MaintenanceLog
     * const MaintenanceLog = await prisma.maintenanceLog.create({
     *   data: {
     *     // ... data to create a MaintenanceLog
     *   }
     * })
     * 
     */
    create<T extends MaintenanceLogCreateArgs>(args: SelectSubset<T, MaintenanceLogCreateArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MaintenanceLogs.
     * @param {MaintenanceLogCreateManyArgs} args - Arguments to create many MaintenanceLogs.
     * @example
     * // Create many MaintenanceLogs
     * const maintenanceLog = await prisma.maintenanceLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceLogCreateManyArgs>(args?: SelectSubset<T, MaintenanceLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenanceLogs and returns the data saved in the database.
     * @param {MaintenanceLogCreateManyAndReturnArgs} args - Arguments to create many MaintenanceLogs.
     * @example
     * // Create many MaintenanceLogs
     * const maintenanceLog = await prisma.maintenanceLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenanceLogs and only return the `id`
     * const maintenanceLogWithIdOnly = await prisma.maintenanceLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceLogCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MaintenanceLog.
     * @param {MaintenanceLogDeleteArgs} args - Arguments to delete one MaintenanceLog.
     * @example
     * // Delete one MaintenanceLog
     * const MaintenanceLog = await prisma.maintenanceLog.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceLog
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceLogDeleteArgs>(args: SelectSubset<T, MaintenanceLogDeleteArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MaintenanceLog.
     * @param {MaintenanceLogUpdateArgs} args - Arguments to update one MaintenanceLog.
     * @example
     * // Update one MaintenanceLog
     * const maintenanceLog = await prisma.maintenanceLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceLogUpdateArgs>(args: SelectSubset<T, MaintenanceLogUpdateArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MaintenanceLogs.
     * @param {MaintenanceLogDeleteManyArgs} args - Arguments to filter MaintenanceLogs to delete.
     * @example
     * // Delete a few MaintenanceLogs
     * const { count } = await prisma.maintenanceLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceLogDeleteManyArgs>(args?: SelectSubset<T, MaintenanceLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceLogs
     * const maintenanceLog = await prisma.maintenanceLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceLogUpdateManyArgs>(args: SelectSubset<T, MaintenanceLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaintenanceLog.
     * @param {MaintenanceLogUpsertArgs} args - Arguments to update or create a MaintenanceLog.
     * @example
     * // Update or create a MaintenanceLog
     * const maintenanceLog = await prisma.maintenanceLog.upsert({
     *   create: {
     *     // ... data to create a MaintenanceLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceLog we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceLogUpsertArgs>(args: SelectSubset<T, MaintenanceLogUpsertArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MaintenanceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogCountArgs} args - Arguments to filter MaintenanceLogs to count.
     * @example
     * // Count the number of MaintenanceLogs
     * const count = await prisma.maintenanceLog.count({
     *   where: {
     *     // ... the filter for the MaintenanceLogs we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceLogCountArgs>(
      args?: Subset<T, MaintenanceLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenanceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceLogAggregateArgs>(args: Subset<T, MaintenanceLogAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceLogAggregateType<T>>

    /**
     * Group by MaintenanceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceLogGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenanceLog model
   */
  readonly fields: MaintenanceLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Equipment<T extends EquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentDefaultArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenanceLog model
   */ 
  interface MaintenanceLogFieldRefs {
    readonly id: FieldRef<"MaintenanceLog", 'String'>
    readonly equipmentId: FieldRef<"MaintenanceLog", 'String'>
    readonly type: FieldRef<"MaintenanceLog", 'String'>
    readonly status: FieldRef<"MaintenanceLog", 'String'>
    readonly priority: FieldRef<"MaintenanceLog", 'String'>
    readonly scheduledDate: FieldRef<"MaintenanceLog", 'DateTime'>
    readonly completedDate: FieldRef<"MaintenanceLog", 'DateTime'>
    readonly duration: FieldRef<"MaintenanceLog", 'Int'>
    readonly performedBy: FieldRef<"MaintenanceLog", 'String'>
    readonly cost: FieldRef<"MaintenanceLog", 'Float'>
    readonly partsUsed: FieldRef<"MaintenanceLog", 'String[]'>
    readonly description: FieldRef<"MaintenanceLog", 'String'>
    readonly createdAt: FieldRef<"MaintenanceLog", 'DateTime'>
    readonly updatedAt: FieldRef<"MaintenanceLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaintenanceLog findUnique
   */
  export type MaintenanceLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceLog to fetch.
     */
    where: MaintenanceLogWhereUniqueInput
  }

  /**
   * MaintenanceLog findUniqueOrThrow
   */
  export type MaintenanceLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceLog to fetch.
     */
    where: MaintenanceLogWhereUniqueInput
  }

  /**
   * MaintenanceLog findFirst
   */
  export type MaintenanceLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceLog to fetch.
     */
    where?: MaintenanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceLogs to fetch.
     */
    orderBy?: MaintenanceLogOrderByWithRelationInput | MaintenanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceLogs.
     */
    cursor?: MaintenanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceLogs.
     */
    distinct?: MaintenanceLogScalarFieldEnum | MaintenanceLogScalarFieldEnum[]
  }

  /**
   * MaintenanceLog findFirstOrThrow
   */
  export type MaintenanceLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceLog to fetch.
     */
    where?: MaintenanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceLogs to fetch.
     */
    orderBy?: MaintenanceLogOrderByWithRelationInput | MaintenanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceLogs.
     */
    cursor?: MaintenanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceLogs.
     */
    distinct?: MaintenanceLogScalarFieldEnum | MaintenanceLogScalarFieldEnum[]
  }

  /**
   * MaintenanceLog findMany
   */
  export type MaintenanceLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceLogs to fetch.
     */
    where?: MaintenanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceLogs to fetch.
     */
    orderBy?: MaintenanceLogOrderByWithRelationInput | MaintenanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenanceLogs.
     */
    cursor?: MaintenanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceLogs.
     */
    skip?: number
    distinct?: MaintenanceLogScalarFieldEnum | MaintenanceLogScalarFieldEnum[]
  }

  /**
   * MaintenanceLog create
   */
  export type MaintenanceLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * The data needed to create a MaintenanceLog.
     */
    data: XOR<MaintenanceLogCreateInput, MaintenanceLogUncheckedCreateInput>
  }

  /**
   * MaintenanceLog createMany
   */
  export type MaintenanceLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenanceLogs.
     */
    data: MaintenanceLogCreateManyInput | MaintenanceLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaintenanceLog createManyAndReturn
   */
  export type MaintenanceLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MaintenanceLogs.
     */
    data: MaintenanceLogCreateManyInput | MaintenanceLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceLog update
   */
  export type MaintenanceLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * The data needed to update a MaintenanceLog.
     */
    data: XOR<MaintenanceLogUpdateInput, MaintenanceLogUncheckedUpdateInput>
    /**
     * Choose, which MaintenanceLog to update.
     */
    where: MaintenanceLogWhereUniqueInput
  }

  /**
   * MaintenanceLog updateMany
   */
  export type MaintenanceLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenanceLogs.
     */
    data: XOR<MaintenanceLogUpdateManyMutationInput, MaintenanceLogUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceLogs to update
     */
    where?: MaintenanceLogWhereInput
  }

  /**
   * MaintenanceLog upsert
   */
  export type MaintenanceLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * The filter to search for the MaintenanceLog to update in case it exists.
     */
    where: MaintenanceLogWhereUniqueInput
    /**
     * In case the MaintenanceLog found by the `where` argument doesn't exist, create a new MaintenanceLog with this data.
     */
    create: XOR<MaintenanceLogCreateInput, MaintenanceLogUncheckedCreateInput>
    /**
     * In case the MaintenanceLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceLogUpdateInput, MaintenanceLogUncheckedUpdateInput>
  }

  /**
   * MaintenanceLog delete
   */
  export type MaintenanceLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * Filter which MaintenanceLog to delete.
     */
    where: MaintenanceLogWhereUniqueInput
  }

  /**
   * MaintenanceLog deleteMany
   */
  export type MaintenanceLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceLogs to delete
     */
    where?: MaintenanceLogWhereInput
  }

  /**
   * MaintenanceLog without action
   */
  export type MaintenanceLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
  }


  /**
   * Model ProblemReport
   */

  export type AggregateProblemReport = {
    _count: ProblemReportCountAggregateOutputType | null
    _min: ProblemReportMinAggregateOutputType | null
    _max: ProblemReportMaxAggregateOutputType | null
  }

  export type ProblemReportMinAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    problemType: string | null
    severity: string | null
    status: string | null
    description: string | null
    reportedDate: Date | null
    reportedBy: string | null
    resolvedDate: Date | null
    resolvedBy: string | null
    resolution: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProblemReportMaxAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    problemType: string | null
    severity: string | null
    status: string | null
    description: string | null
    reportedDate: Date | null
    reportedBy: string | null
    resolvedDate: Date | null
    resolvedBy: string | null
    resolution: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProblemReportCountAggregateOutputType = {
    id: number
    equipmentId: number
    problemType: number
    severity: number
    status: number
    description: number
    reportedDate: number
    reportedBy: number
    resolvedDate: number
    resolvedBy: number
    resolution: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProblemReportMinAggregateInputType = {
    id?: true
    equipmentId?: true
    problemType?: true
    severity?: true
    status?: true
    description?: true
    reportedDate?: true
    reportedBy?: true
    resolvedDate?: true
    resolvedBy?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProblemReportMaxAggregateInputType = {
    id?: true
    equipmentId?: true
    problemType?: true
    severity?: true
    status?: true
    description?: true
    reportedDate?: true
    reportedBy?: true
    resolvedDate?: true
    resolvedBy?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProblemReportCountAggregateInputType = {
    id?: true
    equipmentId?: true
    problemType?: true
    severity?: true
    status?: true
    description?: true
    reportedDate?: true
    reportedBy?: true
    resolvedDate?: true
    resolvedBy?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProblemReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProblemReport to aggregate.
     */
    where?: ProblemReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProblemReports to fetch.
     */
    orderBy?: ProblemReportOrderByWithRelationInput | ProblemReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProblemReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProblemReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProblemReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProblemReports
    **/
    _count?: true | ProblemReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProblemReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProblemReportMaxAggregateInputType
  }

  export type GetProblemReportAggregateType<T extends ProblemReportAggregateArgs> = {
        [P in keyof T & keyof AggregateProblemReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProblemReport[P]>
      : GetScalarType<T[P], AggregateProblemReport[P]>
  }




  export type ProblemReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProblemReportWhereInput
    orderBy?: ProblemReportOrderByWithAggregationInput | ProblemReportOrderByWithAggregationInput[]
    by: ProblemReportScalarFieldEnum[] | ProblemReportScalarFieldEnum
    having?: ProblemReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProblemReportCountAggregateInputType | true
    _min?: ProblemReportMinAggregateInputType
    _max?: ProblemReportMaxAggregateInputType
  }

  export type ProblemReportGroupByOutputType = {
    id: string
    equipmentId: string
    problemType: string
    severity: string
    status: string
    description: string
    reportedDate: Date
    reportedBy: string
    resolvedDate: Date | null
    resolvedBy: string | null
    resolution: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProblemReportCountAggregateOutputType | null
    _min: ProblemReportMinAggregateOutputType | null
    _max: ProblemReportMaxAggregateOutputType | null
  }

  type GetProblemReportGroupByPayload<T extends ProblemReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProblemReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProblemReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProblemReportGroupByOutputType[P]>
            : GetScalarType<T[P], ProblemReportGroupByOutputType[P]>
        }
      >
    >


  export type ProblemReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    problemType?: boolean
    severity?: boolean
    status?: boolean
    description?: boolean
    reportedDate?: boolean
    reportedBy?: boolean
    resolvedDate?: boolean
    resolvedBy?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["problemReport"]>

  export type ProblemReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    problemType?: boolean
    severity?: boolean
    status?: boolean
    description?: boolean
    reportedDate?: boolean
    reportedBy?: boolean
    resolvedDate?: boolean
    resolvedBy?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["problemReport"]>

  export type ProblemReportSelectScalar = {
    id?: boolean
    equipmentId?: boolean
    problemType?: boolean
    severity?: boolean
    status?: boolean
    description?: boolean
    reportedDate?: boolean
    reportedBy?: boolean
    resolvedDate?: boolean
    resolvedBy?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProblemReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type ProblemReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }

  export type $ProblemReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProblemReport"
    objects: {
      Equipment: Prisma.$EquipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      equipmentId: string
      problemType: string
      severity: string
      status: string
      description: string
      reportedDate: Date
      reportedBy: string
      resolvedDate: Date | null
      resolvedBy: string | null
      resolution: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["problemReport"]>
    composites: {}
  }

  type ProblemReportGetPayload<S extends boolean | null | undefined | ProblemReportDefaultArgs> = $Result.GetResult<Prisma.$ProblemReportPayload, S>

  type ProblemReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProblemReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProblemReportCountAggregateInputType | true
    }

  export interface ProblemReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProblemReport'], meta: { name: 'ProblemReport' } }
    /**
     * Find zero or one ProblemReport that matches the filter.
     * @param {ProblemReportFindUniqueArgs} args - Arguments to find a ProblemReport
     * @example
     * // Get one ProblemReport
     * const problemReport = await prisma.problemReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProblemReportFindUniqueArgs>(args: SelectSubset<T, ProblemReportFindUniqueArgs<ExtArgs>>): Prisma__ProblemReportClient<$Result.GetResult<Prisma.$ProblemReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProblemReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProblemReportFindUniqueOrThrowArgs} args - Arguments to find a ProblemReport
     * @example
     * // Get one ProblemReport
     * const problemReport = await prisma.problemReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProblemReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ProblemReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProblemReportClient<$Result.GetResult<Prisma.$ProblemReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProblemReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemReportFindFirstArgs} args - Arguments to find a ProblemReport
     * @example
     * // Get one ProblemReport
     * const problemReport = await prisma.problemReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProblemReportFindFirstArgs>(args?: SelectSubset<T, ProblemReportFindFirstArgs<ExtArgs>>): Prisma__ProblemReportClient<$Result.GetResult<Prisma.$ProblemReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProblemReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemReportFindFirstOrThrowArgs} args - Arguments to find a ProblemReport
     * @example
     * // Get one ProblemReport
     * const problemReport = await prisma.problemReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProblemReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ProblemReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProblemReportClient<$Result.GetResult<Prisma.$ProblemReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProblemReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProblemReports
     * const problemReports = await prisma.problemReport.findMany()
     * 
     * // Get first 10 ProblemReports
     * const problemReports = await prisma.problemReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const problemReportWithIdOnly = await prisma.problemReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProblemReportFindManyArgs>(args?: SelectSubset<T, ProblemReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProblemReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProblemReport.
     * @param {ProblemReportCreateArgs} args - Arguments to create a ProblemReport.
     * @example
     * // Create one ProblemReport
     * const ProblemReport = await prisma.problemReport.create({
     *   data: {
     *     // ... data to create a ProblemReport
     *   }
     * })
     * 
     */
    create<T extends ProblemReportCreateArgs>(args: SelectSubset<T, ProblemReportCreateArgs<ExtArgs>>): Prisma__ProblemReportClient<$Result.GetResult<Prisma.$ProblemReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProblemReports.
     * @param {ProblemReportCreateManyArgs} args - Arguments to create many ProblemReports.
     * @example
     * // Create many ProblemReports
     * const problemReport = await prisma.problemReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProblemReportCreateManyArgs>(args?: SelectSubset<T, ProblemReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProblemReports and returns the data saved in the database.
     * @param {ProblemReportCreateManyAndReturnArgs} args - Arguments to create many ProblemReports.
     * @example
     * // Create many ProblemReports
     * const problemReport = await prisma.problemReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProblemReports and only return the `id`
     * const problemReportWithIdOnly = await prisma.problemReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProblemReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ProblemReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProblemReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProblemReport.
     * @param {ProblemReportDeleteArgs} args - Arguments to delete one ProblemReport.
     * @example
     * // Delete one ProblemReport
     * const ProblemReport = await prisma.problemReport.delete({
     *   where: {
     *     // ... filter to delete one ProblemReport
     *   }
     * })
     * 
     */
    delete<T extends ProblemReportDeleteArgs>(args: SelectSubset<T, ProblemReportDeleteArgs<ExtArgs>>): Prisma__ProblemReportClient<$Result.GetResult<Prisma.$ProblemReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProblemReport.
     * @param {ProblemReportUpdateArgs} args - Arguments to update one ProblemReport.
     * @example
     * // Update one ProblemReport
     * const problemReport = await prisma.problemReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProblemReportUpdateArgs>(args: SelectSubset<T, ProblemReportUpdateArgs<ExtArgs>>): Prisma__ProblemReportClient<$Result.GetResult<Prisma.$ProblemReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProblemReports.
     * @param {ProblemReportDeleteManyArgs} args - Arguments to filter ProblemReports to delete.
     * @example
     * // Delete a few ProblemReports
     * const { count } = await prisma.problemReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProblemReportDeleteManyArgs>(args?: SelectSubset<T, ProblemReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProblemReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProblemReports
     * const problemReport = await prisma.problemReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProblemReportUpdateManyArgs>(args: SelectSubset<T, ProblemReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProblemReport.
     * @param {ProblemReportUpsertArgs} args - Arguments to update or create a ProblemReport.
     * @example
     * // Update or create a ProblemReport
     * const problemReport = await prisma.problemReport.upsert({
     *   create: {
     *     // ... data to create a ProblemReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProblemReport we want to update
     *   }
     * })
     */
    upsert<T extends ProblemReportUpsertArgs>(args: SelectSubset<T, ProblemReportUpsertArgs<ExtArgs>>): Prisma__ProblemReportClient<$Result.GetResult<Prisma.$ProblemReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProblemReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemReportCountArgs} args - Arguments to filter ProblemReports to count.
     * @example
     * // Count the number of ProblemReports
     * const count = await prisma.problemReport.count({
     *   where: {
     *     // ... the filter for the ProblemReports we want to count
     *   }
     * })
    **/
    count<T extends ProblemReportCountArgs>(
      args?: Subset<T, ProblemReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProblemReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProblemReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProblemReportAggregateArgs>(args: Subset<T, ProblemReportAggregateArgs>): Prisma.PrismaPromise<GetProblemReportAggregateType<T>>

    /**
     * Group by ProblemReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProblemReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProblemReportGroupByArgs['orderBy'] }
        : { orderBy?: ProblemReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProblemReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProblemReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProblemReport model
   */
  readonly fields: ProblemReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProblemReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProblemReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Equipment<T extends EquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentDefaultArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProblemReport model
   */ 
  interface ProblemReportFieldRefs {
    readonly id: FieldRef<"ProblemReport", 'String'>
    readonly equipmentId: FieldRef<"ProblemReport", 'String'>
    readonly problemType: FieldRef<"ProblemReport", 'String'>
    readonly severity: FieldRef<"ProblemReport", 'String'>
    readonly status: FieldRef<"ProblemReport", 'String'>
    readonly description: FieldRef<"ProblemReport", 'String'>
    readonly reportedDate: FieldRef<"ProblemReport", 'DateTime'>
    readonly reportedBy: FieldRef<"ProblemReport", 'String'>
    readonly resolvedDate: FieldRef<"ProblemReport", 'DateTime'>
    readonly resolvedBy: FieldRef<"ProblemReport", 'String'>
    readonly resolution: FieldRef<"ProblemReport", 'String'>
    readonly createdAt: FieldRef<"ProblemReport", 'DateTime'>
    readonly updatedAt: FieldRef<"ProblemReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProblemReport findUnique
   */
  export type ProblemReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProblemReport
     */
    select?: ProblemReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemReportInclude<ExtArgs> | null
    /**
     * Filter, which ProblemReport to fetch.
     */
    where: ProblemReportWhereUniqueInput
  }

  /**
   * ProblemReport findUniqueOrThrow
   */
  export type ProblemReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProblemReport
     */
    select?: ProblemReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemReportInclude<ExtArgs> | null
    /**
     * Filter, which ProblemReport to fetch.
     */
    where: ProblemReportWhereUniqueInput
  }

  /**
   * ProblemReport findFirst
   */
  export type ProblemReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProblemReport
     */
    select?: ProblemReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemReportInclude<ExtArgs> | null
    /**
     * Filter, which ProblemReport to fetch.
     */
    where?: ProblemReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProblemReports to fetch.
     */
    orderBy?: ProblemReportOrderByWithRelationInput | ProblemReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProblemReports.
     */
    cursor?: ProblemReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProblemReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProblemReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProblemReports.
     */
    distinct?: ProblemReportScalarFieldEnum | ProblemReportScalarFieldEnum[]
  }

  /**
   * ProblemReport findFirstOrThrow
   */
  export type ProblemReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProblemReport
     */
    select?: ProblemReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemReportInclude<ExtArgs> | null
    /**
     * Filter, which ProblemReport to fetch.
     */
    where?: ProblemReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProblemReports to fetch.
     */
    orderBy?: ProblemReportOrderByWithRelationInput | ProblemReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProblemReports.
     */
    cursor?: ProblemReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProblemReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProblemReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProblemReports.
     */
    distinct?: ProblemReportScalarFieldEnum | ProblemReportScalarFieldEnum[]
  }

  /**
   * ProblemReport findMany
   */
  export type ProblemReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProblemReport
     */
    select?: ProblemReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemReportInclude<ExtArgs> | null
    /**
     * Filter, which ProblemReports to fetch.
     */
    where?: ProblemReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProblemReports to fetch.
     */
    orderBy?: ProblemReportOrderByWithRelationInput | ProblemReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProblemReports.
     */
    cursor?: ProblemReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProblemReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProblemReports.
     */
    skip?: number
    distinct?: ProblemReportScalarFieldEnum | ProblemReportScalarFieldEnum[]
  }

  /**
   * ProblemReport create
   */
  export type ProblemReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProblemReport
     */
    select?: ProblemReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemReportInclude<ExtArgs> | null
    /**
     * The data needed to create a ProblemReport.
     */
    data: XOR<ProblemReportCreateInput, ProblemReportUncheckedCreateInput>
  }

  /**
   * ProblemReport createMany
   */
  export type ProblemReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProblemReports.
     */
    data: ProblemReportCreateManyInput | ProblemReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProblemReport createManyAndReturn
   */
  export type ProblemReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProblemReport
     */
    select?: ProblemReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProblemReports.
     */
    data: ProblemReportCreateManyInput | ProblemReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProblemReport update
   */
  export type ProblemReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProblemReport
     */
    select?: ProblemReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemReportInclude<ExtArgs> | null
    /**
     * The data needed to update a ProblemReport.
     */
    data: XOR<ProblemReportUpdateInput, ProblemReportUncheckedUpdateInput>
    /**
     * Choose, which ProblemReport to update.
     */
    where: ProblemReportWhereUniqueInput
  }

  /**
   * ProblemReport updateMany
   */
  export type ProblemReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProblemReports.
     */
    data: XOR<ProblemReportUpdateManyMutationInput, ProblemReportUncheckedUpdateManyInput>
    /**
     * Filter which ProblemReports to update
     */
    where?: ProblemReportWhereInput
  }

  /**
   * ProblemReport upsert
   */
  export type ProblemReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProblemReport
     */
    select?: ProblemReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemReportInclude<ExtArgs> | null
    /**
     * The filter to search for the ProblemReport to update in case it exists.
     */
    where: ProblemReportWhereUniqueInput
    /**
     * In case the ProblemReport found by the `where` argument doesn't exist, create a new ProblemReport with this data.
     */
    create: XOR<ProblemReportCreateInput, ProblemReportUncheckedCreateInput>
    /**
     * In case the ProblemReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProblemReportUpdateInput, ProblemReportUncheckedUpdateInput>
  }

  /**
   * ProblemReport delete
   */
  export type ProblemReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProblemReport
     */
    select?: ProblemReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemReportInclude<ExtArgs> | null
    /**
     * Filter which ProblemReport to delete.
     */
    where: ProblemReportWhereUniqueInput
  }

  /**
   * ProblemReport deleteMany
   */
  export type ProblemReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProblemReports to delete
     */
    where?: ProblemReportWhereInput
  }

  /**
   * ProblemReport without action
   */
  export type ProblemReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProblemReport
     */
    select?: ProblemReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemReportInclude<ExtArgs> | null
  }


  /**
   * Model TankAssignment
   */

  export type AggregateTankAssignment = {
    _count: TankAssignmentCountAggregateOutputType | null
    _avg: TankAssignmentAvgAggregateOutputType | null
    _sum: TankAssignmentSumAggregateOutputType | null
    _min: TankAssignmentMinAggregateOutputType | null
    _max: TankAssignmentMaxAggregateOutputType | null
  }

  export type TankAssignmentAvgAggregateOutputType = {
    plannedVolume: Decimal | null
    actualVolume: Decimal | null
  }

  export type TankAssignmentSumAggregateOutputType = {
    plannedVolume: Decimal | null
    actualVolume: Decimal | null
  }

  export type TankAssignmentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    tankId: string | null
    lotId: string | null
    phase: $Enums.LotPhase | null
    plannedStart: Date | null
    plannedEnd: Date | null
    actualStart: Date | null
    actualEnd: Date | null
    status: $Enums.AssignmentStatus | null
    plannedVolume: Decimal | null
    actualVolume: Decimal | null
    isBlendTarget: boolean | null
    isSplitSource: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    startTime: Date | null
    endTime: Date | null
    notes: string | null
  }

  export type TankAssignmentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    tankId: string | null
    lotId: string | null
    phase: $Enums.LotPhase | null
    plannedStart: Date | null
    plannedEnd: Date | null
    actualStart: Date | null
    actualEnd: Date | null
    status: $Enums.AssignmentStatus | null
    plannedVolume: Decimal | null
    actualVolume: Decimal | null
    isBlendTarget: boolean | null
    isSplitSource: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    startTime: Date | null
    endTime: Date | null
    notes: string | null
  }

  export type TankAssignmentCountAggregateOutputType = {
    id: number
    tenantId: number
    tankId: number
    lotId: number
    phase: number
    plannedStart: number
    plannedEnd: number
    actualStart: number
    actualEnd: number
    status: number
    plannedVolume: number
    actualVolume: number
    isBlendTarget: number
    isSplitSource: number
    createdBy: number
    createdAt: number
    updatedAt: number
    startTime: number
    endTime: number
    notes: number
    _all: number
  }


  export type TankAssignmentAvgAggregateInputType = {
    plannedVolume?: true
    actualVolume?: true
  }

  export type TankAssignmentSumAggregateInputType = {
    plannedVolume?: true
    actualVolume?: true
  }

  export type TankAssignmentMinAggregateInputType = {
    id?: true
    tenantId?: true
    tankId?: true
    lotId?: true
    phase?: true
    plannedStart?: true
    plannedEnd?: true
    actualStart?: true
    actualEnd?: true
    status?: true
    plannedVolume?: true
    actualVolume?: true
    isBlendTarget?: true
    isSplitSource?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    startTime?: true
    endTime?: true
    notes?: true
  }

  export type TankAssignmentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    tankId?: true
    lotId?: true
    phase?: true
    plannedStart?: true
    plannedEnd?: true
    actualStart?: true
    actualEnd?: true
    status?: true
    plannedVolume?: true
    actualVolume?: true
    isBlendTarget?: true
    isSplitSource?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    startTime?: true
    endTime?: true
    notes?: true
  }

  export type TankAssignmentCountAggregateInputType = {
    id?: true
    tenantId?: true
    tankId?: true
    lotId?: true
    phase?: true
    plannedStart?: true
    plannedEnd?: true
    actualStart?: true
    actualEnd?: true
    status?: true
    plannedVolume?: true
    actualVolume?: true
    isBlendTarget?: true
    isSplitSource?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    startTime?: true
    endTime?: true
    notes?: true
    _all?: true
  }

  export type TankAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TankAssignment to aggregate.
     */
    where?: TankAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TankAssignments to fetch.
     */
    orderBy?: TankAssignmentOrderByWithRelationInput | TankAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TankAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TankAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TankAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TankAssignments
    **/
    _count?: true | TankAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TankAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TankAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TankAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TankAssignmentMaxAggregateInputType
  }

  export type GetTankAssignmentAggregateType<T extends TankAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTankAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTankAssignment[P]>
      : GetScalarType<T[P], AggregateTankAssignment[P]>
  }




  export type TankAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TankAssignmentWhereInput
    orderBy?: TankAssignmentOrderByWithAggregationInput | TankAssignmentOrderByWithAggregationInput[]
    by: TankAssignmentScalarFieldEnum[] | TankAssignmentScalarFieldEnum
    having?: TankAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TankAssignmentCountAggregateInputType | true
    _avg?: TankAssignmentAvgAggregateInputType
    _sum?: TankAssignmentSumAggregateInputType
    _min?: TankAssignmentMinAggregateInputType
    _max?: TankAssignmentMaxAggregateInputType
  }

  export type TankAssignmentGroupByOutputType = {
    id: string
    tenantId: string
    tankId: string
    lotId: string
    phase: $Enums.LotPhase
    plannedStart: Date | null
    plannedEnd: Date | null
    actualStart: Date | null
    actualEnd: Date | null
    status: $Enums.AssignmentStatus
    plannedVolume: Decimal | null
    actualVolume: Decimal | null
    isBlendTarget: boolean
    isSplitSource: boolean
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    startTime: Date | null
    endTime: Date | null
    notes: string | null
    _count: TankAssignmentCountAggregateOutputType | null
    _avg: TankAssignmentAvgAggregateOutputType | null
    _sum: TankAssignmentSumAggregateOutputType | null
    _min: TankAssignmentMinAggregateOutputType | null
    _max: TankAssignmentMaxAggregateOutputType | null
  }

  type GetTankAssignmentGroupByPayload<T extends TankAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TankAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TankAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TankAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], TankAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type TankAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tankId?: boolean
    lotId?: boolean
    phase?: boolean
    plannedStart?: boolean
    plannedEnd?: boolean
    actualStart?: boolean
    actualEnd?: boolean
    status?: boolean
    plannedVolume?: boolean
    actualVolume?: boolean
    isBlendTarget?: boolean
    isSplitSource?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startTime?: boolean
    endTime?: boolean
    notes?: boolean
    Lot?: boolean | LotDefaultArgs<ExtArgs>
    Tank?: boolean | TankDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tankAssignment"]>

  export type TankAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tankId?: boolean
    lotId?: boolean
    phase?: boolean
    plannedStart?: boolean
    plannedEnd?: boolean
    actualStart?: boolean
    actualEnd?: boolean
    status?: boolean
    plannedVolume?: boolean
    actualVolume?: boolean
    isBlendTarget?: boolean
    isSplitSource?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startTime?: boolean
    endTime?: boolean
    notes?: boolean
    Lot?: boolean | LotDefaultArgs<ExtArgs>
    Tank?: boolean | TankDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tankAssignment"]>

  export type TankAssignmentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    tankId?: boolean
    lotId?: boolean
    phase?: boolean
    plannedStart?: boolean
    plannedEnd?: boolean
    actualStart?: boolean
    actualEnd?: boolean
    status?: boolean
    plannedVolume?: boolean
    actualVolume?: boolean
    isBlendTarget?: boolean
    isSplitSource?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startTime?: boolean
    endTime?: boolean
    notes?: boolean
  }

  export type TankAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lot?: boolean | LotDefaultArgs<ExtArgs>
    Tank?: boolean | TankDefaultArgs<ExtArgs>
  }
  export type TankAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lot?: boolean | LotDefaultArgs<ExtArgs>
    Tank?: boolean | TankDefaultArgs<ExtArgs>
  }

  export type $TankAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TankAssignment"
    objects: {
      Lot: Prisma.$LotPayload<ExtArgs>
      Tank: Prisma.$TankPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      tankId: string
      lotId: string
      phase: $Enums.LotPhase
      plannedStart: Date | null
      plannedEnd: Date | null
      actualStart: Date | null
      actualEnd: Date | null
      status: $Enums.AssignmentStatus
      plannedVolume: Prisma.Decimal | null
      actualVolume: Prisma.Decimal | null
      isBlendTarget: boolean
      isSplitSource: boolean
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
      startTime: Date | null
      endTime: Date | null
      notes: string | null
    }, ExtArgs["result"]["tankAssignment"]>
    composites: {}
  }

  type TankAssignmentGetPayload<S extends boolean | null | undefined | TankAssignmentDefaultArgs> = $Result.GetResult<Prisma.$TankAssignmentPayload, S>

  type TankAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TankAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TankAssignmentCountAggregateInputType | true
    }

  export interface TankAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TankAssignment'], meta: { name: 'TankAssignment' } }
    /**
     * Find zero or one TankAssignment that matches the filter.
     * @param {TankAssignmentFindUniqueArgs} args - Arguments to find a TankAssignment
     * @example
     * // Get one TankAssignment
     * const tankAssignment = await prisma.tankAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TankAssignmentFindUniqueArgs>(args: SelectSubset<T, TankAssignmentFindUniqueArgs<ExtArgs>>): Prisma__TankAssignmentClient<$Result.GetResult<Prisma.$TankAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TankAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TankAssignmentFindUniqueOrThrowArgs} args - Arguments to find a TankAssignment
     * @example
     * // Get one TankAssignment
     * const tankAssignment = await prisma.tankAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TankAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TankAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TankAssignmentClient<$Result.GetResult<Prisma.$TankAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TankAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankAssignmentFindFirstArgs} args - Arguments to find a TankAssignment
     * @example
     * // Get one TankAssignment
     * const tankAssignment = await prisma.tankAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TankAssignmentFindFirstArgs>(args?: SelectSubset<T, TankAssignmentFindFirstArgs<ExtArgs>>): Prisma__TankAssignmentClient<$Result.GetResult<Prisma.$TankAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TankAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankAssignmentFindFirstOrThrowArgs} args - Arguments to find a TankAssignment
     * @example
     * // Get one TankAssignment
     * const tankAssignment = await prisma.tankAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TankAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TankAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TankAssignmentClient<$Result.GetResult<Prisma.$TankAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TankAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TankAssignments
     * const tankAssignments = await prisma.tankAssignment.findMany()
     * 
     * // Get first 10 TankAssignments
     * const tankAssignments = await prisma.tankAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tankAssignmentWithIdOnly = await prisma.tankAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TankAssignmentFindManyArgs>(args?: SelectSubset<T, TankAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TankAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TankAssignment.
     * @param {TankAssignmentCreateArgs} args - Arguments to create a TankAssignment.
     * @example
     * // Create one TankAssignment
     * const TankAssignment = await prisma.tankAssignment.create({
     *   data: {
     *     // ... data to create a TankAssignment
     *   }
     * })
     * 
     */
    create<T extends TankAssignmentCreateArgs>(args: SelectSubset<T, TankAssignmentCreateArgs<ExtArgs>>): Prisma__TankAssignmentClient<$Result.GetResult<Prisma.$TankAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TankAssignments.
     * @param {TankAssignmentCreateManyArgs} args - Arguments to create many TankAssignments.
     * @example
     * // Create many TankAssignments
     * const tankAssignment = await prisma.tankAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TankAssignmentCreateManyArgs>(args?: SelectSubset<T, TankAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TankAssignments and returns the data saved in the database.
     * @param {TankAssignmentCreateManyAndReturnArgs} args - Arguments to create many TankAssignments.
     * @example
     * // Create many TankAssignments
     * const tankAssignment = await prisma.tankAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TankAssignments and only return the `id`
     * const tankAssignmentWithIdOnly = await prisma.tankAssignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TankAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TankAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TankAssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TankAssignment.
     * @param {TankAssignmentDeleteArgs} args - Arguments to delete one TankAssignment.
     * @example
     * // Delete one TankAssignment
     * const TankAssignment = await prisma.tankAssignment.delete({
     *   where: {
     *     // ... filter to delete one TankAssignment
     *   }
     * })
     * 
     */
    delete<T extends TankAssignmentDeleteArgs>(args: SelectSubset<T, TankAssignmentDeleteArgs<ExtArgs>>): Prisma__TankAssignmentClient<$Result.GetResult<Prisma.$TankAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TankAssignment.
     * @param {TankAssignmentUpdateArgs} args - Arguments to update one TankAssignment.
     * @example
     * // Update one TankAssignment
     * const tankAssignment = await prisma.tankAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TankAssignmentUpdateArgs>(args: SelectSubset<T, TankAssignmentUpdateArgs<ExtArgs>>): Prisma__TankAssignmentClient<$Result.GetResult<Prisma.$TankAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TankAssignments.
     * @param {TankAssignmentDeleteManyArgs} args - Arguments to filter TankAssignments to delete.
     * @example
     * // Delete a few TankAssignments
     * const { count } = await prisma.tankAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TankAssignmentDeleteManyArgs>(args?: SelectSubset<T, TankAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TankAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TankAssignments
     * const tankAssignment = await prisma.tankAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TankAssignmentUpdateManyArgs>(args: SelectSubset<T, TankAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TankAssignment.
     * @param {TankAssignmentUpsertArgs} args - Arguments to update or create a TankAssignment.
     * @example
     * // Update or create a TankAssignment
     * const tankAssignment = await prisma.tankAssignment.upsert({
     *   create: {
     *     // ... data to create a TankAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TankAssignment we want to update
     *   }
     * })
     */
    upsert<T extends TankAssignmentUpsertArgs>(args: SelectSubset<T, TankAssignmentUpsertArgs<ExtArgs>>): Prisma__TankAssignmentClient<$Result.GetResult<Prisma.$TankAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TankAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankAssignmentCountArgs} args - Arguments to filter TankAssignments to count.
     * @example
     * // Count the number of TankAssignments
     * const count = await prisma.tankAssignment.count({
     *   where: {
     *     // ... the filter for the TankAssignments we want to count
     *   }
     * })
    **/
    count<T extends TankAssignmentCountArgs>(
      args?: Subset<T, TankAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TankAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TankAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TankAssignmentAggregateArgs>(args: Subset<T, TankAssignmentAggregateArgs>): Prisma.PrismaPromise<GetTankAssignmentAggregateType<T>>

    /**
     * Group by TankAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TankAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TankAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TankAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: TankAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TankAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTankAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TankAssignment model
   */
  readonly fields: TankAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TankAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TankAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Lot<T extends LotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LotDefaultArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Tank<T extends TankDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TankDefaultArgs<ExtArgs>>): Prisma__TankClient<$Result.GetResult<Prisma.$TankPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TankAssignment model
   */ 
  interface TankAssignmentFieldRefs {
    readonly id: FieldRef<"TankAssignment", 'String'>
    readonly tenantId: FieldRef<"TankAssignment", 'String'>
    readonly tankId: FieldRef<"TankAssignment", 'String'>
    readonly lotId: FieldRef<"TankAssignment", 'String'>
    readonly phase: FieldRef<"TankAssignment", 'LotPhase'>
    readonly plannedStart: FieldRef<"TankAssignment", 'DateTime'>
    readonly plannedEnd: FieldRef<"TankAssignment", 'DateTime'>
    readonly actualStart: FieldRef<"TankAssignment", 'DateTime'>
    readonly actualEnd: FieldRef<"TankAssignment", 'DateTime'>
    readonly status: FieldRef<"TankAssignment", 'AssignmentStatus'>
    readonly plannedVolume: FieldRef<"TankAssignment", 'Decimal'>
    readonly actualVolume: FieldRef<"TankAssignment", 'Decimal'>
    readonly isBlendTarget: FieldRef<"TankAssignment", 'Boolean'>
    readonly isSplitSource: FieldRef<"TankAssignment", 'Boolean'>
    readonly createdBy: FieldRef<"TankAssignment", 'String'>
    readonly createdAt: FieldRef<"TankAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"TankAssignment", 'DateTime'>
    readonly startTime: FieldRef<"TankAssignment", 'DateTime'>
    readonly endTime: FieldRef<"TankAssignment", 'DateTime'>
    readonly notes: FieldRef<"TankAssignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TankAssignment findUnique
   */
  export type TankAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankAssignment
     */
    select?: TankAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TankAssignment to fetch.
     */
    where: TankAssignmentWhereUniqueInput
  }

  /**
   * TankAssignment findUniqueOrThrow
   */
  export type TankAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankAssignment
     */
    select?: TankAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TankAssignment to fetch.
     */
    where: TankAssignmentWhereUniqueInput
  }

  /**
   * TankAssignment findFirst
   */
  export type TankAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankAssignment
     */
    select?: TankAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TankAssignment to fetch.
     */
    where?: TankAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TankAssignments to fetch.
     */
    orderBy?: TankAssignmentOrderByWithRelationInput | TankAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TankAssignments.
     */
    cursor?: TankAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TankAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TankAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TankAssignments.
     */
    distinct?: TankAssignmentScalarFieldEnum | TankAssignmentScalarFieldEnum[]
  }

  /**
   * TankAssignment findFirstOrThrow
   */
  export type TankAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankAssignment
     */
    select?: TankAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TankAssignment to fetch.
     */
    where?: TankAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TankAssignments to fetch.
     */
    orderBy?: TankAssignmentOrderByWithRelationInput | TankAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TankAssignments.
     */
    cursor?: TankAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TankAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TankAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TankAssignments.
     */
    distinct?: TankAssignmentScalarFieldEnum | TankAssignmentScalarFieldEnum[]
  }

  /**
   * TankAssignment findMany
   */
  export type TankAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankAssignment
     */
    select?: TankAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TankAssignments to fetch.
     */
    where?: TankAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TankAssignments to fetch.
     */
    orderBy?: TankAssignmentOrderByWithRelationInput | TankAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TankAssignments.
     */
    cursor?: TankAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TankAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TankAssignments.
     */
    skip?: number
    distinct?: TankAssignmentScalarFieldEnum | TankAssignmentScalarFieldEnum[]
  }

  /**
   * TankAssignment create
   */
  export type TankAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankAssignment
     */
    select?: TankAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TankAssignment.
     */
    data: XOR<TankAssignmentCreateInput, TankAssignmentUncheckedCreateInput>
  }

  /**
   * TankAssignment createMany
   */
  export type TankAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TankAssignments.
     */
    data: TankAssignmentCreateManyInput | TankAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TankAssignment createManyAndReturn
   */
  export type TankAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankAssignment
     */
    select?: TankAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TankAssignments.
     */
    data: TankAssignmentCreateManyInput | TankAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TankAssignment update
   */
  export type TankAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankAssignment
     */
    select?: TankAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TankAssignment.
     */
    data: XOR<TankAssignmentUpdateInput, TankAssignmentUncheckedUpdateInput>
    /**
     * Choose, which TankAssignment to update.
     */
    where: TankAssignmentWhereUniqueInput
  }

  /**
   * TankAssignment updateMany
   */
  export type TankAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TankAssignments.
     */
    data: XOR<TankAssignmentUpdateManyMutationInput, TankAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which TankAssignments to update
     */
    where?: TankAssignmentWhereInput
  }

  /**
   * TankAssignment upsert
   */
  export type TankAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankAssignment
     */
    select?: TankAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TankAssignment to update in case it exists.
     */
    where: TankAssignmentWhereUniqueInput
    /**
     * In case the TankAssignment found by the `where` argument doesn't exist, create a new TankAssignment with this data.
     */
    create: XOR<TankAssignmentCreateInput, TankAssignmentUncheckedCreateInput>
    /**
     * In case the TankAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TankAssignmentUpdateInput, TankAssignmentUncheckedUpdateInput>
  }

  /**
   * TankAssignment delete
   */
  export type TankAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankAssignment
     */
    select?: TankAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankAssignmentInclude<ExtArgs> | null
    /**
     * Filter which TankAssignment to delete.
     */
    where: TankAssignmentWhereUniqueInput
  }

  /**
   * TankAssignment deleteMany
   */
  export type TankAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TankAssignments to delete
     */
    where?: TankAssignmentWhereInput
  }

  /**
   * TankAssignment without action
   */
  export type TankAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TankAssignment
     */
    select?: TankAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TankAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Transfer
   */

  export type AggregateTransfer = {
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  export type TransferAvgAggregateOutputType = {
    volume: Decimal | null
    measuredLoss: Decimal | null
  }

  export type TransferSumAggregateOutputType = {
    volume: Decimal | null
    measuredLoss: Decimal | null
  }

  export type TransferMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    transferCode: string | null
    sourceLotId: string | null
    sourceTankId: string | null
    destLotId: string | null
    destTankId: string | null
    transferType: $Enums.TransferType | null
    volume: Decimal | null
    plannedAt: Date | null
    executedAt: Date | null
    status: $Enums.TransferStatus | null
    measuredLoss: Decimal | null
    lossReason: string | null
    performedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    transferCode: string | null
    sourceLotId: string | null
    sourceTankId: string | null
    destLotId: string | null
    destTankId: string | null
    transferType: $Enums.TransferType | null
    volume: Decimal | null
    plannedAt: Date | null
    executedAt: Date | null
    status: $Enums.TransferStatus | null
    measuredLoss: Decimal | null
    lossReason: string | null
    performedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransferCountAggregateOutputType = {
    id: number
    tenantId: number
    transferCode: number
    sourceLotId: number
    sourceTankId: number
    destLotId: number
    destTankId: number
    transferType: number
    volume: number
    plannedAt: number
    executedAt: number
    status: number
    measuredLoss: number
    lossReason: number
    performedBy: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransferAvgAggregateInputType = {
    volume?: true
    measuredLoss?: true
  }

  export type TransferSumAggregateInputType = {
    volume?: true
    measuredLoss?: true
  }

  export type TransferMinAggregateInputType = {
    id?: true
    tenantId?: true
    transferCode?: true
    sourceLotId?: true
    sourceTankId?: true
    destLotId?: true
    destTankId?: true
    transferType?: true
    volume?: true
    plannedAt?: true
    executedAt?: true
    status?: true
    measuredLoss?: true
    lossReason?: true
    performedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferMaxAggregateInputType = {
    id?: true
    tenantId?: true
    transferCode?: true
    sourceLotId?: true
    sourceTankId?: true
    destLotId?: true
    destTankId?: true
    transferType?: true
    volume?: true
    plannedAt?: true
    executedAt?: true
    status?: true
    measuredLoss?: true
    lossReason?: true
    performedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransferCountAggregateInputType = {
    id?: true
    tenantId?: true
    transferCode?: true
    sourceLotId?: true
    sourceTankId?: true
    destLotId?: true
    destTankId?: true
    transferType?: true
    volume?: true
    plannedAt?: true
    executedAt?: true
    status?: true
    measuredLoss?: true
    lossReason?: true
    performedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfer to aggregate.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transfers
    **/
    _count?: true | TransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferMaxAggregateInputType
  }

  export type GetTransferAggregateType<T extends TransferAggregateArgs> = {
        [P in keyof T & keyof AggregateTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransfer[P]>
      : GetScalarType<T[P], AggregateTransfer[P]>
  }




  export type TransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransferWhereInput
    orderBy?: TransferOrderByWithAggregationInput | TransferOrderByWithAggregationInput[]
    by: TransferScalarFieldEnum[] | TransferScalarFieldEnum
    having?: TransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferCountAggregateInputType | true
    _avg?: TransferAvgAggregateInputType
    _sum?: TransferSumAggregateInputType
    _min?: TransferMinAggregateInputType
    _max?: TransferMaxAggregateInputType
  }

  export type TransferGroupByOutputType = {
    id: string
    tenantId: string
    transferCode: string
    sourceLotId: string | null
    sourceTankId: string
    destLotId: string | null
    destTankId: string
    transferType: $Enums.TransferType
    volume: Decimal
    plannedAt: Date
    executedAt: Date | null
    status: $Enums.TransferStatus
    measuredLoss: Decimal | null
    lossReason: string | null
    performedBy: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransferCountAggregateOutputType | null
    _avg: TransferAvgAggregateOutputType | null
    _sum: TransferSumAggregateOutputType | null
    _min: TransferMinAggregateOutputType | null
    _max: TransferMaxAggregateOutputType | null
  }

  type GetTransferGroupByPayload<T extends TransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferGroupByOutputType[P]>
            : GetScalarType<T[P], TransferGroupByOutputType[P]>
        }
      >
    >


  export type TransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    transferCode?: boolean
    sourceLotId?: boolean
    sourceTankId?: boolean
    destLotId?: boolean
    destTankId?: boolean
    transferType?: boolean
    volume?: boolean
    plannedAt?: boolean
    executedAt?: boolean
    status?: boolean
    measuredLoss?: boolean
    lossReason?: boolean
    performedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Lot_Transfer_destLotIdToLot?: boolean | Transfer$Lot_Transfer_destLotIdToLotArgs<ExtArgs>
    Tank_Transfer_destTankIdToTank?: boolean | TankDefaultArgs<ExtArgs>
    Lot_Transfer_sourceLotIdToLot?: boolean | Transfer$Lot_Transfer_sourceLotIdToLotArgs<ExtArgs>
    Tank_Transfer_sourceTankIdToTank?: boolean | TankDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    transferCode?: boolean
    sourceLotId?: boolean
    sourceTankId?: boolean
    destLotId?: boolean
    destTankId?: boolean
    transferType?: boolean
    volume?: boolean
    plannedAt?: boolean
    executedAt?: boolean
    status?: boolean
    measuredLoss?: boolean
    lossReason?: boolean
    performedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Lot_Transfer_destLotIdToLot?: boolean | Transfer$Lot_Transfer_destLotIdToLotArgs<ExtArgs>
    Tank_Transfer_destTankIdToTank?: boolean | TankDefaultArgs<ExtArgs>
    Lot_Transfer_sourceLotIdToLot?: boolean | Transfer$Lot_Transfer_sourceLotIdToLotArgs<ExtArgs>
    Tank_Transfer_sourceTankIdToTank?: boolean | TankDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfer"]>

  export type TransferSelectScalar = {
    id?: boolean
    tenantId?: boolean
    transferCode?: boolean
    sourceLotId?: boolean
    sourceTankId?: boolean
    destLotId?: boolean
    destTankId?: boolean
    transferType?: boolean
    volume?: boolean
    plannedAt?: boolean
    executedAt?: boolean
    status?: boolean
    measuredLoss?: boolean
    lossReason?: boolean
    performedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lot_Transfer_destLotIdToLot?: boolean | Transfer$Lot_Transfer_destLotIdToLotArgs<ExtArgs>
    Tank_Transfer_destTankIdToTank?: boolean | TankDefaultArgs<ExtArgs>
    Lot_Transfer_sourceLotIdToLot?: boolean | Transfer$Lot_Transfer_sourceLotIdToLotArgs<ExtArgs>
    Tank_Transfer_sourceTankIdToTank?: boolean | TankDefaultArgs<ExtArgs>
  }
  export type TransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lot_Transfer_destLotIdToLot?: boolean | Transfer$Lot_Transfer_destLotIdToLotArgs<ExtArgs>
    Tank_Transfer_destTankIdToTank?: boolean | TankDefaultArgs<ExtArgs>
    Lot_Transfer_sourceLotIdToLot?: boolean | Transfer$Lot_Transfer_sourceLotIdToLotArgs<ExtArgs>
    Tank_Transfer_sourceTankIdToTank?: boolean | TankDefaultArgs<ExtArgs>
  }

  export type $TransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transfer"
    objects: {
      Lot_Transfer_destLotIdToLot: Prisma.$LotPayload<ExtArgs> | null
      Tank_Transfer_destTankIdToTank: Prisma.$TankPayload<ExtArgs>
      Lot_Transfer_sourceLotIdToLot: Prisma.$LotPayload<ExtArgs> | null
      Tank_Transfer_sourceTankIdToTank: Prisma.$TankPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      transferCode: string
      sourceLotId: string | null
      sourceTankId: string
      destLotId: string | null
      destTankId: string
      transferType: $Enums.TransferType
      volume: Prisma.Decimal
      plannedAt: Date
      executedAt: Date | null
      status: $Enums.TransferStatus
      measuredLoss: Prisma.Decimal | null
      lossReason: string | null
      performedBy: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transfer"]>
    composites: {}
  }

  type TransferGetPayload<S extends boolean | null | undefined | TransferDefaultArgs> = $Result.GetResult<Prisma.$TransferPayload, S>

  type TransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransferFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransferCountAggregateInputType | true
    }

  export interface TransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transfer'], meta: { name: 'Transfer' } }
    /**
     * Find zero or one Transfer that matches the filter.
     * @param {TransferFindUniqueArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransferFindUniqueArgs>(args: SelectSubset<T, TransferFindUniqueArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transfer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransferFindUniqueOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransferFindUniqueOrThrowArgs>(args: SelectSubset<T, TransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransferFindFirstArgs>(args?: SelectSubset<T, TransferFindFirstArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindFirstOrThrowArgs} args - Arguments to find a Transfer
     * @example
     * // Get one Transfer
     * const transfer = await prisma.transfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransferFindFirstOrThrowArgs>(args?: SelectSubset<T, TransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transfers
     * const transfers = await prisma.transfer.findMany()
     * 
     * // Get first 10 Transfers
     * const transfers = await prisma.transfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transferWithIdOnly = await prisma.transfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransferFindManyArgs>(args?: SelectSubset<T, TransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transfer.
     * @param {TransferCreateArgs} args - Arguments to create a Transfer.
     * @example
     * // Create one Transfer
     * const Transfer = await prisma.transfer.create({
     *   data: {
     *     // ... data to create a Transfer
     *   }
     * })
     * 
     */
    create<T extends TransferCreateArgs>(args: SelectSubset<T, TransferCreateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transfers.
     * @param {TransferCreateManyArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransferCreateManyArgs>(args?: SelectSubset<T, TransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transfers and returns the data saved in the database.
     * @param {TransferCreateManyAndReturnArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfer = await prisma.transfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transfers and only return the `id`
     * const transferWithIdOnly = await prisma.transfer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransferCreateManyAndReturnArgs>(args?: SelectSubset<T, TransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transfer.
     * @param {TransferDeleteArgs} args - Arguments to delete one Transfer.
     * @example
     * // Delete one Transfer
     * const Transfer = await prisma.transfer.delete({
     *   where: {
     *     // ... filter to delete one Transfer
     *   }
     * })
     * 
     */
    delete<T extends TransferDeleteArgs>(args: SelectSubset<T, TransferDeleteArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transfer.
     * @param {TransferUpdateArgs} args - Arguments to update one Transfer.
     * @example
     * // Update one Transfer
     * const transfer = await prisma.transfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransferUpdateArgs>(args: SelectSubset<T, TransferUpdateArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transfers.
     * @param {TransferDeleteManyArgs} args - Arguments to filter Transfers to delete.
     * @example
     * // Delete a few Transfers
     * const { count } = await prisma.transfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransferDeleteManyArgs>(args?: SelectSubset<T, TransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transfers
     * const transfer = await prisma.transfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransferUpdateManyArgs>(args: SelectSubset<T, TransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transfer.
     * @param {TransferUpsertArgs} args - Arguments to update or create a Transfer.
     * @example
     * // Update or create a Transfer
     * const transfer = await prisma.transfer.upsert({
     *   create: {
     *     // ... data to create a Transfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transfer we want to update
     *   }
     * })
     */
    upsert<T extends TransferUpsertArgs>(args: SelectSubset<T, TransferUpsertArgs<ExtArgs>>): Prisma__TransferClient<$Result.GetResult<Prisma.$TransferPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferCountArgs} args - Arguments to filter Transfers to count.
     * @example
     * // Count the number of Transfers
     * const count = await prisma.transfer.count({
     *   where: {
     *     // ... the filter for the Transfers we want to count
     *   }
     * })
    **/
    count<T extends TransferCountArgs>(
      args?: Subset<T, TransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferAggregateArgs>(args: Subset<T, TransferAggregateArgs>): Prisma.PrismaPromise<GetTransferAggregateType<T>>

    /**
     * Group by Transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransferGroupByArgs['orderBy'] }
        : { orderBy?: TransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transfer model
   */
  readonly fields: TransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Lot_Transfer_destLotIdToLot<T extends Transfer$Lot_Transfer_destLotIdToLotArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$Lot_Transfer_destLotIdToLotArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Tank_Transfer_destTankIdToTank<T extends TankDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TankDefaultArgs<ExtArgs>>): Prisma__TankClient<$Result.GetResult<Prisma.$TankPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Lot_Transfer_sourceLotIdToLot<T extends Transfer$Lot_Transfer_sourceLotIdToLotArgs<ExtArgs> = {}>(args?: Subset<T, Transfer$Lot_Transfer_sourceLotIdToLotArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Tank_Transfer_sourceTankIdToTank<T extends TankDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TankDefaultArgs<ExtArgs>>): Prisma__TankClient<$Result.GetResult<Prisma.$TankPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transfer model
   */ 
  interface TransferFieldRefs {
    readonly id: FieldRef<"Transfer", 'String'>
    readonly tenantId: FieldRef<"Transfer", 'String'>
    readonly transferCode: FieldRef<"Transfer", 'String'>
    readonly sourceLotId: FieldRef<"Transfer", 'String'>
    readonly sourceTankId: FieldRef<"Transfer", 'String'>
    readonly destLotId: FieldRef<"Transfer", 'String'>
    readonly destTankId: FieldRef<"Transfer", 'String'>
    readonly transferType: FieldRef<"Transfer", 'TransferType'>
    readonly volume: FieldRef<"Transfer", 'Decimal'>
    readonly plannedAt: FieldRef<"Transfer", 'DateTime'>
    readonly executedAt: FieldRef<"Transfer", 'DateTime'>
    readonly status: FieldRef<"Transfer", 'TransferStatus'>
    readonly measuredLoss: FieldRef<"Transfer", 'Decimal'>
    readonly lossReason: FieldRef<"Transfer", 'String'>
    readonly performedBy: FieldRef<"Transfer", 'String'>
    readonly notes: FieldRef<"Transfer", 'String'>
    readonly createdAt: FieldRef<"Transfer", 'DateTime'>
    readonly updatedAt: FieldRef<"Transfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transfer findUnique
   */
  export type TransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findUniqueOrThrow
   */
  export type TransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer findFirst
   */
  export type TransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findFirstOrThrow
   */
  export type TransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfer to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transfers.
     */
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer findMany
   */
  export type TransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter, which Transfers to fetch.
     */
    where?: TransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transfers to fetch.
     */
    orderBy?: TransferOrderByWithRelationInput | TransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transfers.
     */
    cursor?: TransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transfers.
     */
    skip?: number
    distinct?: TransferScalarFieldEnum | TransferScalarFieldEnum[]
  }

  /**
   * Transfer create
   */
  export type TransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to create a Transfer.
     */
    data: XOR<TransferCreateInput, TransferUncheckedCreateInput>
  }

  /**
   * Transfer createMany
   */
  export type TransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transfer createManyAndReturn
   */
  export type TransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transfers.
     */
    data: TransferCreateManyInput | TransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transfer update
   */
  export type TransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The data needed to update a Transfer.
     */
    data: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
    /**
     * Choose, which Transfer to update.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer updateMany
   */
  export type TransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transfers.
     */
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyInput>
    /**
     * Filter which Transfers to update
     */
    where?: TransferWhereInput
  }

  /**
   * Transfer upsert
   */
  export type TransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * The filter to search for the Transfer to update in case it exists.
     */
    where: TransferWhereUniqueInput
    /**
     * In case the Transfer found by the `where` argument doesn't exist, create a new Transfer with this data.
     */
    create: XOR<TransferCreateInput, TransferUncheckedCreateInput>
    /**
     * In case the Transfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransferUpdateInput, TransferUncheckedUpdateInput>
  }

  /**
   * Transfer delete
   */
  export type TransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
    /**
     * Filter which Transfer to delete.
     */
    where: TransferWhereUniqueInput
  }

  /**
   * Transfer deleteMany
   */
  export type TransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transfers to delete
     */
    where?: TransferWhereInput
  }

  /**
   * Transfer.Lot_Transfer_destLotIdToLot
   */
  export type Transfer$Lot_Transfer_destLotIdToLotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    where?: LotWhereInput
  }

  /**
   * Transfer.Lot_Transfer_sourceLotIdToLot
   */
  export type Transfer$Lot_Transfer_sourceLotIdToLotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    where?: LotWhereInput
  }

  /**
   * Transfer without action
   */
  export type TransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transfer
     */
    select?: TransferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransferInclude<ExtArgs> | null
  }


  /**
   * Model Keg
   */

  export type AggregateKeg = {
    _count: KegCountAggregateOutputType | null
    _avg: KegAvgAggregateOutputType | null
    _sum: KegSumAggregateOutputType | null
    _min: KegMinAggregateOutputType | null
    _max: KegMaxAggregateOutputType | null
  }

  export type KegAvgAggregateOutputType = {
    size: number | null
    deposit: Decimal | null
  }

  export type KegSumAggregateOutputType = {
    size: number | null
    deposit: Decimal | null
  }

  export type KegMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    kegNumber: string | null
    size: number | null
    status: $Enums.KegStatus | null
    condition: $Enums.KegCondition | null
    batchId: string | null
    filledAt: Date | null
    productName: string | null
    lotNumber: string | null
    customerId: string | null
    orderId: string | null
    sentAt: Date | null
    returnedAt: Date | null
    deposit: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KegMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    kegNumber: string | null
    size: number | null
    status: $Enums.KegStatus | null
    condition: $Enums.KegCondition | null
    batchId: string | null
    filledAt: Date | null
    productName: string | null
    lotNumber: string | null
    customerId: string | null
    orderId: string | null
    sentAt: Date | null
    returnedAt: Date | null
    deposit: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KegCountAggregateOutputType = {
    id: number
    tenantId: number
    kegNumber: number
    size: number
    status: number
    condition: number
    batchId: number
    filledAt: number
    productName: number
    lotNumber: number
    customerId: number
    orderId: number
    sentAt: number
    returnedAt: number
    deposit: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KegAvgAggregateInputType = {
    size?: true
    deposit?: true
  }

  export type KegSumAggregateInputType = {
    size?: true
    deposit?: true
  }

  export type KegMinAggregateInputType = {
    id?: true
    tenantId?: true
    kegNumber?: true
    size?: true
    status?: true
    condition?: true
    batchId?: true
    filledAt?: true
    productName?: true
    lotNumber?: true
    customerId?: true
    orderId?: true
    sentAt?: true
    returnedAt?: true
    deposit?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KegMaxAggregateInputType = {
    id?: true
    tenantId?: true
    kegNumber?: true
    size?: true
    status?: true
    condition?: true
    batchId?: true
    filledAt?: true
    productName?: true
    lotNumber?: true
    customerId?: true
    orderId?: true
    sentAt?: true
    returnedAt?: true
    deposit?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KegCountAggregateInputType = {
    id?: true
    tenantId?: true
    kegNumber?: true
    size?: true
    status?: true
    condition?: true
    batchId?: true
    filledAt?: true
    productName?: true
    lotNumber?: true
    customerId?: true
    orderId?: true
    sentAt?: true
    returnedAt?: true
    deposit?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KegAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Keg to aggregate.
     */
    where?: KegWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kegs to fetch.
     */
    orderBy?: KegOrderByWithRelationInput | KegOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KegWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kegs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kegs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kegs
    **/
    _count?: true | KegCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KegAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KegSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KegMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KegMaxAggregateInputType
  }

  export type GetKegAggregateType<T extends KegAggregateArgs> = {
        [P in keyof T & keyof AggregateKeg]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeg[P]>
      : GetScalarType<T[P], AggregateKeg[P]>
  }




  export type KegGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KegWhereInput
    orderBy?: KegOrderByWithAggregationInput | KegOrderByWithAggregationInput[]
    by: KegScalarFieldEnum[] | KegScalarFieldEnum
    having?: KegScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KegCountAggregateInputType | true
    _avg?: KegAvgAggregateInputType
    _sum?: KegSumAggregateInputType
    _min?: KegMinAggregateInputType
    _max?: KegMaxAggregateInputType
  }

  export type KegGroupByOutputType = {
    id: string
    tenantId: string
    kegNumber: string
    size: number
    status: $Enums.KegStatus
    condition: $Enums.KegCondition
    batchId: string | null
    filledAt: Date | null
    productName: string | null
    lotNumber: string | null
    customerId: string | null
    orderId: string | null
    sentAt: Date | null
    returnedAt: Date | null
    deposit: Decimal
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: KegCountAggregateOutputType | null
    _avg: KegAvgAggregateOutputType | null
    _sum: KegSumAggregateOutputType | null
    _min: KegMinAggregateOutputType | null
    _max: KegMaxAggregateOutputType | null
  }

  type GetKegGroupByPayload<T extends KegGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KegGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KegGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KegGroupByOutputType[P]>
            : GetScalarType<T[P], KegGroupByOutputType[P]>
        }
      >
    >


  export type KegSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    kegNumber?: boolean
    size?: boolean
    status?: boolean
    condition?: boolean
    batchId?: boolean
    filledAt?: boolean
    productName?: boolean
    lotNumber?: boolean
    customerId?: boolean
    orderId?: boolean
    sentAt?: boolean
    returnedAt?: boolean
    deposit?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Batch?: boolean | Keg$BatchArgs<ExtArgs>
    Customer?: boolean | Keg$CustomerArgs<ExtArgs>
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
    movements?: boolean | Keg$movementsArgs<ExtArgs>
    _count?: boolean | KegCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keg"]>

  export type KegSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    kegNumber?: boolean
    size?: boolean
    status?: boolean
    condition?: boolean
    batchId?: boolean
    filledAt?: boolean
    productName?: boolean
    lotNumber?: boolean
    customerId?: boolean
    orderId?: boolean
    sentAt?: boolean
    returnedAt?: boolean
    deposit?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Batch?: boolean | Keg$BatchArgs<ExtArgs>
    Customer?: boolean | Keg$CustomerArgs<ExtArgs>
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keg"]>

  export type KegSelectScalar = {
    id?: boolean
    tenantId?: boolean
    kegNumber?: boolean
    size?: boolean
    status?: boolean
    condition?: boolean
    batchId?: boolean
    filledAt?: boolean
    productName?: boolean
    lotNumber?: boolean
    customerId?: boolean
    orderId?: boolean
    sentAt?: boolean
    returnedAt?: boolean
    deposit?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KegInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | Keg$BatchArgs<ExtArgs>
    Customer?: boolean | Keg$CustomerArgs<ExtArgs>
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
    movements?: boolean | Keg$movementsArgs<ExtArgs>
    _count?: boolean | KegCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KegIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | Keg$BatchArgs<ExtArgs>
    Customer?: boolean | Keg$CustomerArgs<ExtArgs>
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $KegPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Keg"
    objects: {
      Batch: Prisma.$BatchPayload<ExtArgs> | null
      Customer: Prisma.$CustomerPayload<ExtArgs> | null
      Tenant: Prisma.$TenantPayload<ExtArgs>
      movements: Prisma.$KegMovementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      kegNumber: string
      size: number
      status: $Enums.KegStatus
      condition: $Enums.KegCondition
      batchId: string | null
      filledAt: Date | null
      productName: string | null
      lotNumber: string | null
      customerId: string | null
      orderId: string | null
      sentAt: Date | null
      returnedAt: Date | null
      deposit: Prisma.Decimal
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["keg"]>
    composites: {}
  }

  type KegGetPayload<S extends boolean | null | undefined | KegDefaultArgs> = $Result.GetResult<Prisma.$KegPayload, S>

  type KegCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KegFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KegCountAggregateInputType | true
    }

  export interface KegDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Keg'], meta: { name: 'Keg' } }
    /**
     * Find zero or one Keg that matches the filter.
     * @param {KegFindUniqueArgs} args - Arguments to find a Keg
     * @example
     * // Get one Keg
     * const keg = await prisma.keg.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KegFindUniqueArgs>(args: SelectSubset<T, KegFindUniqueArgs<ExtArgs>>): Prisma__KegClient<$Result.GetResult<Prisma.$KegPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Keg that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KegFindUniqueOrThrowArgs} args - Arguments to find a Keg
     * @example
     * // Get one Keg
     * const keg = await prisma.keg.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KegFindUniqueOrThrowArgs>(args: SelectSubset<T, KegFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KegClient<$Result.GetResult<Prisma.$KegPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Keg that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KegFindFirstArgs} args - Arguments to find a Keg
     * @example
     * // Get one Keg
     * const keg = await prisma.keg.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KegFindFirstArgs>(args?: SelectSubset<T, KegFindFirstArgs<ExtArgs>>): Prisma__KegClient<$Result.GetResult<Prisma.$KegPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Keg that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KegFindFirstOrThrowArgs} args - Arguments to find a Keg
     * @example
     * // Get one Keg
     * const keg = await prisma.keg.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KegFindFirstOrThrowArgs>(args?: SelectSubset<T, KegFindFirstOrThrowArgs<ExtArgs>>): Prisma__KegClient<$Result.GetResult<Prisma.$KegPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Kegs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KegFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kegs
     * const kegs = await prisma.keg.findMany()
     * 
     * // Get first 10 Kegs
     * const kegs = await prisma.keg.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kegWithIdOnly = await prisma.keg.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KegFindManyArgs>(args?: SelectSubset<T, KegFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KegPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Keg.
     * @param {KegCreateArgs} args - Arguments to create a Keg.
     * @example
     * // Create one Keg
     * const Keg = await prisma.keg.create({
     *   data: {
     *     // ... data to create a Keg
     *   }
     * })
     * 
     */
    create<T extends KegCreateArgs>(args: SelectSubset<T, KegCreateArgs<ExtArgs>>): Prisma__KegClient<$Result.GetResult<Prisma.$KegPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Kegs.
     * @param {KegCreateManyArgs} args - Arguments to create many Kegs.
     * @example
     * // Create many Kegs
     * const keg = await prisma.keg.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KegCreateManyArgs>(args?: SelectSubset<T, KegCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kegs and returns the data saved in the database.
     * @param {KegCreateManyAndReturnArgs} args - Arguments to create many Kegs.
     * @example
     * // Create many Kegs
     * const keg = await prisma.keg.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kegs and only return the `id`
     * const kegWithIdOnly = await prisma.keg.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KegCreateManyAndReturnArgs>(args?: SelectSubset<T, KegCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KegPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Keg.
     * @param {KegDeleteArgs} args - Arguments to delete one Keg.
     * @example
     * // Delete one Keg
     * const Keg = await prisma.keg.delete({
     *   where: {
     *     // ... filter to delete one Keg
     *   }
     * })
     * 
     */
    delete<T extends KegDeleteArgs>(args: SelectSubset<T, KegDeleteArgs<ExtArgs>>): Prisma__KegClient<$Result.GetResult<Prisma.$KegPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Keg.
     * @param {KegUpdateArgs} args - Arguments to update one Keg.
     * @example
     * // Update one Keg
     * const keg = await prisma.keg.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KegUpdateArgs>(args: SelectSubset<T, KegUpdateArgs<ExtArgs>>): Prisma__KegClient<$Result.GetResult<Prisma.$KegPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Kegs.
     * @param {KegDeleteManyArgs} args - Arguments to filter Kegs to delete.
     * @example
     * // Delete a few Kegs
     * const { count } = await prisma.keg.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KegDeleteManyArgs>(args?: SelectSubset<T, KegDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kegs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KegUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kegs
     * const keg = await prisma.keg.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KegUpdateManyArgs>(args: SelectSubset<T, KegUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Keg.
     * @param {KegUpsertArgs} args - Arguments to update or create a Keg.
     * @example
     * // Update or create a Keg
     * const keg = await prisma.keg.upsert({
     *   create: {
     *     // ... data to create a Keg
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Keg we want to update
     *   }
     * })
     */
    upsert<T extends KegUpsertArgs>(args: SelectSubset<T, KegUpsertArgs<ExtArgs>>): Prisma__KegClient<$Result.GetResult<Prisma.$KegPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Kegs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KegCountArgs} args - Arguments to filter Kegs to count.
     * @example
     * // Count the number of Kegs
     * const count = await prisma.keg.count({
     *   where: {
     *     // ... the filter for the Kegs we want to count
     *   }
     * })
    **/
    count<T extends KegCountArgs>(
      args?: Subset<T, KegCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KegCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Keg.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KegAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KegAggregateArgs>(args: Subset<T, KegAggregateArgs>): Prisma.PrismaPromise<GetKegAggregateType<T>>

    /**
     * Group by Keg.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KegGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KegGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KegGroupByArgs['orderBy'] }
        : { orderBy?: KegGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KegGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKegGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Keg model
   */
  readonly fields: KegFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Keg.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KegClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Batch<T extends Keg$BatchArgs<ExtArgs> = {}>(args?: Subset<T, Keg$BatchArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Customer<T extends Keg$CustomerArgs<ExtArgs> = {}>(args?: Subset<T, Keg$CustomerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    movements<T extends Keg$movementsArgs<ExtArgs> = {}>(args?: Subset<T, Keg$movementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KegMovementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Keg model
   */ 
  interface KegFieldRefs {
    readonly id: FieldRef<"Keg", 'String'>
    readonly tenantId: FieldRef<"Keg", 'String'>
    readonly kegNumber: FieldRef<"Keg", 'String'>
    readonly size: FieldRef<"Keg", 'Int'>
    readonly status: FieldRef<"Keg", 'KegStatus'>
    readonly condition: FieldRef<"Keg", 'KegCondition'>
    readonly batchId: FieldRef<"Keg", 'String'>
    readonly filledAt: FieldRef<"Keg", 'DateTime'>
    readonly productName: FieldRef<"Keg", 'String'>
    readonly lotNumber: FieldRef<"Keg", 'String'>
    readonly customerId: FieldRef<"Keg", 'String'>
    readonly orderId: FieldRef<"Keg", 'String'>
    readonly sentAt: FieldRef<"Keg", 'DateTime'>
    readonly returnedAt: FieldRef<"Keg", 'DateTime'>
    readonly deposit: FieldRef<"Keg", 'Decimal'>
    readonly notes: FieldRef<"Keg", 'String'>
    readonly createdAt: FieldRef<"Keg", 'DateTime'>
    readonly updatedAt: FieldRef<"Keg", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Keg findUnique
   */
  export type KegFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keg
     */
    select?: KegSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegInclude<ExtArgs> | null
    /**
     * Filter, which Keg to fetch.
     */
    where: KegWhereUniqueInput
  }

  /**
   * Keg findUniqueOrThrow
   */
  export type KegFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keg
     */
    select?: KegSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegInclude<ExtArgs> | null
    /**
     * Filter, which Keg to fetch.
     */
    where: KegWhereUniqueInput
  }

  /**
   * Keg findFirst
   */
  export type KegFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keg
     */
    select?: KegSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegInclude<ExtArgs> | null
    /**
     * Filter, which Keg to fetch.
     */
    where?: KegWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kegs to fetch.
     */
    orderBy?: KegOrderByWithRelationInput | KegOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kegs.
     */
    cursor?: KegWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kegs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kegs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kegs.
     */
    distinct?: KegScalarFieldEnum | KegScalarFieldEnum[]
  }

  /**
   * Keg findFirstOrThrow
   */
  export type KegFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keg
     */
    select?: KegSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegInclude<ExtArgs> | null
    /**
     * Filter, which Keg to fetch.
     */
    where?: KegWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kegs to fetch.
     */
    orderBy?: KegOrderByWithRelationInput | KegOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kegs.
     */
    cursor?: KegWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kegs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kegs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kegs.
     */
    distinct?: KegScalarFieldEnum | KegScalarFieldEnum[]
  }

  /**
   * Keg findMany
   */
  export type KegFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keg
     */
    select?: KegSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegInclude<ExtArgs> | null
    /**
     * Filter, which Kegs to fetch.
     */
    where?: KegWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kegs to fetch.
     */
    orderBy?: KegOrderByWithRelationInput | KegOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kegs.
     */
    cursor?: KegWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kegs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kegs.
     */
    skip?: number
    distinct?: KegScalarFieldEnum | KegScalarFieldEnum[]
  }

  /**
   * Keg create
   */
  export type KegCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keg
     */
    select?: KegSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegInclude<ExtArgs> | null
    /**
     * The data needed to create a Keg.
     */
    data: XOR<KegCreateInput, KegUncheckedCreateInput>
  }

  /**
   * Keg createMany
   */
  export type KegCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Kegs.
     */
    data: KegCreateManyInput | KegCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Keg createManyAndReturn
   */
  export type KegCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keg
     */
    select?: KegSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Kegs.
     */
    data: KegCreateManyInput | KegCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Keg update
   */
  export type KegUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keg
     */
    select?: KegSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegInclude<ExtArgs> | null
    /**
     * The data needed to update a Keg.
     */
    data: XOR<KegUpdateInput, KegUncheckedUpdateInput>
    /**
     * Choose, which Keg to update.
     */
    where: KegWhereUniqueInput
  }

  /**
   * Keg updateMany
   */
  export type KegUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Kegs.
     */
    data: XOR<KegUpdateManyMutationInput, KegUncheckedUpdateManyInput>
    /**
     * Filter which Kegs to update
     */
    where?: KegWhereInput
  }

  /**
   * Keg upsert
   */
  export type KegUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keg
     */
    select?: KegSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegInclude<ExtArgs> | null
    /**
     * The filter to search for the Keg to update in case it exists.
     */
    where: KegWhereUniqueInput
    /**
     * In case the Keg found by the `where` argument doesn't exist, create a new Keg with this data.
     */
    create: XOR<KegCreateInput, KegUncheckedCreateInput>
    /**
     * In case the Keg was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KegUpdateInput, KegUncheckedUpdateInput>
  }

  /**
   * Keg delete
   */
  export type KegDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keg
     */
    select?: KegSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegInclude<ExtArgs> | null
    /**
     * Filter which Keg to delete.
     */
    where: KegWhereUniqueInput
  }

  /**
   * Keg deleteMany
   */
  export type KegDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kegs to delete
     */
    where?: KegWhereInput
  }

  /**
   * Keg.Batch
   */
  export type Keg$BatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
  }

  /**
   * Keg.Customer
   */
  export type Keg$CustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Keg.movements
   */
  export type Keg$movementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KegMovement
     */
    select?: KegMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegMovementInclude<ExtArgs> | null
    where?: KegMovementWhereInput
    orderBy?: KegMovementOrderByWithRelationInput | KegMovementOrderByWithRelationInput[]
    cursor?: KegMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KegMovementScalarFieldEnum | KegMovementScalarFieldEnum[]
  }

  /**
   * Keg without action
   */
  export type KegDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keg
     */
    select?: KegSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegInclude<ExtArgs> | null
  }


  /**
   * Model KegMovement
   */

  export type AggregateKegMovement = {
    _count: KegMovementCountAggregateOutputType | null
    _min: KegMovementMinAggregateOutputType | null
    _max: KegMovementMaxAggregateOutputType | null
  }

  export type KegMovementMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    kegId: string | null
    action: $Enums.KegAction | null
    fromStatus: $Enums.KegStatus | null
    toStatus: $Enums.KegStatus | null
    productId: string | null
    productName: string | null
    customerId: string | null
    customerName: string | null
    orderId: string | null
    batchId: string | null
    notes: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type KegMovementMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    kegId: string | null
    action: $Enums.KegAction | null
    fromStatus: $Enums.KegStatus | null
    toStatus: $Enums.KegStatus | null
    productId: string | null
    productName: string | null
    customerId: string | null
    customerName: string | null
    orderId: string | null
    batchId: string | null
    notes: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type KegMovementCountAggregateOutputType = {
    id: number
    tenantId: number
    kegId: number
    action: number
    fromStatus: number
    toStatus: number
    productId: number
    productName: number
    customerId: number
    customerName: number
    orderId: number
    batchId: number
    notes: number
    createdAt: number
    createdBy: number
    _all: number
  }


  export type KegMovementMinAggregateInputType = {
    id?: true
    tenantId?: true
    kegId?: true
    action?: true
    fromStatus?: true
    toStatus?: true
    productId?: true
    productName?: true
    customerId?: true
    customerName?: true
    orderId?: true
    batchId?: true
    notes?: true
    createdAt?: true
    createdBy?: true
  }

  export type KegMovementMaxAggregateInputType = {
    id?: true
    tenantId?: true
    kegId?: true
    action?: true
    fromStatus?: true
    toStatus?: true
    productId?: true
    productName?: true
    customerId?: true
    customerName?: true
    orderId?: true
    batchId?: true
    notes?: true
    createdAt?: true
    createdBy?: true
  }

  export type KegMovementCountAggregateInputType = {
    id?: true
    tenantId?: true
    kegId?: true
    action?: true
    fromStatus?: true
    toStatus?: true
    productId?: true
    productName?: true
    customerId?: true
    customerName?: true
    orderId?: true
    batchId?: true
    notes?: true
    createdAt?: true
    createdBy?: true
    _all?: true
  }

  export type KegMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KegMovement to aggregate.
     */
    where?: KegMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KegMovements to fetch.
     */
    orderBy?: KegMovementOrderByWithRelationInput | KegMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KegMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KegMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KegMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KegMovements
    **/
    _count?: true | KegMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KegMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KegMovementMaxAggregateInputType
  }

  export type GetKegMovementAggregateType<T extends KegMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateKegMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKegMovement[P]>
      : GetScalarType<T[P], AggregateKegMovement[P]>
  }




  export type KegMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KegMovementWhereInput
    orderBy?: KegMovementOrderByWithAggregationInput | KegMovementOrderByWithAggregationInput[]
    by: KegMovementScalarFieldEnum[] | KegMovementScalarFieldEnum
    having?: KegMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KegMovementCountAggregateInputType | true
    _min?: KegMovementMinAggregateInputType
    _max?: KegMovementMaxAggregateInputType
  }

  export type KegMovementGroupByOutputType = {
    id: string
    tenantId: string
    kegId: string
    action: $Enums.KegAction
    fromStatus: $Enums.KegStatus
    toStatus: $Enums.KegStatus
    productId: string | null
    productName: string | null
    customerId: string | null
    customerName: string | null
    orderId: string | null
    batchId: string | null
    notes: string | null
    createdAt: Date
    createdBy: string | null
    _count: KegMovementCountAggregateOutputType | null
    _min: KegMovementMinAggregateOutputType | null
    _max: KegMovementMaxAggregateOutputType | null
  }

  type GetKegMovementGroupByPayload<T extends KegMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KegMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KegMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KegMovementGroupByOutputType[P]>
            : GetScalarType<T[P], KegMovementGroupByOutputType[P]>
        }
      >
    >


  export type KegMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    kegId?: boolean
    action?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    productId?: boolean
    productName?: boolean
    customerId?: boolean
    customerName?: boolean
    orderId?: boolean
    batchId?: boolean
    notes?: boolean
    createdAt?: boolean
    createdBy?: boolean
    keg?: boolean | KegDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kegMovement"]>

  export type KegMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    kegId?: boolean
    action?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    productId?: boolean
    productName?: boolean
    customerId?: boolean
    customerName?: boolean
    orderId?: boolean
    batchId?: boolean
    notes?: boolean
    createdAt?: boolean
    createdBy?: boolean
    keg?: boolean | KegDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kegMovement"]>

  export type KegMovementSelectScalar = {
    id?: boolean
    tenantId?: boolean
    kegId?: boolean
    action?: boolean
    fromStatus?: boolean
    toStatus?: boolean
    productId?: boolean
    productName?: boolean
    customerId?: boolean
    customerName?: boolean
    orderId?: boolean
    batchId?: boolean
    notes?: boolean
    createdAt?: boolean
    createdBy?: boolean
  }

  export type KegMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keg?: boolean | KegDefaultArgs<ExtArgs>
  }
  export type KegMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keg?: boolean | KegDefaultArgs<ExtArgs>
  }

  export type $KegMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KegMovement"
    objects: {
      keg: Prisma.$KegPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      kegId: string
      action: $Enums.KegAction
      fromStatus: $Enums.KegStatus
      toStatus: $Enums.KegStatus
      productId: string | null
      productName: string | null
      customerId: string | null
      customerName: string | null
      orderId: string | null
      batchId: string | null
      notes: string | null
      createdAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["kegMovement"]>
    composites: {}
  }

  type KegMovementGetPayload<S extends boolean | null | undefined | KegMovementDefaultArgs> = $Result.GetResult<Prisma.$KegMovementPayload, S>

  type KegMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KegMovementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KegMovementCountAggregateInputType | true
    }

  export interface KegMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KegMovement'], meta: { name: 'KegMovement' } }
    /**
     * Find zero or one KegMovement that matches the filter.
     * @param {KegMovementFindUniqueArgs} args - Arguments to find a KegMovement
     * @example
     * // Get one KegMovement
     * const kegMovement = await prisma.kegMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KegMovementFindUniqueArgs>(args: SelectSubset<T, KegMovementFindUniqueArgs<ExtArgs>>): Prisma__KegMovementClient<$Result.GetResult<Prisma.$KegMovementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KegMovement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KegMovementFindUniqueOrThrowArgs} args - Arguments to find a KegMovement
     * @example
     * // Get one KegMovement
     * const kegMovement = await prisma.kegMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KegMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, KegMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KegMovementClient<$Result.GetResult<Prisma.$KegMovementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KegMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KegMovementFindFirstArgs} args - Arguments to find a KegMovement
     * @example
     * // Get one KegMovement
     * const kegMovement = await prisma.kegMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KegMovementFindFirstArgs>(args?: SelectSubset<T, KegMovementFindFirstArgs<ExtArgs>>): Prisma__KegMovementClient<$Result.GetResult<Prisma.$KegMovementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KegMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KegMovementFindFirstOrThrowArgs} args - Arguments to find a KegMovement
     * @example
     * // Get one KegMovement
     * const kegMovement = await prisma.kegMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KegMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, KegMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__KegMovementClient<$Result.GetResult<Prisma.$KegMovementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KegMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KegMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KegMovements
     * const kegMovements = await prisma.kegMovement.findMany()
     * 
     * // Get first 10 KegMovements
     * const kegMovements = await prisma.kegMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kegMovementWithIdOnly = await prisma.kegMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KegMovementFindManyArgs>(args?: SelectSubset<T, KegMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KegMovementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KegMovement.
     * @param {KegMovementCreateArgs} args - Arguments to create a KegMovement.
     * @example
     * // Create one KegMovement
     * const KegMovement = await prisma.kegMovement.create({
     *   data: {
     *     // ... data to create a KegMovement
     *   }
     * })
     * 
     */
    create<T extends KegMovementCreateArgs>(args: SelectSubset<T, KegMovementCreateArgs<ExtArgs>>): Prisma__KegMovementClient<$Result.GetResult<Prisma.$KegMovementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KegMovements.
     * @param {KegMovementCreateManyArgs} args - Arguments to create many KegMovements.
     * @example
     * // Create many KegMovements
     * const kegMovement = await prisma.kegMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KegMovementCreateManyArgs>(args?: SelectSubset<T, KegMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KegMovements and returns the data saved in the database.
     * @param {KegMovementCreateManyAndReturnArgs} args - Arguments to create many KegMovements.
     * @example
     * // Create many KegMovements
     * const kegMovement = await prisma.kegMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KegMovements and only return the `id`
     * const kegMovementWithIdOnly = await prisma.kegMovement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KegMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, KegMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KegMovementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a KegMovement.
     * @param {KegMovementDeleteArgs} args - Arguments to delete one KegMovement.
     * @example
     * // Delete one KegMovement
     * const KegMovement = await prisma.kegMovement.delete({
     *   where: {
     *     // ... filter to delete one KegMovement
     *   }
     * })
     * 
     */
    delete<T extends KegMovementDeleteArgs>(args: SelectSubset<T, KegMovementDeleteArgs<ExtArgs>>): Prisma__KegMovementClient<$Result.GetResult<Prisma.$KegMovementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KegMovement.
     * @param {KegMovementUpdateArgs} args - Arguments to update one KegMovement.
     * @example
     * // Update one KegMovement
     * const kegMovement = await prisma.kegMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KegMovementUpdateArgs>(args: SelectSubset<T, KegMovementUpdateArgs<ExtArgs>>): Prisma__KegMovementClient<$Result.GetResult<Prisma.$KegMovementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KegMovements.
     * @param {KegMovementDeleteManyArgs} args - Arguments to filter KegMovements to delete.
     * @example
     * // Delete a few KegMovements
     * const { count } = await prisma.kegMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KegMovementDeleteManyArgs>(args?: SelectSubset<T, KegMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KegMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KegMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KegMovements
     * const kegMovement = await prisma.kegMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KegMovementUpdateManyArgs>(args: SelectSubset<T, KegMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KegMovement.
     * @param {KegMovementUpsertArgs} args - Arguments to update or create a KegMovement.
     * @example
     * // Update or create a KegMovement
     * const kegMovement = await prisma.kegMovement.upsert({
     *   create: {
     *     // ... data to create a KegMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KegMovement we want to update
     *   }
     * })
     */
    upsert<T extends KegMovementUpsertArgs>(args: SelectSubset<T, KegMovementUpsertArgs<ExtArgs>>): Prisma__KegMovementClient<$Result.GetResult<Prisma.$KegMovementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KegMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KegMovementCountArgs} args - Arguments to filter KegMovements to count.
     * @example
     * // Count the number of KegMovements
     * const count = await prisma.kegMovement.count({
     *   where: {
     *     // ... the filter for the KegMovements we want to count
     *   }
     * })
    **/
    count<T extends KegMovementCountArgs>(
      args?: Subset<T, KegMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KegMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KegMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KegMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KegMovementAggregateArgs>(args: Subset<T, KegMovementAggregateArgs>): Prisma.PrismaPromise<GetKegMovementAggregateType<T>>

    /**
     * Group by KegMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KegMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KegMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KegMovementGroupByArgs['orderBy'] }
        : { orderBy?: KegMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KegMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKegMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KegMovement model
   */
  readonly fields: KegMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KegMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KegMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    keg<T extends KegDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KegDefaultArgs<ExtArgs>>): Prisma__KegClient<$Result.GetResult<Prisma.$KegPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KegMovement model
   */ 
  interface KegMovementFieldRefs {
    readonly id: FieldRef<"KegMovement", 'String'>
    readonly tenantId: FieldRef<"KegMovement", 'String'>
    readonly kegId: FieldRef<"KegMovement", 'String'>
    readonly action: FieldRef<"KegMovement", 'KegAction'>
    readonly fromStatus: FieldRef<"KegMovement", 'KegStatus'>
    readonly toStatus: FieldRef<"KegMovement", 'KegStatus'>
    readonly productId: FieldRef<"KegMovement", 'String'>
    readonly productName: FieldRef<"KegMovement", 'String'>
    readonly customerId: FieldRef<"KegMovement", 'String'>
    readonly customerName: FieldRef<"KegMovement", 'String'>
    readonly orderId: FieldRef<"KegMovement", 'String'>
    readonly batchId: FieldRef<"KegMovement", 'String'>
    readonly notes: FieldRef<"KegMovement", 'String'>
    readonly createdAt: FieldRef<"KegMovement", 'DateTime'>
    readonly createdBy: FieldRef<"KegMovement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KegMovement findUnique
   */
  export type KegMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KegMovement
     */
    select?: KegMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegMovementInclude<ExtArgs> | null
    /**
     * Filter, which KegMovement to fetch.
     */
    where: KegMovementWhereUniqueInput
  }

  /**
   * KegMovement findUniqueOrThrow
   */
  export type KegMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KegMovement
     */
    select?: KegMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegMovementInclude<ExtArgs> | null
    /**
     * Filter, which KegMovement to fetch.
     */
    where: KegMovementWhereUniqueInput
  }

  /**
   * KegMovement findFirst
   */
  export type KegMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KegMovement
     */
    select?: KegMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegMovementInclude<ExtArgs> | null
    /**
     * Filter, which KegMovement to fetch.
     */
    where?: KegMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KegMovements to fetch.
     */
    orderBy?: KegMovementOrderByWithRelationInput | KegMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KegMovements.
     */
    cursor?: KegMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KegMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KegMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KegMovements.
     */
    distinct?: KegMovementScalarFieldEnum | KegMovementScalarFieldEnum[]
  }

  /**
   * KegMovement findFirstOrThrow
   */
  export type KegMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KegMovement
     */
    select?: KegMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegMovementInclude<ExtArgs> | null
    /**
     * Filter, which KegMovement to fetch.
     */
    where?: KegMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KegMovements to fetch.
     */
    orderBy?: KegMovementOrderByWithRelationInput | KegMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KegMovements.
     */
    cursor?: KegMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KegMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KegMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KegMovements.
     */
    distinct?: KegMovementScalarFieldEnum | KegMovementScalarFieldEnum[]
  }

  /**
   * KegMovement findMany
   */
  export type KegMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KegMovement
     */
    select?: KegMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegMovementInclude<ExtArgs> | null
    /**
     * Filter, which KegMovements to fetch.
     */
    where?: KegMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KegMovements to fetch.
     */
    orderBy?: KegMovementOrderByWithRelationInput | KegMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KegMovements.
     */
    cursor?: KegMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KegMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KegMovements.
     */
    skip?: number
    distinct?: KegMovementScalarFieldEnum | KegMovementScalarFieldEnum[]
  }

  /**
   * KegMovement create
   */
  export type KegMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KegMovement
     */
    select?: KegMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a KegMovement.
     */
    data: XOR<KegMovementCreateInput, KegMovementUncheckedCreateInput>
  }

  /**
   * KegMovement createMany
   */
  export type KegMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KegMovements.
     */
    data: KegMovementCreateManyInput | KegMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KegMovement createManyAndReturn
   */
  export type KegMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KegMovement
     */
    select?: KegMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many KegMovements.
     */
    data: KegMovementCreateManyInput | KegMovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KegMovement update
   */
  export type KegMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KegMovement
     */
    select?: KegMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a KegMovement.
     */
    data: XOR<KegMovementUpdateInput, KegMovementUncheckedUpdateInput>
    /**
     * Choose, which KegMovement to update.
     */
    where: KegMovementWhereUniqueInput
  }

  /**
   * KegMovement updateMany
   */
  export type KegMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KegMovements.
     */
    data: XOR<KegMovementUpdateManyMutationInput, KegMovementUncheckedUpdateManyInput>
    /**
     * Filter which KegMovements to update
     */
    where?: KegMovementWhereInput
  }

  /**
   * KegMovement upsert
   */
  export type KegMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KegMovement
     */
    select?: KegMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the KegMovement to update in case it exists.
     */
    where: KegMovementWhereUniqueInput
    /**
     * In case the KegMovement found by the `where` argument doesn't exist, create a new KegMovement with this data.
     */
    create: XOR<KegMovementCreateInput, KegMovementUncheckedCreateInput>
    /**
     * In case the KegMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KegMovementUpdateInput, KegMovementUncheckedUpdateInput>
  }

  /**
   * KegMovement delete
   */
  export type KegMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KegMovement
     */
    select?: KegMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegMovementInclude<ExtArgs> | null
    /**
     * Filter which KegMovement to delete.
     */
    where: KegMovementWhereUniqueInput
  }

  /**
   * KegMovement deleteMany
   */
  export type KegMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KegMovements to delete
     */
    where?: KegMovementWhereInput
  }

  /**
   * KegMovement without action
   */
  export type KegMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KegMovement
     */
    select?: KegMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KegMovementInclude<ExtArgs> | null
  }


  /**
   * Model QCTest
   */

  export type AggregateQCTest = {
    _count: QCTestCountAggregateOutputType | null
    _avg: QCTestAvgAggregateOutputType | null
    _sum: QCTestSumAggregateOutputType | null
    _min: QCTestMinAggregateOutputType | null
    _max: QCTestMaxAggregateOutputType | null
  }

  export type QCTestAvgAggregateOutputType = {
    minValue: Decimal | null
    maxValue: Decimal | null
    targetValue: Decimal | null
    result: Decimal | null
  }

  export type QCTestSumAggregateOutputType = {
    minValue: Decimal | null
    maxValue: Decimal | null
    targetValue: Decimal | null
    result: Decimal | null
  }

  export type QCTestMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    batchId: string | null
    lotId: string | null
    testType: $Enums.QCTestType | null
    status: $Enums.QCTestStatus | null
    priority: $Enums.QCTestPriority | null
    scheduledDate: Date | null
    completedDate: Date | null
    minValue: Decimal | null
    maxValue: Decimal | null
    targetValue: Decimal | null
    result: Decimal | null
    unit: string | null
    notes: string | null
    performedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QCTestMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    batchId: string | null
    lotId: string | null
    testType: $Enums.QCTestType | null
    status: $Enums.QCTestStatus | null
    priority: $Enums.QCTestPriority | null
    scheduledDate: Date | null
    completedDate: Date | null
    minValue: Decimal | null
    maxValue: Decimal | null
    targetValue: Decimal | null
    result: Decimal | null
    unit: string | null
    notes: string | null
    performedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QCTestCountAggregateOutputType = {
    id: number
    tenantId: number
    batchId: number
    lotId: number
    testType: number
    status: number
    priority: number
    scheduledDate: number
    completedDate: number
    minValue: number
    maxValue: number
    targetValue: number
    result: number
    unit: number
    notes: number
    performedBy: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QCTestAvgAggregateInputType = {
    minValue?: true
    maxValue?: true
    targetValue?: true
    result?: true
  }

  export type QCTestSumAggregateInputType = {
    minValue?: true
    maxValue?: true
    targetValue?: true
    result?: true
  }

  export type QCTestMinAggregateInputType = {
    id?: true
    tenantId?: true
    batchId?: true
    lotId?: true
    testType?: true
    status?: true
    priority?: true
    scheduledDate?: true
    completedDate?: true
    minValue?: true
    maxValue?: true
    targetValue?: true
    result?: true
    unit?: true
    notes?: true
    performedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QCTestMaxAggregateInputType = {
    id?: true
    tenantId?: true
    batchId?: true
    lotId?: true
    testType?: true
    status?: true
    priority?: true
    scheduledDate?: true
    completedDate?: true
    minValue?: true
    maxValue?: true
    targetValue?: true
    result?: true
    unit?: true
    notes?: true
    performedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QCTestCountAggregateInputType = {
    id?: true
    tenantId?: true
    batchId?: true
    lotId?: true
    testType?: true
    status?: true
    priority?: true
    scheduledDate?: true
    completedDate?: true
    minValue?: true
    maxValue?: true
    targetValue?: true
    result?: true
    unit?: true
    notes?: true
    performedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QCTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QCTest to aggregate.
     */
    where?: QCTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QCTests to fetch.
     */
    orderBy?: QCTestOrderByWithRelationInput | QCTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QCTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QCTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QCTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QCTests
    **/
    _count?: true | QCTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QCTestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QCTestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QCTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QCTestMaxAggregateInputType
  }

  export type GetQCTestAggregateType<T extends QCTestAggregateArgs> = {
        [P in keyof T & keyof AggregateQCTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQCTest[P]>
      : GetScalarType<T[P], AggregateQCTest[P]>
  }




  export type QCTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QCTestWhereInput
    orderBy?: QCTestOrderByWithAggregationInput | QCTestOrderByWithAggregationInput[]
    by: QCTestScalarFieldEnum[] | QCTestScalarFieldEnum
    having?: QCTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QCTestCountAggregateInputType | true
    _avg?: QCTestAvgAggregateInputType
    _sum?: QCTestSumAggregateInputType
    _min?: QCTestMinAggregateInputType
    _max?: QCTestMaxAggregateInputType
  }

  export type QCTestGroupByOutputType = {
    id: string
    tenantId: string
    batchId: string
    lotId: string | null
    testType: $Enums.QCTestType
    status: $Enums.QCTestStatus
    priority: $Enums.QCTestPriority
    scheduledDate: Date
    completedDate: Date | null
    minValue: Decimal | null
    maxValue: Decimal | null
    targetValue: Decimal | null
    result: Decimal | null
    unit: string | null
    notes: string | null
    performedBy: string | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: QCTestCountAggregateOutputType | null
    _avg: QCTestAvgAggregateOutputType | null
    _sum: QCTestSumAggregateOutputType | null
    _min: QCTestMinAggregateOutputType | null
    _max: QCTestMaxAggregateOutputType | null
  }

  type GetQCTestGroupByPayload<T extends QCTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QCTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QCTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QCTestGroupByOutputType[P]>
            : GetScalarType<T[P], QCTestGroupByOutputType[P]>
        }
      >
    >


  export type QCTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    batchId?: boolean
    lotId?: boolean
    testType?: boolean
    status?: boolean
    priority?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    minValue?: boolean
    maxValue?: boolean
    targetValue?: boolean
    result?: boolean
    unit?: boolean
    notes?: boolean
    performedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Batch?: boolean | BatchDefaultArgs<ExtArgs>
    Lot?: boolean | QCTest$LotArgs<ExtArgs>
  }, ExtArgs["result"]["qCTest"]>

  export type QCTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    batchId?: boolean
    lotId?: boolean
    testType?: boolean
    status?: boolean
    priority?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    minValue?: boolean
    maxValue?: boolean
    targetValue?: boolean
    result?: boolean
    unit?: boolean
    notes?: boolean
    performedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Batch?: boolean | BatchDefaultArgs<ExtArgs>
    Lot?: boolean | QCTest$LotArgs<ExtArgs>
  }, ExtArgs["result"]["qCTest"]>

  export type QCTestSelectScalar = {
    id?: boolean
    tenantId?: boolean
    batchId?: boolean
    lotId?: boolean
    testType?: boolean
    status?: boolean
    priority?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    minValue?: boolean
    maxValue?: boolean
    targetValue?: boolean
    result?: boolean
    unit?: boolean
    notes?: boolean
    performedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QCTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | BatchDefaultArgs<ExtArgs>
    Lot?: boolean | QCTest$LotArgs<ExtArgs>
  }
  export type QCTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Batch?: boolean | BatchDefaultArgs<ExtArgs>
    Lot?: boolean | QCTest$LotArgs<ExtArgs>
  }

  export type $QCTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QCTest"
    objects: {
      Batch: Prisma.$BatchPayload<ExtArgs>
      Lot: Prisma.$LotPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      batchId: string
      lotId: string | null
      testType: $Enums.QCTestType
      status: $Enums.QCTestStatus
      priority: $Enums.QCTestPriority
      scheduledDate: Date
      completedDate: Date | null
      minValue: Prisma.Decimal | null
      maxValue: Prisma.Decimal | null
      targetValue: Prisma.Decimal | null
      result: Prisma.Decimal | null
      unit: string | null
      notes: string | null
      performedBy: string | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["qCTest"]>
    composites: {}
  }

  type QCTestGetPayload<S extends boolean | null | undefined | QCTestDefaultArgs> = $Result.GetResult<Prisma.$QCTestPayload, S>

  type QCTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QCTestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QCTestCountAggregateInputType | true
    }

  export interface QCTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QCTest'], meta: { name: 'QCTest' } }
    /**
     * Find zero or one QCTest that matches the filter.
     * @param {QCTestFindUniqueArgs} args - Arguments to find a QCTest
     * @example
     * // Get one QCTest
     * const qCTest = await prisma.qCTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QCTestFindUniqueArgs>(args: SelectSubset<T, QCTestFindUniqueArgs<ExtArgs>>): Prisma__QCTestClient<$Result.GetResult<Prisma.$QCTestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QCTest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QCTestFindUniqueOrThrowArgs} args - Arguments to find a QCTest
     * @example
     * // Get one QCTest
     * const qCTest = await prisma.qCTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QCTestFindUniqueOrThrowArgs>(args: SelectSubset<T, QCTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QCTestClient<$Result.GetResult<Prisma.$QCTestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QCTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QCTestFindFirstArgs} args - Arguments to find a QCTest
     * @example
     * // Get one QCTest
     * const qCTest = await prisma.qCTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QCTestFindFirstArgs>(args?: SelectSubset<T, QCTestFindFirstArgs<ExtArgs>>): Prisma__QCTestClient<$Result.GetResult<Prisma.$QCTestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QCTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QCTestFindFirstOrThrowArgs} args - Arguments to find a QCTest
     * @example
     * // Get one QCTest
     * const qCTest = await prisma.qCTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QCTestFindFirstOrThrowArgs>(args?: SelectSubset<T, QCTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__QCTestClient<$Result.GetResult<Prisma.$QCTestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QCTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QCTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QCTests
     * const qCTests = await prisma.qCTest.findMany()
     * 
     * // Get first 10 QCTests
     * const qCTests = await prisma.qCTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qCTestWithIdOnly = await prisma.qCTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QCTestFindManyArgs>(args?: SelectSubset<T, QCTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QCTestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QCTest.
     * @param {QCTestCreateArgs} args - Arguments to create a QCTest.
     * @example
     * // Create one QCTest
     * const QCTest = await prisma.qCTest.create({
     *   data: {
     *     // ... data to create a QCTest
     *   }
     * })
     * 
     */
    create<T extends QCTestCreateArgs>(args: SelectSubset<T, QCTestCreateArgs<ExtArgs>>): Prisma__QCTestClient<$Result.GetResult<Prisma.$QCTestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QCTests.
     * @param {QCTestCreateManyArgs} args - Arguments to create many QCTests.
     * @example
     * // Create many QCTests
     * const qCTest = await prisma.qCTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QCTestCreateManyArgs>(args?: SelectSubset<T, QCTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QCTests and returns the data saved in the database.
     * @param {QCTestCreateManyAndReturnArgs} args - Arguments to create many QCTests.
     * @example
     * // Create many QCTests
     * const qCTest = await prisma.qCTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QCTests and only return the `id`
     * const qCTestWithIdOnly = await prisma.qCTest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QCTestCreateManyAndReturnArgs>(args?: SelectSubset<T, QCTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QCTestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QCTest.
     * @param {QCTestDeleteArgs} args - Arguments to delete one QCTest.
     * @example
     * // Delete one QCTest
     * const QCTest = await prisma.qCTest.delete({
     *   where: {
     *     // ... filter to delete one QCTest
     *   }
     * })
     * 
     */
    delete<T extends QCTestDeleteArgs>(args: SelectSubset<T, QCTestDeleteArgs<ExtArgs>>): Prisma__QCTestClient<$Result.GetResult<Prisma.$QCTestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QCTest.
     * @param {QCTestUpdateArgs} args - Arguments to update one QCTest.
     * @example
     * // Update one QCTest
     * const qCTest = await prisma.qCTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QCTestUpdateArgs>(args: SelectSubset<T, QCTestUpdateArgs<ExtArgs>>): Prisma__QCTestClient<$Result.GetResult<Prisma.$QCTestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QCTests.
     * @param {QCTestDeleteManyArgs} args - Arguments to filter QCTests to delete.
     * @example
     * // Delete a few QCTests
     * const { count } = await prisma.qCTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QCTestDeleteManyArgs>(args?: SelectSubset<T, QCTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QCTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QCTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QCTests
     * const qCTest = await prisma.qCTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QCTestUpdateManyArgs>(args: SelectSubset<T, QCTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QCTest.
     * @param {QCTestUpsertArgs} args - Arguments to update or create a QCTest.
     * @example
     * // Update or create a QCTest
     * const qCTest = await prisma.qCTest.upsert({
     *   create: {
     *     // ... data to create a QCTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QCTest we want to update
     *   }
     * })
     */
    upsert<T extends QCTestUpsertArgs>(args: SelectSubset<T, QCTestUpsertArgs<ExtArgs>>): Prisma__QCTestClient<$Result.GetResult<Prisma.$QCTestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QCTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QCTestCountArgs} args - Arguments to filter QCTests to count.
     * @example
     * // Count the number of QCTests
     * const count = await prisma.qCTest.count({
     *   where: {
     *     // ... the filter for the QCTests we want to count
     *   }
     * })
    **/
    count<T extends QCTestCountArgs>(
      args?: Subset<T, QCTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QCTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QCTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QCTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QCTestAggregateArgs>(args: Subset<T, QCTestAggregateArgs>): Prisma.PrismaPromise<GetQCTestAggregateType<T>>

    /**
     * Group by QCTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QCTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QCTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QCTestGroupByArgs['orderBy'] }
        : { orderBy?: QCTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QCTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQCTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QCTest model
   */
  readonly fields: QCTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QCTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QCTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Batch<T extends BatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BatchDefaultArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Lot<T extends QCTest$LotArgs<ExtArgs> = {}>(args?: Subset<T, QCTest$LotArgs<ExtArgs>>): Prisma__LotClient<$Result.GetResult<Prisma.$LotPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QCTest model
   */ 
  interface QCTestFieldRefs {
    readonly id: FieldRef<"QCTest", 'String'>
    readonly tenantId: FieldRef<"QCTest", 'String'>
    readonly batchId: FieldRef<"QCTest", 'String'>
    readonly lotId: FieldRef<"QCTest", 'String'>
    readonly testType: FieldRef<"QCTest", 'QCTestType'>
    readonly status: FieldRef<"QCTest", 'QCTestStatus'>
    readonly priority: FieldRef<"QCTest", 'QCTestPriority'>
    readonly scheduledDate: FieldRef<"QCTest", 'DateTime'>
    readonly completedDate: FieldRef<"QCTest", 'DateTime'>
    readonly minValue: FieldRef<"QCTest", 'Decimal'>
    readonly maxValue: FieldRef<"QCTest", 'Decimal'>
    readonly targetValue: FieldRef<"QCTest", 'Decimal'>
    readonly result: FieldRef<"QCTest", 'Decimal'>
    readonly unit: FieldRef<"QCTest", 'String'>
    readonly notes: FieldRef<"QCTest", 'String'>
    readonly performedBy: FieldRef<"QCTest", 'String'>
    readonly createdBy: FieldRef<"QCTest", 'String'>
    readonly createdAt: FieldRef<"QCTest", 'DateTime'>
    readonly updatedAt: FieldRef<"QCTest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QCTest findUnique
   */
  export type QCTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCTest
     */
    select?: QCTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCTestInclude<ExtArgs> | null
    /**
     * Filter, which QCTest to fetch.
     */
    where: QCTestWhereUniqueInput
  }

  /**
   * QCTest findUniqueOrThrow
   */
  export type QCTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCTest
     */
    select?: QCTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCTestInclude<ExtArgs> | null
    /**
     * Filter, which QCTest to fetch.
     */
    where: QCTestWhereUniqueInput
  }

  /**
   * QCTest findFirst
   */
  export type QCTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCTest
     */
    select?: QCTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCTestInclude<ExtArgs> | null
    /**
     * Filter, which QCTest to fetch.
     */
    where?: QCTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QCTests to fetch.
     */
    orderBy?: QCTestOrderByWithRelationInput | QCTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QCTests.
     */
    cursor?: QCTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QCTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QCTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QCTests.
     */
    distinct?: QCTestScalarFieldEnum | QCTestScalarFieldEnum[]
  }

  /**
   * QCTest findFirstOrThrow
   */
  export type QCTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCTest
     */
    select?: QCTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCTestInclude<ExtArgs> | null
    /**
     * Filter, which QCTest to fetch.
     */
    where?: QCTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QCTests to fetch.
     */
    orderBy?: QCTestOrderByWithRelationInput | QCTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QCTests.
     */
    cursor?: QCTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QCTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QCTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QCTests.
     */
    distinct?: QCTestScalarFieldEnum | QCTestScalarFieldEnum[]
  }

  /**
   * QCTest findMany
   */
  export type QCTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCTest
     */
    select?: QCTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCTestInclude<ExtArgs> | null
    /**
     * Filter, which QCTests to fetch.
     */
    where?: QCTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QCTests to fetch.
     */
    orderBy?: QCTestOrderByWithRelationInput | QCTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QCTests.
     */
    cursor?: QCTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QCTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QCTests.
     */
    skip?: number
    distinct?: QCTestScalarFieldEnum | QCTestScalarFieldEnum[]
  }

  /**
   * QCTest create
   */
  export type QCTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCTest
     */
    select?: QCTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCTestInclude<ExtArgs> | null
    /**
     * The data needed to create a QCTest.
     */
    data: XOR<QCTestCreateInput, QCTestUncheckedCreateInput>
  }

  /**
   * QCTest createMany
   */
  export type QCTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QCTests.
     */
    data: QCTestCreateManyInput | QCTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QCTest createManyAndReturn
   */
  export type QCTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCTest
     */
    select?: QCTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QCTests.
     */
    data: QCTestCreateManyInput | QCTestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QCTest update
   */
  export type QCTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCTest
     */
    select?: QCTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCTestInclude<ExtArgs> | null
    /**
     * The data needed to update a QCTest.
     */
    data: XOR<QCTestUpdateInput, QCTestUncheckedUpdateInput>
    /**
     * Choose, which QCTest to update.
     */
    where: QCTestWhereUniqueInput
  }

  /**
   * QCTest updateMany
   */
  export type QCTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QCTests.
     */
    data: XOR<QCTestUpdateManyMutationInput, QCTestUncheckedUpdateManyInput>
    /**
     * Filter which QCTests to update
     */
    where?: QCTestWhereInput
  }

  /**
   * QCTest upsert
   */
  export type QCTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCTest
     */
    select?: QCTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCTestInclude<ExtArgs> | null
    /**
     * The filter to search for the QCTest to update in case it exists.
     */
    where: QCTestWhereUniqueInput
    /**
     * In case the QCTest found by the `where` argument doesn't exist, create a new QCTest with this data.
     */
    create: XOR<QCTestCreateInput, QCTestUncheckedCreateInput>
    /**
     * In case the QCTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QCTestUpdateInput, QCTestUncheckedUpdateInput>
  }

  /**
   * QCTest delete
   */
  export type QCTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCTest
     */
    select?: QCTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCTestInclude<ExtArgs> | null
    /**
     * Filter which QCTest to delete.
     */
    where: QCTestWhereUniqueInput
  }

  /**
   * QCTest deleteMany
   */
  export type QCTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QCTests to delete
     */
    where?: QCTestWhereInput
  }

  /**
   * QCTest.Lot
   */
  export type QCTest$LotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lot
     */
    select?: LotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LotInclude<ExtArgs> | null
    where?: LotWhereInput
  }

  /**
   * QCTest without action
   */
  export type QCTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QCTest
     */
    select?: QCTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QCTestInclude<ExtArgs> | null
  }


  /**
   * Model Configuration
   */

  export type AggregateConfiguration = {
    _count: ConfigurationCountAggregateOutputType | null
    _min: ConfigurationMinAggregateOutputType | null
    _max: ConfigurationMaxAggregateOutputType | null
  }

  export type ConfigurationMinAggregateOutputType = {
    id: string | null
    key: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ConfigurationMaxAggregateOutputType = {
    id: string | null
    key: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ConfigurationCountAggregateOutputType = {
    id: number
    key: number
    value: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type ConfigurationMinAggregateInputType = {
    id?: true
    key?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ConfigurationMaxAggregateInputType = {
    id?: true
    key?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ConfigurationCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Configuration to aggregate.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Configurations
    **/
    _count?: true | ConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigurationMaxAggregateInputType
  }

  export type GetConfigurationAggregateType<T extends ConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfiguration[P]>
      : GetScalarType<T[P], AggregateConfiguration[P]>
  }




  export type ConfigurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigurationWhereInput
    orderBy?: ConfigurationOrderByWithAggregationInput | ConfigurationOrderByWithAggregationInput[]
    by: ConfigurationScalarFieldEnum[] | ConfigurationScalarFieldEnum
    having?: ConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigurationCountAggregateInputType | true
    _min?: ConfigurationMinAggregateInputType
    _max?: ConfigurationMaxAggregateInputType
  }

  export type ConfigurationGroupByOutputType = {
    id: string
    key: string
    value: JsonValue
    updatedAt: Date
    createdAt: Date
    _count: ConfigurationCountAggregateOutputType | null
    _min: ConfigurationMinAggregateOutputType | null
    _max: ConfigurationMaxAggregateOutputType | null
  }

  type GetConfigurationGroupByPayload<T extends ConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type ConfigurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["configuration"]>

  export type ConfigurationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["configuration"]>

  export type ConfigurationSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }


  export type $ConfigurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Configuration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: Prisma.JsonValue
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["configuration"]>
    composites: {}
  }

  type ConfigurationGetPayload<S extends boolean | null | undefined | ConfigurationDefaultArgs> = $Result.GetResult<Prisma.$ConfigurationPayload, S>

  type ConfigurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConfigurationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConfigurationCountAggregateInputType | true
    }

  export interface ConfigurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Configuration'], meta: { name: 'Configuration' } }
    /**
     * Find zero or one Configuration that matches the filter.
     * @param {ConfigurationFindUniqueArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfigurationFindUniqueArgs>(args: SelectSubset<T, ConfigurationFindUniqueArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Configuration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConfigurationFindUniqueOrThrowArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfigurationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfigurationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Configuration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationFindFirstArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfigurationFindFirstArgs>(args?: SelectSubset<T, ConfigurationFindFirstArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Configuration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationFindFirstOrThrowArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfigurationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfigurationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Configurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configurations
     * const configurations = await prisma.configuration.findMany()
     * 
     * // Get first 10 Configurations
     * const configurations = await prisma.configuration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configurationWithIdOnly = await prisma.configuration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfigurationFindManyArgs>(args?: SelectSubset<T, ConfigurationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Configuration.
     * @param {ConfigurationCreateArgs} args - Arguments to create a Configuration.
     * @example
     * // Create one Configuration
     * const Configuration = await prisma.configuration.create({
     *   data: {
     *     // ... data to create a Configuration
     *   }
     * })
     * 
     */
    create<T extends ConfigurationCreateArgs>(args: SelectSubset<T, ConfigurationCreateArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Configurations.
     * @param {ConfigurationCreateManyArgs} args - Arguments to create many Configurations.
     * @example
     * // Create many Configurations
     * const configuration = await prisma.configuration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfigurationCreateManyArgs>(args?: SelectSubset<T, ConfigurationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Configurations and returns the data saved in the database.
     * @param {ConfigurationCreateManyAndReturnArgs} args - Arguments to create many Configurations.
     * @example
     * // Create many Configurations
     * const configuration = await prisma.configuration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Configurations and only return the `id`
     * const configurationWithIdOnly = await prisma.configuration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfigurationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfigurationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Configuration.
     * @param {ConfigurationDeleteArgs} args - Arguments to delete one Configuration.
     * @example
     * // Delete one Configuration
     * const Configuration = await prisma.configuration.delete({
     *   where: {
     *     // ... filter to delete one Configuration
     *   }
     * })
     * 
     */
    delete<T extends ConfigurationDeleteArgs>(args: SelectSubset<T, ConfigurationDeleteArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Configuration.
     * @param {ConfigurationUpdateArgs} args - Arguments to update one Configuration.
     * @example
     * // Update one Configuration
     * const configuration = await prisma.configuration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfigurationUpdateArgs>(args: SelectSubset<T, ConfigurationUpdateArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Configurations.
     * @param {ConfigurationDeleteManyArgs} args - Arguments to filter Configurations to delete.
     * @example
     * // Delete a few Configurations
     * const { count } = await prisma.configuration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfigurationDeleteManyArgs>(args?: SelectSubset<T, ConfigurationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configurations
     * const configuration = await prisma.configuration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfigurationUpdateManyArgs>(args: SelectSubset<T, ConfigurationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Configuration.
     * @param {ConfigurationUpsertArgs} args - Arguments to update or create a Configuration.
     * @example
     * // Update or create a Configuration
     * const configuration = await prisma.configuration.upsert({
     *   create: {
     *     // ... data to create a Configuration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Configuration we want to update
     *   }
     * })
     */
    upsert<T extends ConfigurationUpsertArgs>(args: SelectSubset<T, ConfigurationUpsertArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationCountArgs} args - Arguments to filter Configurations to count.
     * @example
     * // Count the number of Configurations
     * const count = await prisma.configuration.count({
     *   where: {
     *     // ... the filter for the Configurations we want to count
     *   }
     * })
    **/
    count<T extends ConfigurationCountArgs>(
      args?: Subset<T, ConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Configuration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigurationAggregateArgs>(args: Subset<T, ConfigurationAggregateArgs>): Prisma.PrismaPromise<GetConfigurationAggregateType<T>>

    /**
     * Group by Configuration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: ConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Configuration model
   */
  readonly fields: ConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Configuration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Configuration model
   */ 
  interface ConfigurationFieldRefs {
    readonly id: FieldRef<"Configuration", 'String'>
    readonly key: FieldRef<"Configuration", 'String'>
    readonly value: FieldRef<"Configuration", 'Json'>
    readonly updatedAt: FieldRef<"Configuration", 'DateTime'>
    readonly createdAt: FieldRef<"Configuration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Configuration findUnique
   */
  export type ConfigurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration findUniqueOrThrow
   */
  export type ConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration findFirst
   */
  export type ConfigurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configurations.
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configurations.
     */
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * Configuration findFirstOrThrow
   */
  export type ConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configurations.
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configurations.
     */
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * Configuration findMany
   */
  export type ConfigurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Filter, which Configurations to fetch.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Configurations.
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * Configuration create
   */
  export type ConfigurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * The data needed to create a Configuration.
     */
    data: XOR<ConfigurationCreateInput, ConfigurationUncheckedCreateInput>
  }

  /**
   * Configuration createMany
   */
  export type ConfigurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Configurations.
     */
    data: ConfigurationCreateManyInput | ConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Configuration createManyAndReturn
   */
  export type ConfigurationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Configurations.
     */
    data: ConfigurationCreateManyInput | ConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Configuration update
   */
  export type ConfigurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * The data needed to update a Configuration.
     */
    data: XOR<ConfigurationUpdateInput, ConfigurationUncheckedUpdateInput>
    /**
     * Choose, which Configuration to update.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration updateMany
   */
  export type ConfigurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Configurations.
     */
    data: XOR<ConfigurationUpdateManyMutationInput, ConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which Configurations to update
     */
    where?: ConfigurationWhereInput
  }

  /**
   * Configuration upsert
   */
  export type ConfigurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * The filter to search for the Configuration to update in case it exists.
     */
    where: ConfigurationWhereUniqueInput
    /**
     * In case the Configuration found by the `where` argument doesn't exist, create a new Configuration with this data.
     */
    create: XOR<ConfigurationCreateInput, ConfigurationUncheckedCreateInput>
    /**
     * In case the Configuration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigurationUpdateInput, ConfigurationUncheckedUpdateInput>
  }

  /**
   * Configuration delete
   */
  export type ConfigurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Filter which Configuration to delete.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration deleteMany
   */
  export type ConfigurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Configurations to delete
     */
    where?: ConfigurationWhereInput
  }

  /**
   * Configuration without action
   */
  export type ConfigurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
  }


  /**
   * Model Museum
   */

  export type AggregateMuseum = {
    _count: MuseumCountAggregateOutputType | null
    _avg: MuseumAvgAggregateOutputType | null
    _sum: MuseumSumAggregateOutputType | null
    _min: MuseumMinAggregateOutputType | null
    _max: MuseumMaxAggregateOutputType | null
  }

  export type MuseumAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type MuseumSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type MuseumMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    city: string | null
    address: string | null
    nameEn: string | null
    descriptionEn: string | null
    cityEn: string | null
    addressEn: string | null
    nameRu: string | null
    descriptionRu: string | null
    cityRu: string | null
    addressRu: string | null
    nameDe: string | null
    descriptionDe: string | null
    cityDe: string | null
    addressDe: string | null
    nameFr: string | null
    descriptionFr: string | null
    cityFr: string | null
    addressFr: string | null
    slug: string | null
    coverImage: string | null
    latitude: number | null
    longitude: number | null
    contactEmail: string | null
    contactPhone: string | null
    website: string | null
    showMap: boolean | null
    showQrScanner: boolean | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MuseumMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    city: string | null
    address: string | null
    nameEn: string | null
    descriptionEn: string | null
    cityEn: string | null
    addressEn: string | null
    nameRu: string | null
    descriptionRu: string | null
    cityRu: string | null
    addressRu: string | null
    nameDe: string | null
    descriptionDe: string | null
    cityDe: string | null
    addressDe: string | null
    nameFr: string | null
    descriptionFr: string | null
    cityFr: string | null
    addressFr: string | null
    slug: string | null
    coverImage: string | null
    latitude: number | null
    longitude: number | null
    contactEmail: string | null
    contactPhone: string | null
    website: string | null
    showMap: boolean | null
    showQrScanner: boolean | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MuseumCountAggregateOutputType = {
    id: number
    name: number
    description: number
    city: number
    address: number
    nameEn: number
    descriptionEn: number
    cityEn: number
    addressEn: number
    nameRu: number
    descriptionRu: number
    cityRu: number
    addressRu: number
    nameDe: number
    descriptionDe: number
    cityDe: number
    addressDe: number
    nameFr: number
    descriptionFr: number
    cityFr: number
    addressFr: number
    slug: number
    coverImage: number
    latitude: number
    longitude: number
    contactEmail: number
    contactPhone: number
    website: number
    showMap: number
    showQrScanner: number
    isPublished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MuseumAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type MuseumSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type MuseumMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    city?: true
    address?: true
    nameEn?: true
    descriptionEn?: true
    cityEn?: true
    addressEn?: true
    nameRu?: true
    descriptionRu?: true
    cityRu?: true
    addressRu?: true
    nameDe?: true
    descriptionDe?: true
    cityDe?: true
    addressDe?: true
    nameFr?: true
    descriptionFr?: true
    cityFr?: true
    addressFr?: true
    slug?: true
    coverImage?: true
    latitude?: true
    longitude?: true
    contactEmail?: true
    contactPhone?: true
    website?: true
    showMap?: true
    showQrScanner?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MuseumMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    city?: true
    address?: true
    nameEn?: true
    descriptionEn?: true
    cityEn?: true
    addressEn?: true
    nameRu?: true
    descriptionRu?: true
    cityRu?: true
    addressRu?: true
    nameDe?: true
    descriptionDe?: true
    cityDe?: true
    addressDe?: true
    nameFr?: true
    descriptionFr?: true
    cityFr?: true
    addressFr?: true
    slug?: true
    coverImage?: true
    latitude?: true
    longitude?: true
    contactEmail?: true
    contactPhone?: true
    website?: true
    showMap?: true
    showQrScanner?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MuseumCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    city?: true
    address?: true
    nameEn?: true
    descriptionEn?: true
    cityEn?: true
    addressEn?: true
    nameRu?: true
    descriptionRu?: true
    cityRu?: true
    addressRu?: true
    nameDe?: true
    descriptionDe?: true
    cityDe?: true
    addressDe?: true
    nameFr?: true
    descriptionFr?: true
    cityFr?: true
    addressFr?: true
    slug?: true
    coverImage?: true
    latitude?: true
    longitude?: true
    contactEmail?: true
    contactPhone?: true
    website?: true
    showMap?: true
    showQrScanner?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MuseumAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Museum to aggregate.
     */
    where?: MuseumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Museums to fetch.
     */
    orderBy?: MuseumOrderByWithRelationInput | MuseumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MuseumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Museums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Museums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Museums
    **/
    _count?: true | MuseumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MuseumAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MuseumSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MuseumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MuseumMaxAggregateInputType
  }

  export type GetMuseumAggregateType<T extends MuseumAggregateArgs> = {
        [P in keyof T & keyof AggregateMuseum]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMuseum[P]>
      : GetScalarType<T[P], AggregateMuseum[P]>
  }




  export type MuseumGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MuseumWhereInput
    orderBy?: MuseumOrderByWithAggregationInput | MuseumOrderByWithAggregationInput[]
    by: MuseumScalarFieldEnum[] | MuseumScalarFieldEnum
    having?: MuseumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MuseumCountAggregateInputType | true
    _avg?: MuseumAvgAggregateInputType
    _sum?: MuseumSumAggregateInputType
    _min?: MuseumMinAggregateInputType
    _max?: MuseumMaxAggregateInputType
  }

  export type MuseumGroupByOutputType = {
    id: string
    name: string
    description: string | null
    city: string | null
    address: string | null
    nameEn: string | null
    descriptionEn: string | null
    cityEn: string | null
    addressEn: string | null
    nameRu: string | null
    descriptionRu: string | null
    cityRu: string | null
    addressRu: string | null
    nameDe: string | null
    descriptionDe: string | null
    cityDe: string | null
    addressDe: string | null
    nameFr: string | null
    descriptionFr: string | null
    cityFr: string | null
    addressFr: string | null
    slug: string
    coverImage: string | null
    latitude: number | null
    longitude: number | null
    contactEmail: string | null
    contactPhone: string | null
    website: string | null
    showMap: boolean
    showQrScanner: boolean
    isPublished: boolean
    createdAt: Date
    updatedAt: Date
    _count: MuseumCountAggregateOutputType | null
    _avg: MuseumAvgAggregateOutputType | null
    _sum: MuseumSumAggregateOutputType | null
    _min: MuseumMinAggregateOutputType | null
    _max: MuseumMaxAggregateOutputType | null
  }

  type GetMuseumGroupByPayload<T extends MuseumGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MuseumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MuseumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MuseumGroupByOutputType[P]>
            : GetScalarType<T[P], MuseumGroupByOutputType[P]>
        }
      >
    >


  export type MuseumSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    city?: boolean
    address?: boolean
    nameEn?: boolean
    descriptionEn?: boolean
    cityEn?: boolean
    addressEn?: boolean
    nameRu?: boolean
    descriptionRu?: boolean
    cityRu?: boolean
    addressRu?: boolean
    nameDe?: boolean
    descriptionDe?: boolean
    cityDe?: boolean
    addressDe?: boolean
    nameFr?: boolean
    descriptionFr?: boolean
    cityFr?: boolean
    addressFr?: boolean
    slug?: boolean
    coverImage?: boolean
    latitude?: boolean
    longitude?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    website?: boolean
    showMap?: boolean
    showQrScanner?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tours?: boolean | Museum$toursArgs<ExtArgs>
    _count?: boolean | MuseumCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["museum"]>

  export type MuseumSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    city?: boolean
    address?: boolean
    nameEn?: boolean
    descriptionEn?: boolean
    cityEn?: boolean
    addressEn?: boolean
    nameRu?: boolean
    descriptionRu?: boolean
    cityRu?: boolean
    addressRu?: boolean
    nameDe?: boolean
    descriptionDe?: boolean
    cityDe?: boolean
    addressDe?: boolean
    nameFr?: boolean
    descriptionFr?: boolean
    cityFr?: boolean
    addressFr?: boolean
    slug?: boolean
    coverImage?: boolean
    latitude?: boolean
    longitude?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    website?: boolean
    showMap?: boolean
    showQrScanner?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["museum"]>

  export type MuseumSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    city?: boolean
    address?: boolean
    nameEn?: boolean
    descriptionEn?: boolean
    cityEn?: boolean
    addressEn?: boolean
    nameRu?: boolean
    descriptionRu?: boolean
    cityRu?: boolean
    addressRu?: boolean
    nameDe?: boolean
    descriptionDe?: boolean
    cityDe?: boolean
    addressDe?: boolean
    nameFr?: boolean
    descriptionFr?: boolean
    cityFr?: boolean
    addressFr?: boolean
    slug?: boolean
    coverImage?: boolean
    latitude?: boolean
    longitude?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    website?: boolean
    showMap?: boolean
    showQrScanner?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MuseumInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tours?: boolean | Museum$toursArgs<ExtArgs>
    _count?: boolean | MuseumCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MuseumIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MuseumPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Museum"
    objects: {
      tours: Prisma.$TourPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      city: string | null
      address: string | null
      nameEn: string | null
      descriptionEn: string | null
      cityEn: string | null
      addressEn: string | null
      nameRu: string | null
      descriptionRu: string | null
      cityRu: string | null
      addressRu: string | null
      nameDe: string | null
      descriptionDe: string | null
      cityDe: string | null
      addressDe: string | null
      nameFr: string | null
      descriptionFr: string | null
      cityFr: string | null
      addressFr: string | null
      slug: string
      coverImage: string | null
      latitude: number | null
      longitude: number | null
      contactEmail: string | null
      contactPhone: string | null
      website: string | null
      showMap: boolean
      showQrScanner: boolean
      isPublished: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["museum"]>
    composites: {}
  }

  type MuseumGetPayload<S extends boolean | null | undefined | MuseumDefaultArgs> = $Result.GetResult<Prisma.$MuseumPayload, S>

  type MuseumCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MuseumFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MuseumCountAggregateInputType | true
    }

  export interface MuseumDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Museum'], meta: { name: 'Museum' } }
    /**
     * Find zero or one Museum that matches the filter.
     * @param {MuseumFindUniqueArgs} args - Arguments to find a Museum
     * @example
     * // Get one Museum
     * const museum = await prisma.museum.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MuseumFindUniqueArgs>(args: SelectSubset<T, MuseumFindUniqueArgs<ExtArgs>>): Prisma__MuseumClient<$Result.GetResult<Prisma.$MuseumPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Museum that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MuseumFindUniqueOrThrowArgs} args - Arguments to find a Museum
     * @example
     * // Get one Museum
     * const museum = await prisma.museum.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MuseumFindUniqueOrThrowArgs>(args: SelectSubset<T, MuseumFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MuseumClient<$Result.GetResult<Prisma.$MuseumPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Museum that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuseumFindFirstArgs} args - Arguments to find a Museum
     * @example
     * // Get one Museum
     * const museum = await prisma.museum.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MuseumFindFirstArgs>(args?: SelectSubset<T, MuseumFindFirstArgs<ExtArgs>>): Prisma__MuseumClient<$Result.GetResult<Prisma.$MuseumPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Museum that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuseumFindFirstOrThrowArgs} args - Arguments to find a Museum
     * @example
     * // Get one Museum
     * const museum = await prisma.museum.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MuseumFindFirstOrThrowArgs>(args?: SelectSubset<T, MuseumFindFirstOrThrowArgs<ExtArgs>>): Prisma__MuseumClient<$Result.GetResult<Prisma.$MuseumPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Museums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuseumFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Museums
     * const museums = await prisma.museum.findMany()
     * 
     * // Get first 10 Museums
     * const museums = await prisma.museum.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const museumWithIdOnly = await prisma.museum.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MuseumFindManyArgs>(args?: SelectSubset<T, MuseumFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MuseumPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Museum.
     * @param {MuseumCreateArgs} args - Arguments to create a Museum.
     * @example
     * // Create one Museum
     * const Museum = await prisma.museum.create({
     *   data: {
     *     // ... data to create a Museum
     *   }
     * })
     * 
     */
    create<T extends MuseumCreateArgs>(args: SelectSubset<T, MuseumCreateArgs<ExtArgs>>): Prisma__MuseumClient<$Result.GetResult<Prisma.$MuseumPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Museums.
     * @param {MuseumCreateManyArgs} args - Arguments to create many Museums.
     * @example
     * // Create many Museums
     * const museum = await prisma.museum.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MuseumCreateManyArgs>(args?: SelectSubset<T, MuseumCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Museums and returns the data saved in the database.
     * @param {MuseumCreateManyAndReturnArgs} args - Arguments to create many Museums.
     * @example
     * // Create many Museums
     * const museum = await prisma.museum.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Museums and only return the `id`
     * const museumWithIdOnly = await prisma.museum.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MuseumCreateManyAndReturnArgs>(args?: SelectSubset<T, MuseumCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MuseumPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Museum.
     * @param {MuseumDeleteArgs} args - Arguments to delete one Museum.
     * @example
     * // Delete one Museum
     * const Museum = await prisma.museum.delete({
     *   where: {
     *     // ... filter to delete one Museum
     *   }
     * })
     * 
     */
    delete<T extends MuseumDeleteArgs>(args: SelectSubset<T, MuseumDeleteArgs<ExtArgs>>): Prisma__MuseumClient<$Result.GetResult<Prisma.$MuseumPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Museum.
     * @param {MuseumUpdateArgs} args - Arguments to update one Museum.
     * @example
     * // Update one Museum
     * const museum = await prisma.museum.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MuseumUpdateArgs>(args: SelectSubset<T, MuseumUpdateArgs<ExtArgs>>): Prisma__MuseumClient<$Result.GetResult<Prisma.$MuseumPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Museums.
     * @param {MuseumDeleteManyArgs} args - Arguments to filter Museums to delete.
     * @example
     * // Delete a few Museums
     * const { count } = await prisma.museum.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MuseumDeleteManyArgs>(args?: SelectSubset<T, MuseumDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Museums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuseumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Museums
     * const museum = await prisma.museum.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MuseumUpdateManyArgs>(args: SelectSubset<T, MuseumUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Museum.
     * @param {MuseumUpsertArgs} args - Arguments to update or create a Museum.
     * @example
     * // Update or create a Museum
     * const museum = await prisma.museum.upsert({
     *   create: {
     *     // ... data to create a Museum
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Museum we want to update
     *   }
     * })
     */
    upsert<T extends MuseumUpsertArgs>(args: SelectSubset<T, MuseumUpsertArgs<ExtArgs>>): Prisma__MuseumClient<$Result.GetResult<Prisma.$MuseumPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Museums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuseumCountArgs} args - Arguments to filter Museums to count.
     * @example
     * // Count the number of Museums
     * const count = await prisma.museum.count({
     *   where: {
     *     // ... the filter for the Museums we want to count
     *   }
     * })
    **/
    count<T extends MuseumCountArgs>(
      args?: Subset<T, MuseumCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MuseumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Museum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuseumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MuseumAggregateArgs>(args: Subset<T, MuseumAggregateArgs>): Prisma.PrismaPromise<GetMuseumAggregateType<T>>

    /**
     * Group by Museum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuseumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MuseumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MuseumGroupByArgs['orderBy'] }
        : { orderBy?: MuseumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MuseumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMuseumGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Museum model
   */
  readonly fields: MuseumFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Museum.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MuseumClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tours<T extends Museum$toursArgs<ExtArgs> = {}>(args?: Subset<T, Museum$toursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Museum model
   */ 
  interface MuseumFieldRefs {
    readonly id: FieldRef<"Museum", 'String'>
    readonly name: FieldRef<"Museum", 'String'>
    readonly description: FieldRef<"Museum", 'String'>
    readonly city: FieldRef<"Museum", 'String'>
    readonly address: FieldRef<"Museum", 'String'>
    readonly nameEn: FieldRef<"Museum", 'String'>
    readonly descriptionEn: FieldRef<"Museum", 'String'>
    readonly cityEn: FieldRef<"Museum", 'String'>
    readonly addressEn: FieldRef<"Museum", 'String'>
    readonly nameRu: FieldRef<"Museum", 'String'>
    readonly descriptionRu: FieldRef<"Museum", 'String'>
    readonly cityRu: FieldRef<"Museum", 'String'>
    readonly addressRu: FieldRef<"Museum", 'String'>
    readonly nameDe: FieldRef<"Museum", 'String'>
    readonly descriptionDe: FieldRef<"Museum", 'String'>
    readonly cityDe: FieldRef<"Museum", 'String'>
    readonly addressDe: FieldRef<"Museum", 'String'>
    readonly nameFr: FieldRef<"Museum", 'String'>
    readonly descriptionFr: FieldRef<"Museum", 'String'>
    readonly cityFr: FieldRef<"Museum", 'String'>
    readonly addressFr: FieldRef<"Museum", 'String'>
    readonly slug: FieldRef<"Museum", 'String'>
    readonly coverImage: FieldRef<"Museum", 'String'>
    readonly latitude: FieldRef<"Museum", 'Float'>
    readonly longitude: FieldRef<"Museum", 'Float'>
    readonly contactEmail: FieldRef<"Museum", 'String'>
    readonly contactPhone: FieldRef<"Museum", 'String'>
    readonly website: FieldRef<"Museum", 'String'>
    readonly showMap: FieldRef<"Museum", 'Boolean'>
    readonly showQrScanner: FieldRef<"Museum", 'Boolean'>
    readonly isPublished: FieldRef<"Museum", 'Boolean'>
    readonly createdAt: FieldRef<"Museum", 'DateTime'>
    readonly updatedAt: FieldRef<"Museum", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Museum findUnique
   */
  export type MuseumFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Museum
     */
    select?: MuseumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuseumInclude<ExtArgs> | null
    /**
     * Filter, which Museum to fetch.
     */
    where: MuseumWhereUniqueInput
  }

  /**
   * Museum findUniqueOrThrow
   */
  export type MuseumFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Museum
     */
    select?: MuseumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuseumInclude<ExtArgs> | null
    /**
     * Filter, which Museum to fetch.
     */
    where: MuseumWhereUniqueInput
  }

  /**
   * Museum findFirst
   */
  export type MuseumFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Museum
     */
    select?: MuseumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuseumInclude<ExtArgs> | null
    /**
     * Filter, which Museum to fetch.
     */
    where?: MuseumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Museums to fetch.
     */
    orderBy?: MuseumOrderByWithRelationInput | MuseumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Museums.
     */
    cursor?: MuseumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Museums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Museums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Museums.
     */
    distinct?: MuseumScalarFieldEnum | MuseumScalarFieldEnum[]
  }

  /**
   * Museum findFirstOrThrow
   */
  export type MuseumFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Museum
     */
    select?: MuseumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuseumInclude<ExtArgs> | null
    /**
     * Filter, which Museum to fetch.
     */
    where?: MuseumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Museums to fetch.
     */
    orderBy?: MuseumOrderByWithRelationInput | MuseumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Museums.
     */
    cursor?: MuseumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Museums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Museums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Museums.
     */
    distinct?: MuseumScalarFieldEnum | MuseumScalarFieldEnum[]
  }

  /**
   * Museum findMany
   */
  export type MuseumFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Museum
     */
    select?: MuseumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuseumInclude<ExtArgs> | null
    /**
     * Filter, which Museums to fetch.
     */
    where?: MuseumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Museums to fetch.
     */
    orderBy?: MuseumOrderByWithRelationInput | MuseumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Museums.
     */
    cursor?: MuseumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Museums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Museums.
     */
    skip?: number
    distinct?: MuseumScalarFieldEnum | MuseumScalarFieldEnum[]
  }

  /**
   * Museum create
   */
  export type MuseumCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Museum
     */
    select?: MuseumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuseumInclude<ExtArgs> | null
    /**
     * The data needed to create a Museum.
     */
    data: XOR<MuseumCreateInput, MuseumUncheckedCreateInput>
  }

  /**
   * Museum createMany
   */
  export type MuseumCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Museums.
     */
    data: MuseumCreateManyInput | MuseumCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Museum createManyAndReturn
   */
  export type MuseumCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Museum
     */
    select?: MuseumSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Museums.
     */
    data: MuseumCreateManyInput | MuseumCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Museum update
   */
  export type MuseumUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Museum
     */
    select?: MuseumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuseumInclude<ExtArgs> | null
    /**
     * The data needed to update a Museum.
     */
    data: XOR<MuseumUpdateInput, MuseumUncheckedUpdateInput>
    /**
     * Choose, which Museum to update.
     */
    where: MuseumWhereUniqueInput
  }

  /**
   * Museum updateMany
   */
  export type MuseumUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Museums.
     */
    data: XOR<MuseumUpdateManyMutationInput, MuseumUncheckedUpdateManyInput>
    /**
     * Filter which Museums to update
     */
    where?: MuseumWhereInput
  }

  /**
   * Museum upsert
   */
  export type MuseumUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Museum
     */
    select?: MuseumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuseumInclude<ExtArgs> | null
    /**
     * The filter to search for the Museum to update in case it exists.
     */
    where: MuseumWhereUniqueInput
    /**
     * In case the Museum found by the `where` argument doesn't exist, create a new Museum with this data.
     */
    create: XOR<MuseumCreateInput, MuseumUncheckedCreateInput>
    /**
     * In case the Museum was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MuseumUpdateInput, MuseumUncheckedUpdateInput>
  }

  /**
   * Museum delete
   */
  export type MuseumDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Museum
     */
    select?: MuseumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuseumInclude<ExtArgs> | null
    /**
     * Filter which Museum to delete.
     */
    where: MuseumWhereUniqueInput
  }

  /**
   * Museum deleteMany
   */
  export type MuseumDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Museums to delete
     */
    where?: MuseumWhereInput
  }

  /**
   * Museum.tours
   */
  export type Museum$toursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    where?: TourWhereInput
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    cursor?: TourWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * Museum without action
   */
  export type MuseumDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Museum
     */
    select?: MuseumSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuseumInclude<ExtArgs> | null
  }


  /**
   * Model Tour
   */

  export type AggregateTour = {
    _count: TourCountAggregateOutputType | null
    _min: TourMinAggregateOutputType | null
    _max: TourMaxAggregateOutputType | null
  }

  export type TourMinAggregateOutputType = {
    id: string | null
    museumId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TourMaxAggregateOutputType = {
    id: string | null
    museumId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TourCountAggregateOutputType = {
    id: number
    museumId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TourMinAggregateInputType = {
    id?: true
    museumId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TourMaxAggregateInputType = {
    id?: true
    museumId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TourCountAggregateInputType = {
    id?: true
    museumId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TourAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tour to aggregate.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tours
    **/
    _count?: true | TourCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TourMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TourMaxAggregateInputType
  }

  export type GetTourAggregateType<T extends TourAggregateArgs> = {
        [P in keyof T & keyof AggregateTour]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTour[P]>
      : GetScalarType<T[P], AggregateTour[P]>
  }




  export type TourGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TourWhereInput
    orderBy?: TourOrderByWithAggregationInput | TourOrderByWithAggregationInput[]
    by: TourScalarFieldEnum[] | TourScalarFieldEnum
    having?: TourScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TourCountAggregateInputType | true
    _min?: TourMinAggregateInputType
    _max?: TourMaxAggregateInputType
  }

  export type TourGroupByOutputType = {
    id: string
    museumId: string
    createdAt: Date
    updatedAt: Date
    _count: TourCountAggregateOutputType | null
    _min: TourMinAggregateOutputType | null
    _max: TourMaxAggregateOutputType | null
  }

  type GetTourGroupByPayload<T extends TourGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TourGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TourGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TourGroupByOutputType[P]>
            : GetScalarType<T[P], TourGroupByOutputType[P]>
        }
      >
    >


  export type TourSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    museumId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    museum?: boolean | MuseumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tour"]>

  export type TourSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    museumId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    museum?: boolean | MuseumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tour"]>

  export type TourSelectScalar = {
    id?: boolean
    museumId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TourInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    museum?: boolean | MuseumDefaultArgs<ExtArgs>
  }
  export type TourIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    museum?: boolean | MuseumDefaultArgs<ExtArgs>
  }

  export type $TourPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tour"
    objects: {
      museum: Prisma.$MuseumPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      museumId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tour"]>
    composites: {}
  }

  type TourGetPayload<S extends boolean | null | undefined | TourDefaultArgs> = $Result.GetResult<Prisma.$TourPayload, S>

  type TourCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TourFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TourCountAggregateInputType | true
    }

  export interface TourDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tour'], meta: { name: 'Tour' } }
    /**
     * Find zero or one Tour that matches the filter.
     * @param {TourFindUniqueArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TourFindUniqueArgs>(args: SelectSubset<T, TourFindUniqueArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tour that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TourFindUniqueOrThrowArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TourFindUniqueOrThrowArgs>(args: SelectSubset<T, TourFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tour that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFindFirstArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TourFindFirstArgs>(args?: SelectSubset<T, TourFindFirstArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tour that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFindFirstOrThrowArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TourFindFirstOrThrowArgs>(args?: SelectSubset<T, TourFindFirstOrThrowArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tours
     * const tours = await prisma.tour.findMany()
     * 
     * // Get first 10 Tours
     * const tours = await prisma.tour.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tourWithIdOnly = await prisma.tour.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TourFindManyArgs>(args?: SelectSubset<T, TourFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tour.
     * @param {TourCreateArgs} args - Arguments to create a Tour.
     * @example
     * // Create one Tour
     * const Tour = await prisma.tour.create({
     *   data: {
     *     // ... data to create a Tour
     *   }
     * })
     * 
     */
    create<T extends TourCreateArgs>(args: SelectSubset<T, TourCreateArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tours.
     * @param {TourCreateManyArgs} args - Arguments to create many Tours.
     * @example
     * // Create many Tours
     * const tour = await prisma.tour.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TourCreateManyArgs>(args?: SelectSubset<T, TourCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tours and returns the data saved in the database.
     * @param {TourCreateManyAndReturnArgs} args - Arguments to create many Tours.
     * @example
     * // Create many Tours
     * const tour = await prisma.tour.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tours and only return the `id`
     * const tourWithIdOnly = await prisma.tour.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TourCreateManyAndReturnArgs>(args?: SelectSubset<T, TourCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tour.
     * @param {TourDeleteArgs} args - Arguments to delete one Tour.
     * @example
     * // Delete one Tour
     * const Tour = await prisma.tour.delete({
     *   where: {
     *     // ... filter to delete one Tour
     *   }
     * })
     * 
     */
    delete<T extends TourDeleteArgs>(args: SelectSubset<T, TourDeleteArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tour.
     * @param {TourUpdateArgs} args - Arguments to update one Tour.
     * @example
     * // Update one Tour
     * const tour = await prisma.tour.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TourUpdateArgs>(args: SelectSubset<T, TourUpdateArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tours.
     * @param {TourDeleteManyArgs} args - Arguments to filter Tours to delete.
     * @example
     * // Delete a few Tours
     * const { count } = await prisma.tour.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TourDeleteManyArgs>(args?: SelectSubset<T, TourDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tours
     * const tour = await prisma.tour.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TourUpdateManyArgs>(args: SelectSubset<T, TourUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tour.
     * @param {TourUpsertArgs} args - Arguments to update or create a Tour.
     * @example
     * // Update or create a Tour
     * const tour = await prisma.tour.upsert({
     *   create: {
     *     // ... data to create a Tour
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tour we want to update
     *   }
     * })
     */
    upsert<T extends TourUpsertArgs>(args: SelectSubset<T, TourUpsertArgs<ExtArgs>>): Prisma__TourClient<$Result.GetResult<Prisma.$TourPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourCountArgs} args - Arguments to filter Tours to count.
     * @example
     * // Count the number of Tours
     * const count = await prisma.tour.count({
     *   where: {
     *     // ... the filter for the Tours we want to count
     *   }
     * })
    **/
    count<T extends TourCountArgs>(
      args?: Subset<T, TourCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TourCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TourAggregateArgs>(args: Subset<T, TourAggregateArgs>): Prisma.PrismaPromise<GetTourAggregateType<T>>

    /**
     * Group by Tour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TourGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TourGroupByArgs['orderBy'] }
        : { orderBy?: TourGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TourGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTourGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tour model
   */
  readonly fields: TourFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tour.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TourClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    museum<T extends MuseumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MuseumDefaultArgs<ExtArgs>>): Prisma__MuseumClient<$Result.GetResult<Prisma.$MuseumPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tour model
   */ 
  interface TourFieldRefs {
    readonly id: FieldRef<"Tour", 'String'>
    readonly museumId: FieldRef<"Tour", 'String'>
    readonly createdAt: FieldRef<"Tour", 'DateTime'>
    readonly updatedAt: FieldRef<"Tour", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tour findUnique
   */
  export type TourFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where: TourWhereUniqueInput
  }

  /**
   * Tour findUniqueOrThrow
   */
  export type TourFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where: TourWhereUniqueInput
  }

  /**
   * Tour findFirst
   */
  export type TourFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tours.
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tours.
     */
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * Tour findFirstOrThrow
   */
  export type TourFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tour to fetch.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tours.
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tours.
     */
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * Tour findMany
   */
  export type TourFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter, which Tours to fetch.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: TourOrderByWithRelationInput | TourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tours.
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * Tour create
   */
  export type TourCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * The data needed to create a Tour.
     */
    data: XOR<TourCreateInput, TourUncheckedCreateInput>
  }

  /**
   * Tour createMany
   */
  export type TourCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tours.
     */
    data: TourCreateManyInput | TourCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tour createManyAndReturn
   */
  export type TourCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tours.
     */
    data: TourCreateManyInput | TourCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tour update
   */
  export type TourUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * The data needed to update a Tour.
     */
    data: XOR<TourUpdateInput, TourUncheckedUpdateInput>
    /**
     * Choose, which Tour to update.
     */
    where: TourWhereUniqueInput
  }

  /**
   * Tour updateMany
   */
  export type TourUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tours.
     */
    data: XOR<TourUpdateManyMutationInput, TourUncheckedUpdateManyInput>
    /**
     * Filter which Tours to update
     */
    where?: TourWhereInput
  }

  /**
   * Tour upsert
   */
  export type TourUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * The filter to search for the Tour to update in case it exists.
     */
    where: TourWhereUniqueInput
    /**
     * In case the Tour found by the `where` argument doesn't exist, create a new Tour with this data.
     */
    create: XOR<TourCreateInput, TourUncheckedCreateInput>
    /**
     * In case the Tour was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TourUpdateInput, TourUncheckedUpdateInput>
  }

  /**
   * Tour delete
   */
  export type TourDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
    /**
     * Filter which Tour to delete.
     */
    where: TourWhereUniqueInput
  }

  /**
   * Tour deleteMany
   */
  export type TourDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tours to delete
     */
    where?: TourWhereInput
  }

  /**
   * Tour without action
   */
  export type TourDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TourInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    plan: 'plan',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    code: 'code',
    legalName: 'legalName',
    taxId: 'taxId',
    phone: 'phone',
    email: 'email',
    address: 'address',
    website: 'website',
    bankName: 'bankName',
    bankAccount: 'bankAccount',
    bankSwift: 'bankSwift'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    email: 'email',
    name: 'name',
    role: 'role',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    password: 'password',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RecipeScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    createdBy: 'createdBy',
    name: 'name',
    style: 'style',
    abv: 'abv',
    ibu: 'ibu',
    color: 'color',
    og: 'og',
    fg: 'fg',
    batchSize: 'batchSize',
    boilTime: 'boilTime',
    efficiency: 'efficiency',
    description: 'description',
    notes: 'notes',
    process: 'process',
    status: 'status',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    yeastStrain: 'yeastStrain'
  };

  export type RecipeScalarFieldEnum = (typeof RecipeScalarFieldEnum)[keyof typeof RecipeScalarFieldEnum]


  export const RecipeIngredientScalarFieldEnum: {
    id: 'id',
    recipeId: 'recipeId',
    inventoryItemId: 'inventoryItemId',
    name: 'name',
    category: 'category',
    amount: 'amount',
    unit: 'unit',
    additionTime: 'additionTime',
    specs: 'specs'
  };

  export type RecipeIngredientScalarFieldEnum = (typeof RecipeIngredientScalarFieldEnum)[keyof typeof RecipeIngredientScalarFieldEnum]


  export const InventoryItemScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    sku: 'sku',
    name: 'name',
    category: 'category',
    ingredientType: 'ingredientType',
    unit: 'unit',
    reorderPoint: 'reorderPoint',
    supplier: 'supplier',
    location: 'location',
    specs: 'specs',
    cachedBalance: 'cachedBalance',
    costPerUnit: 'costPerUnit',
    balanceUpdatedAt: 'balanceUpdatedAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


  export const InventoryLedgerScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    itemId: 'itemId',
    quantity: 'quantity',
    type: 'type',
    batchId: 'batchId',
    orderId: 'orderId',
    packagingId: 'packagingId',
    notes: 'notes',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type InventoryLedgerScalarFieldEnum = (typeof InventoryLedgerScalarFieldEnum)[keyof typeof InventoryLedgerScalarFieldEnum]


  export const IngredientCatalogScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    supplier: 'supplier',
    origin: 'origin',
    specs: 'specs',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IngredientCatalogScalarFieldEnum = (typeof IngredientCatalogScalarFieldEnum)[keyof typeof IngredientCatalogScalarFieldEnum]


  export const BatchScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    batchNumber: 'batchNumber',
    recipeId: 'recipeId',
    status: 'status',
    volume: 'volume',
    packagedVolume: 'packagedVolume',
    originalGravity: 'originalGravity',
    currentGravity: 'currentGravity',
    finalGravity: 'finalGravity',
    abv: 'abv',
    tankId: 'tankId',
    plannedDate: 'plannedDate',
    brewedAt: 'brewedAt',
    fermentationStartedAt: 'fermentationStartedAt',
    conditioningStartedAt: 'conditioningStartedAt',
    readyAt: 'readyAt',
    completedAt: 'completedAt',
    createdBy: 'createdBy',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    targetOg: 'targetOg',
    fermentationTankId: 'fermentationTankId'
  };

  export type BatchScalarFieldEnum = (typeof BatchScalarFieldEnum)[keyof typeof BatchScalarFieldEnum]


  export const BatchIngredientScalarFieldEnum: {
    id: 'id',
    batchId: 'batchId',
    inventoryItemId: 'inventoryItemId',
    name: 'name',
    category: 'category',
    plannedAmount: 'plannedAmount',
    actualAmount: 'actualAmount',
    unit: 'unit',
    lotNumber: 'lotNumber',
    addedAt: 'addedAt'
  };

  export type BatchIngredientScalarFieldEnum = (typeof BatchIngredientScalarFieldEnum)[keyof typeof BatchIngredientScalarFieldEnum]


  export const GravityReadingScalarFieldEnum: {
    id: 'id',
    batchId: 'batchId',
    gravity: 'gravity',
    temperature: 'temperature',
    notes: 'notes',
    recordedBy: 'recordedBy',
    recordedAt: 'recordedAt'
  };

  export type GravityReadingScalarFieldEnum = (typeof GravityReadingScalarFieldEnum)[keyof typeof GravityReadingScalarFieldEnum]


  export const BatchTimelineScalarFieldEnum: {
    id: 'id',
    batchId: 'batchId',
    type: 'type',
    title: 'title',
    description: 'description',
    data: 'data',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type BatchTimelineScalarFieldEnum = (typeof BatchTimelineScalarFieldEnum)[keyof typeof BatchTimelineScalarFieldEnum]


  export const TankScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    type: 'type',
    capacity: 'capacity',
    status: 'status',
    currentBatchId: 'currentBatchId',
    location: 'location',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    capabilities: 'capabilities',
    currentLotId: 'currentLotId',
    currentPhase: 'currentPhase',
    defaultTurnaroundHours: 'defaultTurnaroundHours',
    maxFillPercent: 'maxFillPercent',
    minFillPercent: 'minFillPercent'
  };

  export type TankScalarFieldEnum = (typeof TankScalarFieldEnum)[keyof typeof TankScalarFieldEnum]


  export const TankOccupationScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    tankId: 'tankId',
    batchId: 'batchId',
    phase: 'phase',
    startedAt: 'startedAt',
    endedAt: 'endedAt'
  };

  export type TankOccupationScalarFieldEnum = (typeof TankOccupationScalarFieldEnum)[keyof typeof TankOccupationScalarFieldEnum]


  export const PackagingRunScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    batchId: 'batchId',
    packageType: 'packageType',
    quantity: 'quantity',
    volumeTotal: 'volumeTotal',
    lotNumber: 'lotNumber',
    performedBy: 'performedBy',
    notes: 'notes',
    performedAt: 'performedAt'
  };

  export type PackagingRunScalarFieldEnum = (typeof PackagingRunScalarFieldEnum)[keyof typeof PackagingRunScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    type: 'type',
    email: 'email',
    phone: 'phone',
    address: 'address',
    city: 'city',
    taxId: 'taxId',
    kegReturnDays: 'kegReturnDays',
    kegDepositRequired: 'kegDepositRequired',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    category: 'category',
    email: 'email',
    phone: 'phone',
    address: 'address',
    city: 'city',
    taxId: 'taxId',
    bankAccount: 'bankAccount',
    notes: 'notes',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const SalesOrderScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    orderNumber: 'orderNumber',
    customerId: 'customerId',
    status: 'status',
    paymentStatus: 'paymentStatus',
    totalAmount: 'totalAmount',
    paidAmount: 'paidAmount',
    notes: 'notes',
    orderedAt: 'orderedAt',
    shippedAt: 'shippedAt',
    deliveredAt: 'deliveredAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt'
  };

  export type SalesOrderScalarFieldEnum = (typeof SalesOrderScalarFieldEnum)[keyof typeof SalesOrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productName: 'productName',
    packageType: 'packageType',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice',
    batchId: 'batchId'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    type: 'type',
    date: 'date',
    amount: 'amount',
    incomeCategory: 'incomeCategory',
    expenseCategory: 'expenseCategory',
    description: 'description',
    customerId: 'customerId',
    supplierId: 'supplierId',
    orderId: 'orderId',
    invoiceId: 'invoiceId',
    expenseId: 'expenseId',
    paymentId: 'paymentId',
    paymentMethod: 'paymentMethod',
    reference: 'reference',
    notes: 'notes',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    invoiceNumber: 'invoiceNumber',
    type: 'type',
    status: 'status',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    paidAt: 'paidAt',
    customerId: 'customerId',
    supplierId: 'supplierId',
    orderId: 'orderId',
    subtotal: 'subtotal',
    discount: 'discount',
    tax: 'tax',
    total: 'total',
    paidAmount: 'paidAmount',
    notes: 'notes',
    terms: 'terms',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    description: 'description',
    quantity: 'quantity',
    unit: 'unit',
    unitPrice: 'unitPrice',
    total: 'total',
    productName: 'productName',
    packageType: 'packageType',
    batchId: 'batchId',
    sortOrder: 'sortOrder'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    invoiceId: 'invoiceId',
    orderId: 'orderId',
    amount: 'amount',
    method: 'method',
    date: 'date',
    reference: 'reference',
    notes: 'notes',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    category: 'category',
    supplierId: 'supplierId',
    amount: 'amount',
    date: 'date',
    description: 'description',
    invoiceNumber: 'invoiceNumber',
    invoiceId: 'invoiceId',
    isPaid: 'isPaid',
    paidAt: 'paidAt',
    paymentMethod: 'paymentMethod',
    receiptUrl: 'receiptUrl',
    notes: 'notes',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const BudgetScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    category: 'category',
    year: 'year',
    month: 'month',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BudgetScalarFieldEnum = (typeof BudgetScalarFieldEnum)[keyof typeof BudgetScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    oldData: 'oldData',
    newData: 'newData',
    metadata: 'metadata',
    correlationId: 'correlationId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const BlendingConfigScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    requireRecipeMatch: 'requireRecipeMatch',
    requireYeastMatch: 'requireYeastMatch',
    requirePhaseMatch: 'requirePhaseMatch',
    requireStyleMatch: 'requireStyleMatch',
    maxBlendSources: 'maxBlendSources',
    allowOverCapacity: 'allowOverCapacity',
    maxAgeDifferenceHours: 'maxAgeDifferenceHours',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlendingConfigScalarFieldEnum = (typeof BlendingConfigScalarFieldEnum)[keyof typeof BlendingConfigScalarFieldEnum]


  export const CIPLogScalarFieldEnum: {
    id: 'id',
    equipmentId: 'equipmentId',
    cipType: 'cipType',
    date: 'date',
    duration: 'duration',
    temperature: 'temperature',
    causticConcentration: 'causticConcentration',
    performedBy: 'performedBy',
    result: 'result',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type CIPLogScalarFieldEnum = (typeof CIPLogScalarFieldEnum)[keyof typeof CIPLogScalarFieldEnum]


  export const EquipmentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    type: 'type',
    status: 'status',
    capacity: 'capacity',
    model: 'model',
    manufacturer: 'manufacturer',
    serialNumber: 'serialNumber',
    location: 'location',
    workingPressure: 'workingPressure',
    currentTemp: 'currentTemp',
    currentPressure: 'currentPressure',
    installationDate: 'installationDate',
    warrantyDate: 'warrantyDate',
    lastCIP: 'lastCIP',
    nextCIP: 'nextCIP',
    lastMaintenance: 'lastMaintenance',
    nextMaintenance: 'nextMaintenance',
    cipIntervalDays: 'cipIntervalDays',
    inspectionIntervalDays: 'inspectionIntervalDays',
    annualMaintenanceDays: 'annualMaintenanceDays',
    currentBatchId: 'currentBatchId',
    currentBatchNumber: 'currentBatchNumber',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    purchaseDate: 'purchaseDate',
    capabilities: 'capabilities'
  };

  export type EquipmentScalarFieldEnum = (typeof EquipmentScalarFieldEnum)[keyof typeof EquipmentScalarFieldEnum]


  export const LotScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    lotCode: 'lotCode',
    phase: 'phase',
    status: 'status',
    plannedVolume: 'plannedVolume',
    actualVolume: 'actualVolume',
    notes: 'notes',
    parentLotId: 'parentLotId',
    splitRatio: 'splitRatio',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt',
    lotNumber: 'lotNumber',
    blendedAt: 'blendedAt',
    isBlendResult: 'isBlendResult',
    splitAt: 'splitAt'
  };

  export type LotScalarFieldEnum = (typeof LotScalarFieldEnum)[keyof typeof LotScalarFieldEnum]


  export const LotBatchScalarFieldEnum: {
    id: 'id',
    lotId: 'lotId',
    batchId: 'batchId',
    volumeContribution: 'volumeContribution',
    batchPercentage: 'batchPercentage',
    addedAt: 'addedAt'
  };

  export type LotBatchScalarFieldEnum = (typeof LotBatchScalarFieldEnum)[keyof typeof LotBatchScalarFieldEnum]


  export const LotReadingScalarFieldEnum: {
    id: 'id',
    lotId: 'lotId',
    tankId: 'tankId',
    readingType: 'readingType',
    value: 'value',
    unit: 'unit',
    notes: 'notes',
    recordedBy: 'recordedBy',
    recordedAt: 'recordedAt'
  };

  export type LotReadingScalarFieldEnum = (typeof LotReadingScalarFieldEnum)[keyof typeof LotReadingScalarFieldEnum]


  export const MaintenanceLogScalarFieldEnum: {
    id: 'id',
    equipmentId: 'equipmentId',
    type: 'type',
    status: 'status',
    priority: 'priority',
    scheduledDate: 'scheduledDate',
    completedDate: 'completedDate',
    duration: 'duration',
    performedBy: 'performedBy',
    cost: 'cost',
    partsUsed: 'partsUsed',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaintenanceLogScalarFieldEnum = (typeof MaintenanceLogScalarFieldEnum)[keyof typeof MaintenanceLogScalarFieldEnum]


  export const ProblemReportScalarFieldEnum: {
    id: 'id',
    equipmentId: 'equipmentId',
    problemType: 'problemType',
    severity: 'severity',
    status: 'status',
    description: 'description',
    reportedDate: 'reportedDate',
    reportedBy: 'reportedBy',
    resolvedDate: 'resolvedDate',
    resolvedBy: 'resolvedBy',
    resolution: 'resolution',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProblemReportScalarFieldEnum = (typeof ProblemReportScalarFieldEnum)[keyof typeof ProblemReportScalarFieldEnum]


  export const TankAssignmentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    tankId: 'tankId',
    lotId: 'lotId',
    phase: 'phase',
    plannedStart: 'plannedStart',
    plannedEnd: 'plannedEnd',
    actualStart: 'actualStart',
    actualEnd: 'actualEnd',
    status: 'status',
    plannedVolume: 'plannedVolume',
    actualVolume: 'actualVolume',
    isBlendTarget: 'isBlendTarget',
    isSplitSource: 'isSplitSource',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    startTime: 'startTime',
    endTime: 'endTime',
    notes: 'notes'
  };

  export type TankAssignmentScalarFieldEnum = (typeof TankAssignmentScalarFieldEnum)[keyof typeof TankAssignmentScalarFieldEnum]


  export const TransferScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    transferCode: 'transferCode',
    sourceLotId: 'sourceLotId',
    sourceTankId: 'sourceTankId',
    destLotId: 'destLotId',
    destTankId: 'destTankId',
    transferType: 'transferType',
    volume: 'volume',
    plannedAt: 'plannedAt',
    executedAt: 'executedAt',
    status: 'status',
    measuredLoss: 'measuredLoss',
    lossReason: 'lossReason',
    performedBy: 'performedBy',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransferScalarFieldEnum = (typeof TransferScalarFieldEnum)[keyof typeof TransferScalarFieldEnum]


  export const KegScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    kegNumber: 'kegNumber',
    size: 'size',
    status: 'status',
    condition: 'condition',
    batchId: 'batchId',
    filledAt: 'filledAt',
    productName: 'productName',
    lotNumber: 'lotNumber',
    customerId: 'customerId',
    orderId: 'orderId',
    sentAt: 'sentAt',
    returnedAt: 'returnedAt',
    deposit: 'deposit',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KegScalarFieldEnum = (typeof KegScalarFieldEnum)[keyof typeof KegScalarFieldEnum]


  export const KegMovementScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    kegId: 'kegId',
    action: 'action',
    fromStatus: 'fromStatus',
    toStatus: 'toStatus',
    productId: 'productId',
    productName: 'productName',
    customerId: 'customerId',
    customerName: 'customerName',
    orderId: 'orderId',
    batchId: 'batchId',
    notes: 'notes',
    createdAt: 'createdAt',
    createdBy: 'createdBy'
  };

  export type KegMovementScalarFieldEnum = (typeof KegMovementScalarFieldEnum)[keyof typeof KegMovementScalarFieldEnum]


  export const QCTestScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    batchId: 'batchId',
    lotId: 'lotId',
    testType: 'testType',
    status: 'status',
    priority: 'priority',
    scheduledDate: 'scheduledDate',
    completedDate: 'completedDate',
    minValue: 'minValue',
    maxValue: 'maxValue',
    targetValue: 'targetValue',
    result: 'result',
    unit: 'unit',
    notes: 'notes',
    performedBy: 'performedBy',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QCTestScalarFieldEnum = (typeof QCTestScalarFieldEnum)[keyof typeof QCTestScalarFieldEnum]


  export const ConfigurationScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type ConfigurationScalarFieldEnum = (typeof ConfigurationScalarFieldEnum)[keyof typeof ConfigurationScalarFieldEnum]


  export const MuseumScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    city: 'city',
    address: 'address',
    nameEn: 'nameEn',
    descriptionEn: 'descriptionEn',
    cityEn: 'cityEn',
    addressEn: 'addressEn',
    nameRu: 'nameRu',
    descriptionRu: 'descriptionRu',
    cityRu: 'cityRu',
    addressRu: 'addressRu',
    nameDe: 'nameDe',
    descriptionDe: 'descriptionDe',
    cityDe: 'cityDe',
    addressDe: 'addressDe',
    nameFr: 'nameFr',
    descriptionFr: 'descriptionFr',
    cityFr: 'cityFr',
    addressFr: 'addressFr',
    slug: 'slug',
    coverImage: 'coverImage',
    latitude: 'latitude',
    longitude: 'longitude',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    website: 'website',
    showMap: 'showMap',
    showQrScanner: 'showQrScanner',
    isPublished: 'isPublished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MuseumScalarFieldEnum = (typeof MuseumScalarFieldEnum)[keyof typeof MuseumScalarFieldEnum]


  export const TourScalarFieldEnum: {
    id: 'id',
    museumId: 'museumId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TourScalarFieldEnum = (typeof TourScalarFieldEnum)[keyof typeof TourScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'PlanType'
   */
  export type EnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType'>
    


  /**
   * Reference to a field of type 'PlanType[]'
   */
  export type ListEnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'RecipeStatus'
   */
  export type EnumRecipeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecipeStatus'>
    


  /**
   * Reference to a field of type 'RecipeStatus[]'
   */
  export type ListEnumRecipeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecipeStatus[]'>
    


  /**
   * Reference to a field of type 'IngredientCategory'
   */
  export type EnumIngredientCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IngredientCategory'>
    


  /**
   * Reference to a field of type 'IngredientCategory[]'
   */
  export type ListEnumIngredientCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IngredientCategory[]'>
    


  /**
   * Reference to a field of type 'InventoryCategory'
   */
  export type EnumInventoryCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryCategory'>
    


  /**
   * Reference to a field of type 'InventoryCategory[]'
   */
  export type ListEnumInventoryCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryCategory[]'>
    


  /**
   * Reference to a field of type 'LedgerEntryType'
   */
  export type EnumLedgerEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerEntryType'>
    


  /**
   * Reference to a field of type 'LedgerEntryType[]'
   */
  export type ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerEntryType[]'>
    


  /**
   * Reference to a field of type 'BatchStatus'
   */
  export type EnumBatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BatchStatus'>
    


  /**
   * Reference to a field of type 'BatchStatus[]'
   */
  export type ListEnumBatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BatchStatus[]'>
    


  /**
   * Reference to a field of type 'TimelineEventType'
   */
  export type EnumTimelineEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TimelineEventType'>
    


  /**
   * Reference to a field of type 'TimelineEventType[]'
   */
  export type ListEnumTimelineEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TimelineEventType[]'>
    


  /**
   * Reference to a field of type 'TankType'
   */
  export type EnumTankTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TankType'>
    


  /**
   * Reference to a field of type 'TankType[]'
   */
  export type ListEnumTankTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TankType[]'>
    


  /**
   * Reference to a field of type 'TankStatus'
   */
  export type EnumTankStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TankStatus'>
    


  /**
   * Reference to a field of type 'TankStatus[]'
   */
  export type ListEnumTankStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TankStatus[]'>
    


  /**
   * Reference to a field of type 'TankCapability[]'
   */
  export type ListEnumTankCapabilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TankCapability[]'>
    


  /**
   * Reference to a field of type 'TankCapability'
   */
  export type EnumTankCapabilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TankCapability'>
    


  /**
   * Reference to a field of type 'LotPhase'
   */
  export type EnumLotPhaseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LotPhase'>
    


  /**
   * Reference to a field of type 'LotPhase[]'
   */
  export type ListEnumLotPhaseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LotPhase[]'>
    


  /**
   * Reference to a field of type 'OccupationPhase'
   */
  export type EnumOccupationPhaseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OccupationPhase'>
    


  /**
   * Reference to a field of type 'OccupationPhase[]'
   */
  export type ListEnumOccupationPhaseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OccupationPhase[]'>
    


  /**
   * Reference to a field of type 'PackageType'
   */
  export type EnumPackageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PackageType'>
    


  /**
   * Reference to a field of type 'PackageType[]'
   */
  export type ListEnumPackageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PackageType[]'>
    


  /**
   * Reference to a field of type 'CustomerType'
   */
  export type EnumCustomerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerType'>
    


  /**
   * Reference to a field of type 'CustomerType[]'
   */
  export type ListEnumCustomerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerType[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'IncomeCategory'
   */
  export type EnumIncomeCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncomeCategory'>
    


  /**
   * Reference to a field of type 'IncomeCategory[]'
   */
  export type ListEnumIncomeCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncomeCategory[]'>
    


  /**
   * Reference to a field of type 'ExpenseCategory'
   */
  export type EnumExpenseCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseCategory'>
    


  /**
   * Reference to a field of type 'ExpenseCategory[]'
   */
  export type ListEnumExpenseCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseCategory[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'InvoiceType'
   */
  export type EnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType'>
    


  /**
   * Reference to a field of type 'InvoiceType[]'
   */
  export type ListEnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'LotStatus'
   */
  export type EnumLotStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LotStatus'>
    


  /**
   * Reference to a field of type 'LotStatus[]'
   */
  export type ListEnumLotStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LotStatus[]'>
    


  /**
   * Reference to a field of type 'ReadingType'
   */
  export type EnumReadingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReadingType'>
    


  /**
   * Reference to a field of type 'ReadingType[]'
   */
  export type ListEnumReadingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReadingType[]'>
    


  /**
   * Reference to a field of type 'AssignmentStatus'
   */
  export type EnumAssignmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentStatus'>
    


  /**
   * Reference to a field of type 'AssignmentStatus[]'
   */
  export type ListEnumAssignmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentStatus[]'>
    


  /**
   * Reference to a field of type 'TransferType'
   */
  export type EnumTransferTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferType'>
    


  /**
   * Reference to a field of type 'TransferType[]'
   */
  export type ListEnumTransferTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferType[]'>
    


  /**
   * Reference to a field of type 'TransferStatus'
   */
  export type EnumTransferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferStatus'>
    


  /**
   * Reference to a field of type 'TransferStatus[]'
   */
  export type ListEnumTransferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferStatus[]'>
    


  /**
   * Reference to a field of type 'KegStatus'
   */
  export type EnumKegStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KegStatus'>
    


  /**
   * Reference to a field of type 'KegStatus[]'
   */
  export type ListEnumKegStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KegStatus[]'>
    


  /**
   * Reference to a field of type 'KegCondition'
   */
  export type EnumKegConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KegCondition'>
    


  /**
   * Reference to a field of type 'KegCondition[]'
   */
  export type ListEnumKegConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KegCondition[]'>
    


  /**
   * Reference to a field of type 'KegAction'
   */
  export type EnumKegActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KegAction'>
    


  /**
   * Reference to a field of type 'KegAction[]'
   */
  export type ListEnumKegActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KegAction[]'>
    


  /**
   * Reference to a field of type 'QCTestType'
   */
  export type EnumQCTestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QCTestType'>
    


  /**
   * Reference to a field of type 'QCTestType[]'
   */
  export type ListEnumQCTestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QCTestType[]'>
    


  /**
   * Reference to a field of type 'QCTestStatus'
   */
  export type EnumQCTestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QCTestStatus'>
    


  /**
   * Reference to a field of type 'QCTestStatus[]'
   */
  export type ListEnumQCTestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QCTestStatus[]'>
    


  /**
   * Reference to a field of type 'QCTestPriority'
   */
  export type EnumQCTestPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QCTestPriority'>
    


  /**
   * Reference to a field of type 'QCTestPriority[]'
   */
  export type ListEnumQCTestPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QCTestPriority[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    slug?: StringFilter<"Tenant"> | string
    plan?: EnumPlanTypeFilter<"Tenant"> | $Enums.PlanType
    isActive?: BoolFilter<"Tenant"> | boolean
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    code?: StringFilter<"Tenant"> | string
    legalName?: StringNullableFilter<"Tenant"> | string | null
    taxId?: StringNullableFilter<"Tenant"> | string | null
    phone?: StringNullableFilter<"Tenant"> | string | null
    email?: StringNullableFilter<"Tenant"> | string | null
    address?: StringNullableFilter<"Tenant"> | string | null
    website?: StringNullableFilter<"Tenant"> | string | null
    bankName?: StringNullableFilter<"Tenant"> | string | null
    bankAccount?: StringNullableFilter<"Tenant"> | string | null
    bankSwift?: StringNullableFilter<"Tenant"> | string | null
    batches?: BatchListRelationFilter
    budgets?: BudgetListRelationFilter
    customers?: CustomerListRelationFilter
    Equipment?: EquipmentListRelationFilter
    expenses?: ExpenseListRelationFilter
    inventory?: InventoryItemListRelationFilter
    invoices?: InvoiceListRelationFilter
    Keg?: KegListRelationFilter
    payments?: PaymentListRelationFilter
    recipes?: RecipeListRelationFilter
    orders?: SalesOrderListRelationFilter
    suppliers?: SupplierListRelationFilter
    tanks?: TankListRelationFilter
    transactions?: TransactionListRelationFilter
    users?: UserListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    plan?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    legalName?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    bankSwift?: SortOrderInput | SortOrder
    batches?: BatchOrderByRelationAggregateInput
    budgets?: BudgetOrderByRelationAggregateInput
    customers?: CustomerOrderByRelationAggregateInput
    Equipment?: EquipmentOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    inventory?: InventoryItemOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    Keg?: KegOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    recipes?: RecipeOrderByRelationAggregateInput
    orders?: SalesOrderOrderByRelationAggregateInput
    suppliers?: SupplierOrderByRelationAggregateInput
    tanks?: TankOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    code?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    plan?: EnumPlanTypeFilter<"Tenant"> | $Enums.PlanType
    isActive?: BoolFilter<"Tenant"> | boolean
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    legalName?: StringNullableFilter<"Tenant"> | string | null
    taxId?: StringNullableFilter<"Tenant"> | string | null
    phone?: StringNullableFilter<"Tenant"> | string | null
    email?: StringNullableFilter<"Tenant"> | string | null
    address?: StringNullableFilter<"Tenant"> | string | null
    website?: StringNullableFilter<"Tenant"> | string | null
    bankName?: StringNullableFilter<"Tenant"> | string | null
    bankAccount?: StringNullableFilter<"Tenant"> | string | null
    bankSwift?: StringNullableFilter<"Tenant"> | string | null
    batches?: BatchListRelationFilter
    budgets?: BudgetListRelationFilter
    customers?: CustomerListRelationFilter
    Equipment?: EquipmentListRelationFilter
    expenses?: ExpenseListRelationFilter
    inventory?: InventoryItemListRelationFilter
    invoices?: InvoiceListRelationFilter
    Keg?: KegListRelationFilter
    payments?: PaymentListRelationFilter
    recipes?: RecipeListRelationFilter
    orders?: SalesOrderListRelationFilter
    suppliers?: SupplierListRelationFilter
    tanks?: TankListRelationFilter
    transactions?: TransactionListRelationFilter
    users?: UserListRelationFilter
  }, "id" | "slug" | "code">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    plan?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    legalName?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    bankSwift?: SortOrderInput | SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    slug?: StringWithAggregatesFilter<"Tenant"> | string
    plan?: EnumPlanTypeWithAggregatesFilter<"Tenant"> | $Enums.PlanType
    isActive?: BoolWithAggregatesFilter<"Tenant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    code?: StringWithAggregatesFilter<"Tenant"> | string
    legalName?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    email?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    address?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    website?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    bankAccount?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    bankSwift?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    password?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_email?: UserTenantIdEmailCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    tenantId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    password?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id" | "tenantId_email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    tenantId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type RecipeWhereInput = {
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    id?: StringFilter<"Recipe"> | string
    tenantId?: StringFilter<"Recipe"> | string
    createdBy?: StringNullableFilter<"Recipe"> | string | null
    name?: StringFilter<"Recipe"> | string
    style?: StringNullableFilter<"Recipe"> | string | null
    abv?: DecimalNullableFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    ibu?: IntNullableFilter<"Recipe"> | number | null
    color?: IntNullableFilter<"Recipe"> | number | null
    og?: DecimalNullableFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    fg?: DecimalNullableFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    batchSize?: DecimalNullableFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    boilTime?: IntNullableFilter<"Recipe"> | number | null
    efficiency?: DecimalNullableFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"Recipe"> | string | null
    notes?: StringNullableFilter<"Recipe"> | string | null
    process?: JsonNullableFilter<"Recipe">
    status?: EnumRecipeStatusFilter<"Recipe"> | $Enums.RecipeStatus
    isActive?: BoolFilter<"Recipe"> | boolean
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeFilter<"Recipe"> | Date | string
    yeastStrain?: StringNullableFilter<"Recipe"> | string | null
    batches?: BatchListRelationFilter
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    ingredients?: RecipeIngredientListRelationFilter
  }

  export type RecipeOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    name?: SortOrder
    style?: SortOrderInput | SortOrder
    abv?: SortOrderInput | SortOrder
    ibu?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    og?: SortOrderInput | SortOrder
    fg?: SortOrderInput | SortOrder
    batchSize?: SortOrderInput | SortOrder
    boilTime?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    process?: SortOrderInput | SortOrder
    status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yeastStrain?: SortOrderInput | SortOrder
    batches?: BatchOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
    ingredients?: RecipeIngredientOrderByRelationAggregateInput
  }

  export type RecipeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_name?: RecipeTenantIdNameCompoundUniqueInput
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    tenantId?: StringFilter<"Recipe"> | string
    createdBy?: StringNullableFilter<"Recipe"> | string | null
    name?: StringFilter<"Recipe"> | string
    style?: StringNullableFilter<"Recipe"> | string | null
    abv?: DecimalNullableFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    ibu?: IntNullableFilter<"Recipe"> | number | null
    color?: IntNullableFilter<"Recipe"> | number | null
    og?: DecimalNullableFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    fg?: DecimalNullableFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    batchSize?: DecimalNullableFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    boilTime?: IntNullableFilter<"Recipe"> | number | null
    efficiency?: DecimalNullableFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"Recipe"> | string | null
    notes?: StringNullableFilter<"Recipe"> | string | null
    process?: JsonNullableFilter<"Recipe">
    status?: EnumRecipeStatusFilter<"Recipe"> | $Enums.RecipeStatus
    isActive?: BoolFilter<"Recipe"> | boolean
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeFilter<"Recipe"> | Date | string
    yeastStrain?: StringNullableFilter<"Recipe"> | string | null
    batches?: BatchListRelationFilter
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    ingredients?: RecipeIngredientListRelationFilter
  }, "id" | "tenantId_name">

  export type RecipeOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    name?: SortOrder
    style?: SortOrderInput | SortOrder
    abv?: SortOrderInput | SortOrder
    ibu?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    og?: SortOrderInput | SortOrder
    fg?: SortOrderInput | SortOrder
    batchSize?: SortOrderInput | SortOrder
    boilTime?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    process?: SortOrderInput | SortOrder
    status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yeastStrain?: SortOrderInput | SortOrder
    _count?: RecipeCountOrderByAggregateInput
    _avg?: RecipeAvgOrderByAggregateInput
    _max?: RecipeMaxOrderByAggregateInput
    _min?: RecipeMinOrderByAggregateInput
    _sum?: RecipeSumOrderByAggregateInput
  }

  export type RecipeScalarWhereWithAggregatesInput = {
    AND?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    OR?: RecipeScalarWhereWithAggregatesInput[]
    NOT?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Recipe"> | string
    tenantId?: StringWithAggregatesFilter<"Recipe"> | string
    createdBy?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    name?: StringWithAggregatesFilter<"Recipe"> | string
    style?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    abv?: DecimalNullableWithAggregatesFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    ibu?: IntNullableWithAggregatesFilter<"Recipe"> | number | null
    color?: IntNullableWithAggregatesFilter<"Recipe"> | number | null
    og?: DecimalNullableWithAggregatesFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    fg?: DecimalNullableWithAggregatesFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    batchSize?: DecimalNullableWithAggregatesFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    boilTime?: IntNullableWithAggregatesFilter<"Recipe"> | number | null
    efficiency?: DecimalNullableWithAggregatesFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    process?: JsonNullableWithAggregatesFilter<"Recipe">
    status?: EnumRecipeStatusWithAggregatesFilter<"Recipe"> | $Enums.RecipeStatus
    isActive?: BoolWithAggregatesFilter<"Recipe"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Recipe"> | Date | string
    yeastStrain?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
  }

  export type RecipeIngredientWhereInput = {
    AND?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    OR?: RecipeIngredientWhereInput[]
    NOT?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    id?: StringFilter<"RecipeIngredient"> | string
    recipeId?: StringFilter<"RecipeIngredient"> | string
    inventoryItemId?: StringNullableFilter<"RecipeIngredient"> | string | null
    name?: StringFilter<"RecipeIngredient"> | string
    category?: EnumIngredientCategoryFilter<"RecipeIngredient"> | $Enums.IngredientCategory
    amount?: DecimalFilter<"RecipeIngredient"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"RecipeIngredient"> | string
    additionTime?: IntNullableFilter<"RecipeIngredient"> | number | null
    specs?: JsonNullableFilter<"RecipeIngredient">
    inventoryItem?: XOR<InventoryItemNullableRelationFilter, InventoryItemWhereInput> | null
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
  }

  export type RecipeIngredientOrderByWithRelationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    inventoryItemId?: SortOrderInput | SortOrder
    name?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    additionTime?: SortOrderInput | SortOrder
    specs?: SortOrderInput | SortOrder
    inventoryItem?: InventoryItemOrderByWithRelationInput
    recipe?: RecipeOrderByWithRelationInput
  }

  export type RecipeIngredientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    OR?: RecipeIngredientWhereInput[]
    NOT?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    recipeId?: StringFilter<"RecipeIngredient"> | string
    inventoryItemId?: StringNullableFilter<"RecipeIngredient"> | string | null
    name?: StringFilter<"RecipeIngredient"> | string
    category?: EnumIngredientCategoryFilter<"RecipeIngredient"> | $Enums.IngredientCategory
    amount?: DecimalFilter<"RecipeIngredient"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"RecipeIngredient"> | string
    additionTime?: IntNullableFilter<"RecipeIngredient"> | number | null
    specs?: JsonNullableFilter<"RecipeIngredient">
    inventoryItem?: XOR<InventoryItemNullableRelationFilter, InventoryItemWhereInput> | null
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
  }, "id">

  export type RecipeIngredientOrderByWithAggregationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    inventoryItemId?: SortOrderInput | SortOrder
    name?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    additionTime?: SortOrderInput | SortOrder
    specs?: SortOrderInput | SortOrder
    _count?: RecipeIngredientCountOrderByAggregateInput
    _avg?: RecipeIngredientAvgOrderByAggregateInput
    _max?: RecipeIngredientMaxOrderByAggregateInput
    _min?: RecipeIngredientMinOrderByAggregateInput
    _sum?: RecipeIngredientSumOrderByAggregateInput
  }

  export type RecipeIngredientScalarWhereWithAggregatesInput = {
    AND?: RecipeIngredientScalarWhereWithAggregatesInput | RecipeIngredientScalarWhereWithAggregatesInput[]
    OR?: RecipeIngredientScalarWhereWithAggregatesInput[]
    NOT?: RecipeIngredientScalarWhereWithAggregatesInput | RecipeIngredientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecipeIngredient"> | string
    recipeId?: StringWithAggregatesFilter<"RecipeIngredient"> | string
    inventoryItemId?: StringNullableWithAggregatesFilter<"RecipeIngredient"> | string | null
    name?: StringWithAggregatesFilter<"RecipeIngredient"> | string
    category?: EnumIngredientCategoryWithAggregatesFilter<"RecipeIngredient"> | $Enums.IngredientCategory
    amount?: DecimalWithAggregatesFilter<"RecipeIngredient"> | Decimal | DecimalJsLike | number | string
    unit?: StringWithAggregatesFilter<"RecipeIngredient"> | string
    additionTime?: IntNullableWithAggregatesFilter<"RecipeIngredient"> | number | null
    specs?: JsonNullableWithAggregatesFilter<"RecipeIngredient">
  }

  export type InventoryItemWhereInput = {
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    tenantId?: StringFilter<"InventoryItem"> | string
    sku?: StringFilter<"InventoryItem"> | string
    name?: StringFilter<"InventoryItem"> | string
    category?: EnumInventoryCategoryFilter<"InventoryItem"> | $Enums.InventoryCategory
    ingredientType?: StringNullableFilter<"InventoryItem"> | string | null
    unit?: StringFilter<"InventoryItem"> | string
    reorderPoint?: DecimalNullableFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string | null
    supplier?: StringNullableFilter<"InventoryItem"> | string | null
    location?: StringNullableFilter<"InventoryItem"> | string | null
    specs?: JsonNullableFilter<"InventoryItem">
    cachedBalance?: DecimalFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    costPerUnit?: DecimalNullableFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    isActive?: BoolFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    ledger?: InventoryLedgerListRelationFilter
    recipeIngredients?: RecipeIngredientListRelationFilter
  }

  export type InventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    category?: SortOrder
    ingredientType?: SortOrderInput | SortOrder
    unit?: SortOrder
    reorderPoint?: SortOrderInput | SortOrder
    supplier?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    specs?: SortOrderInput | SortOrder
    cachedBalance?: SortOrder
    costPerUnit?: SortOrderInput | SortOrder
    balanceUpdatedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    ledger?: InventoryLedgerOrderByRelationAggregateInput
    recipeIngredients?: RecipeIngredientOrderByRelationAggregateInput
  }

  export type InventoryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_sku?: InventoryItemTenantIdSkuCompoundUniqueInput
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    tenantId?: StringFilter<"InventoryItem"> | string
    sku?: StringFilter<"InventoryItem"> | string
    name?: StringFilter<"InventoryItem"> | string
    category?: EnumInventoryCategoryFilter<"InventoryItem"> | $Enums.InventoryCategory
    ingredientType?: StringNullableFilter<"InventoryItem"> | string | null
    unit?: StringFilter<"InventoryItem"> | string
    reorderPoint?: DecimalNullableFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string | null
    supplier?: StringNullableFilter<"InventoryItem"> | string | null
    location?: StringNullableFilter<"InventoryItem"> | string | null
    specs?: JsonNullableFilter<"InventoryItem">
    cachedBalance?: DecimalFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    costPerUnit?: DecimalNullableFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    isActive?: BoolFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    ledger?: InventoryLedgerListRelationFilter
    recipeIngredients?: RecipeIngredientListRelationFilter
  }, "id" | "tenantId_sku">

  export type InventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    category?: SortOrder
    ingredientType?: SortOrderInput | SortOrder
    unit?: SortOrder
    reorderPoint?: SortOrderInput | SortOrder
    supplier?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    specs?: SortOrderInput | SortOrder
    cachedBalance?: SortOrder
    costPerUnit?: SortOrderInput | SortOrder
    balanceUpdatedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryItemCountOrderByAggregateInput
    _avg?: InventoryItemAvgOrderByAggregateInput
    _max?: InventoryItemMaxOrderByAggregateInput
    _min?: InventoryItemMinOrderByAggregateInput
    _sum?: InventoryItemSumOrderByAggregateInput
  }

  export type InventoryItemScalarWhereWithAggregatesInput = {
    AND?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    OR?: InventoryItemScalarWhereWithAggregatesInput[]
    NOT?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryItem"> | string
    tenantId?: StringWithAggregatesFilter<"InventoryItem"> | string
    sku?: StringWithAggregatesFilter<"InventoryItem"> | string
    name?: StringWithAggregatesFilter<"InventoryItem"> | string
    category?: EnumInventoryCategoryWithAggregatesFilter<"InventoryItem"> | $Enums.InventoryCategory
    ingredientType?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    unit?: StringWithAggregatesFilter<"InventoryItem"> | string
    reorderPoint?: DecimalNullableWithAggregatesFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string | null
    supplier?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    location?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    specs?: JsonNullableWithAggregatesFilter<"InventoryItem">
    cachedBalance?: DecimalWithAggregatesFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    costPerUnit?: DecimalNullableWithAggregatesFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
    isActive?: BoolWithAggregatesFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
  }

  export type InventoryLedgerWhereInput = {
    AND?: InventoryLedgerWhereInput | InventoryLedgerWhereInput[]
    OR?: InventoryLedgerWhereInput[]
    NOT?: InventoryLedgerWhereInput | InventoryLedgerWhereInput[]
    id?: StringFilter<"InventoryLedger"> | string
    tenantId?: StringFilter<"InventoryLedger"> | string
    itemId?: StringFilter<"InventoryLedger"> | string
    quantity?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    type?: EnumLedgerEntryTypeFilter<"InventoryLedger"> | $Enums.LedgerEntryType
    batchId?: StringNullableFilter<"InventoryLedger"> | string | null
    orderId?: StringNullableFilter<"InventoryLedger"> | string | null
    packagingId?: StringNullableFilter<"InventoryLedger"> | string | null
    notes?: StringNullableFilter<"InventoryLedger"> | string | null
    createdBy?: StringFilter<"InventoryLedger"> | string
    createdAt?: DateTimeFilter<"InventoryLedger"> | Date | string
    batch?: XOR<BatchNullableRelationFilter, BatchWhereInput> | null
    item?: XOR<InventoryItemRelationFilter, InventoryItemWhereInput>
  }

  export type InventoryLedgerOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    batchId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    packagingId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    batch?: BatchOrderByWithRelationInput
    item?: InventoryItemOrderByWithRelationInput
  }

  export type InventoryLedgerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryLedgerWhereInput | InventoryLedgerWhereInput[]
    OR?: InventoryLedgerWhereInput[]
    NOT?: InventoryLedgerWhereInput | InventoryLedgerWhereInput[]
    tenantId?: StringFilter<"InventoryLedger"> | string
    itemId?: StringFilter<"InventoryLedger"> | string
    quantity?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    type?: EnumLedgerEntryTypeFilter<"InventoryLedger"> | $Enums.LedgerEntryType
    batchId?: StringNullableFilter<"InventoryLedger"> | string | null
    orderId?: StringNullableFilter<"InventoryLedger"> | string | null
    packagingId?: StringNullableFilter<"InventoryLedger"> | string | null
    notes?: StringNullableFilter<"InventoryLedger"> | string | null
    createdBy?: StringFilter<"InventoryLedger"> | string
    createdAt?: DateTimeFilter<"InventoryLedger"> | Date | string
    batch?: XOR<BatchNullableRelationFilter, BatchWhereInput> | null
    item?: XOR<InventoryItemRelationFilter, InventoryItemWhereInput>
  }, "id">

  export type InventoryLedgerOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    batchId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    packagingId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: InventoryLedgerCountOrderByAggregateInput
    _avg?: InventoryLedgerAvgOrderByAggregateInput
    _max?: InventoryLedgerMaxOrderByAggregateInput
    _min?: InventoryLedgerMinOrderByAggregateInput
    _sum?: InventoryLedgerSumOrderByAggregateInput
  }

  export type InventoryLedgerScalarWhereWithAggregatesInput = {
    AND?: InventoryLedgerScalarWhereWithAggregatesInput | InventoryLedgerScalarWhereWithAggregatesInput[]
    OR?: InventoryLedgerScalarWhereWithAggregatesInput[]
    NOT?: InventoryLedgerScalarWhereWithAggregatesInput | InventoryLedgerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryLedger"> | string
    tenantId?: StringWithAggregatesFilter<"InventoryLedger"> | string
    itemId?: StringWithAggregatesFilter<"InventoryLedger"> | string
    quantity?: DecimalWithAggregatesFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    type?: EnumLedgerEntryTypeWithAggregatesFilter<"InventoryLedger"> | $Enums.LedgerEntryType
    batchId?: StringNullableWithAggregatesFilter<"InventoryLedger"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"InventoryLedger"> | string | null
    packagingId?: StringNullableWithAggregatesFilter<"InventoryLedger"> | string | null
    notes?: StringNullableWithAggregatesFilter<"InventoryLedger"> | string | null
    createdBy?: StringWithAggregatesFilter<"InventoryLedger"> | string
    createdAt?: DateTimeWithAggregatesFilter<"InventoryLedger"> | Date | string
  }

  export type IngredientCatalogWhereInput = {
    AND?: IngredientCatalogWhereInput | IngredientCatalogWhereInput[]
    OR?: IngredientCatalogWhereInput[]
    NOT?: IngredientCatalogWhereInput | IngredientCatalogWhereInput[]
    id?: StringFilter<"IngredientCatalog"> | string
    type?: StringFilter<"IngredientCatalog"> | string
    name?: StringFilter<"IngredientCatalog"> | string
    supplier?: StringNullableFilter<"IngredientCatalog"> | string | null
    origin?: StringNullableFilter<"IngredientCatalog"> | string | null
    specs?: JsonNullableFilter<"IngredientCatalog">
    isActive?: BoolFilter<"IngredientCatalog"> | boolean
    createdAt?: DateTimeFilter<"IngredientCatalog"> | Date | string
    updatedAt?: DateTimeFilter<"IngredientCatalog"> | Date | string
  }

  export type IngredientCatalogOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    supplier?: SortOrderInput | SortOrder
    origin?: SortOrderInput | SortOrder
    specs?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IngredientCatalogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IngredientCatalogWhereInput | IngredientCatalogWhereInput[]
    OR?: IngredientCatalogWhereInput[]
    NOT?: IngredientCatalogWhereInput | IngredientCatalogWhereInput[]
    type?: StringFilter<"IngredientCatalog"> | string
    name?: StringFilter<"IngredientCatalog"> | string
    supplier?: StringNullableFilter<"IngredientCatalog"> | string | null
    origin?: StringNullableFilter<"IngredientCatalog"> | string | null
    specs?: JsonNullableFilter<"IngredientCatalog">
    isActive?: BoolFilter<"IngredientCatalog"> | boolean
    createdAt?: DateTimeFilter<"IngredientCatalog"> | Date | string
    updatedAt?: DateTimeFilter<"IngredientCatalog"> | Date | string
  }, "id">

  export type IngredientCatalogOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    supplier?: SortOrderInput | SortOrder
    origin?: SortOrderInput | SortOrder
    specs?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IngredientCatalogCountOrderByAggregateInput
    _max?: IngredientCatalogMaxOrderByAggregateInput
    _min?: IngredientCatalogMinOrderByAggregateInput
  }

  export type IngredientCatalogScalarWhereWithAggregatesInput = {
    AND?: IngredientCatalogScalarWhereWithAggregatesInput | IngredientCatalogScalarWhereWithAggregatesInput[]
    OR?: IngredientCatalogScalarWhereWithAggregatesInput[]
    NOT?: IngredientCatalogScalarWhereWithAggregatesInput | IngredientCatalogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IngredientCatalog"> | string
    type?: StringWithAggregatesFilter<"IngredientCatalog"> | string
    name?: StringWithAggregatesFilter<"IngredientCatalog"> | string
    supplier?: StringNullableWithAggregatesFilter<"IngredientCatalog"> | string | null
    origin?: StringNullableWithAggregatesFilter<"IngredientCatalog"> | string | null
    specs?: JsonNullableWithAggregatesFilter<"IngredientCatalog">
    isActive?: BoolWithAggregatesFilter<"IngredientCatalog"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"IngredientCatalog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IngredientCatalog"> | Date | string
  }

  export type BatchWhereInput = {
    AND?: BatchWhereInput | BatchWhereInput[]
    OR?: BatchWhereInput[]
    NOT?: BatchWhereInput | BatchWhereInput[]
    id?: StringFilter<"Batch"> | string
    tenantId?: StringFilter<"Batch"> | string
    batchNumber?: StringFilter<"Batch"> | string
    recipeId?: StringFilter<"Batch"> | string
    status?: EnumBatchStatusFilter<"Batch"> | $Enums.BatchStatus
    volume?: DecimalFilter<"Batch"> | Decimal | DecimalJsLike | number | string
    packagedVolume?: DecimalNullableFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    originalGravity?: DecimalNullableFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    currentGravity?: DecimalNullableFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    finalGravity?: DecimalNullableFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    abv?: DecimalNullableFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    tankId?: StringNullableFilter<"Batch"> | string | null
    plannedDate?: DateTimeFilter<"Batch"> | Date | string
    brewedAt?: DateTimeNullableFilter<"Batch"> | Date | string | null
    fermentationStartedAt?: DateTimeNullableFilter<"Batch"> | Date | string | null
    conditioningStartedAt?: DateTimeNullableFilter<"Batch"> | Date | string | null
    readyAt?: DateTimeNullableFilter<"Batch"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Batch"> | Date | string | null
    createdBy?: StringFilter<"Batch"> | string
    notes?: StringNullableFilter<"Batch"> | string | null
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    updatedAt?: DateTimeFilter<"Batch"> | Date | string
    targetOg?: DecimalNullableFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: StringNullableFilter<"Batch"> | string | null
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
    tank?: XOR<TankNullableRelationFilter, TankWhereInput> | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    ingredients?: BatchIngredientListRelationFilter
    timeline?: BatchTimelineListRelationFilter
    gravityReadings?: GravityReadingListRelationFilter
    ledgerEntries?: InventoryLedgerListRelationFilter
    Keg?: KegListRelationFilter
    LotBatch?: LotBatchListRelationFilter
    packagingRuns?: PackagingRunListRelationFilter
    QCTest?: QCTestListRelationFilter
  }

  export type BatchOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    batchNumber?: SortOrder
    recipeId?: SortOrder
    status?: SortOrder
    volume?: SortOrder
    packagedVolume?: SortOrderInput | SortOrder
    originalGravity?: SortOrderInput | SortOrder
    currentGravity?: SortOrderInput | SortOrder
    finalGravity?: SortOrderInput | SortOrder
    abv?: SortOrderInput | SortOrder
    tankId?: SortOrderInput | SortOrder
    plannedDate?: SortOrder
    brewedAt?: SortOrderInput | SortOrder
    fermentationStartedAt?: SortOrderInput | SortOrder
    conditioningStartedAt?: SortOrderInput | SortOrder
    readyAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    targetOg?: SortOrderInput | SortOrder
    fermentationTankId?: SortOrderInput | SortOrder
    recipe?: RecipeOrderByWithRelationInput
    tank?: TankOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    ingredients?: BatchIngredientOrderByRelationAggregateInput
    timeline?: BatchTimelineOrderByRelationAggregateInput
    gravityReadings?: GravityReadingOrderByRelationAggregateInput
    ledgerEntries?: InventoryLedgerOrderByRelationAggregateInput
    Keg?: KegOrderByRelationAggregateInput
    LotBatch?: LotBatchOrderByRelationAggregateInput
    packagingRuns?: PackagingRunOrderByRelationAggregateInput
    QCTest?: QCTestOrderByRelationAggregateInput
  }

  export type BatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_batchNumber?: BatchTenantIdBatchNumberCompoundUniqueInput
    AND?: BatchWhereInput | BatchWhereInput[]
    OR?: BatchWhereInput[]
    NOT?: BatchWhereInput | BatchWhereInput[]
    tenantId?: StringFilter<"Batch"> | string
    batchNumber?: StringFilter<"Batch"> | string
    recipeId?: StringFilter<"Batch"> | string
    status?: EnumBatchStatusFilter<"Batch"> | $Enums.BatchStatus
    volume?: DecimalFilter<"Batch"> | Decimal | DecimalJsLike | number | string
    packagedVolume?: DecimalNullableFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    originalGravity?: DecimalNullableFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    currentGravity?: DecimalNullableFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    finalGravity?: DecimalNullableFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    abv?: DecimalNullableFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    tankId?: StringNullableFilter<"Batch"> | string | null
    plannedDate?: DateTimeFilter<"Batch"> | Date | string
    brewedAt?: DateTimeNullableFilter<"Batch"> | Date | string | null
    fermentationStartedAt?: DateTimeNullableFilter<"Batch"> | Date | string | null
    conditioningStartedAt?: DateTimeNullableFilter<"Batch"> | Date | string | null
    readyAt?: DateTimeNullableFilter<"Batch"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Batch"> | Date | string | null
    createdBy?: StringFilter<"Batch"> | string
    notes?: StringNullableFilter<"Batch"> | string | null
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    updatedAt?: DateTimeFilter<"Batch"> | Date | string
    targetOg?: DecimalNullableFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: StringNullableFilter<"Batch"> | string | null
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
    tank?: XOR<TankNullableRelationFilter, TankWhereInput> | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    ingredients?: BatchIngredientListRelationFilter
    timeline?: BatchTimelineListRelationFilter
    gravityReadings?: GravityReadingListRelationFilter
    ledgerEntries?: InventoryLedgerListRelationFilter
    Keg?: KegListRelationFilter
    LotBatch?: LotBatchListRelationFilter
    packagingRuns?: PackagingRunListRelationFilter
    QCTest?: QCTestListRelationFilter
  }, "id" | "tenantId_batchNumber">

  export type BatchOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    batchNumber?: SortOrder
    recipeId?: SortOrder
    status?: SortOrder
    volume?: SortOrder
    packagedVolume?: SortOrderInput | SortOrder
    originalGravity?: SortOrderInput | SortOrder
    currentGravity?: SortOrderInput | SortOrder
    finalGravity?: SortOrderInput | SortOrder
    abv?: SortOrderInput | SortOrder
    tankId?: SortOrderInput | SortOrder
    plannedDate?: SortOrder
    brewedAt?: SortOrderInput | SortOrder
    fermentationStartedAt?: SortOrderInput | SortOrder
    conditioningStartedAt?: SortOrderInput | SortOrder
    readyAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    targetOg?: SortOrderInput | SortOrder
    fermentationTankId?: SortOrderInput | SortOrder
    _count?: BatchCountOrderByAggregateInput
    _avg?: BatchAvgOrderByAggregateInput
    _max?: BatchMaxOrderByAggregateInput
    _min?: BatchMinOrderByAggregateInput
    _sum?: BatchSumOrderByAggregateInput
  }

  export type BatchScalarWhereWithAggregatesInput = {
    AND?: BatchScalarWhereWithAggregatesInput | BatchScalarWhereWithAggregatesInput[]
    OR?: BatchScalarWhereWithAggregatesInput[]
    NOT?: BatchScalarWhereWithAggregatesInput | BatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Batch"> | string
    tenantId?: StringWithAggregatesFilter<"Batch"> | string
    batchNumber?: StringWithAggregatesFilter<"Batch"> | string
    recipeId?: StringWithAggregatesFilter<"Batch"> | string
    status?: EnumBatchStatusWithAggregatesFilter<"Batch"> | $Enums.BatchStatus
    volume?: DecimalWithAggregatesFilter<"Batch"> | Decimal | DecimalJsLike | number | string
    packagedVolume?: DecimalNullableWithAggregatesFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    originalGravity?: DecimalNullableWithAggregatesFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    currentGravity?: DecimalNullableWithAggregatesFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    finalGravity?: DecimalNullableWithAggregatesFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    abv?: DecimalNullableWithAggregatesFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    tankId?: StringNullableWithAggregatesFilter<"Batch"> | string | null
    plannedDate?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
    brewedAt?: DateTimeNullableWithAggregatesFilter<"Batch"> | Date | string | null
    fermentationStartedAt?: DateTimeNullableWithAggregatesFilter<"Batch"> | Date | string | null
    conditioningStartedAt?: DateTimeNullableWithAggregatesFilter<"Batch"> | Date | string | null
    readyAt?: DateTimeNullableWithAggregatesFilter<"Batch"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Batch"> | Date | string | null
    createdBy?: StringWithAggregatesFilter<"Batch"> | string
    notes?: StringNullableWithAggregatesFilter<"Batch"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
    targetOg?: DecimalNullableWithAggregatesFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: StringNullableWithAggregatesFilter<"Batch"> | string | null
  }

  export type BatchIngredientWhereInput = {
    AND?: BatchIngredientWhereInput | BatchIngredientWhereInput[]
    OR?: BatchIngredientWhereInput[]
    NOT?: BatchIngredientWhereInput | BatchIngredientWhereInput[]
    id?: StringFilter<"BatchIngredient"> | string
    batchId?: StringFilter<"BatchIngredient"> | string
    inventoryItemId?: StringNullableFilter<"BatchIngredient"> | string | null
    name?: StringFilter<"BatchIngredient"> | string
    category?: EnumIngredientCategoryFilter<"BatchIngredient"> | $Enums.IngredientCategory
    plannedAmount?: DecimalFilter<"BatchIngredient"> | Decimal | DecimalJsLike | number | string
    actualAmount?: DecimalNullableFilter<"BatchIngredient"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringFilter<"BatchIngredient"> | string
    lotNumber?: StringNullableFilter<"BatchIngredient"> | string | null
    addedAt?: DateTimeNullableFilter<"BatchIngredient"> | Date | string | null
    batch?: XOR<BatchRelationFilter, BatchWhereInput>
  }

  export type BatchIngredientOrderByWithRelationInput = {
    id?: SortOrder
    batchId?: SortOrder
    inventoryItemId?: SortOrderInput | SortOrder
    name?: SortOrder
    category?: SortOrder
    plannedAmount?: SortOrder
    actualAmount?: SortOrderInput | SortOrder
    unit?: SortOrder
    lotNumber?: SortOrderInput | SortOrder
    addedAt?: SortOrderInput | SortOrder
    batch?: BatchOrderByWithRelationInput
  }

  export type BatchIngredientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BatchIngredientWhereInput | BatchIngredientWhereInput[]
    OR?: BatchIngredientWhereInput[]
    NOT?: BatchIngredientWhereInput | BatchIngredientWhereInput[]
    batchId?: StringFilter<"BatchIngredient"> | string
    inventoryItemId?: StringNullableFilter<"BatchIngredient"> | string | null
    name?: StringFilter<"BatchIngredient"> | string
    category?: EnumIngredientCategoryFilter<"BatchIngredient"> | $Enums.IngredientCategory
    plannedAmount?: DecimalFilter<"BatchIngredient"> | Decimal | DecimalJsLike | number | string
    actualAmount?: DecimalNullableFilter<"BatchIngredient"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringFilter<"BatchIngredient"> | string
    lotNumber?: StringNullableFilter<"BatchIngredient"> | string | null
    addedAt?: DateTimeNullableFilter<"BatchIngredient"> | Date | string | null
    batch?: XOR<BatchRelationFilter, BatchWhereInput>
  }, "id">

  export type BatchIngredientOrderByWithAggregationInput = {
    id?: SortOrder
    batchId?: SortOrder
    inventoryItemId?: SortOrderInput | SortOrder
    name?: SortOrder
    category?: SortOrder
    plannedAmount?: SortOrder
    actualAmount?: SortOrderInput | SortOrder
    unit?: SortOrder
    lotNumber?: SortOrderInput | SortOrder
    addedAt?: SortOrderInput | SortOrder
    _count?: BatchIngredientCountOrderByAggregateInput
    _avg?: BatchIngredientAvgOrderByAggregateInput
    _max?: BatchIngredientMaxOrderByAggregateInput
    _min?: BatchIngredientMinOrderByAggregateInput
    _sum?: BatchIngredientSumOrderByAggregateInput
  }

  export type BatchIngredientScalarWhereWithAggregatesInput = {
    AND?: BatchIngredientScalarWhereWithAggregatesInput | BatchIngredientScalarWhereWithAggregatesInput[]
    OR?: BatchIngredientScalarWhereWithAggregatesInput[]
    NOT?: BatchIngredientScalarWhereWithAggregatesInput | BatchIngredientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BatchIngredient"> | string
    batchId?: StringWithAggregatesFilter<"BatchIngredient"> | string
    inventoryItemId?: StringNullableWithAggregatesFilter<"BatchIngredient"> | string | null
    name?: StringWithAggregatesFilter<"BatchIngredient"> | string
    category?: EnumIngredientCategoryWithAggregatesFilter<"BatchIngredient"> | $Enums.IngredientCategory
    plannedAmount?: DecimalWithAggregatesFilter<"BatchIngredient"> | Decimal | DecimalJsLike | number | string
    actualAmount?: DecimalNullableWithAggregatesFilter<"BatchIngredient"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringWithAggregatesFilter<"BatchIngredient"> | string
    lotNumber?: StringNullableWithAggregatesFilter<"BatchIngredient"> | string | null
    addedAt?: DateTimeNullableWithAggregatesFilter<"BatchIngredient"> | Date | string | null
  }

  export type GravityReadingWhereInput = {
    AND?: GravityReadingWhereInput | GravityReadingWhereInput[]
    OR?: GravityReadingWhereInput[]
    NOT?: GravityReadingWhereInput | GravityReadingWhereInput[]
    id?: StringFilter<"GravityReading"> | string
    batchId?: StringFilter<"GravityReading"> | string
    gravity?: DecimalFilter<"GravityReading"> | Decimal | DecimalJsLike | number | string
    temperature?: DecimalFilter<"GravityReading"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"GravityReading"> | string | null
    recordedBy?: StringFilter<"GravityReading"> | string
    recordedAt?: DateTimeFilter<"GravityReading"> | Date | string
    batch?: XOR<BatchRelationFilter, BatchWhereInput>
  }

  export type GravityReadingOrderByWithRelationInput = {
    id?: SortOrder
    batchId?: SortOrder
    gravity?: SortOrder
    temperature?: SortOrder
    notes?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    recordedAt?: SortOrder
    batch?: BatchOrderByWithRelationInput
  }

  export type GravityReadingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GravityReadingWhereInput | GravityReadingWhereInput[]
    OR?: GravityReadingWhereInput[]
    NOT?: GravityReadingWhereInput | GravityReadingWhereInput[]
    batchId?: StringFilter<"GravityReading"> | string
    gravity?: DecimalFilter<"GravityReading"> | Decimal | DecimalJsLike | number | string
    temperature?: DecimalFilter<"GravityReading"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"GravityReading"> | string | null
    recordedBy?: StringFilter<"GravityReading"> | string
    recordedAt?: DateTimeFilter<"GravityReading"> | Date | string
    batch?: XOR<BatchRelationFilter, BatchWhereInput>
  }, "id">

  export type GravityReadingOrderByWithAggregationInput = {
    id?: SortOrder
    batchId?: SortOrder
    gravity?: SortOrder
    temperature?: SortOrder
    notes?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    recordedAt?: SortOrder
    _count?: GravityReadingCountOrderByAggregateInput
    _avg?: GravityReadingAvgOrderByAggregateInput
    _max?: GravityReadingMaxOrderByAggregateInput
    _min?: GravityReadingMinOrderByAggregateInput
    _sum?: GravityReadingSumOrderByAggregateInput
  }

  export type GravityReadingScalarWhereWithAggregatesInput = {
    AND?: GravityReadingScalarWhereWithAggregatesInput | GravityReadingScalarWhereWithAggregatesInput[]
    OR?: GravityReadingScalarWhereWithAggregatesInput[]
    NOT?: GravityReadingScalarWhereWithAggregatesInput | GravityReadingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GravityReading"> | string
    batchId?: StringWithAggregatesFilter<"GravityReading"> | string
    gravity?: DecimalWithAggregatesFilter<"GravityReading"> | Decimal | DecimalJsLike | number | string
    temperature?: DecimalWithAggregatesFilter<"GravityReading"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"GravityReading"> | string | null
    recordedBy?: StringWithAggregatesFilter<"GravityReading"> | string
    recordedAt?: DateTimeWithAggregatesFilter<"GravityReading"> | Date | string
  }

  export type BatchTimelineWhereInput = {
    AND?: BatchTimelineWhereInput | BatchTimelineWhereInput[]
    OR?: BatchTimelineWhereInput[]
    NOT?: BatchTimelineWhereInput | BatchTimelineWhereInput[]
    id?: StringFilter<"BatchTimeline"> | string
    batchId?: StringFilter<"BatchTimeline"> | string
    type?: EnumTimelineEventTypeFilter<"BatchTimeline"> | $Enums.TimelineEventType
    title?: StringFilter<"BatchTimeline"> | string
    description?: StringNullableFilter<"BatchTimeline"> | string | null
    data?: JsonNullableFilter<"BatchTimeline">
    createdBy?: StringFilter<"BatchTimeline"> | string
    createdAt?: DateTimeFilter<"BatchTimeline"> | Date | string
    batch?: XOR<BatchRelationFilter, BatchWhereInput>
  }

  export type BatchTimelineOrderByWithRelationInput = {
    id?: SortOrder
    batchId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    batch?: BatchOrderByWithRelationInput
  }

  export type BatchTimelineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BatchTimelineWhereInput | BatchTimelineWhereInput[]
    OR?: BatchTimelineWhereInput[]
    NOT?: BatchTimelineWhereInput | BatchTimelineWhereInput[]
    batchId?: StringFilter<"BatchTimeline"> | string
    type?: EnumTimelineEventTypeFilter<"BatchTimeline"> | $Enums.TimelineEventType
    title?: StringFilter<"BatchTimeline"> | string
    description?: StringNullableFilter<"BatchTimeline"> | string | null
    data?: JsonNullableFilter<"BatchTimeline">
    createdBy?: StringFilter<"BatchTimeline"> | string
    createdAt?: DateTimeFilter<"BatchTimeline"> | Date | string
    batch?: XOR<BatchRelationFilter, BatchWhereInput>
  }, "id">

  export type BatchTimelineOrderByWithAggregationInput = {
    id?: SortOrder
    batchId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: BatchTimelineCountOrderByAggregateInput
    _max?: BatchTimelineMaxOrderByAggregateInput
    _min?: BatchTimelineMinOrderByAggregateInput
  }

  export type BatchTimelineScalarWhereWithAggregatesInput = {
    AND?: BatchTimelineScalarWhereWithAggregatesInput | BatchTimelineScalarWhereWithAggregatesInput[]
    OR?: BatchTimelineScalarWhereWithAggregatesInput[]
    NOT?: BatchTimelineScalarWhereWithAggregatesInput | BatchTimelineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BatchTimeline"> | string
    batchId?: StringWithAggregatesFilter<"BatchTimeline"> | string
    type?: EnumTimelineEventTypeWithAggregatesFilter<"BatchTimeline"> | $Enums.TimelineEventType
    title?: StringWithAggregatesFilter<"BatchTimeline"> | string
    description?: StringNullableWithAggregatesFilter<"BatchTimeline"> | string | null
    data?: JsonNullableWithAggregatesFilter<"BatchTimeline">
    createdBy?: StringWithAggregatesFilter<"BatchTimeline"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BatchTimeline"> | Date | string
  }

  export type TankWhereInput = {
    AND?: TankWhereInput | TankWhereInput[]
    OR?: TankWhereInput[]
    NOT?: TankWhereInput | TankWhereInput[]
    id?: StringFilter<"Tank"> | string
    tenantId?: StringFilter<"Tank"> | string
    name?: StringFilter<"Tank"> | string
    type?: EnumTankTypeFilter<"Tank"> | $Enums.TankType
    capacity?: DecimalFilter<"Tank"> | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFilter<"Tank"> | $Enums.TankStatus
    currentBatchId?: StringNullableFilter<"Tank"> | string | null
    location?: StringNullableFilter<"Tank"> | string | null
    version?: IntFilter<"Tank"> | number
    createdAt?: DateTimeFilter<"Tank"> | Date | string
    updatedAt?: DateTimeFilter<"Tank"> | Date | string
    capabilities?: EnumTankCapabilityNullableListFilter<"Tank">
    currentLotId?: StringNullableFilter<"Tank"> | string | null
    currentPhase?: EnumLotPhaseNullableFilter<"Tank"> | $Enums.LotPhase | null
    defaultTurnaroundHours?: IntNullableFilter<"Tank"> | number | null
    maxFillPercent?: IntNullableFilter<"Tank"> | number | null
    minFillPercent?: IntNullableFilter<"Tank"> | number | null
    batches?: BatchListRelationFilter
    LotReading?: LotReadingListRelationFilter
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    TankAssignment?: TankAssignmentListRelationFilter
    occupations?: TankOccupationListRelationFilter
    Transfer_Transfer_destTankIdToTank?: TransferListRelationFilter
    Transfer_Transfer_sourceTankIdToTank?: TransferListRelationFilter
  }

  export type TankOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    currentBatchId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    capabilities?: SortOrder
    currentLotId?: SortOrderInput | SortOrder
    currentPhase?: SortOrderInput | SortOrder
    defaultTurnaroundHours?: SortOrderInput | SortOrder
    maxFillPercent?: SortOrderInput | SortOrder
    minFillPercent?: SortOrderInput | SortOrder
    batches?: BatchOrderByRelationAggregateInput
    LotReading?: LotReadingOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
    TankAssignment?: TankAssignmentOrderByRelationAggregateInput
    occupations?: TankOccupationOrderByRelationAggregateInput
    Transfer_Transfer_destTankIdToTank?: TransferOrderByRelationAggregateInput
    Transfer_Transfer_sourceTankIdToTank?: TransferOrderByRelationAggregateInput
  }

  export type TankWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_name?: TankTenantIdNameCompoundUniqueInput
    AND?: TankWhereInput | TankWhereInput[]
    OR?: TankWhereInput[]
    NOT?: TankWhereInput | TankWhereInput[]
    tenantId?: StringFilter<"Tank"> | string
    name?: StringFilter<"Tank"> | string
    type?: EnumTankTypeFilter<"Tank"> | $Enums.TankType
    capacity?: DecimalFilter<"Tank"> | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFilter<"Tank"> | $Enums.TankStatus
    currentBatchId?: StringNullableFilter<"Tank"> | string | null
    location?: StringNullableFilter<"Tank"> | string | null
    version?: IntFilter<"Tank"> | number
    createdAt?: DateTimeFilter<"Tank"> | Date | string
    updatedAt?: DateTimeFilter<"Tank"> | Date | string
    capabilities?: EnumTankCapabilityNullableListFilter<"Tank">
    currentLotId?: StringNullableFilter<"Tank"> | string | null
    currentPhase?: EnumLotPhaseNullableFilter<"Tank"> | $Enums.LotPhase | null
    defaultTurnaroundHours?: IntNullableFilter<"Tank"> | number | null
    maxFillPercent?: IntNullableFilter<"Tank"> | number | null
    minFillPercent?: IntNullableFilter<"Tank"> | number | null
    batches?: BatchListRelationFilter
    LotReading?: LotReadingListRelationFilter
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    TankAssignment?: TankAssignmentListRelationFilter
    occupations?: TankOccupationListRelationFilter
    Transfer_Transfer_destTankIdToTank?: TransferListRelationFilter
    Transfer_Transfer_sourceTankIdToTank?: TransferListRelationFilter
  }, "id" | "tenantId_name">

  export type TankOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    currentBatchId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    capabilities?: SortOrder
    currentLotId?: SortOrderInput | SortOrder
    currentPhase?: SortOrderInput | SortOrder
    defaultTurnaroundHours?: SortOrderInput | SortOrder
    maxFillPercent?: SortOrderInput | SortOrder
    minFillPercent?: SortOrderInput | SortOrder
    _count?: TankCountOrderByAggregateInput
    _avg?: TankAvgOrderByAggregateInput
    _max?: TankMaxOrderByAggregateInput
    _min?: TankMinOrderByAggregateInput
    _sum?: TankSumOrderByAggregateInput
  }

  export type TankScalarWhereWithAggregatesInput = {
    AND?: TankScalarWhereWithAggregatesInput | TankScalarWhereWithAggregatesInput[]
    OR?: TankScalarWhereWithAggregatesInput[]
    NOT?: TankScalarWhereWithAggregatesInput | TankScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tank"> | string
    tenantId?: StringWithAggregatesFilter<"Tank"> | string
    name?: StringWithAggregatesFilter<"Tank"> | string
    type?: EnumTankTypeWithAggregatesFilter<"Tank"> | $Enums.TankType
    capacity?: DecimalWithAggregatesFilter<"Tank"> | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusWithAggregatesFilter<"Tank"> | $Enums.TankStatus
    currentBatchId?: StringNullableWithAggregatesFilter<"Tank"> | string | null
    location?: StringNullableWithAggregatesFilter<"Tank"> | string | null
    version?: IntWithAggregatesFilter<"Tank"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Tank"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tank"> | Date | string
    capabilities?: EnumTankCapabilityNullableListFilter<"Tank">
    currentLotId?: StringNullableWithAggregatesFilter<"Tank"> | string | null
    currentPhase?: EnumLotPhaseNullableWithAggregatesFilter<"Tank"> | $Enums.LotPhase | null
    defaultTurnaroundHours?: IntNullableWithAggregatesFilter<"Tank"> | number | null
    maxFillPercent?: IntNullableWithAggregatesFilter<"Tank"> | number | null
    minFillPercent?: IntNullableWithAggregatesFilter<"Tank"> | number | null
  }

  export type TankOccupationWhereInput = {
    AND?: TankOccupationWhereInput | TankOccupationWhereInput[]
    OR?: TankOccupationWhereInput[]
    NOT?: TankOccupationWhereInput | TankOccupationWhereInput[]
    id?: StringFilter<"TankOccupation"> | string
    tenantId?: StringFilter<"TankOccupation"> | string
    tankId?: StringFilter<"TankOccupation"> | string
    batchId?: StringFilter<"TankOccupation"> | string
    phase?: EnumOccupationPhaseFilter<"TankOccupation"> | $Enums.OccupationPhase
    startedAt?: DateTimeFilter<"TankOccupation"> | Date | string
    endedAt?: DateTimeNullableFilter<"TankOccupation"> | Date | string | null
    tank?: XOR<TankRelationFilter, TankWhereInput>
  }

  export type TankOccupationOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tankId?: SortOrder
    batchId?: SortOrder
    phase?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    tank?: TankOrderByWithRelationInput
  }

  export type TankOccupationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TankOccupationWhereInput | TankOccupationWhereInput[]
    OR?: TankOccupationWhereInput[]
    NOT?: TankOccupationWhereInput | TankOccupationWhereInput[]
    tenantId?: StringFilter<"TankOccupation"> | string
    tankId?: StringFilter<"TankOccupation"> | string
    batchId?: StringFilter<"TankOccupation"> | string
    phase?: EnumOccupationPhaseFilter<"TankOccupation"> | $Enums.OccupationPhase
    startedAt?: DateTimeFilter<"TankOccupation"> | Date | string
    endedAt?: DateTimeNullableFilter<"TankOccupation"> | Date | string | null
    tank?: XOR<TankRelationFilter, TankWhereInput>
  }, "id">

  export type TankOccupationOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tankId?: SortOrder
    batchId?: SortOrder
    phase?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    _count?: TankOccupationCountOrderByAggregateInput
    _max?: TankOccupationMaxOrderByAggregateInput
    _min?: TankOccupationMinOrderByAggregateInput
  }

  export type TankOccupationScalarWhereWithAggregatesInput = {
    AND?: TankOccupationScalarWhereWithAggregatesInput | TankOccupationScalarWhereWithAggregatesInput[]
    OR?: TankOccupationScalarWhereWithAggregatesInput[]
    NOT?: TankOccupationScalarWhereWithAggregatesInput | TankOccupationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TankOccupation"> | string
    tenantId?: StringWithAggregatesFilter<"TankOccupation"> | string
    tankId?: StringWithAggregatesFilter<"TankOccupation"> | string
    batchId?: StringWithAggregatesFilter<"TankOccupation"> | string
    phase?: EnumOccupationPhaseWithAggregatesFilter<"TankOccupation"> | $Enums.OccupationPhase
    startedAt?: DateTimeWithAggregatesFilter<"TankOccupation"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"TankOccupation"> | Date | string | null
  }

  export type PackagingRunWhereInput = {
    AND?: PackagingRunWhereInput | PackagingRunWhereInput[]
    OR?: PackagingRunWhereInput[]
    NOT?: PackagingRunWhereInput | PackagingRunWhereInput[]
    id?: StringFilter<"PackagingRun"> | string
    tenantId?: StringFilter<"PackagingRun"> | string
    batchId?: StringFilter<"PackagingRun"> | string
    packageType?: EnumPackageTypeFilter<"PackagingRun"> | $Enums.PackageType
    quantity?: IntFilter<"PackagingRun"> | number
    volumeTotal?: DecimalFilter<"PackagingRun"> | Decimal | DecimalJsLike | number | string
    lotNumber?: StringNullableFilter<"PackagingRun"> | string | null
    performedBy?: StringFilter<"PackagingRun"> | string
    notes?: StringNullableFilter<"PackagingRun"> | string | null
    performedAt?: DateTimeFilter<"PackagingRun"> | Date | string
    batch?: XOR<BatchRelationFilter, BatchWhereInput>
  }

  export type PackagingRunOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    batchId?: SortOrder
    packageType?: SortOrder
    quantity?: SortOrder
    volumeTotal?: SortOrder
    lotNumber?: SortOrderInput | SortOrder
    performedBy?: SortOrder
    notes?: SortOrderInput | SortOrder
    performedAt?: SortOrder
    batch?: BatchOrderByWithRelationInput
  }

  export type PackagingRunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PackagingRunWhereInput | PackagingRunWhereInput[]
    OR?: PackagingRunWhereInput[]
    NOT?: PackagingRunWhereInput | PackagingRunWhereInput[]
    tenantId?: StringFilter<"PackagingRun"> | string
    batchId?: StringFilter<"PackagingRun"> | string
    packageType?: EnumPackageTypeFilter<"PackagingRun"> | $Enums.PackageType
    quantity?: IntFilter<"PackagingRun"> | number
    volumeTotal?: DecimalFilter<"PackagingRun"> | Decimal | DecimalJsLike | number | string
    lotNumber?: StringNullableFilter<"PackagingRun"> | string | null
    performedBy?: StringFilter<"PackagingRun"> | string
    notes?: StringNullableFilter<"PackagingRun"> | string | null
    performedAt?: DateTimeFilter<"PackagingRun"> | Date | string
    batch?: XOR<BatchRelationFilter, BatchWhereInput>
  }, "id">

  export type PackagingRunOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    batchId?: SortOrder
    packageType?: SortOrder
    quantity?: SortOrder
    volumeTotal?: SortOrder
    lotNumber?: SortOrderInput | SortOrder
    performedBy?: SortOrder
    notes?: SortOrderInput | SortOrder
    performedAt?: SortOrder
    _count?: PackagingRunCountOrderByAggregateInput
    _avg?: PackagingRunAvgOrderByAggregateInput
    _max?: PackagingRunMaxOrderByAggregateInput
    _min?: PackagingRunMinOrderByAggregateInput
    _sum?: PackagingRunSumOrderByAggregateInput
  }

  export type PackagingRunScalarWhereWithAggregatesInput = {
    AND?: PackagingRunScalarWhereWithAggregatesInput | PackagingRunScalarWhereWithAggregatesInput[]
    OR?: PackagingRunScalarWhereWithAggregatesInput[]
    NOT?: PackagingRunScalarWhereWithAggregatesInput | PackagingRunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PackagingRun"> | string
    tenantId?: StringWithAggregatesFilter<"PackagingRun"> | string
    batchId?: StringWithAggregatesFilter<"PackagingRun"> | string
    packageType?: EnumPackageTypeWithAggregatesFilter<"PackagingRun"> | $Enums.PackageType
    quantity?: IntWithAggregatesFilter<"PackagingRun"> | number
    volumeTotal?: DecimalWithAggregatesFilter<"PackagingRun"> | Decimal | DecimalJsLike | number | string
    lotNumber?: StringNullableWithAggregatesFilter<"PackagingRun"> | string | null
    performedBy?: StringWithAggregatesFilter<"PackagingRun"> | string
    notes?: StringNullableWithAggregatesFilter<"PackagingRun"> | string | null
    performedAt?: DateTimeWithAggregatesFilter<"PackagingRun"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    tenantId?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    type?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    city?: StringNullableFilter<"Customer"> | string | null
    taxId?: StringNullableFilter<"Customer"> | string | null
    kegReturnDays?: IntFilter<"Customer"> | number
    kegDepositRequired?: BoolFilter<"Customer"> | boolean
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    invoices?: InvoiceListRelationFilter
    Keg?: KegListRelationFilter
    orders?: SalesOrderListRelationFilter
    transactions?: TransactionListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    kegReturnDays?: SortOrder
    kegDepositRequired?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
    Keg?: KegOrderByRelationAggregateInput
    orders?: SalesOrderOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_name?: CustomerTenantIdNameCompoundUniqueInput
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    tenantId?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    type?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    city?: StringNullableFilter<"Customer"> | string | null
    taxId?: StringNullableFilter<"Customer"> | string | null
    kegReturnDays?: IntFilter<"Customer"> | number
    kegDepositRequired?: BoolFilter<"Customer"> | boolean
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    invoices?: InvoiceListRelationFilter
    Keg?: KegListRelationFilter
    orders?: SalesOrderListRelationFilter
    transactions?: TransactionListRelationFilter
  }, "id" | "tenantId_name">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    kegReturnDays?: SortOrder
    kegDepositRequired?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    tenantId?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    type?: EnumCustomerTypeWithAggregatesFilter<"Customer"> | $Enums.CustomerType
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    city?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    kegReturnDays?: IntWithAggregatesFilter<"Customer"> | number
    kegDepositRequired?: BoolWithAggregatesFilter<"Customer"> | boolean
    isActive?: BoolWithAggregatesFilter<"Customer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: StringFilter<"Supplier"> | string
    tenantId?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    category?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    city?: StringNullableFilter<"Supplier"> | string | null
    taxId?: StringNullableFilter<"Supplier"> | string | null
    bankAccount?: StringNullableFilter<"Supplier"> | string | null
    notes?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    expenses?: ExpenseListRelationFilter
    invoices?: InvoiceListRelationFilter
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    transactions?: TransactionListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expenses?: ExpenseOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_name?: SupplierTenantIdNameCompoundUniqueInput
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    tenantId?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    category?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    city?: StringNullableFilter<"Supplier"> | string | null
    taxId?: StringNullableFilter<"Supplier"> | string | null
    bankAccount?: StringNullableFilter<"Supplier"> | string | null
    notes?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    expenses?: ExpenseListRelationFilter
    invoices?: InvoiceListRelationFilter
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    transactions?: TransactionListRelationFilter
  }, "id" | "tenantId_name">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supplier"> | string
    tenantId?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    category?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    email?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    address?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    city?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    bankAccount?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    isActive?: BoolWithAggregatesFilter<"Supplier"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
  }

  export type SalesOrderWhereInput = {
    AND?: SalesOrderWhereInput | SalesOrderWhereInput[]
    OR?: SalesOrderWhereInput[]
    NOT?: SalesOrderWhereInput | SalesOrderWhereInput[]
    id?: StringFilter<"SalesOrder"> | string
    tenantId?: StringFilter<"SalesOrder"> | string
    orderNumber?: StringFilter<"SalesOrder"> | string
    customerId?: StringFilter<"SalesOrder"> | string
    status?: EnumOrderStatusFilter<"SalesOrder"> | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFilter<"SalesOrder"> | $Enums.PaymentStatus
    totalAmount?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"SalesOrder"> | string | null
    orderedAt?: DateTimeFilter<"SalesOrder"> | Date | string
    shippedAt?: DateTimeNullableFilter<"SalesOrder"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"SalesOrder"> | Date | string | null
    createdBy?: StringFilter<"SalesOrder"> | string
    updatedAt?: DateTimeFilter<"SalesOrder"> | Date | string
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    items?: OrderItemListRelationFilter
    payments?: PaymentListRelationFilter
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    transactions?: TransactionListRelationFilter
  }

  export type SalesOrderOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    orderedAt?: SortOrder
    shippedAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    customer?: CustomerOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type SalesOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_orderNumber?: SalesOrderTenantIdOrderNumberCompoundUniqueInput
    AND?: SalesOrderWhereInput | SalesOrderWhereInput[]
    OR?: SalesOrderWhereInput[]
    NOT?: SalesOrderWhereInput | SalesOrderWhereInput[]
    tenantId?: StringFilter<"SalesOrder"> | string
    orderNumber?: StringFilter<"SalesOrder"> | string
    customerId?: StringFilter<"SalesOrder"> | string
    status?: EnumOrderStatusFilter<"SalesOrder"> | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFilter<"SalesOrder"> | $Enums.PaymentStatus
    totalAmount?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"SalesOrder"> | string | null
    orderedAt?: DateTimeFilter<"SalesOrder"> | Date | string
    shippedAt?: DateTimeNullableFilter<"SalesOrder"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"SalesOrder"> | Date | string | null
    createdBy?: StringFilter<"SalesOrder"> | string
    updatedAt?: DateTimeFilter<"SalesOrder"> | Date | string
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    items?: OrderItemListRelationFilter
    payments?: PaymentListRelationFilter
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    transactions?: TransactionListRelationFilter
  }, "id" | "tenantId_orderNumber">

  export type SalesOrderOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    orderedAt?: SortOrder
    shippedAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesOrderCountOrderByAggregateInput
    _avg?: SalesOrderAvgOrderByAggregateInput
    _max?: SalesOrderMaxOrderByAggregateInput
    _min?: SalesOrderMinOrderByAggregateInput
    _sum?: SalesOrderSumOrderByAggregateInput
  }

  export type SalesOrderScalarWhereWithAggregatesInput = {
    AND?: SalesOrderScalarWhereWithAggregatesInput | SalesOrderScalarWhereWithAggregatesInput[]
    OR?: SalesOrderScalarWhereWithAggregatesInput[]
    NOT?: SalesOrderScalarWhereWithAggregatesInput | SalesOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalesOrder"> | string
    tenantId?: StringWithAggregatesFilter<"SalesOrder"> | string
    orderNumber?: StringWithAggregatesFilter<"SalesOrder"> | string
    customerId?: StringWithAggregatesFilter<"SalesOrder"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"SalesOrder"> | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"SalesOrder"> | $Enums.PaymentStatus
    totalAmount?: DecimalWithAggregatesFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalWithAggregatesFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"SalesOrder"> | string | null
    orderedAt?: DateTimeWithAggregatesFilter<"SalesOrder"> | Date | string
    shippedAt?: DateTimeNullableWithAggregatesFilter<"SalesOrder"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"SalesOrder"> | Date | string | null
    createdBy?: StringWithAggregatesFilter<"SalesOrder"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesOrder"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productName?: StringFilter<"OrderItem"> | string
    packageType?: EnumPackageTypeFilter<"OrderItem"> | $Enums.PackageType
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    batchId?: StringNullableFilter<"OrderItem"> | string | null
    order?: XOR<SalesOrderRelationFilter, SalesOrderWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productName?: SortOrder
    packageType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    batchId?: SortOrderInput | SortOrder
    order?: SalesOrderOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    productName?: StringFilter<"OrderItem"> | string
    packageType?: EnumPackageTypeFilter<"OrderItem"> | $Enums.PackageType
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    batchId?: StringNullableFilter<"OrderItem"> | string | null
    order?: XOR<SalesOrderRelationFilter, SalesOrderWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productName?: SortOrder
    packageType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    batchId?: SortOrderInput | SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    productName?: StringWithAggregatesFilter<"OrderItem"> | string
    packageType?: EnumPackageTypeWithAggregatesFilter<"OrderItem"> | $Enums.PackageType
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    batchId?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    tenantId?: StringFilter<"Transaction"> | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    date?: DateTimeFilter<"Transaction"> | Date | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    incomeCategory?: EnumIncomeCategoryNullableFilter<"Transaction"> | $Enums.IncomeCategory | null
    expenseCategory?: EnumExpenseCategoryNullableFilter<"Transaction"> | $Enums.ExpenseCategory | null
    description?: StringNullableFilter<"Transaction"> | string | null
    customerId?: StringNullableFilter<"Transaction"> | string | null
    supplierId?: StringNullableFilter<"Transaction"> | string | null
    orderId?: StringNullableFilter<"Transaction"> | string | null
    invoiceId?: StringNullableFilter<"Transaction"> | string | null
    expenseId?: StringNullableFilter<"Transaction"> | string | null
    paymentId?: StringNullableFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodNullableFilter<"Transaction"> | $Enums.PaymentMethod | null
    reference?: StringNullableFilter<"Transaction"> | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    createdBy?: StringFilter<"Transaction"> | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    expense?: XOR<ExpenseNullableRelationFilter, ExpenseWhereInput> | null
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    order?: XOR<SalesOrderNullableRelationFilter, SalesOrderWhereInput> | null
    supplier?: XOR<SupplierNullableRelationFilter, SupplierWhereInput> | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    incomeCategory?: SortOrderInput | SortOrder
    expenseCategory?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    expenseId?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    expense?: ExpenseOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
    order?: SalesOrderOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    tenantId?: StringFilter<"Transaction"> | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    date?: DateTimeFilter<"Transaction"> | Date | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    incomeCategory?: EnumIncomeCategoryNullableFilter<"Transaction"> | $Enums.IncomeCategory | null
    expenseCategory?: EnumExpenseCategoryNullableFilter<"Transaction"> | $Enums.ExpenseCategory | null
    description?: StringNullableFilter<"Transaction"> | string | null
    customerId?: StringNullableFilter<"Transaction"> | string | null
    supplierId?: StringNullableFilter<"Transaction"> | string | null
    orderId?: StringNullableFilter<"Transaction"> | string | null
    invoiceId?: StringNullableFilter<"Transaction"> | string | null
    expenseId?: StringNullableFilter<"Transaction"> | string | null
    paymentId?: StringNullableFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodNullableFilter<"Transaction"> | $Enums.PaymentMethod | null
    reference?: StringNullableFilter<"Transaction"> | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    createdBy?: StringFilter<"Transaction"> | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    expense?: XOR<ExpenseNullableRelationFilter, ExpenseWhereInput> | null
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    order?: XOR<SalesOrderNullableRelationFilter, SalesOrderWhereInput> | null
    supplier?: XOR<SupplierNullableRelationFilter, SupplierWhereInput> | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    incomeCategory?: SortOrderInput | SortOrder
    expenseCategory?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    expenseId?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    tenantId?: StringWithAggregatesFilter<"Transaction"> | string
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    date?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    incomeCategory?: EnumIncomeCategoryNullableWithAggregatesFilter<"Transaction"> | $Enums.IncomeCategory | null
    expenseCategory?: EnumExpenseCategoryNullableWithAggregatesFilter<"Transaction"> | $Enums.ExpenseCategory | null
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    supplierId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    invoiceId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    expenseId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    paymentId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodNullableWithAggregatesFilter<"Transaction"> | $Enums.PaymentMethod | null
    reference?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdBy?: StringWithAggregatesFilter<"Transaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    tenantId?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    customerId?: StringNullableFilter<"Invoice"> | string | null
    supplierId?: StringNullableFilter<"Invoice"> | string | null
    orderId?: StringNullableFilter<"Invoice"> | string | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Invoice"> | string | null
    terms?: StringNullableFilter<"Invoice"> | string | null
    createdBy?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    order?: XOR<SalesOrderNullableRelationFilter, SalesOrderWhereInput> | null
    supplier?: XOR<SupplierNullableRelationFilter, SupplierWhereInput> | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    items?: InvoiceItemListRelationFilter
    payments?: PaymentListRelationFilter
    transactions?: TransactionListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    order?: SalesOrderOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    items?: InvoiceItemOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    tenantId_invoiceNumber?: InvoiceTenantIdInvoiceNumberCompoundUniqueInput
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    tenantId?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    customerId?: StringNullableFilter<"Invoice"> | string | null
    supplierId?: StringNullableFilter<"Invoice"> | string | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Invoice"> | string | null
    terms?: StringNullableFilter<"Invoice"> | string | null
    createdBy?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    order?: XOR<SalesOrderNullableRelationFilter, SalesOrderWhereInput> | null
    supplier?: XOR<SupplierNullableRelationFilter, SupplierWhereInput> | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    items?: InvoiceItemListRelationFilter
    payments?: PaymentListRelationFilter
    transactions?: TransactionListRelationFilter
  }, "id" | "orderId" | "tenantId_invoiceNumber">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    tenantId?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    type?: EnumInvoiceTypeWithAggregatesFilter<"Invoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    issueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    customerId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    supplierId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    subtotal?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    terms?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdBy?: StringWithAggregatesFilter<"Invoice"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringNullableFilter<"InvoiceItem"> | string | null
    unitPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    productName?: StringNullableFilter<"InvoiceItem"> | string | null
    packageType?: EnumPackageTypeNullableFilter<"InvoiceItem"> | $Enums.PackageType | null
    batchId?: StringNullableFilter<"InvoiceItem"> | string | null
    sortOrder?: IntFilter<"InvoiceItem"> | number
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit?: SortOrderInput | SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    productName?: SortOrderInput | SortOrder
    packageType?: SortOrderInput | SortOrder
    batchId?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    invoiceId?: StringFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringNullableFilter<"InvoiceItem"> | string | null
    unitPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    productName?: StringNullableFilter<"InvoiceItem"> | string | null
    packageType?: EnumPackageTypeNullableFilter<"InvoiceItem"> | $Enums.PackageType | null
    batchId?: StringNullableFilter<"InvoiceItem"> | string | null
    sortOrder?: IntFilter<"InvoiceItem"> | number
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit?: SortOrderInput | SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    productName?: SortOrderInput | SortOrder
    packageType?: SortOrderInput | SortOrder
    batchId?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceItem"> | string
    invoiceId?: StringWithAggregatesFilter<"InvoiceItem"> | string
    description?: StringWithAggregatesFilter<"InvoiceItem"> | string
    quantity?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringNullableWithAggregatesFilter<"InvoiceItem"> | string | null
    unitPrice?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    productName?: StringNullableWithAggregatesFilter<"InvoiceItem"> | string | null
    packageType?: EnumPackageTypeNullableWithAggregatesFilter<"InvoiceItem"> | $Enums.PackageType | null
    batchId?: StringNullableWithAggregatesFilter<"InvoiceItem"> | string | null
    sortOrder?: IntWithAggregatesFilter<"InvoiceItem"> | number
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    tenantId?: StringFilter<"Payment"> | string
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    orderId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    date?: DateTimeFilter<"Payment"> | Date | string
    reference?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdBy?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    order?: XOR<SalesOrderNullableRelationFilter, SalesOrderWhereInput> | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    amount?: SortOrder
    method?: SortOrder
    date?: SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    order?: SalesOrderOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    tenantId?: StringFilter<"Payment"> | string
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    orderId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    date?: DateTimeFilter<"Payment"> | Date | string
    reference?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdBy?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    order?: XOR<SalesOrderNullableRelationFilter, SalesOrderWhereInput> | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    amount?: SortOrder
    method?: SortOrder
    date?: SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    tenantId?: StringWithAggregatesFilter<"Payment"> | string
    invoiceId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    date?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    reference?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdBy?: StringWithAggregatesFilter<"Payment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: StringFilter<"Expense"> | string
    tenantId?: StringFilter<"Expense"> | string
    category?: EnumExpenseCategoryFilter<"Expense"> | $Enums.ExpenseCategory
    supplierId?: StringNullableFilter<"Expense"> | string | null
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"Expense"> | Date | string
    description?: StringNullableFilter<"Expense"> | string | null
    invoiceNumber?: StringNullableFilter<"Expense"> | string | null
    invoiceId?: StringNullableFilter<"Expense"> | string | null
    isPaid?: BoolFilter<"Expense"> | boolean
    paidAt?: DateTimeNullableFilter<"Expense"> | Date | string | null
    paymentMethod?: EnumPaymentMethodNullableFilter<"Expense"> | $Enums.PaymentMethod | null
    receiptUrl?: StringNullableFilter<"Expense"> | string | null
    notes?: StringNullableFilter<"Expense"> | string | null
    createdBy?: StringFilter<"Expense"> | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    supplier?: XOR<SupplierNullableRelationFilter, SupplierWhereInput> | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    transactions?: TransactionListRelationFilter
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    category?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplier?: SupplierOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    tenantId?: StringFilter<"Expense"> | string
    category?: EnumExpenseCategoryFilter<"Expense"> | $Enums.ExpenseCategory
    supplierId?: StringNullableFilter<"Expense"> | string | null
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"Expense"> | Date | string
    description?: StringNullableFilter<"Expense"> | string | null
    invoiceNumber?: StringNullableFilter<"Expense"> | string | null
    invoiceId?: StringNullableFilter<"Expense"> | string | null
    isPaid?: BoolFilter<"Expense"> | boolean
    paidAt?: DateTimeNullableFilter<"Expense"> | Date | string | null
    paymentMethod?: EnumPaymentMethodNullableFilter<"Expense"> | $Enums.PaymentMethod | null
    receiptUrl?: StringNullableFilter<"Expense"> | string | null
    notes?: StringNullableFilter<"Expense"> | string | null
    createdBy?: StringFilter<"Expense"> | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    supplier?: XOR<SupplierNullableRelationFilter, SupplierWhereInput> | null
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    transactions?: TransactionListRelationFilter
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    category?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expense"> | string
    tenantId?: StringWithAggregatesFilter<"Expense"> | string
    category?: EnumExpenseCategoryWithAggregatesFilter<"Expense"> | $Enums.ExpenseCategory
    supplierId?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    amount?: DecimalWithAggregatesFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    invoiceNumber?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    invoiceId?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    isPaid?: BoolWithAggregatesFilter<"Expense"> | boolean
    paidAt?: DateTimeNullableWithAggregatesFilter<"Expense"> | Date | string | null
    paymentMethod?: EnumPaymentMethodNullableWithAggregatesFilter<"Expense"> | $Enums.PaymentMethod | null
    receiptUrl?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    createdBy?: StringWithAggregatesFilter<"Expense"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
  }

  export type BudgetWhereInput = {
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    id?: StringFilter<"Budget"> | string
    tenantId?: StringFilter<"Budget"> | string
    category?: EnumExpenseCategoryFilter<"Budget"> | $Enums.ExpenseCategory
    year?: IntFilter<"Budget"> | number
    month?: IntNullableFilter<"Budget"> | number | null
    amount?: DecimalFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type BudgetOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    category?: SortOrder
    year?: SortOrder
    month?: SortOrderInput | SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type BudgetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_category_year_month?: BudgetTenantIdCategoryYearMonthCompoundUniqueInput
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    tenantId?: StringFilter<"Budget"> | string
    category?: EnumExpenseCategoryFilter<"Budget"> | $Enums.ExpenseCategory
    year?: IntFilter<"Budget"> | number
    month?: IntNullableFilter<"Budget"> | number | null
    amount?: DecimalFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id" | "tenantId_category_year_month">

  export type BudgetOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    category?: SortOrder
    year?: SortOrder
    month?: SortOrderInput | SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BudgetCountOrderByAggregateInput
    _avg?: BudgetAvgOrderByAggregateInput
    _max?: BudgetMaxOrderByAggregateInput
    _min?: BudgetMinOrderByAggregateInput
    _sum?: BudgetSumOrderByAggregateInput
  }

  export type BudgetScalarWhereWithAggregatesInput = {
    AND?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    OR?: BudgetScalarWhereWithAggregatesInput[]
    NOT?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Budget"> | string
    tenantId?: StringWithAggregatesFilter<"Budget"> | string
    category?: EnumExpenseCategoryWithAggregatesFilter<"Budget"> | $Enums.ExpenseCategory
    year?: IntWithAggregatesFilter<"Budget"> | number
    month?: IntNullableWithAggregatesFilter<"Budget"> | number | null
    amount?: DecimalWithAggregatesFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    tenantId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    correlationId?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    correlationId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    tenantId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    correlationId?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    correlationId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    tenantId?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    oldData?: JsonNullableWithAggregatesFilter<"AuditLog">
    newData?: JsonNullableWithAggregatesFilter<"AuditLog">
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    correlationId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type BlendingConfigWhereInput = {
    AND?: BlendingConfigWhereInput | BlendingConfigWhereInput[]
    OR?: BlendingConfigWhereInput[]
    NOT?: BlendingConfigWhereInput | BlendingConfigWhereInput[]
    id?: StringFilter<"BlendingConfig"> | string
    tenantId?: StringFilter<"BlendingConfig"> | string
    requireRecipeMatch?: BoolFilter<"BlendingConfig"> | boolean
    requireYeastMatch?: BoolFilter<"BlendingConfig"> | boolean
    requirePhaseMatch?: BoolFilter<"BlendingConfig"> | boolean
    requireStyleMatch?: BoolFilter<"BlendingConfig"> | boolean
    maxBlendSources?: IntFilter<"BlendingConfig"> | number
    allowOverCapacity?: BoolFilter<"BlendingConfig"> | boolean
    maxAgeDifferenceHours?: IntFilter<"BlendingConfig"> | number
    createdAt?: DateTimeFilter<"BlendingConfig"> | Date | string
    updatedAt?: DateTimeFilter<"BlendingConfig"> | Date | string
  }

  export type BlendingConfigOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    requireRecipeMatch?: SortOrder
    requireYeastMatch?: SortOrder
    requirePhaseMatch?: SortOrder
    requireStyleMatch?: SortOrder
    maxBlendSources?: SortOrder
    allowOverCapacity?: SortOrder
    maxAgeDifferenceHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlendingConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId?: string
    AND?: BlendingConfigWhereInput | BlendingConfigWhereInput[]
    OR?: BlendingConfigWhereInput[]
    NOT?: BlendingConfigWhereInput | BlendingConfigWhereInput[]
    requireRecipeMatch?: BoolFilter<"BlendingConfig"> | boolean
    requireYeastMatch?: BoolFilter<"BlendingConfig"> | boolean
    requirePhaseMatch?: BoolFilter<"BlendingConfig"> | boolean
    requireStyleMatch?: BoolFilter<"BlendingConfig"> | boolean
    maxBlendSources?: IntFilter<"BlendingConfig"> | number
    allowOverCapacity?: BoolFilter<"BlendingConfig"> | boolean
    maxAgeDifferenceHours?: IntFilter<"BlendingConfig"> | number
    createdAt?: DateTimeFilter<"BlendingConfig"> | Date | string
    updatedAt?: DateTimeFilter<"BlendingConfig"> | Date | string
  }, "id" | "tenantId">

  export type BlendingConfigOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    requireRecipeMatch?: SortOrder
    requireYeastMatch?: SortOrder
    requirePhaseMatch?: SortOrder
    requireStyleMatch?: SortOrder
    maxBlendSources?: SortOrder
    allowOverCapacity?: SortOrder
    maxAgeDifferenceHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlendingConfigCountOrderByAggregateInput
    _avg?: BlendingConfigAvgOrderByAggregateInput
    _max?: BlendingConfigMaxOrderByAggregateInput
    _min?: BlendingConfigMinOrderByAggregateInput
    _sum?: BlendingConfigSumOrderByAggregateInput
  }

  export type BlendingConfigScalarWhereWithAggregatesInput = {
    AND?: BlendingConfigScalarWhereWithAggregatesInput | BlendingConfigScalarWhereWithAggregatesInput[]
    OR?: BlendingConfigScalarWhereWithAggregatesInput[]
    NOT?: BlendingConfigScalarWhereWithAggregatesInput | BlendingConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlendingConfig"> | string
    tenantId?: StringWithAggregatesFilter<"BlendingConfig"> | string
    requireRecipeMatch?: BoolWithAggregatesFilter<"BlendingConfig"> | boolean
    requireYeastMatch?: BoolWithAggregatesFilter<"BlendingConfig"> | boolean
    requirePhaseMatch?: BoolWithAggregatesFilter<"BlendingConfig"> | boolean
    requireStyleMatch?: BoolWithAggregatesFilter<"BlendingConfig"> | boolean
    maxBlendSources?: IntWithAggregatesFilter<"BlendingConfig"> | number
    allowOverCapacity?: BoolWithAggregatesFilter<"BlendingConfig"> | boolean
    maxAgeDifferenceHours?: IntWithAggregatesFilter<"BlendingConfig"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BlendingConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlendingConfig"> | Date | string
  }

  export type CIPLogWhereInput = {
    AND?: CIPLogWhereInput | CIPLogWhereInput[]
    OR?: CIPLogWhereInput[]
    NOT?: CIPLogWhereInput | CIPLogWhereInput[]
    id?: StringFilter<"CIPLog"> | string
    equipmentId?: StringFilter<"CIPLog"> | string
    cipType?: StringFilter<"CIPLog"> | string
    date?: DateTimeFilter<"CIPLog"> | Date | string
    duration?: IntFilter<"CIPLog"> | number
    temperature?: FloatNullableFilter<"CIPLog"> | number | null
    causticConcentration?: FloatNullableFilter<"CIPLog"> | number | null
    performedBy?: StringFilter<"CIPLog"> | string
    result?: StringFilter<"CIPLog"> | string
    notes?: StringNullableFilter<"CIPLog"> | string | null
    createdAt?: DateTimeFilter<"CIPLog"> | Date | string
    Equipment?: XOR<EquipmentRelationFilter, EquipmentWhereInput>
  }

  export type CIPLogOrderByWithRelationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    cipType?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    temperature?: SortOrderInput | SortOrder
    causticConcentration?: SortOrderInput | SortOrder
    performedBy?: SortOrder
    result?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    Equipment?: EquipmentOrderByWithRelationInput
  }

  export type CIPLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CIPLogWhereInput | CIPLogWhereInput[]
    OR?: CIPLogWhereInput[]
    NOT?: CIPLogWhereInput | CIPLogWhereInput[]
    equipmentId?: StringFilter<"CIPLog"> | string
    cipType?: StringFilter<"CIPLog"> | string
    date?: DateTimeFilter<"CIPLog"> | Date | string
    duration?: IntFilter<"CIPLog"> | number
    temperature?: FloatNullableFilter<"CIPLog"> | number | null
    causticConcentration?: FloatNullableFilter<"CIPLog"> | number | null
    performedBy?: StringFilter<"CIPLog"> | string
    result?: StringFilter<"CIPLog"> | string
    notes?: StringNullableFilter<"CIPLog"> | string | null
    createdAt?: DateTimeFilter<"CIPLog"> | Date | string
    Equipment?: XOR<EquipmentRelationFilter, EquipmentWhereInput>
  }, "id">

  export type CIPLogOrderByWithAggregationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    cipType?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    temperature?: SortOrderInput | SortOrder
    causticConcentration?: SortOrderInput | SortOrder
    performedBy?: SortOrder
    result?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CIPLogCountOrderByAggregateInput
    _avg?: CIPLogAvgOrderByAggregateInput
    _max?: CIPLogMaxOrderByAggregateInput
    _min?: CIPLogMinOrderByAggregateInput
    _sum?: CIPLogSumOrderByAggregateInput
  }

  export type CIPLogScalarWhereWithAggregatesInput = {
    AND?: CIPLogScalarWhereWithAggregatesInput | CIPLogScalarWhereWithAggregatesInput[]
    OR?: CIPLogScalarWhereWithAggregatesInput[]
    NOT?: CIPLogScalarWhereWithAggregatesInput | CIPLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CIPLog"> | string
    equipmentId?: StringWithAggregatesFilter<"CIPLog"> | string
    cipType?: StringWithAggregatesFilter<"CIPLog"> | string
    date?: DateTimeWithAggregatesFilter<"CIPLog"> | Date | string
    duration?: IntWithAggregatesFilter<"CIPLog"> | number
    temperature?: FloatNullableWithAggregatesFilter<"CIPLog"> | number | null
    causticConcentration?: FloatNullableWithAggregatesFilter<"CIPLog"> | number | null
    performedBy?: StringWithAggregatesFilter<"CIPLog"> | string
    result?: StringWithAggregatesFilter<"CIPLog"> | string
    notes?: StringNullableWithAggregatesFilter<"CIPLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CIPLog"> | Date | string
  }

  export type EquipmentWhereInput = {
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    id?: StringFilter<"Equipment"> | string
    tenantId?: StringFilter<"Equipment"> | string
    name?: StringFilter<"Equipment"> | string
    type?: StringFilter<"Equipment"> | string
    status?: StringFilter<"Equipment"> | string
    capacity?: IntNullableFilter<"Equipment"> | number | null
    model?: StringNullableFilter<"Equipment"> | string | null
    manufacturer?: StringNullableFilter<"Equipment"> | string | null
    serialNumber?: StringNullableFilter<"Equipment"> | string | null
    location?: StringNullableFilter<"Equipment"> | string | null
    workingPressure?: FloatNullableFilter<"Equipment"> | number | null
    currentTemp?: FloatNullableFilter<"Equipment"> | number | null
    currentPressure?: FloatNullableFilter<"Equipment"> | number | null
    installationDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    warrantyDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    lastCIP?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    nextCIP?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    lastMaintenance?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    nextMaintenance?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    cipIntervalDays?: IntFilter<"Equipment"> | number
    inspectionIntervalDays?: IntFilter<"Equipment"> | number
    annualMaintenanceDays?: IntFilter<"Equipment"> | number
    currentBatchId?: StringNullableFilter<"Equipment"> | string | null
    currentBatchNumber?: StringNullableFilter<"Equipment"> | string | null
    notes?: StringNullableFilter<"Equipment"> | string | null
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    purchaseDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    capabilities?: StringNullableListFilter<"Equipment">
    CIPLog?: CIPLogListRelationFilter
    Tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    MaintenanceLog?: MaintenanceLogListRelationFilter
    ProblemReport?: ProblemReportListRelationFilter
  }

  export type EquipmentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    capacity?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    workingPressure?: SortOrderInput | SortOrder
    currentTemp?: SortOrderInput | SortOrder
    currentPressure?: SortOrderInput | SortOrder
    installationDate?: SortOrderInput | SortOrder
    warrantyDate?: SortOrderInput | SortOrder
    lastCIP?: SortOrderInput | SortOrder
    nextCIP?: SortOrderInput | SortOrder
    lastMaintenance?: SortOrderInput | SortOrder
    nextMaintenance?: SortOrderInput | SortOrder
    cipIntervalDays?: SortOrder
    inspectionIntervalDays?: SortOrder
    annualMaintenanceDays?: SortOrder
    currentBatchId?: SortOrderInput | SortOrder
    currentBatchNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    capabilities?: SortOrder
    CIPLog?: CIPLogOrderByRelationAggregateInput
    Tenant?: TenantOrderByWithRelationInput
    MaintenanceLog?: MaintenanceLogOrderByRelationAggregateInput
    ProblemReport?: ProblemReportOrderByRelationAggregateInput
  }

  export type EquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    tenantId?: StringFilter<"Equipment"> | string
    name?: StringFilter<"Equipment"> | string
    type?: StringFilter<"Equipment"> | string
    status?: StringFilter<"Equipment"> | string
    capacity?: IntNullableFilter<"Equipment"> | number | null
    model?: StringNullableFilter<"Equipment"> | string | null
    manufacturer?: StringNullableFilter<"Equipment"> | string | null
    serialNumber?: StringNullableFilter<"Equipment"> | string | null
    location?: StringNullableFilter<"Equipment"> | string | null
    workingPressure?: FloatNullableFilter<"Equipment"> | number | null
    currentTemp?: FloatNullableFilter<"Equipment"> | number | null
    currentPressure?: FloatNullableFilter<"Equipment"> | number | null
    installationDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    warrantyDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    lastCIP?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    nextCIP?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    lastMaintenance?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    nextMaintenance?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    cipIntervalDays?: IntFilter<"Equipment"> | number
    inspectionIntervalDays?: IntFilter<"Equipment"> | number
    annualMaintenanceDays?: IntFilter<"Equipment"> | number
    currentBatchId?: StringNullableFilter<"Equipment"> | string | null
    currentBatchNumber?: StringNullableFilter<"Equipment"> | string | null
    notes?: StringNullableFilter<"Equipment"> | string | null
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    purchaseDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    capabilities?: StringNullableListFilter<"Equipment">
    CIPLog?: CIPLogListRelationFilter
    Tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    MaintenanceLog?: MaintenanceLogListRelationFilter
    ProblemReport?: ProblemReportListRelationFilter
  }, "id">

  export type EquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    capacity?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    workingPressure?: SortOrderInput | SortOrder
    currentTemp?: SortOrderInput | SortOrder
    currentPressure?: SortOrderInput | SortOrder
    installationDate?: SortOrderInput | SortOrder
    warrantyDate?: SortOrderInput | SortOrder
    lastCIP?: SortOrderInput | SortOrder
    nextCIP?: SortOrderInput | SortOrder
    lastMaintenance?: SortOrderInput | SortOrder
    nextMaintenance?: SortOrderInput | SortOrder
    cipIntervalDays?: SortOrder
    inspectionIntervalDays?: SortOrder
    annualMaintenanceDays?: SortOrder
    currentBatchId?: SortOrderInput | SortOrder
    currentBatchNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseDate?: SortOrderInput | SortOrder
    capabilities?: SortOrder
    _count?: EquipmentCountOrderByAggregateInput
    _avg?: EquipmentAvgOrderByAggregateInput
    _max?: EquipmentMaxOrderByAggregateInput
    _min?: EquipmentMinOrderByAggregateInput
    _sum?: EquipmentSumOrderByAggregateInput
  }

  export type EquipmentScalarWhereWithAggregatesInput = {
    AND?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    OR?: EquipmentScalarWhereWithAggregatesInput[]
    NOT?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Equipment"> | string
    tenantId?: StringWithAggregatesFilter<"Equipment"> | string
    name?: StringWithAggregatesFilter<"Equipment"> | string
    type?: StringWithAggregatesFilter<"Equipment"> | string
    status?: StringWithAggregatesFilter<"Equipment"> | string
    capacity?: IntNullableWithAggregatesFilter<"Equipment"> | number | null
    model?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    manufacturer?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    serialNumber?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    location?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    workingPressure?: FloatNullableWithAggregatesFilter<"Equipment"> | number | null
    currentTemp?: FloatNullableWithAggregatesFilter<"Equipment"> | number | null
    currentPressure?: FloatNullableWithAggregatesFilter<"Equipment"> | number | null
    installationDate?: DateTimeNullableWithAggregatesFilter<"Equipment"> | Date | string | null
    warrantyDate?: DateTimeNullableWithAggregatesFilter<"Equipment"> | Date | string | null
    lastCIP?: DateTimeNullableWithAggregatesFilter<"Equipment"> | Date | string | null
    nextCIP?: DateTimeNullableWithAggregatesFilter<"Equipment"> | Date | string | null
    lastMaintenance?: DateTimeNullableWithAggregatesFilter<"Equipment"> | Date | string | null
    nextMaintenance?: DateTimeNullableWithAggregatesFilter<"Equipment"> | Date | string | null
    cipIntervalDays?: IntWithAggregatesFilter<"Equipment"> | number
    inspectionIntervalDays?: IntWithAggregatesFilter<"Equipment"> | number
    annualMaintenanceDays?: IntWithAggregatesFilter<"Equipment"> | number
    currentBatchId?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    currentBatchNumber?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Equipment"> | Date | string
    purchaseDate?: DateTimeNullableWithAggregatesFilter<"Equipment"> | Date | string | null
    capabilities?: StringNullableListFilter<"Equipment">
  }

  export type LotWhereInput = {
    AND?: LotWhereInput | LotWhereInput[]
    OR?: LotWhereInput[]
    NOT?: LotWhereInput | LotWhereInput[]
    id?: StringFilter<"Lot"> | string
    tenantId?: StringFilter<"Lot"> | string
    lotCode?: StringNullableFilter<"Lot"> | string | null
    phase?: EnumLotPhaseFilter<"Lot"> | $Enums.LotPhase
    status?: EnumLotStatusFilter<"Lot"> | $Enums.LotStatus
    plannedVolume?: DecimalFilter<"Lot"> | Decimal | DecimalJsLike | number | string
    actualVolume?: DecimalNullableFilter<"Lot"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Lot"> | string | null
    parentLotId?: StringNullableFilter<"Lot"> | string | null
    splitRatio?: DecimalNullableFilter<"Lot"> | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFilter<"Lot"> | string
    createdAt?: DateTimeFilter<"Lot"> | Date | string
    updatedAt?: DateTimeFilter<"Lot"> | Date | string
    completedAt?: DateTimeNullableFilter<"Lot"> | Date | string | null
    lotNumber?: StringNullableFilter<"Lot"> | string | null
    blendedAt?: DateTimeNullableFilter<"Lot"> | Date | string | null
    isBlendResult?: BoolNullableFilter<"Lot"> | boolean | null
    splitAt?: DateTimeNullableFilter<"Lot"> | Date | string | null
    Lot?: XOR<LotNullableRelationFilter, LotWhereInput> | null
    other_Lot?: LotListRelationFilter
    LotBatch?: LotBatchListRelationFilter
    LotReading?: LotReadingListRelationFilter
    QCTest?: QCTestListRelationFilter
    TankAssignment?: TankAssignmentListRelationFilter
    Transfer_Transfer_destLotIdToLot?: TransferListRelationFilter
    Transfer_Transfer_sourceLotIdToLot?: TransferListRelationFilter
  }

  export type LotOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    lotCode?: SortOrderInput | SortOrder
    phase?: SortOrder
    status?: SortOrder
    plannedVolume?: SortOrder
    actualVolume?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    parentLotId?: SortOrderInput | SortOrder
    splitRatio?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    lotNumber?: SortOrderInput | SortOrder
    blendedAt?: SortOrderInput | SortOrder
    isBlendResult?: SortOrderInput | SortOrder
    splitAt?: SortOrderInput | SortOrder
    Lot?: LotOrderByWithRelationInput
    other_Lot?: LotOrderByRelationAggregateInput
    LotBatch?: LotBatchOrderByRelationAggregateInput
    LotReading?: LotReadingOrderByRelationAggregateInput
    QCTest?: QCTestOrderByRelationAggregateInput
    TankAssignment?: TankAssignmentOrderByRelationAggregateInput
    Transfer_Transfer_destLotIdToLot?: TransferOrderByRelationAggregateInput
    Transfer_Transfer_sourceLotIdToLot?: TransferOrderByRelationAggregateInput
  }

  export type LotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_lotCode?: LotTenantIdLotCodeCompoundUniqueInput
    AND?: LotWhereInput | LotWhereInput[]
    OR?: LotWhereInput[]
    NOT?: LotWhereInput | LotWhereInput[]
    tenantId?: StringFilter<"Lot"> | string
    lotCode?: StringNullableFilter<"Lot"> | string | null
    phase?: EnumLotPhaseFilter<"Lot"> | $Enums.LotPhase
    status?: EnumLotStatusFilter<"Lot"> | $Enums.LotStatus
    plannedVolume?: DecimalFilter<"Lot"> | Decimal | DecimalJsLike | number | string
    actualVolume?: DecimalNullableFilter<"Lot"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Lot"> | string | null
    parentLotId?: StringNullableFilter<"Lot"> | string | null
    splitRatio?: DecimalNullableFilter<"Lot"> | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFilter<"Lot"> | string
    createdAt?: DateTimeFilter<"Lot"> | Date | string
    updatedAt?: DateTimeFilter<"Lot"> | Date | string
    completedAt?: DateTimeNullableFilter<"Lot"> | Date | string | null
    lotNumber?: StringNullableFilter<"Lot"> | string | null
    blendedAt?: DateTimeNullableFilter<"Lot"> | Date | string | null
    isBlendResult?: BoolNullableFilter<"Lot"> | boolean | null
    splitAt?: DateTimeNullableFilter<"Lot"> | Date | string | null
    Lot?: XOR<LotNullableRelationFilter, LotWhereInput> | null
    other_Lot?: LotListRelationFilter
    LotBatch?: LotBatchListRelationFilter
    LotReading?: LotReadingListRelationFilter
    QCTest?: QCTestListRelationFilter
    TankAssignment?: TankAssignmentListRelationFilter
    Transfer_Transfer_destLotIdToLot?: TransferListRelationFilter
    Transfer_Transfer_sourceLotIdToLot?: TransferListRelationFilter
  }, "id" | "tenantId_lotCode">

  export type LotOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    lotCode?: SortOrderInput | SortOrder
    phase?: SortOrder
    status?: SortOrder
    plannedVolume?: SortOrder
    actualVolume?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    parentLotId?: SortOrderInput | SortOrder
    splitRatio?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    lotNumber?: SortOrderInput | SortOrder
    blendedAt?: SortOrderInput | SortOrder
    isBlendResult?: SortOrderInput | SortOrder
    splitAt?: SortOrderInput | SortOrder
    _count?: LotCountOrderByAggregateInput
    _avg?: LotAvgOrderByAggregateInput
    _max?: LotMaxOrderByAggregateInput
    _min?: LotMinOrderByAggregateInput
    _sum?: LotSumOrderByAggregateInput
  }

  export type LotScalarWhereWithAggregatesInput = {
    AND?: LotScalarWhereWithAggregatesInput | LotScalarWhereWithAggregatesInput[]
    OR?: LotScalarWhereWithAggregatesInput[]
    NOT?: LotScalarWhereWithAggregatesInput | LotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lot"> | string
    tenantId?: StringWithAggregatesFilter<"Lot"> | string
    lotCode?: StringNullableWithAggregatesFilter<"Lot"> | string | null
    phase?: EnumLotPhaseWithAggregatesFilter<"Lot"> | $Enums.LotPhase
    status?: EnumLotStatusWithAggregatesFilter<"Lot"> | $Enums.LotStatus
    plannedVolume?: DecimalWithAggregatesFilter<"Lot"> | Decimal | DecimalJsLike | number | string
    actualVolume?: DecimalNullableWithAggregatesFilter<"Lot"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"Lot"> | string | null
    parentLotId?: StringNullableWithAggregatesFilter<"Lot"> | string | null
    splitRatio?: DecimalNullableWithAggregatesFilter<"Lot"> | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringWithAggregatesFilter<"Lot"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Lot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lot"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Lot"> | Date | string | null
    lotNumber?: StringNullableWithAggregatesFilter<"Lot"> | string | null
    blendedAt?: DateTimeNullableWithAggregatesFilter<"Lot"> | Date | string | null
    isBlendResult?: BoolNullableWithAggregatesFilter<"Lot"> | boolean | null
    splitAt?: DateTimeNullableWithAggregatesFilter<"Lot"> | Date | string | null
  }

  export type LotBatchWhereInput = {
    AND?: LotBatchWhereInput | LotBatchWhereInput[]
    OR?: LotBatchWhereInput[]
    NOT?: LotBatchWhereInput | LotBatchWhereInput[]
    id?: StringFilter<"LotBatch"> | string
    lotId?: StringFilter<"LotBatch"> | string
    batchId?: StringFilter<"LotBatch"> | string
    volumeContribution?: DecimalFilter<"LotBatch"> | Decimal | DecimalJsLike | number | string
    batchPercentage?: DecimalFilter<"LotBatch"> | Decimal | DecimalJsLike | number | string
    addedAt?: DateTimeFilter<"LotBatch"> | Date | string
    Batch?: XOR<BatchRelationFilter, BatchWhereInput>
    Lot?: XOR<LotRelationFilter, LotWhereInput>
  }

  export type LotBatchOrderByWithRelationInput = {
    id?: SortOrder
    lotId?: SortOrder
    batchId?: SortOrder
    volumeContribution?: SortOrder
    batchPercentage?: SortOrder
    addedAt?: SortOrder
    Batch?: BatchOrderByWithRelationInput
    Lot?: LotOrderByWithRelationInput
  }

  export type LotBatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lotId_batchId?: LotBatchLotIdBatchIdCompoundUniqueInput
    AND?: LotBatchWhereInput | LotBatchWhereInput[]
    OR?: LotBatchWhereInput[]
    NOT?: LotBatchWhereInput | LotBatchWhereInput[]
    lotId?: StringFilter<"LotBatch"> | string
    batchId?: StringFilter<"LotBatch"> | string
    volumeContribution?: DecimalFilter<"LotBatch"> | Decimal | DecimalJsLike | number | string
    batchPercentage?: DecimalFilter<"LotBatch"> | Decimal | DecimalJsLike | number | string
    addedAt?: DateTimeFilter<"LotBatch"> | Date | string
    Batch?: XOR<BatchRelationFilter, BatchWhereInput>
    Lot?: XOR<LotRelationFilter, LotWhereInput>
  }, "id" | "lotId_batchId">

  export type LotBatchOrderByWithAggregationInput = {
    id?: SortOrder
    lotId?: SortOrder
    batchId?: SortOrder
    volumeContribution?: SortOrder
    batchPercentage?: SortOrder
    addedAt?: SortOrder
    _count?: LotBatchCountOrderByAggregateInput
    _avg?: LotBatchAvgOrderByAggregateInput
    _max?: LotBatchMaxOrderByAggregateInput
    _min?: LotBatchMinOrderByAggregateInput
    _sum?: LotBatchSumOrderByAggregateInput
  }

  export type LotBatchScalarWhereWithAggregatesInput = {
    AND?: LotBatchScalarWhereWithAggregatesInput | LotBatchScalarWhereWithAggregatesInput[]
    OR?: LotBatchScalarWhereWithAggregatesInput[]
    NOT?: LotBatchScalarWhereWithAggregatesInput | LotBatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LotBatch"> | string
    lotId?: StringWithAggregatesFilter<"LotBatch"> | string
    batchId?: StringWithAggregatesFilter<"LotBatch"> | string
    volumeContribution?: DecimalWithAggregatesFilter<"LotBatch"> | Decimal | DecimalJsLike | number | string
    batchPercentage?: DecimalWithAggregatesFilter<"LotBatch"> | Decimal | DecimalJsLike | number | string
    addedAt?: DateTimeWithAggregatesFilter<"LotBatch"> | Date | string
  }

  export type LotReadingWhereInput = {
    AND?: LotReadingWhereInput | LotReadingWhereInput[]
    OR?: LotReadingWhereInput[]
    NOT?: LotReadingWhereInput | LotReadingWhereInput[]
    id?: StringFilter<"LotReading"> | string
    lotId?: StringFilter<"LotReading"> | string
    tankId?: StringFilter<"LotReading"> | string
    readingType?: EnumReadingTypeFilter<"LotReading"> | $Enums.ReadingType
    value?: DecimalFilter<"LotReading"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"LotReading"> | string
    notes?: StringNullableFilter<"LotReading"> | string | null
    recordedBy?: StringFilter<"LotReading"> | string
    recordedAt?: DateTimeFilter<"LotReading"> | Date | string
    Lot?: XOR<LotRelationFilter, LotWhereInput>
    Tank?: XOR<TankRelationFilter, TankWhereInput>
  }

  export type LotReadingOrderByWithRelationInput = {
    id?: SortOrder
    lotId?: SortOrder
    tankId?: SortOrder
    readingType?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    notes?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    recordedAt?: SortOrder
    Lot?: LotOrderByWithRelationInput
    Tank?: TankOrderByWithRelationInput
  }

  export type LotReadingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LotReadingWhereInput | LotReadingWhereInput[]
    OR?: LotReadingWhereInput[]
    NOT?: LotReadingWhereInput | LotReadingWhereInput[]
    lotId?: StringFilter<"LotReading"> | string
    tankId?: StringFilter<"LotReading"> | string
    readingType?: EnumReadingTypeFilter<"LotReading"> | $Enums.ReadingType
    value?: DecimalFilter<"LotReading"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"LotReading"> | string
    notes?: StringNullableFilter<"LotReading"> | string | null
    recordedBy?: StringFilter<"LotReading"> | string
    recordedAt?: DateTimeFilter<"LotReading"> | Date | string
    Lot?: XOR<LotRelationFilter, LotWhereInput>
    Tank?: XOR<TankRelationFilter, TankWhereInput>
  }, "id">

  export type LotReadingOrderByWithAggregationInput = {
    id?: SortOrder
    lotId?: SortOrder
    tankId?: SortOrder
    readingType?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    notes?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    recordedAt?: SortOrder
    _count?: LotReadingCountOrderByAggregateInput
    _avg?: LotReadingAvgOrderByAggregateInput
    _max?: LotReadingMaxOrderByAggregateInput
    _min?: LotReadingMinOrderByAggregateInput
    _sum?: LotReadingSumOrderByAggregateInput
  }

  export type LotReadingScalarWhereWithAggregatesInput = {
    AND?: LotReadingScalarWhereWithAggregatesInput | LotReadingScalarWhereWithAggregatesInput[]
    OR?: LotReadingScalarWhereWithAggregatesInput[]
    NOT?: LotReadingScalarWhereWithAggregatesInput | LotReadingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LotReading"> | string
    lotId?: StringWithAggregatesFilter<"LotReading"> | string
    tankId?: StringWithAggregatesFilter<"LotReading"> | string
    readingType?: EnumReadingTypeWithAggregatesFilter<"LotReading"> | $Enums.ReadingType
    value?: DecimalWithAggregatesFilter<"LotReading"> | Decimal | DecimalJsLike | number | string
    unit?: StringWithAggregatesFilter<"LotReading"> | string
    notes?: StringNullableWithAggregatesFilter<"LotReading"> | string | null
    recordedBy?: StringWithAggregatesFilter<"LotReading"> | string
    recordedAt?: DateTimeWithAggregatesFilter<"LotReading"> | Date | string
  }

  export type MaintenanceLogWhereInput = {
    AND?: MaintenanceLogWhereInput | MaintenanceLogWhereInput[]
    OR?: MaintenanceLogWhereInput[]
    NOT?: MaintenanceLogWhereInput | MaintenanceLogWhereInput[]
    id?: StringFilter<"MaintenanceLog"> | string
    equipmentId?: StringFilter<"MaintenanceLog"> | string
    type?: StringFilter<"MaintenanceLog"> | string
    status?: StringFilter<"MaintenanceLog"> | string
    priority?: StringNullableFilter<"MaintenanceLog"> | string | null
    scheduledDate?: DateTimeNullableFilter<"MaintenanceLog"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"MaintenanceLog"> | Date | string | null
    duration?: IntNullableFilter<"MaintenanceLog"> | number | null
    performedBy?: StringNullableFilter<"MaintenanceLog"> | string | null
    cost?: FloatNullableFilter<"MaintenanceLog"> | number | null
    partsUsed?: StringNullableListFilter<"MaintenanceLog">
    description?: StringNullableFilter<"MaintenanceLog"> | string | null
    createdAt?: DateTimeFilter<"MaintenanceLog"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceLog"> | Date | string
    Equipment?: XOR<EquipmentRelationFilter, EquipmentWhereInput>
  }

  export type MaintenanceLogOrderByWithRelationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrderInput | SortOrder
    scheduledDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    partsUsed?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Equipment?: EquipmentOrderByWithRelationInput
  }

  export type MaintenanceLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenanceLogWhereInput | MaintenanceLogWhereInput[]
    OR?: MaintenanceLogWhereInput[]
    NOT?: MaintenanceLogWhereInput | MaintenanceLogWhereInput[]
    equipmentId?: StringFilter<"MaintenanceLog"> | string
    type?: StringFilter<"MaintenanceLog"> | string
    status?: StringFilter<"MaintenanceLog"> | string
    priority?: StringNullableFilter<"MaintenanceLog"> | string | null
    scheduledDate?: DateTimeNullableFilter<"MaintenanceLog"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"MaintenanceLog"> | Date | string | null
    duration?: IntNullableFilter<"MaintenanceLog"> | number | null
    performedBy?: StringNullableFilter<"MaintenanceLog"> | string | null
    cost?: FloatNullableFilter<"MaintenanceLog"> | number | null
    partsUsed?: StringNullableListFilter<"MaintenanceLog">
    description?: StringNullableFilter<"MaintenanceLog"> | string | null
    createdAt?: DateTimeFilter<"MaintenanceLog"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceLog"> | Date | string
    Equipment?: XOR<EquipmentRelationFilter, EquipmentWhereInput>
  }, "id">

  export type MaintenanceLogOrderByWithAggregationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrderInput | SortOrder
    scheduledDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    partsUsed?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaintenanceLogCountOrderByAggregateInput
    _avg?: MaintenanceLogAvgOrderByAggregateInput
    _max?: MaintenanceLogMaxOrderByAggregateInput
    _min?: MaintenanceLogMinOrderByAggregateInput
    _sum?: MaintenanceLogSumOrderByAggregateInput
  }

  export type MaintenanceLogScalarWhereWithAggregatesInput = {
    AND?: MaintenanceLogScalarWhereWithAggregatesInput | MaintenanceLogScalarWhereWithAggregatesInput[]
    OR?: MaintenanceLogScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceLogScalarWhereWithAggregatesInput | MaintenanceLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaintenanceLog"> | string
    equipmentId?: StringWithAggregatesFilter<"MaintenanceLog"> | string
    type?: StringWithAggregatesFilter<"MaintenanceLog"> | string
    status?: StringWithAggregatesFilter<"MaintenanceLog"> | string
    priority?: StringNullableWithAggregatesFilter<"MaintenanceLog"> | string | null
    scheduledDate?: DateTimeNullableWithAggregatesFilter<"MaintenanceLog"> | Date | string | null
    completedDate?: DateTimeNullableWithAggregatesFilter<"MaintenanceLog"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"MaintenanceLog"> | number | null
    performedBy?: StringNullableWithAggregatesFilter<"MaintenanceLog"> | string | null
    cost?: FloatNullableWithAggregatesFilter<"MaintenanceLog"> | number | null
    partsUsed?: StringNullableListFilter<"MaintenanceLog">
    description?: StringNullableWithAggregatesFilter<"MaintenanceLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MaintenanceLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MaintenanceLog"> | Date | string
  }

  export type ProblemReportWhereInput = {
    AND?: ProblemReportWhereInput | ProblemReportWhereInput[]
    OR?: ProblemReportWhereInput[]
    NOT?: ProblemReportWhereInput | ProblemReportWhereInput[]
    id?: StringFilter<"ProblemReport"> | string
    equipmentId?: StringFilter<"ProblemReport"> | string
    problemType?: StringFilter<"ProblemReport"> | string
    severity?: StringFilter<"ProblemReport"> | string
    status?: StringFilter<"ProblemReport"> | string
    description?: StringFilter<"ProblemReport"> | string
    reportedDate?: DateTimeFilter<"ProblemReport"> | Date | string
    reportedBy?: StringFilter<"ProblemReport"> | string
    resolvedDate?: DateTimeNullableFilter<"ProblemReport"> | Date | string | null
    resolvedBy?: StringNullableFilter<"ProblemReport"> | string | null
    resolution?: StringNullableFilter<"ProblemReport"> | string | null
    createdAt?: DateTimeFilter<"ProblemReport"> | Date | string
    updatedAt?: DateTimeFilter<"ProblemReport"> | Date | string
    Equipment?: XOR<EquipmentRelationFilter, EquipmentWhereInput>
  }

  export type ProblemReportOrderByWithRelationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    problemType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    description?: SortOrder
    reportedDate?: SortOrder
    reportedBy?: SortOrder
    resolvedDate?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Equipment?: EquipmentOrderByWithRelationInput
  }

  export type ProblemReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProblemReportWhereInput | ProblemReportWhereInput[]
    OR?: ProblemReportWhereInput[]
    NOT?: ProblemReportWhereInput | ProblemReportWhereInput[]
    equipmentId?: StringFilter<"ProblemReport"> | string
    problemType?: StringFilter<"ProblemReport"> | string
    severity?: StringFilter<"ProblemReport"> | string
    status?: StringFilter<"ProblemReport"> | string
    description?: StringFilter<"ProblemReport"> | string
    reportedDate?: DateTimeFilter<"ProblemReport"> | Date | string
    reportedBy?: StringFilter<"ProblemReport"> | string
    resolvedDate?: DateTimeNullableFilter<"ProblemReport"> | Date | string | null
    resolvedBy?: StringNullableFilter<"ProblemReport"> | string | null
    resolution?: StringNullableFilter<"ProblemReport"> | string | null
    createdAt?: DateTimeFilter<"ProblemReport"> | Date | string
    updatedAt?: DateTimeFilter<"ProblemReport"> | Date | string
    Equipment?: XOR<EquipmentRelationFilter, EquipmentWhereInput>
  }, "id">

  export type ProblemReportOrderByWithAggregationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    problemType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    description?: SortOrder
    reportedDate?: SortOrder
    reportedBy?: SortOrder
    resolvedDate?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProblemReportCountOrderByAggregateInput
    _max?: ProblemReportMaxOrderByAggregateInput
    _min?: ProblemReportMinOrderByAggregateInput
  }

  export type ProblemReportScalarWhereWithAggregatesInput = {
    AND?: ProblemReportScalarWhereWithAggregatesInput | ProblemReportScalarWhereWithAggregatesInput[]
    OR?: ProblemReportScalarWhereWithAggregatesInput[]
    NOT?: ProblemReportScalarWhereWithAggregatesInput | ProblemReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProblemReport"> | string
    equipmentId?: StringWithAggregatesFilter<"ProblemReport"> | string
    problemType?: StringWithAggregatesFilter<"ProblemReport"> | string
    severity?: StringWithAggregatesFilter<"ProblemReport"> | string
    status?: StringWithAggregatesFilter<"ProblemReport"> | string
    description?: StringWithAggregatesFilter<"ProblemReport"> | string
    reportedDate?: DateTimeWithAggregatesFilter<"ProblemReport"> | Date | string
    reportedBy?: StringWithAggregatesFilter<"ProblemReport"> | string
    resolvedDate?: DateTimeNullableWithAggregatesFilter<"ProblemReport"> | Date | string | null
    resolvedBy?: StringNullableWithAggregatesFilter<"ProblemReport"> | string | null
    resolution?: StringNullableWithAggregatesFilter<"ProblemReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProblemReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProblemReport"> | Date | string
  }

  export type TankAssignmentWhereInput = {
    AND?: TankAssignmentWhereInput | TankAssignmentWhereInput[]
    OR?: TankAssignmentWhereInput[]
    NOT?: TankAssignmentWhereInput | TankAssignmentWhereInput[]
    id?: StringFilter<"TankAssignment"> | string
    tenantId?: StringFilter<"TankAssignment"> | string
    tankId?: StringFilter<"TankAssignment"> | string
    lotId?: StringFilter<"TankAssignment"> | string
    phase?: EnumLotPhaseFilter<"TankAssignment"> | $Enums.LotPhase
    plannedStart?: DateTimeNullableFilter<"TankAssignment"> | Date | string | null
    plannedEnd?: DateTimeNullableFilter<"TankAssignment"> | Date | string | null
    actualStart?: DateTimeNullableFilter<"TankAssignment"> | Date | string | null
    actualEnd?: DateTimeNullableFilter<"TankAssignment"> | Date | string | null
    status?: EnumAssignmentStatusFilter<"TankAssignment"> | $Enums.AssignmentStatus
    plannedVolume?: DecimalNullableFilter<"TankAssignment"> | Decimal | DecimalJsLike | number | string | null
    actualVolume?: DecimalNullableFilter<"TankAssignment"> | Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: BoolFilter<"TankAssignment"> | boolean
    isSplitSource?: BoolFilter<"TankAssignment"> | boolean
    createdBy?: StringNullableFilter<"TankAssignment"> | string | null
    createdAt?: DateTimeFilter<"TankAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"TankAssignment"> | Date | string
    startTime?: DateTimeNullableFilter<"TankAssignment"> | Date | string | null
    endTime?: DateTimeNullableFilter<"TankAssignment"> | Date | string | null
    notes?: StringNullableFilter<"TankAssignment"> | string | null
    Lot?: XOR<LotRelationFilter, LotWhereInput>
    Tank?: XOR<TankRelationFilter, TankWhereInput>
  }

  export type TankAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tankId?: SortOrder
    lotId?: SortOrder
    phase?: SortOrder
    plannedStart?: SortOrderInput | SortOrder
    plannedEnd?: SortOrderInput | SortOrder
    actualStart?: SortOrderInput | SortOrder
    actualEnd?: SortOrderInput | SortOrder
    status?: SortOrder
    plannedVolume?: SortOrderInput | SortOrder
    actualVolume?: SortOrderInput | SortOrder
    isBlendTarget?: SortOrder
    isSplitSource?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    Lot?: LotOrderByWithRelationInput
    Tank?: TankOrderByWithRelationInput
  }

  export type TankAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TankAssignmentWhereInput | TankAssignmentWhereInput[]
    OR?: TankAssignmentWhereInput[]
    NOT?: TankAssignmentWhereInput | TankAssignmentWhereInput[]
    tenantId?: StringFilter<"TankAssignment"> | string
    tankId?: StringFilter<"TankAssignment"> | string
    lotId?: StringFilter<"TankAssignment"> | string
    phase?: EnumLotPhaseFilter<"TankAssignment"> | $Enums.LotPhase
    plannedStart?: DateTimeNullableFilter<"TankAssignment"> | Date | string | null
    plannedEnd?: DateTimeNullableFilter<"TankAssignment"> | Date | string | null
    actualStart?: DateTimeNullableFilter<"TankAssignment"> | Date | string | null
    actualEnd?: DateTimeNullableFilter<"TankAssignment"> | Date | string | null
    status?: EnumAssignmentStatusFilter<"TankAssignment"> | $Enums.AssignmentStatus
    plannedVolume?: DecimalNullableFilter<"TankAssignment"> | Decimal | DecimalJsLike | number | string | null
    actualVolume?: DecimalNullableFilter<"TankAssignment"> | Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: BoolFilter<"TankAssignment"> | boolean
    isSplitSource?: BoolFilter<"TankAssignment"> | boolean
    createdBy?: StringNullableFilter<"TankAssignment"> | string | null
    createdAt?: DateTimeFilter<"TankAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"TankAssignment"> | Date | string
    startTime?: DateTimeNullableFilter<"TankAssignment"> | Date | string | null
    endTime?: DateTimeNullableFilter<"TankAssignment"> | Date | string | null
    notes?: StringNullableFilter<"TankAssignment"> | string | null
    Lot?: XOR<LotRelationFilter, LotWhereInput>
    Tank?: XOR<TankRelationFilter, TankWhereInput>
  }, "id">

  export type TankAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tankId?: SortOrder
    lotId?: SortOrder
    phase?: SortOrder
    plannedStart?: SortOrderInput | SortOrder
    plannedEnd?: SortOrderInput | SortOrder
    actualStart?: SortOrderInput | SortOrder
    actualEnd?: SortOrderInput | SortOrder
    status?: SortOrder
    plannedVolume?: SortOrderInput | SortOrder
    actualVolume?: SortOrderInput | SortOrder
    isBlendTarget?: SortOrder
    isSplitSource?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: TankAssignmentCountOrderByAggregateInput
    _avg?: TankAssignmentAvgOrderByAggregateInput
    _max?: TankAssignmentMaxOrderByAggregateInput
    _min?: TankAssignmentMinOrderByAggregateInput
    _sum?: TankAssignmentSumOrderByAggregateInput
  }

  export type TankAssignmentScalarWhereWithAggregatesInput = {
    AND?: TankAssignmentScalarWhereWithAggregatesInput | TankAssignmentScalarWhereWithAggregatesInput[]
    OR?: TankAssignmentScalarWhereWithAggregatesInput[]
    NOT?: TankAssignmentScalarWhereWithAggregatesInput | TankAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TankAssignment"> | string
    tenantId?: StringWithAggregatesFilter<"TankAssignment"> | string
    tankId?: StringWithAggregatesFilter<"TankAssignment"> | string
    lotId?: StringWithAggregatesFilter<"TankAssignment"> | string
    phase?: EnumLotPhaseWithAggregatesFilter<"TankAssignment"> | $Enums.LotPhase
    plannedStart?: DateTimeNullableWithAggregatesFilter<"TankAssignment"> | Date | string | null
    plannedEnd?: DateTimeNullableWithAggregatesFilter<"TankAssignment"> | Date | string | null
    actualStart?: DateTimeNullableWithAggregatesFilter<"TankAssignment"> | Date | string | null
    actualEnd?: DateTimeNullableWithAggregatesFilter<"TankAssignment"> | Date | string | null
    status?: EnumAssignmentStatusWithAggregatesFilter<"TankAssignment"> | $Enums.AssignmentStatus
    plannedVolume?: DecimalNullableWithAggregatesFilter<"TankAssignment"> | Decimal | DecimalJsLike | number | string | null
    actualVolume?: DecimalNullableWithAggregatesFilter<"TankAssignment"> | Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: BoolWithAggregatesFilter<"TankAssignment"> | boolean
    isSplitSource?: BoolWithAggregatesFilter<"TankAssignment"> | boolean
    createdBy?: StringNullableWithAggregatesFilter<"TankAssignment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TankAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TankAssignment"> | Date | string
    startTime?: DateTimeNullableWithAggregatesFilter<"TankAssignment"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"TankAssignment"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"TankAssignment"> | string | null
  }

  export type TransferWhereInput = {
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    id?: StringFilter<"Transfer"> | string
    tenantId?: StringFilter<"Transfer"> | string
    transferCode?: StringFilter<"Transfer"> | string
    sourceLotId?: StringNullableFilter<"Transfer"> | string | null
    sourceTankId?: StringFilter<"Transfer"> | string
    destLotId?: StringNullableFilter<"Transfer"> | string | null
    destTankId?: StringFilter<"Transfer"> | string
    transferType?: EnumTransferTypeFilter<"Transfer"> | $Enums.TransferType
    volume?: DecimalFilter<"Transfer"> | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeFilter<"Transfer"> | Date | string
    executedAt?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    status?: EnumTransferStatusFilter<"Transfer"> | $Enums.TransferStatus
    measuredLoss?: DecimalNullableFilter<"Transfer"> | Decimal | DecimalJsLike | number | string | null
    lossReason?: StringNullableFilter<"Transfer"> | string | null
    performedBy?: StringNullableFilter<"Transfer"> | string | null
    notes?: StringNullableFilter<"Transfer"> | string | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
    Lot_Transfer_destLotIdToLot?: XOR<LotNullableRelationFilter, LotWhereInput> | null
    Tank_Transfer_destTankIdToTank?: XOR<TankRelationFilter, TankWhereInput>
    Lot_Transfer_sourceLotIdToLot?: XOR<LotNullableRelationFilter, LotWhereInput> | null
    Tank_Transfer_sourceTankIdToTank?: XOR<TankRelationFilter, TankWhereInput>
  }

  export type TransferOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    transferCode?: SortOrder
    sourceLotId?: SortOrderInput | SortOrder
    sourceTankId?: SortOrder
    destLotId?: SortOrderInput | SortOrder
    destTankId?: SortOrder
    transferType?: SortOrder
    volume?: SortOrder
    plannedAt?: SortOrder
    executedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    measuredLoss?: SortOrderInput | SortOrder
    lossReason?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Lot_Transfer_destLotIdToLot?: LotOrderByWithRelationInput
    Tank_Transfer_destTankIdToTank?: TankOrderByWithRelationInput
    Lot_Transfer_sourceLotIdToLot?: LotOrderByWithRelationInput
    Tank_Transfer_sourceTankIdToTank?: TankOrderByWithRelationInput
  }

  export type TransferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_transferCode?: TransferTenantIdTransferCodeCompoundUniqueInput
    AND?: TransferWhereInput | TransferWhereInput[]
    OR?: TransferWhereInput[]
    NOT?: TransferWhereInput | TransferWhereInput[]
    tenantId?: StringFilter<"Transfer"> | string
    transferCode?: StringFilter<"Transfer"> | string
    sourceLotId?: StringNullableFilter<"Transfer"> | string | null
    sourceTankId?: StringFilter<"Transfer"> | string
    destLotId?: StringNullableFilter<"Transfer"> | string | null
    destTankId?: StringFilter<"Transfer"> | string
    transferType?: EnumTransferTypeFilter<"Transfer"> | $Enums.TransferType
    volume?: DecimalFilter<"Transfer"> | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeFilter<"Transfer"> | Date | string
    executedAt?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    status?: EnumTransferStatusFilter<"Transfer"> | $Enums.TransferStatus
    measuredLoss?: DecimalNullableFilter<"Transfer"> | Decimal | DecimalJsLike | number | string | null
    lossReason?: StringNullableFilter<"Transfer"> | string | null
    performedBy?: StringNullableFilter<"Transfer"> | string | null
    notes?: StringNullableFilter<"Transfer"> | string | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
    Lot_Transfer_destLotIdToLot?: XOR<LotNullableRelationFilter, LotWhereInput> | null
    Tank_Transfer_destTankIdToTank?: XOR<TankRelationFilter, TankWhereInput>
    Lot_Transfer_sourceLotIdToLot?: XOR<LotNullableRelationFilter, LotWhereInput> | null
    Tank_Transfer_sourceTankIdToTank?: XOR<TankRelationFilter, TankWhereInput>
  }, "id" | "tenantId_transferCode">

  export type TransferOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    transferCode?: SortOrder
    sourceLotId?: SortOrderInput | SortOrder
    sourceTankId?: SortOrder
    destLotId?: SortOrderInput | SortOrder
    destTankId?: SortOrder
    transferType?: SortOrder
    volume?: SortOrder
    plannedAt?: SortOrder
    executedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    measuredLoss?: SortOrderInput | SortOrder
    lossReason?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransferCountOrderByAggregateInput
    _avg?: TransferAvgOrderByAggregateInput
    _max?: TransferMaxOrderByAggregateInput
    _min?: TransferMinOrderByAggregateInput
    _sum?: TransferSumOrderByAggregateInput
  }

  export type TransferScalarWhereWithAggregatesInput = {
    AND?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    OR?: TransferScalarWhereWithAggregatesInput[]
    NOT?: TransferScalarWhereWithAggregatesInput | TransferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transfer"> | string
    tenantId?: StringWithAggregatesFilter<"Transfer"> | string
    transferCode?: StringWithAggregatesFilter<"Transfer"> | string
    sourceLotId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    sourceTankId?: StringWithAggregatesFilter<"Transfer"> | string
    destLotId?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    destTankId?: StringWithAggregatesFilter<"Transfer"> | string
    transferType?: EnumTransferTypeWithAggregatesFilter<"Transfer"> | $Enums.TransferType
    volume?: DecimalWithAggregatesFilter<"Transfer"> | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
    executedAt?: DateTimeNullableWithAggregatesFilter<"Transfer"> | Date | string | null
    status?: EnumTransferStatusWithAggregatesFilter<"Transfer"> | $Enums.TransferStatus
    measuredLoss?: DecimalNullableWithAggregatesFilter<"Transfer"> | Decimal | DecimalJsLike | number | string | null
    lossReason?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    performedBy?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Transfer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transfer"> | Date | string
  }

  export type KegWhereInput = {
    AND?: KegWhereInput | KegWhereInput[]
    OR?: KegWhereInput[]
    NOT?: KegWhereInput | KegWhereInput[]
    id?: StringFilter<"Keg"> | string
    tenantId?: StringFilter<"Keg"> | string
    kegNumber?: StringFilter<"Keg"> | string
    size?: IntFilter<"Keg"> | number
    status?: EnumKegStatusFilter<"Keg"> | $Enums.KegStatus
    condition?: EnumKegConditionFilter<"Keg"> | $Enums.KegCondition
    batchId?: StringNullableFilter<"Keg"> | string | null
    filledAt?: DateTimeNullableFilter<"Keg"> | Date | string | null
    productName?: StringNullableFilter<"Keg"> | string | null
    lotNumber?: StringNullableFilter<"Keg"> | string | null
    customerId?: StringNullableFilter<"Keg"> | string | null
    orderId?: StringNullableFilter<"Keg"> | string | null
    sentAt?: DateTimeNullableFilter<"Keg"> | Date | string | null
    returnedAt?: DateTimeNullableFilter<"Keg"> | Date | string | null
    deposit?: DecimalFilter<"Keg"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Keg"> | string | null
    createdAt?: DateTimeFilter<"Keg"> | Date | string
    updatedAt?: DateTimeFilter<"Keg"> | Date | string
    Batch?: XOR<BatchNullableRelationFilter, BatchWhereInput> | null
    Customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    Tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    movements?: KegMovementListRelationFilter
  }

  export type KegOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kegNumber?: SortOrder
    size?: SortOrder
    status?: SortOrder
    condition?: SortOrder
    batchId?: SortOrderInput | SortOrder
    filledAt?: SortOrderInput | SortOrder
    productName?: SortOrderInput | SortOrder
    lotNumber?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    returnedAt?: SortOrderInput | SortOrder
    deposit?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Batch?: BatchOrderByWithRelationInput
    Customer?: CustomerOrderByWithRelationInput
    Tenant?: TenantOrderByWithRelationInput
    movements?: KegMovementOrderByRelationAggregateInput
  }

  export type KegWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_kegNumber?: KegTenantIdKegNumberCompoundUniqueInput
    AND?: KegWhereInput | KegWhereInput[]
    OR?: KegWhereInput[]
    NOT?: KegWhereInput | KegWhereInput[]
    tenantId?: StringFilter<"Keg"> | string
    kegNumber?: StringFilter<"Keg"> | string
    size?: IntFilter<"Keg"> | number
    status?: EnumKegStatusFilter<"Keg"> | $Enums.KegStatus
    condition?: EnumKegConditionFilter<"Keg"> | $Enums.KegCondition
    batchId?: StringNullableFilter<"Keg"> | string | null
    filledAt?: DateTimeNullableFilter<"Keg"> | Date | string | null
    productName?: StringNullableFilter<"Keg"> | string | null
    lotNumber?: StringNullableFilter<"Keg"> | string | null
    customerId?: StringNullableFilter<"Keg"> | string | null
    orderId?: StringNullableFilter<"Keg"> | string | null
    sentAt?: DateTimeNullableFilter<"Keg"> | Date | string | null
    returnedAt?: DateTimeNullableFilter<"Keg"> | Date | string | null
    deposit?: DecimalFilter<"Keg"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Keg"> | string | null
    createdAt?: DateTimeFilter<"Keg"> | Date | string
    updatedAt?: DateTimeFilter<"Keg"> | Date | string
    Batch?: XOR<BatchNullableRelationFilter, BatchWhereInput> | null
    Customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    Tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    movements?: KegMovementListRelationFilter
  }, "id" | "tenantId_kegNumber">

  export type KegOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kegNumber?: SortOrder
    size?: SortOrder
    status?: SortOrder
    condition?: SortOrder
    batchId?: SortOrderInput | SortOrder
    filledAt?: SortOrderInput | SortOrder
    productName?: SortOrderInput | SortOrder
    lotNumber?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    returnedAt?: SortOrderInput | SortOrder
    deposit?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KegCountOrderByAggregateInput
    _avg?: KegAvgOrderByAggregateInput
    _max?: KegMaxOrderByAggregateInput
    _min?: KegMinOrderByAggregateInput
    _sum?: KegSumOrderByAggregateInput
  }

  export type KegScalarWhereWithAggregatesInput = {
    AND?: KegScalarWhereWithAggregatesInput | KegScalarWhereWithAggregatesInput[]
    OR?: KegScalarWhereWithAggregatesInput[]
    NOT?: KegScalarWhereWithAggregatesInput | KegScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Keg"> | string
    tenantId?: StringWithAggregatesFilter<"Keg"> | string
    kegNumber?: StringWithAggregatesFilter<"Keg"> | string
    size?: IntWithAggregatesFilter<"Keg"> | number
    status?: EnumKegStatusWithAggregatesFilter<"Keg"> | $Enums.KegStatus
    condition?: EnumKegConditionWithAggregatesFilter<"Keg"> | $Enums.KegCondition
    batchId?: StringNullableWithAggregatesFilter<"Keg"> | string | null
    filledAt?: DateTimeNullableWithAggregatesFilter<"Keg"> | Date | string | null
    productName?: StringNullableWithAggregatesFilter<"Keg"> | string | null
    lotNumber?: StringNullableWithAggregatesFilter<"Keg"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"Keg"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"Keg"> | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"Keg"> | Date | string | null
    returnedAt?: DateTimeNullableWithAggregatesFilter<"Keg"> | Date | string | null
    deposit?: DecimalWithAggregatesFilter<"Keg"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"Keg"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Keg"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Keg"> | Date | string
  }

  export type KegMovementWhereInput = {
    AND?: KegMovementWhereInput | KegMovementWhereInput[]
    OR?: KegMovementWhereInput[]
    NOT?: KegMovementWhereInput | KegMovementWhereInput[]
    id?: StringFilter<"KegMovement"> | string
    tenantId?: StringFilter<"KegMovement"> | string
    kegId?: StringFilter<"KegMovement"> | string
    action?: EnumKegActionFilter<"KegMovement"> | $Enums.KegAction
    fromStatus?: EnumKegStatusFilter<"KegMovement"> | $Enums.KegStatus
    toStatus?: EnumKegStatusFilter<"KegMovement"> | $Enums.KegStatus
    productId?: StringNullableFilter<"KegMovement"> | string | null
    productName?: StringNullableFilter<"KegMovement"> | string | null
    customerId?: StringNullableFilter<"KegMovement"> | string | null
    customerName?: StringNullableFilter<"KegMovement"> | string | null
    orderId?: StringNullableFilter<"KegMovement"> | string | null
    batchId?: StringNullableFilter<"KegMovement"> | string | null
    notes?: StringNullableFilter<"KegMovement"> | string | null
    createdAt?: DateTimeFilter<"KegMovement"> | Date | string
    createdBy?: StringNullableFilter<"KegMovement"> | string | null
    keg?: XOR<KegRelationFilter, KegWhereInput>
  }

  export type KegMovementOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kegId?: SortOrder
    action?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    productId?: SortOrderInput | SortOrder
    productName?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    batchId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    keg?: KegOrderByWithRelationInput
  }

  export type KegMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KegMovementWhereInput | KegMovementWhereInput[]
    OR?: KegMovementWhereInput[]
    NOT?: KegMovementWhereInput | KegMovementWhereInput[]
    tenantId?: StringFilter<"KegMovement"> | string
    kegId?: StringFilter<"KegMovement"> | string
    action?: EnumKegActionFilter<"KegMovement"> | $Enums.KegAction
    fromStatus?: EnumKegStatusFilter<"KegMovement"> | $Enums.KegStatus
    toStatus?: EnumKegStatusFilter<"KegMovement"> | $Enums.KegStatus
    productId?: StringNullableFilter<"KegMovement"> | string | null
    productName?: StringNullableFilter<"KegMovement"> | string | null
    customerId?: StringNullableFilter<"KegMovement"> | string | null
    customerName?: StringNullableFilter<"KegMovement"> | string | null
    orderId?: StringNullableFilter<"KegMovement"> | string | null
    batchId?: StringNullableFilter<"KegMovement"> | string | null
    notes?: StringNullableFilter<"KegMovement"> | string | null
    createdAt?: DateTimeFilter<"KegMovement"> | Date | string
    createdBy?: StringNullableFilter<"KegMovement"> | string | null
    keg?: XOR<KegRelationFilter, KegWhereInput>
  }, "id">

  export type KegMovementOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kegId?: SortOrder
    action?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    productId?: SortOrderInput | SortOrder
    productName?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    batchId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: KegMovementCountOrderByAggregateInput
    _max?: KegMovementMaxOrderByAggregateInput
    _min?: KegMovementMinOrderByAggregateInput
  }

  export type KegMovementScalarWhereWithAggregatesInput = {
    AND?: KegMovementScalarWhereWithAggregatesInput | KegMovementScalarWhereWithAggregatesInput[]
    OR?: KegMovementScalarWhereWithAggregatesInput[]
    NOT?: KegMovementScalarWhereWithAggregatesInput | KegMovementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KegMovement"> | string
    tenantId?: StringWithAggregatesFilter<"KegMovement"> | string
    kegId?: StringWithAggregatesFilter<"KegMovement"> | string
    action?: EnumKegActionWithAggregatesFilter<"KegMovement"> | $Enums.KegAction
    fromStatus?: EnumKegStatusWithAggregatesFilter<"KegMovement"> | $Enums.KegStatus
    toStatus?: EnumKegStatusWithAggregatesFilter<"KegMovement"> | $Enums.KegStatus
    productId?: StringNullableWithAggregatesFilter<"KegMovement"> | string | null
    productName?: StringNullableWithAggregatesFilter<"KegMovement"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"KegMovement"> | string | null
    customerName?: StringNullableWithAggregatesFilter<"KegMovement"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"KegMovement"> | string | null
    batchId?: StringNullableWithAggregatesFilter<"KegMovement"> | string | null
    notes?: StringNullableWithAggregatesFilter<"KegMovement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"KegMovement"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"KegMovement"> | string | null
  }

  export type QCTestWhereInput = {
    AND?: QCTestWhereInput | QCTestWhereInput[]
    OR?: QCTestWhereInput[]
    NOT?: QCTestWhereInput | QCTestWhereInput[]
    id?: StringFilter<"QCTest"> | string
    tenantId?: StringFilter<"QCTest"> | string
    batchId?: StringFilter<"QCTest"> | string
    lotId?: StringNullableFilter<"QCTest"> | string | null
    testType?: EnumQCTestTypeFilter<"QCTest"> | $Enums.QCTestType
    status?: EnumQCTestStatusFilter<"QCTest"> | $Enums.QCTestStatus
    priority?: EnumQCTestPriorityFilter<"QCTest"> | $Enums.QCTestPriority
    scheduledDate?: DateTimeFilter<"QCTest"> | Date | string
    completedDate?: DateTimeNullableFilter<"QCTest"> | Date | string | null
    minValue?: DecimalNullableFilter<"QCTest"> | Decimal | DecimalJsLike | number | string | null
    maxValue?: DecimalNullableFilter<"QCTest"> | Decimal | DecimalJsLike | number | string | null
    targetValue?: DecimalNullableFilter<"QCTest"> | Decimal | DecimalJsLike | number | string | null
    result?: DecimalNullableFilter<"QCTest"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"QCTest"> | string | null
    notes?: StringNullableFilter<"QCTest"> | string | null
    performedBy?: StringNullableFilter<"QCTest"> | string | null
    createdBy?: StringFilter<"QCTest"> | string
    createdAt?: DateTimeFilter<"QCTest"> | Date | string
    updatedAt?: DateTimeFilter<"QCTest"> | Date | string
    Batch?: XOR<BatchRelationFilter, BatchWhereInput>
    Lot?: XOR<LotNullableRelationFilter, LotWhereInput> | null
  }

  export type QCTestOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    batchId?: SortOrder
    lotId?: SortOrderInput | SortOrder
    testType?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrderInput | SortOrder
    minValue?: SortOrderInput | SortOrder
    maxValue?: SortOrderInput | SortOrder
    targetValue?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Batch?: BatchOrderByWithRelationInput
    Lot?: LotOrderByWithRelationInput
  }

  export type QCTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QCTestWhereInput | QCTestWhereInput[]
    OR?: QCTestWhereInput[]
    NOT?: QCTestWhereInput | QCTestWhereInput[]
    tenantId?: StringFilter<"QCTest"> | string
    batchId?: StringFilter<"QCTest"> | string
    lotId?: StringNullableFilter<"QCTest"> | string | null
    testType?: EnumQCTestTypeFilter<"QCTest"> | $Enums.QCTestType
    status?: EnumQCTestStatusFilter<"QCTest"> | $Enums.QCTestStatus
    priority?: EnumQCTestPriorityFilter<"QCTest"> | $Enums.QCTestPriority
    scheduledDate?: DateTimeFilter<"QCTest"> | Date | string
    completedDate?: DateTimeNullableFilter<"QCTest"> | Date | string | null
    minValue?: DecimalNullableFilter<"QCTest"> | Decimal | DecimalJsLike | number | string | null
    maxValue?: DecimalNullableFilter<"QCTest"> | Decimal | DecimalJsLike | number | string | null
    targetValue?: DecimalNullableFilter<"QCTest"> | Decimal | DecimalJsLike | number | string | null
    result?: DecimalNullableFilter<"QCTest"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"QCTest"> | string | null
    notes?: StringNullableFilter<"QCTest"> | string | null
    performedBy?: StringNullableFilter<"QCTest"> | string | null
    createdBy?: StringFilter<"QCTest"> | string
    createdAt?: DateTimeFilter<"QCTest"> | Date | string
    updatedAt?: DateTimeFilter<"QCTest"> | Date | string
    Batch?: XOR<BatchRelationFilter, BatchWhereInput>
    Lot?: XOR<LotNullableRelationFilter, LotWhereInput> | null
  }, "id">

  export type QCTestOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    batchId?: SortOrder
    lotId?: SortOrderInput | SortOrder
    testType?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrderInput | SortOrder
    minValue?: SortOrderInput | SortOrder
    maxValue?: SortOrderInput | SortOrder
    targetValue?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    performedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QCTestCountOrderByAggregateInput
    _avg?: QCTestAvgOrderByAggregateInput
    _max?: QCTestMaxOrderByAggregateInput
    _min?: QCTestMinOrderByAggregateInput
    _sum?: QCTestSumOrderByAggregateInput
  }

  export type QCTestScalarWhereWithAggregatesInput = {
    AND?: QCTestScalarWhereWithAggregatesInput | QCTestScalarWhereWithAggregatesInput[]
    OR?: QCTestScalarWhereWithAggregatesInput[]
    NOT?: QCTestScalarWhereWithAggregatesInput | QCTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QCTest"> | string
    tenantId?: StringWithAggregatesFilter<"QCTest"> | string
    batchId?: StringWithAggregatesFilter<"QCTest"> | string
    lotId?: StringNullableWithAggregatesFilter<"QCTest"> | string | null
    testType?: EnumQCTestTypeWithAggregatesFilter<"QCTest"> | $Enums.QCTestType
    status?: EnumQCTestStatusWithAggregatesFilter<"QCTest"> | $Enums.QCTestStatus
    priority?: EnumQCTestPriorityWithAggregatesFilter<"QCTest"> | $Enums.QCTestPriority
    scheduledDate?: DateTimeWithAggregatesFilter<"QCTest"> | Date | string
    completedDate?: DateTimeNullableWithAggregatesFilter<"QCTest"> | Date | string | null
    minValue?: DecimalNullableWithAggregatesFilter<"QCTest"> | Decimal | DecimalJsLike | number | string | null
    maxValue?: DecimalNullableWithAggregatesFilter<"QCTest"> | Decimal | DecimalJsLike | number | string | null
    targetValue?: DecimalNullableWithAggregatesFilter<"QCTest"> | Decimal | DecimalJsLike | number | string | null
    result?: DecimalNullableWithAggregatesFilter<"QCTest"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableWithAggregatesFilter<"QCTest"> | string | null
    notes?: StringNullableWithAggregatesFilter<"QCTest"> | string | null
    performedBy?: StringNullableWithAggregatesFilter<"QCTest"> | string | null
    createdBy?: StringWithAggregatesFilter<"QCTest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"QCTest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QCTest"> | Date | string
  }

  export type ConfigurationWhereInput = {
    AND?: ConfigurationWhereInput | ConfigurationWhereInput[]
    OR?: ConfigurationWhereInput[]
    NOT?: ConfigurationWhereInput | ConfigurationWhereInput[]
    id?: StringFilter<"Configuration"> | string
    key?: StringFilter<"Configuration"> | string
    value?: JsonFilter<"Configuration">
    updatedAt?: DateTimeFilter<"Configuration"> | Date | string
    createdAt?: DateTimeFilter<"Configuration"> | Date | string
  }

  export type ConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: ConfigurationWhereInput | ConfigurationWhereInput[]
    OR?: ConfigurationWhereInput[]
    NOT?: ConfigurationWhereInput | ConfigurationWhereInput[]
    value?: JsonFilter<"Configuration">
    updatedAt?: DateTimeFilter<"Configuration"> | Date | string
    createdAt?: DateTimeFilter<"Configuration"> | Date | string
  }, "id" | "key">

  export type ConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: ConfigurationCountOrderByAggregateInput
    _max?: ConfigurationMaxOrderByAggregateInput
    _min?: ConfigurationMinOrderByAggregateInput
  }

  export type ConfigurationScalarWhereWithAggregatesInput = {
    AND?: ConfigurationScalarWhereWithAggregatesInput | ConfigurationScalarWhereWithAggregatesInput[]
    OR?: ConfigurationScalarWhereWithAggregatesInput[]
    NOT?: ConfigurationScalarWhereWithAggregatesInput | ConfigurationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Configuration"> | string
    key?: StringWithAggregatesFilter<"Configuration"> | string
    value?: JsonWithAggregatesFilter<"Configuration">
    updatedAt?: DateTimeWithAggregatesFilter<"Configuration"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Configuration"> | Date | string
  }

  export type MuseumWhereInput = {
    AND?: MuseumWhereInput | MuseumWhereInput[]
    OR?: MuseumWhereInput[]
    NOT?: MuseumWhereInput | MuseumWhereInput[]
    id?: StringFilter<"Museum"> | string
    name?: StringFilter<"Museum"> | string
    description?: StringNullableFilter<"Museum"> | string | null
    city?: StringNullableFilter<"Museum"> | string | null
    address?: StringNullableFilter<"Museum"> | string | null
    nameEn?: StringNullableFilter<"Museum"> | string | null
    descriptionEn?: StringNullableFilter<"Museum"> | string | null
    cityEn?: StringNullableFilter<"Museum"> | string | null
    addressEn?: StringNullableFilter<"Museum"> | string | null
    nameRu?: StringNullableFilter<"Museum"> | string | null
    descriptionRu?: StringNullableFilter<"Museum"> | string | null
    cityRu?: StringNullableFilter<"Museum"> | string | null
    addressRu?: StringNullableFilter<"Museum"> | string | null
    nameDe?: StringNullableFilter<"Museum"> | string | null
    descriptionDe?: StringNullableFilter<"Museum"> | string | null
    cityDe?: StringNullableFilter<"Museum"> | string | null
    addressDe?: StringNullableFilter<"Museum"> | string | null
    nameFr?: StringNullableFilter<"Museum"> | string | null
    descriptionFr?: StringNullableFilter<"Museum"> | string | null
    cityFr?: StringNullableFilter<"Museum"> | string | null
    addressFr?: StringNullableFilter<"Museum"> | string | null
    slug?: StringFilter<"Museum"> | string
    coverImage?: StringNullableFilter<"Museum"> | string | null
    latitude?: FloatNullableFilter<"Museum"> | number | null
    longitude?: FloatNullableFilter<"Museum"> | number | null
    contactEmail?: StringNullableFilter<"Museum"> | string | null
    contactPhone?: StringNullableFilter<"Museum"> | string | null
    website?: StringNullableFilter<"Museum"> | string | null
    showMap?: BoolFilter<"Museum"> | boolean
    showQrScanner?: BoolFilter<"Museum"> | boolean
    isPublished?: BoolFilter<"Museum"> | boolean
    createdAt?: DateTimeFilter<"Museum"> | Date | string
    updatedAt?: DateTimeFilter<"Museum"> | Date | string
    tours?: TourListRelationFilter
  }

  export type MuseumOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    nameEn?: SortOrderInput | SortOrder
    descriptionEn?: SortOrderInput | SortOrder
    cityEn?: SortOrderInput | SortOrder
    addressEn?: SortOrderInput | SortOrder
    nameRu?: SortOrderInput | SortOrder
    descriptionRu?: SortOrderInput | SortOrder
    cityRu?: SortOrderInput | SortOrder
    addressRu?: SortOrderInput | SortOrder
    nameDe?: SortOrderInput | SortOrder
    descriptionDe?: SortOrderInput | SortOrder
    cityDe?: SortOrderInput | SortOrder
    addressDe?: SortOrderInput | SortOrder
    nameFr?: SortOrderInput | SortOrder
    descriptionFr?: SortOrderInput | SortOrder
    cityFr?: SortOrderInput | SortOrder
    addressFr?: SortOrderInput | SortOrder
    slug?: SortOrder
    coverImage?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    showMap?: SortOrder
    showQrScanner?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tours?: TourOrderByRelationAggregateInput
  }

  export type MuseumWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: MuseumWhereInput | MuseumWhereInput[]
    OR?: MuseumWhereInput[]
    NOT?: MuseumWhereInput | MuseumWhereInput[]
    name?: StringFilter<"Museum"> | string
    description?: StringNullableFilter<"Museum"> | string | null
    city?: StringNullableFilter<"Museum"> | string | null
    address?: StringNullableFilter<"Museum"> | string | null
    nameEn?: StringNullableFilter<"Museum"> | string | null
    descriptionEn?: StringNullableFilter<"Museum"> | string | null
    cityEn?: StringNullableFilter<"Museum"> | string | null
    addressEn?: StringNullableFilter<"Museum"> | string | null
    nameRu?: StringNullableFilter<"Museum"> | string | null
    descriptionRu?: StringNullableFilter<"Museum"> | string | null
    cityRu?: StringNullableFilter<"Museum"> | string | null
    addressRu?: StringNullableFilter<"Museum"> | string | null
    nameDe?: StringNullableFilter<"Museum"> | string | null
    descriptionDe?: StringNullableFilter<"Museum"> | string | null
    cityDe?: StringNullableFilter<"Museum"> | string | null
    addressDe?: StringNullableFilter<"Museum"> | string | null
    nameFr?: StringNullableFilter<"Museum"> | string | null
    descriptionFr?: StringNullableFilter<"Museum"> | string | null
    cityFr?: StringNullableFilter<"Museum"> | string | null
    addressFr?: StringNullableFilter<"Museum"> | string | null
    coverImage?: StringNullableFilter<"Museum"> | string | null
    latitude?: FloatNullableFilter<"Museum"> | number | null
    longitude?: FloatNullableFilter<"Museum"> | number | null
    contactEmail?: StringNullableFilter<"Museum"> | string | null
    contactPhone?: StringNullableFilter<"Museum"> | string | null
    website?: StringNullableFilter<"Museum"> | string | null
    showMap?: BoolFilter<"Museum"> | boolean
    showQrScanner?: BoolFilter<"Museum"> | boolean
    isPublished?: BoolFilter<"Museum"> | boolean
    createdAt?: DateTimeFilter<"Museum"> | Date | string
    updatedAt?: DateTimeFilter<"Museum"> | Date | string
    tours?: TourListRelationFilter
  }, "id" | "slug">

  export type MuseumOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    nameEn?: SortOrderInput | SortOrder
    descriptionEn?: SortOrderInput | SortOrder
    cityEn?: SortOrderInput | SortOrder
    addressEn?: SortOrderInput | SortOrder
    nameRu?: SortOrderInput | SortOrder
    descriptionRu?: SortOrderInput | SortOrder
    cityRu?: SortOrderInput | SortOrder
    addressRu?: SortOrderInput | SortOrder
    nameDe?: SortOrderInput | SortOrder
    descriptionDe?: SortOrderInput | SortOrder
    cityDe?: SortOrderInput | SortOrder
    addressDe?: SortOrderInput | SortOrder
    nameFr?: SortOrderInput | SortOrder
    descriptionFr?: SortOrderInput | SortOrder
    cityFr?: SortOrderInput | SortOrder
    addressFr?: SortOrderInput | SortOrder
    slug?: SortOrder
    coverImage?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    showMap?: SortOrder
    showQrScanner?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MuseumCountOrderByAggregateInput
    _avg?: MuseumAvgOrderByAggregateInput
    _max?: MuseumMaxOrderByAggregateInput
    _min?: MuseumMinOrderByAggregateInput
    _sum?: MuseumSumOrderByAggregateInput
  }

  export type MuseumScalarWhereWithAggregatesInput = {
    AND?: MuseumScalarWhereWithAggregatesInput | MuseumScalarWhereWithAggregatesInput[]
    OR?: MuseumScalarWhereWithAggregatesInput[]
    NOT?: MuseumScalarWhereWithAggregatesInput | MuseumScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Museum"> | string
    name?: StringWithAggregatesFilter<"Museum"> | string
    description?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    city?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    address?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    nameEn?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    descriptionEn?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    cityEn?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    addressEn?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    nameRu?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    descriptionRu?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    cityRu?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    addressRu?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    nameDe?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    descriptionDe?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    cityDe?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    addressDe?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    nameFr?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    descriptionFr?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    cityFr?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    addressFr?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    slug?: StringWithAggregatesFilter<"Museum"> | string
    coverImage?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"Museum"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Museum"> | number | null
    contactEmail?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    website?: StringNullableWithAggregatesFilter<"Museum"> | string | null
    showMap?: BoolWithAggregatesFilter<"Museum"> | boolean
    showQrScanner?: BoolWithAggregatesFilter<"Museum"> | boolean
    isPublished?: BoolWithAggregatesFilter<"Museum"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Museum"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Museum"> | Date | string
  }

  export type TourWhereInput = {
    AND?: TourWhereInput | TourWhereInput[]
    OR?: TourWhereInput[]
    NOT?: TourWhereInput | TourWhereInput[]
    id?: StringFilter<"Tour"> | string
    museumId?: StringFilter<"Tour"> | string
    createdAt?: DateTimeFilter<"Tour"> | Date | string
    updatedAt?: DateTimeFilter<"Tour"> | Date | string
    museum?: XOR<MuseumRelationFilter, MuseumWhereInput>
  }

  export type TourOrderByWithRelationInput = {
    id?: SortOrder
    museumId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    museum?: MuseumOrderByWithRelationInput
  }

  export type TourWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TourWhereInput | TourWhereInput[]
    OR?: TourWhereInput[]
    NOT?: TourWhereInput | TourWhereInput[]
    museumId?: StringFilter<"Tour"> | string
    createdAt?: DateTimeFilter<"Tour"> | Date | string
    updatedAt?: DateTimeFilter<"Tour"> | Date | string
    museum?: XOR<MuseumRelationFilter, MuseumWhereInput>
  }, "id">

  export type TourOrderByWithAggregationInput = {
    id?: SortOrder
    museumId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TourCountOrderByAggregateInput
    _max?: TourMaxOrderByAggregateInput
    _min?: TourMinOrderByAggregateInput
  }

  export type TourScalarWhereWithAggregatesInput = {
    AND?: TourScalarWhereWithAggregatesInput | TourScalarWhereWithAggregatesInput[]
    OR?: TourScalarWhereWithAggregatesInput[]
    NOT?: TourScalarWhereWithAggregatesInput | TourScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tour"> | string
    museumId?: StringWithAggregatesFilter<"Tour"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tour"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tour"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchCreateNestedManyWithoutTenantInput
    budgets?: BudgetCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    Keg?: KegCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    recipes?: RecipeCreateNestedManyWithoutTenantInput
    orders?: SalesOrderCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    tanks?: TankCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchUncheckedCreateNestedManyWithoutTenantInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    Keg?: KegUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutTenantInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    tanks?: TankUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    Keg?: KegUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    tanks?: TankUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUncheckedUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    Keg?: KegUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    tanks?: TankUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    tenantId: string
    email: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateManyInput = {
    id?: string
    tenantId: string
    email: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecipeCreateInput = {
    id?: string
    createdBy?: string | null
    name: string
    style?: string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    ibu?: number | null
    color?: number | null
    og?: Decimal | DecimalJsLike | number | string | null
    fg?: Decimal | DecimalJsLike | number | string | null
    batchSize?: Decimal | DecimalJsLike | number | string | null
    boilTime?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    notes?: string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.RecipeStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    yeastStrain?: string | null
    batches?: BatchCreateNestedManyWithoutRecipeInput
    tenant: TenantCreateNestedOneWithoutRecipesInput
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateInput = {
    id?: string
    tenantId: string
    createdBy?: string | null
    name: string
    style?: string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    ibu?: number | null
    color?: number | null
    og?: Decimal | DecimalJsLike | number | string | null
    fg?: Decimal | DecimalJsLike | number | string | null
    batchSize?: Decimal | DecimalJsLike | number | string | null
    boilTime?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    notes?: string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.RecipeStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    yeastStrain?: string | null
    batches?: BatchUncheckedCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    style?: NullableStringFieldUpdateOperationsInput | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ibu?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableIntFieldUpdateOperationsInput | number | null
    og?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    batchSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boilTime?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumRecipeStatusFieldUpdateOperationsInput | $Enums.RecipeStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yeastStrain?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUpdateManyWithoutRecipeNestedInput
    tenant?: TenantUpdateOneRequiredWithoutRecipesNestedInput
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    style?: NullableStringFieldUpdateOperationsInput | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ibu?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableIntFieldUpdateOperationsInput | number | null
    og?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    batchSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boilTime?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumRecipeStatusFieldUpdateOperationsInput | $Enums.RecipeStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yeastStrain?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUncheckedUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateManyInput = {
    id?: string
    tenantId: string
    createdBy?: string | null
    name: string
    style?: string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    ibu?: number | null
    color?: number | null
    og?: Decimal | DecimalJsLike | number | string | null
    fg?: Decimal | DecimalJsLike | number | string | null
    batchSize?: Decimal | DecimalJsLike | number | string | null
    boilTime?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    notes?: string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.RecipeStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    yeastStrain?: string | null
  }

  export type RecipeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    style?: NullableStringFieldUpdateOperationsInput | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ibu?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableIntFieldUpdateOperationsInput | number | null
    og?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    batchSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boilTime?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumRecipeStatusFieldUpdateOperationsInput | $Enums.RecipeStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yeastStrain?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    style?: NullableStringFieldUpdateOperationsInput | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ibu?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableIntFieldUpdateOperationsInput | number | null
    og?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    batchSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boilTime?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumRecipeStatusFieldUpdateOperationsInput | $Enums.RecipeStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yeastStrain?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeIngredientCreateInput = {
    id?: string
    name: string
    category: $Enums.IngredientCategory
    amount: Decimal | DecimalJsLike | number | string
    unit: string
    additionTime?: number | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventoryItem?: InventoryItemCreateNestedOneWithoutRecipeIngredientsInput
    recipe: RecipeCreateNestedOneWithoutIngredientsInput
  }

  export type RecipeIngredientUncheckedCreateInput = {
    id?: string
    recipeId: string
    inventoryItemId?: string | null
    name: string
    category: $Enums.IngredientCategory
    amount: Decimal | DecimalJsLike | number | string
    unit: string
    additionTime?: number | null
    specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RecipeIngredientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumIngredientCategoryFieldUpdateOperationsInput | $Enums.IngredientCategory
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    additionTime?: NullableIntFieldUpdateOperationsInput | number | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventoryItem?: InventoryItemUpdateOneWithoutRecipeIngredientsNestedInput
    recipe?: RecipeUpdateOneRequiredWithoutIngredientsNestedInput
  }

  export type RecipeIngredientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumIngredientCategoryFieldUpdateOperationsInput | $Enums.IngredientCategory
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    additionTime?: NullableIntFieldUpdateOperationsInput | number | null
    specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RecipeIngredientCreateManyInput = {
    id?: string
    recipeId: string
    inventoryItemId?: string | null
    name: string
    category: $Enums.IngredientCategory
    amount: Decimal | DecimalJsLike | number | string
    unit: string
    additionTime?: number | null
    specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RecipeIngredientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumIngredientCategoryFieldUpdateOperationsInput | $Enums.IngredientCategory
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    additionTime?: NullableIntFieldUpdateOperationsInput | number | null
    specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RecipeIngredientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumIngredientCategoryFieldUpdateOperationsInput | $Enums.IngredientCategory
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    additionTime?: NullableIntFieldUpdateOperationsInput | number | null
    specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InventoryItemCreateInput = {
    id?: string
    sku: string
    name: string
    category?: $Enums.InventoryCategory
    ingredientType?: string | null
    unit?: string
    reorderPoint?: Decimal | DecimalJsLike | number | string | null
    supplier?: string | null
    location?: string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: Decimal | DecimalJsLike | number | string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInventoryInput
    ledger?: InventoryLedgerCreateNestedManyWithoutItemInput
    recipeIngredients?: RecipeIngredientCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateInput = {
    id?: string
    tenantId: string
    sku: string
    name: string
    category?: $Enums.InventoryCategory
    ingredientType?: string | null
    unit?: string
    reorderPoint?: Decimal | DecimalJsLike | number | string | null
    supplier?: string | null
    location?: string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: Decimal | DecimalJsLike | number | string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ledger?: InventoryLedgerUncheckedCreateNestedManyWithoutItemInput
    recipeIngredients?: RecipeIngredientUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    ingredientType?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderPoint?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInventoryNestedInput
    ledger?: InventoryLedgerUpdateManyWithoutItemNestedInput
    recipeIngredients?: RecipeIngredientUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    ingredientType?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderPoint?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledger?: InventoryLedgerUncheckedUpdateManyWithoutItemNestedInput
    recipeIngredients?: RecipeIngredientUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemCreateManyInput = {
    id?: string
    tenantId: string
    sku: string
    name: string
    category?: $Enums.InventoryCategory
    ingredientType?: string | null
    unit?: string
    reorderPoint?: Decimal | DecimalJsLike | number | string | null
    supplier?: string | null
    location?: string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: Decimal | DecimalJsLike | number | string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    ingredientType?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderPoint?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    ingredientType?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderPoint?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLedgerCreateInput = {
    id?: string
    tenantId: string
    quantity: Decimal | DecimalJsLike | number | string
    type: $Enums.LedgerEntryType
    orderId?: string | null
    packagingId?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    batch?: BatchCreateNestedOneWithoutLedgerEntriesInput
    item: InventoryItemCreateNestedOneWithoutLedgerInput
  }

  export type InventoryLedgerUncheckedCreateInput = {
    id?: string
    tenantId: string
    itemId: string
    quantity: Decimal | DecimalJsLike | number | string
    type: $Enums.LedgerEntryType
    batchId?: string | null
    orderId?: string | null
    packagingId?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type InventoryLedgerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    packagingId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: BatchUpdateOneWithoutLedgerEntriesNestedInput
    item?: InventoryItemUpdateOneRequiredWithoutLedgerNestedInput
  }

  export type InventoryLedgerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    packagingId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLedgerCreateManyInput = {
    id?: string
    tenantId: string
    itemId: string
    quantity: Decimal | DecimalJsLike | number | string
    type: $Enums.LedgerEntryType
    batchId?: string | null
    orderId?: string | null
    packagingId?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type InventoryLedgerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    packagingId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLedgerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    packagingId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngredientCatalogCreateInput = {
    id?: string
    type?: string
    name: string
    supplier?: string | null
    origin?: string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IngredientCatalogUncheckedCreateInput = {
    id?: string
    type?: string
    name: string
    supplier?: string | null
    origin?: string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IngredientCatalogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngredientCatalogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngredientCatalogCreateManyInput = {
    id?: string
    type?: string
    name: string
    supplier?: string | null
    origin?: string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IngredientCatalogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngredientCatalogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchCreateInput = {
    id?: string
    batchNumber: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    recipe: RecipeCreateNestedOneWithoutBatchesInput
    tank?: TankCreateNestedOneWithoutBatchesInput
    tenant: TenantCreateNestedOneWithoutBatchesInput
    ingredients?: BatchIngredientCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerCreateNestedManyWithoutBatchInput
    Keg?: KegCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunCreateNestedManyWithoutBatchInput
    QCTest?: QCTestCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateInput = {
    id?: string
    tenantId: string
    batchNumber: string
    recipeId: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    tankId?: string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    ingredients?: BatchIngredientUncheckedCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineUncheckedCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingUncheckedCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerUncheckedCreateNestedManyWithoutBatchInput
    Keg?: KegUncheckedCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchUncheckedCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunUncheckedCreateNestedManyWithoutBatchInput
    QCTest?: QCTestUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    recipe?: RecipeUpdateOneRequiredWithoutBatchesNestedInput
    tank?: TankUpdateOneWithoutBatchesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutBatchesNestedInput
    ingredients?: BatchIngredientUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUpdateManyWithoutBatchNestedInput
    Keg?: KegUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tankId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: BatchIngredientUncheckedUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUncheckedUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUncheckedUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUncheckedUpdateManyWithoutBatchNestedInput
    Keg?: KegUncheckedUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUncheckedUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUncheckedUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchCreateManyInput = {
    id?: string
    tenantId: string
    batchNumber: string
    recipeId: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    tankId?: string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
  }

  export type BatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tankId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BatchIngredientCreateInput = {
    id?: string
    inventoryItemId?: string | null
    name: string
    category: $Enums.IngredientCategory
    plannedAmount: Decimal | DecimalJsLike | number | string
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    unit: string
    lotNumber?: string | null
    addedAt?: Date | string | null
    batch: BatchCreateNestedOneWithoutIngredientsInput
  }

  export type BatchIngredientUncheckedCreateInput = {
    id?: string
    batchId: string
    inventoryItemId?: string | null
    name: string
    category: $Enums.IngredientCategory
    plannedAmount: Decimal | DecimalJsLike | number | string
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    unit: string
    lotNumber?: string | null
    addedAt?: Date | string | null
  }

  export type BatchIngredientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumIngredientCategoryFieldUpdateOperationsInput | $Enums.IngredientCategory
    plannedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batch?: BatchUpdateOneRequiredWithoutIngredientsNestedInput
  }

  export type BatchIngredientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumIngredientCategoryFieldUpdateOperationsInput | $Enums.IngredientCategory
    plannedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BatchIngredientCreateManyInput = {
    id?: string
    batchId: string
    inventoryItemId?: string | null
    name: string
    category: $Enums.IngredientCategory
    plannedAmount: Decimal | DecimalJsLike | number | string
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    unit: string
    lotNumber?: string | null
    addedAt?: Date | string | null
  }

  export type BatchIngredientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumIngredientCategoryFieldUpdateOperationsInput | $Enums.IngredientCategory
    plannedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BatchIngredientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumIngredientCategoryFieldUpdateOperationsInput | $Enums.IngredientCategory
    plannedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GravityReadingCreateInput = {
    id?: string
    gravity: Decimal | DecimalJsLike | number | string
    temperature: Decimal | DecimalJsLike | number | string
    notes?: string | null
    recordedBy: string
    recordedAt?: Date | string
    batch: BatchCreateNestedOneWithoutGravityReadingsInput
  }

  export type GravityReadingUncheckedCreateInput = {
    id?: string
    batchId: string
    gravity: Decimal | DecimalJsLike | number | string
    temperature: Decimal | DecimalJsLike | number | string
    notes?: string | null
    recordedBy: string
    recordedAt?: Date | string
  }

  export type GravityReadingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gravity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    temperature?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: BatchUpdateOneRequiredWithoutGravityReadingsNestedInput
  }

  export type GravityReadingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    gravity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    temperature?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GravityReadingCreateManyInput = {
    id?: string
    batchId: string
    gravity: Decimal | DecimalJsLike | number | string
    temperature: Decimal | DecimalJsLike | number | string
    notes?: string | null
    recordedBy: string
    recordedAt?: Date | string
  }

  export type GravityReadingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gravity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    temperature?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GravityReadingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    gravity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    temperature?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchTimelineCreateInput = {
    id?: string
    type: $Enums.TimelineEventType
    title: string
    description?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
    batch: BatchCreateNestedOneWithoutTimelineInput
  }

  export type BatchTimelineUncheckedCreateInput = {
    id?: string
    batchId: string
    type: $Enums.TimelineEventType
    title: string
    description?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
  }

  export type BatchTimelineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTimelineEventTypeFieldUpdateOperationsInput | $Enums.TimelineEventType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: BatchUpdateOneRequiredWithoutTimelineNestedInput
  }

  export type BatchTimelineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    type?: EnumTimelineEventTypeFieldUpdateOperationsInput | $Enums.TimelineEventType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchTimelineCreateManyInput = {
    id?: string
    batchId: string
    type: $Enums.TimelineEventType
    title: string
    description?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
  }

  export type BatchTimelineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTimelineEventTypeFieldUpdateOperationsInput | $Enums.TimelineEventType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchTimelineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    type?: EnumTimelineEventTypeFieldUpdateOperationsInput | $Enums.TimelineEventType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TankCreateInput = {
    id?: string
    name: string
    type: $Enums.TankType
    capacity: Decimal | DecimalJsLike | number | string
    status?: $Enums.TankStatus
    currentBatchId?: string | null
    location?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: TankCreatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: string | null
    currentPhase?: $Enums.LotPhase | null
    defaultTurnaroundHours?: number | null
    maxFillPercent?: number | null
    minFillPercent?: number | null
    batches?: BatchCreateNestedManyWithoutTankInput
    LotReading?: LotReadingCreateNestedManyWithoutTankInput
    tenant: TenantCreateNestedOneWithoutTanksInput
    TankAssignment?: TankAssignmentCreateNestedManyWithoutTankInput
    occupations?: TankOccupationCreateNestedManyWithoutTankInput
    Transfer_Transfer_destTankIdToTank?: TransferCreateNestedManyWithoutTank_Transfer_destTankIdToTankInput
    Transfer_Transfer_sourceTankIdToTank?: TransferCreateNestedManyWithoutTank_Transfer_sourceTankIdToTankInput
  }

  export type TankUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.TankType
    capacity: Decimal | DecimalJsLike | number | string
    status?: $Enums.TankStatus
    currentBatchId?: string | null
    location?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: TankCreatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: string | null
    currentPhase?: $Enums.LotPhase | null
    defaultTurnaroundHours?: number | null
    maxFillPercent?: number | null
    minFillPercent?: number | null
    batches?: BatchUncheckedCreateNestedManyWithoutTankInput
    LotReading?: LotReadingUncheckedCreateNestedManyWithoutTankInput
    TankAssignment?: TankAssignmentUncheckedCreateNestedManyWithoutTankInput
    occupations?: TankOccupationUncheckedCreateNestedManyWithoutTankInput
    Transfer_Transfer_destTankIdToTank?: TransferUncheckedCreateNestedManyWithoutTank_Transfer_destTankIdToTankInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUncheckedCreateNestedManyWithoutTank_Transfer_sourceTankIdToTankInput
  }

  export type TankUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTankTypeFieldUpdateOperationsInput | $Enums.TankType
    capacity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFieldUpdateOperationsInput | $Enums.TankStatus
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: TankUpdatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPhase?: NullableEnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase | null
    defaultTurnaroundHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    minFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    batches?: BatchUpdateManyWithoutTankNestedInput
    LotReading?: LotReadingUpdateManyWithoutTankNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTanksNestedInput
    TankAssignment?: TankAssignmentUpdateManyWithoutTankNestedInput
    occupations?: TankOccupationUpdateManyWithoutTankNestedInput
    Transfer_Transfer_destTankIdToTank?: TransferUpdateManyWithoutTank_Transfer_destTankIdToTankNestedInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUpdateManyWithoutTank_Transfer_sourceTankIdToTankNestedInput
  }

  export type TankUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTankTypeFieldUpdateOperationsInput | $Enums.TankType
    capacity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFieldUpdateOperationsInput | $Enums.TankStatus
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: TankUpdatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPhase?: NullableEnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase | null
    defaultTurnaroundHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    minFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    batches?: BatchUncheckedUpdateManyWithoutTankNestedInput
    LotReading?: LotReadingUncheckedUpdateManyWithoutTankNestedInput
    TankAssignment?: TankAssignmentUncheckedUpdateManyWithoutTankNestedInput
    occupations?: TankOccupationUncheckedUpdateManyWithoutTankNestedInput
    Transfer_Transfer_destTankIdToTank?: TransferUncheckedUpdateManyWithoutTank_Transfer_destTankIdToTankNestedInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUncheckedUpdateManyWithoutTank_Transfer_sourceTankIdToTankNestedInput
  }

  export type TankCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.TankType
    capacity: Decimal | DecimalJsLike | number | string
    status?: $Enums.TankStatus
    currentBatchId?: string | null
    location?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: TankCreatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: string | null
    currentPhase?: $Enums.LotPhase | null
    defaultTurnaroundHours?: number | null
    maxFillPercent?: number | null
    minFillPercent?: number | null
  }

  export type TankUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTankTypeFieldUpdateOperationsInput | $Enums.TankType
    capacity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFieldUpdateOperationsInput | $Enums.TankStatus
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: TankUpdatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPhase?: NullableEnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase | null
    defaultTurnaroundHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    minFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TankUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTankTypeFieldUpdateOperationsInput | $Enums.TankType
    capacity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFieldUpdateOperationsInput | $Enums.TankStatus
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: TankUpdatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPhase?: NullableEnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase | null
    defaultTurnaroundHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    minFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TankOccupationCreateInput = {
    id?: string
    tenantId: string
    batchId: string
    phase: $Enums.OccupationPhase
    startedAt?: Date | string
    endedAt?: Date | string | null
    tank: TankCreateNestedOneWithoutOccupationsInput
  }

  export type TankOccupationUncheckedCreateInput = {
    id?: string
    tenantId: string
    tankId: string
    batchId: string
    phase: $Enums.OccupationPhase
    startedAt?: Date | string
    endedAt?: Date | string | null
  }

  export type TankOccupationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    phase?: EnumOccupationPhaseFieldUpdateOperationsInput | $Enums.OccupationPhase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tank?: TankUpdateOneRequiredWithoutOccupationsNestedInput
  }

  export type TankOccupationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tankId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    phase?: EnumOccupationPhaseFieldUpdateOperationsInput | $Enums.OccupationPhase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TankOccupationCreateManyInput = {
    id?: string
    tenantId: string
    tankId: string
    batchId: string
    phase: $Enums.OccupationPhase
    startedAt?: Date | string
    endedAt?: Date | string | null
  }

  export type TankOccupationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    phase?: EnumOccupationPhaseFieldUpdateOperationsInput | $Enums.OccupationPhase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TankOccupationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tankId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    phase?: EnumOccupationPhaseFieldUpdateOperationsInput | $Enums.OccupationPhase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PackagingRunCreateInput = {
    id?: string
    tenantId: string
    packageType: $Enums.PackageType
    quantity: number
    volumeTotal: Decimal | DecimalJsLike | number | string
    lotNumber?: string | null
    performedBy: string
    notes?: string | null
    performedAt?: Date | string
    batch: BatchCreateNestedOneWithoutPackagingRunsInput
  }

  export type PackagingRunUncheckedCreateInput = {
    id?: string
    tenantId: string
    batchId: string
    packageType: $Enums.PackageType
    quantity: number
    volumeTotal: Decimal | DecimalJsLike | number | string
    lotNumber?: string | null
    performedBy: string
    notes?: string | null
    performedAt?: Date | string
  }

  export type PackagingRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    packageType?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    quantity?: IntFieldUpdateOperationsInput | number
    volumeTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: BatchUpdateOneRequiredWithoutPackagingRunsNestedInput
  }

  export type PackagingRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    packageType?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    quantity?: IntFieldUpdateOperationsInput | number
    volumeTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackagingRunCreateManyInput = {
    id?: string
    tenantId: string
    batchId: string
    packageType: $Enums.PackageType
    quantity: number
    volumeTotal: Decimal | DecimalJsLike | number | string
    lotNumber?: string | null
    performedBy: string
    notes?: string | null
    performedAt?: Date | string
  }

  export type PackagingRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    packageType?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    quantity?: IntFieldUpdateOperationsInput | number
    volumeTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackagingRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    packageType?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    quantity?: IntFieldUpdateOperationsInput | number
    volumeTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    kegReturnDays?: number
    kegDepositRequired?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCustomersInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    Keg?: KegCreateNestedManyWithoutCustomerInput
    orders?: SalesOrderCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    kegReturnDays?: number
    kegDepositRequired?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    Keg?: KegUncheckedCreateNestedManyWithoutCustomerInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    kegReturnDays?: IntFieldUpdateOperationsInput | number
    kegDepositRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    Keg?: KegUpdateManyWithoutCustomerNestedInput
    orders?: SalesOrderUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    kegReturnDays?: IntFieldUpdateOperationsInput | number
    kegDepositRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    Keg?: KegUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    kegReturnDays?: number
    kegDepositRequired?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    kegReturnDays?: IntFieldUpdateOperationsInput | number
    kegDepositRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    kegReturnDays?: IntFieldUpdateOperationsInput | number
    kegDepositRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateInput = {
    id?: string
    name: string
    category?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expenses?: ExpenseCreateNestedManyWithoutSupplierInput
    invoices?: InvoiceCreateNestedManyWithoutSupplierInput
    tenant: TenantCreateNestedOneWithoutSuppliersInput
    transactions?: TransactionCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    category?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expenses?: ExpenseUncheckedCreateNestedManyWithoutSupplierInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSupplierInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: ExpenseUpdateManyWithoutSupplierNestedInput
    invoices?: InvoiceUpdateManyWithoutSupplierNestedInput
    tenant?: TenantUpdateOneRequiredWithoutSuppliersNestedInput
    transactions?: TransactionUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: ExpenseUncheckedUpdateManyWithoutSupplierNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    category?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderCreateInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    orderedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdBy: string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    tenant: TenantCreateNestedOneWithoutOrdersInput
    transactions?: TransactionCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderUncheckedCreateInput = {
    id?: string
    tenantId: string
    orderNumber: string
    customerId: string
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    orderedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdBy: string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    transactions?: TransactionUpdateManyWithoutOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type SalesOrderCreateManyInput = {
    id?: string
    tenantId: string
    orderNumber: string
    customerId: string
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    orderedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdBy: string
    updatedAt?: Date | string
  }

  export type SalesOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    id?: string
    productName: string
    packageType: $Enums.PackageType
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    batchId?: string | null
    order: SalesOrderCreateNestedOneWithoutItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    productName: string
    packageType: $Enums.PackageType
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    batchId?: string | null
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    packageType?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: SalesOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    packageType?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    productName: string
    packageType: $Enums.PackageType
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    batchId?: string | null
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    packageType?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    packageType?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionCreateInput = {
    id?: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    expense?: ExpenseCreateNestedOneWithoutTransactionsInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
    order?: SalesOrderCreateNestedOneWithoutTransactionsInput
    supplier?: SupplierCreateNestedOneWithoutTransactionsInput
    tenant: TenantCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    tenantId: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    customerId?: string | null
    supplierId?: string | null
    orderId?: string | null
    invoiceId?: string | null
    expenseId?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    expense?: ExpenseUpdateOneWithoutTransactionsNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
    order?: SalesOrderUpdateOneWithoutTransactionsNestedInput
    supplier?: SupplierUpdateOneWithoutTransactionsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    expenseId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    tenantId: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    customerId?: string | null
    supplierId?: string | null
    orderId?: string | null
    invoiceId?: string | null
    expenseId?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    expenseId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutInvoicesInput
    order?: SalesOrderCreateNestedOneWithoutInvoiceInput
    supplier?: SupplierCreateNestedOneWithoutInvoicesInput
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    customerId?: string | null
    supplierId?: string | null
    orderId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutInvoicesNestedInput
    order?: SalesOrderUpdateOneWithoutInvoiceNestedInput
    supplier?: SupplierUpdateOneWithoutInvoicesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    customerId?: string | null
    supplierId?: string | null
    orderId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateInput = {
    id?: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    productName?: string | null
    packageType?: $Enums.PackageType | null
    batchId?: string | null
    sortOrder?: number
    invoice: InvoiceCreateNestedOneWithoutItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: string
    invoiceId: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    productName?: string | null
    packageType?: $Enums.PackageType | null
    batchId?: string | null
    sortOrder?: number
  }

  export type InvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableEnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableEnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceItemCreateManyInput = {
    id?: string
    invoiceId: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    productName?: string | null
    packageType?: $Enums.PackageType | null
    batchId?: string | null
    sortOrder?: number
  }

  export type InvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableEnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableEnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PaymentMethod
    date?: Date | string
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutPaymentsInput
    order?: SalesOrderCreateNestedOneWithoutPaymentsInput
    tenant: TenantCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    tenantId: string
    invoiceId?: string | null
    orderId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PaymentMethod
    date?: Date | string
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutPaymentsNestedInput
    order?: SalesOrderUpdateOneWithoutPaymentsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    tenantId: string
    invoiceId?: string | null
    orderId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PaymentMethod
    date?: Date | string
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateInput = {
    id?: string
    category: $Enums.ExpenseCategory
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    invoiceNumber?: string | null
    invoiceId?: string | null
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    receiptUrl?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier?: SupplierCreateNestedOneWithoutExpensesInput
    tenant: TenantCreateNestedOneWithoutExpensesInput
    transactions?: TransactionCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    tenantId: string
    category: $Enums.ExpenseCategory
    supplierId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    invoiceNumber?: string | null
    invoiceId?: string | null
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    receiptUrl?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneWithoutExpensesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutExpensesNestedInput
    transactions?: TransactionUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseCreateManyInput = {
    id?: string
    tenantId: string
    category: $Enums.ExpenseCategory
    supplierId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    invoiceNumber?: string | null
    invoiceId?: string | null
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    receiptUrl?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCreateInput = {
    id?: string
    category: $Enums.ExpenseCategory
    year: number
    month?: number | null
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBudgetsInput
  }

  export type BudgetUncheckedCreateInput = {
    id?: string
    tenantId: string
    category: $Enums.ExpenseCategory
    year: number
    month?: number | null
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    year?: IntFieldUpdateOperationsInput | number
    month?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBudgetsNestedInput
  }

  export type BudgetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    year?: IntFieldUpdateOperationsInput | number
    month?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCreateManyInput = {
    id?: string
    tenantId: string
    category: $Enums.ExpenseCategory
    year: number
    month?: number | null
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    year?: IntFieldUpdateOperationsInput | number
    month?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    year?: IntFieldUpdateOperationsInput | number
    month?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    tenantId: string
    userId: string
    action: string
    entityType: string
    entityId: string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    action: string
    entityType: string
    entityId: string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    action: string
    entityType: string
    entityId: string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    correlationId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlendingConfigCreateInput = {
    id: string
    tenantId: string
    requireRecipeMatch?: boolean
    requireYeastMatch?: boolean
    requirePhaseMatch?: boolean
    requireStyleMatch?: boolean
    maxBlendSources?: number
    allowOverCapacity?: boolean
    maxAgeDifferenceHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlendingConfigUncheckedCreateInput = {
    id: string
    tenantId: string
    requireRecipeMatch?: boolean
    requireYeastMatch?: boolean
    requirePhaseMatch?: boolean
    requireStyleMatch?: boolean
    maxBlendSources?: number
    allowOverCapacity?: boolean
    maxAgeDifferenceHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlendingConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    requireRecipeMatch?: BoolFieldUpdateOperationsInput | boolean
    requireYeastMatch?: BoolFieldUpdateOperationsInput | boolean
    requirePhaseMatch?: BoolFieldUpdateOperationsInput | boolean
    requireStyleMatch?: BoolFieldUpdateOperationsInput | boolean
    maxBlendSources?: IntFieldUpdateOperationsInput | number
    allowOverCapacity?: BoolFieldUpdateOperationsInput | boolean
    maxAgeDifferenceHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlendingConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    requireRecipeMatch?: BoolFieldUpdateOperationsInput | boolean
    requireYeastMatch?: BoolFieldUpdateOperationsInput | boolean
    requirePhaseMatch?: BoolFieldUpdateOperationsInput | boolean
    requireStyleMatch?: BoolFieldUpdateOperationsInput | boolean
    maxBlendSources?: IntFieldUpdateOperationsInput | number
    allowOverCapacity?: BoolFieldUpdateOperationsInput | boolean
    maxAgeDifferenceHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlendingConfigCreateManyInput = {
    id: string
    tenantId: string
    requireRecipeMatch?: boolean
    requireYeastMatch?: boolean
    requirePhaseMatch?: boolean
    requireStyleMatch?: boolean
    maxBlendSources?: number
    allowOverCapacity?: boolean
    maxAgeDifferenceHours?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlendingConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    requireRecipeMatch?: BoolFieldUpdateOperationsInput | boolean
    requireYeastMatch?: BoolFieldUpdateOperationsInput | boolean
    requirePhaseMatch?: BoolFieldUpdateOperationsInput | boolean
    requireStyleMatch?: BoolFieldUpdateOperationsInput | boolean
    maxBlendSources?: IntFieldUpdateOperationsInput | number
    allowOverCapacity?: BoolFieldUpdateOperationsInput | boolean
    maxAgeDifferenceHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlendingConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    requireRecipeMatch?: BoolFieldUpdateOperationsInput | boolean
    requireYeastMatch?: BoolFieldUpdateOperationsInput | boolean
    requirePhaseMatch?: BoolFieldUpdateOperationsInput | boolean
    requireStyleMatch?: BoolFieldUpdateOperationsInput | boolean
    maxBlendSources?: IntFieldUpdateOperationsInput | number
    allowOverCapacity?: BoolFieldUpdateOperationsInput | boolean
    maxAgeDifferenceHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CIPLogCreateInput = {
    id: string
    cipType: string
    date: Date | string
    duration: number
    temperature?: number | null
    causticConcentration?: number | null
    performedBy: string
    result: string
    notes?: string | null
    createdAt?: Date | string
    Equipment: EquipmentCreateNestedOneWithoutCIPLogInput
  }

  export type CIPLogUncheckedCreateInput = {
    id: string
    equipmentId: string
    cipType: string
    date: Date | string
    duration: number
    temperature?: number | null
    causticConcentration?: number | null
    performedBy: string
    result: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type CIPLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cipType?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    causticConcentration?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Equipment?: EquipmentUpdateOneRequiredWithoutCIPLogNestedInput
  }

  export type CIPLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    cipType?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    causticConcentration?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CIPLogCreateManyInput = {
    id: string
    equipmentId: string
    cipType: string
    date: Date | string
    duration: number
    temperature?: number | null
    causticConcentration?: number | null
    performedBy: string
    result: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type CIPLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cipType?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    causticConcentration?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CIPLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    cipType?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    causticConcentration?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCreateInput = {
    id: string
    name: string
    type: string
    status?: string
    capacity?: number | null
    model?: string | null
    manufacturer?: string | null
    serialNumber?: string | null
    location?: string | null
    workingPressure?: number | null
    currentTemp?: number | null
    currentPressure?: number | null
    installationDate?: Date | string | null
    warrantyDate?: Date | string | null
    lastCIP?: Date | string | null
    nextCIP?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    cipIntervalDays?: number
    inspectionIntervalDays?: number
    annualMaintenanceDays?: number
    currentBatchId?: string | null
    currentBatchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    purchaseDate?: Date | string | null
    capabilities?: EquipmentCreatecapabilitiesInput | string[]
    CIPLog?: CIPLogCreateNestedManyWithoutEquipmentInput
    Tenant: TenantCreateNestedOneWithoutEquipmentInput
    MaintenanceLog?: MaintenanceLogCreateNestedManyWithoutEquipmentInput
    ProblemReport?: ProblemReportCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateInput = {
    id: string
    tenantId: string
    name: string
    type: string
    status?: string
    capacity?: number | null
    model?: string | null
    manufacturer?: string | null
    serialNumber?: string | null
    location?: string | null
    workingPressure?: number | null
    currentTemp?: number | null
    currentPressure?: number | null
    installationDate?: Date | string | null
    warrantyDate?: Date | string | null
    lastCIP?: Date | string | null
    nextCIP?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    cipIntervalDays?: number
    inspectionIntervalDays?: number
    annualMaintenanceDays?: number
    currentBatchId?: string | null
    currentBatchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    purchaseDate?: Date | string | null
    capabilities?: EquipmentCreatecapabilitiesInput | string[]
    CIPLog?: CIPLogUncheckedCreateNestedManyWithoutEquipmentInput
    MaintenanceLog?: MaintenanceLogUncheckedCreateNestedManyWithoutEquipmentInput
    ProblemReport?: ProblemReportUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workingPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    currentTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cipIntervalDays?: IntFieldUpdateOperationsInput | number
    inspectionIntervalDays?: IntFieldUpdateOperationsInput | number
    annualMaintenanceDays?: IntFieldUpdateOperationsInput | number
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBatchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capabilities?: EquipmentUpdatecapabilitiesInput | string[]
    CIPLog?: CIPLogUpdateManyWithoutEquipmentNestedInput
    Tenant?: TenantUpdateOneRequiredWithoutEquipmentNestedInput
    MaintenanceLog?: MaintenanceLogUpdateManyWithoutEquipmentNestedInput
    ProblemReport?: ProblemReportUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workingPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    currentTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cipIntervalDays?: IntFieldUpdateOperationsInput | number
    inspectionIntervalDays?: IntFieldUpdateOperationsInput | number
    annualMaintenanceDays?: IntFieldUpdateOperationsInput | number
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBatchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capabilities?: EquipmentUpdatecapabilitiesInput | string[]
    CIPLog?: CIPLogUncheckedUpdateManyWithoutEquipmentNestedInput
    MaintenanceLog?: MaintenanceLogUncheckedUpdateManyWithoutEquipmentNestedInput
    ProblemReport?: ProblemReportUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentCreateManyInput = {
    id: string
    tenantId: string
    name: string
    type: string
    status?: string
    capacity?: number | null
    model?: string | null
    manufacturer?: string | null
    serialNumber?: string | null
    location?: string | null
    workingPressure?: number | null
    currentTemp?: number | null
    currentPressure?: number | null
    installationDate?: Date | string | null
    warrantyDate?: Date | string | null
    lastCIP?: Date | string | null
    nextCIP?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    cipIntervalDays?: number
    inspectionIntervalDays?: number
    annualMaintenanceDays?: number
    currentBatchId?: string | null
    currentBatchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    purchaseDate?: Date | string | null
    capabilities?: EquipmentCreatecapabilitiesInput | string[]
  }

  export type EquipmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workingPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    currentTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cipIntervalDays?: IntFieldUpdateOperationsInput | number
    inspectionIntervalDays?: IntFieldUpdateOperationsInput | number
    annualMaintenanceDays?: IntFieldUpdateOperationsInput | number
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBatchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capabilities?: EquipmentUpdatecapabilitiesInput | string[]
  }

  export type EquipmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workingPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    currentTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cipIntervalDays?: IntFieldUpdateOperationsInput | number
    inspectionIntervalDays?: IntFieldUpdateOperationsInput | number
    annualMaintenanceDays?: IntFieldUpdateOperationsInput | number
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBatchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capabilities?: EquipmentUpdatecapabilitiesInput | string[]
  }

  export type LotCreateInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
    Lot?: LotCreateNestedOneWithoutOther_LotInput
    other_Lot?: LotCreateNestedManyWithoutLotInput
    LotBatch?: LotBatchCreateNestedManyWithoutLotInput
    LotReading?: LotReadingCreateNestedManyWithoutLotInput
    QCTest?: QCTestCreateNestedManyWithoutLotInput
    TankAssignment?: TankAssignmentCreateNestedManyWithoutLotInput
    Transfer_Transfer_destLotIdToLot?: TransferCreateNestedManyWithoutLot_Transfer_destLotIdToLotInput
    Transfer_Transfer_sourceLotIdToLot?: TransferCreateNestedManyWithoutLot_Transfer_sourceLotIdToLotInput
  }

  export type LotUncheckedCreateInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    parentLotId?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
    other_Lot?: LotUncheckedCreateNestedManyWithoutLotInput
    LotBatch?: LotBatchUncheckedCreateNestedManyWithoutLotInput
    LotReading?: LotReadingUncheckedCreateNestedManyWithoutLotInput
    QCTest?: QCTestUncheckedCreateNestedManyWithoutLotInput
    TankAssignment?: TankAssignmentUncheckedCreateNestedManyWithoutLotInput
    Transfer_Transfer_destLotIdToLot?: TransferUncheckedCreateNestedManyWithoutLot_Transfer_destLotIdToLotInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUncheckedCreateNestedManyWithoutLot_Transfer_sourceLotIdToLotInput
  }

  export type LotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Lot?: LotUpdateOneWithoutOther_LotNestedInput
    other_Lot?: LotUpdateManyWithoutLotNestedInput
    LotBatch?: LotBatchUpdateManyWithoutLotNestedInput
    LotReading?: LotReadingUpdateManyWithoutLotNestedInput
    QCTest?: QCTestUpdateManyWithoutLotNestedInput
    TankAssignment?: TankAssignmentUpdateManyWithoutLotNestedInput
    Transfer_Transfer_destLotIdToLot?: TransferUpdateManyWithoutLot_Transfer_destLotIdToLotNestedInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUpdateManyWithoutLot_Transfer_sourceLotIdToLotNestedInput
  }

  export type LotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_Lot?: LotUncheckedUpdateManyWithoutLotNestedInput
    LotBatch?: LotBatchUncheckedUpdateManyWithoutLotNestedInput
    LotReading?: LotReadingUncheckedUpdateManyWithoutLotNestedInput
    QCTest?: QCTestUncheckedUpdateManyWithoutLotNestedInput
    TankAssignment?: TankAssignmentUncheckedUpdateManyWithoutLotNestedInput
    Transfer_Transfer_destLotIdToLot?: TransferUncheckedUpdateManyWithoutLot_Transfer_destLotIdToLotNestedInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUncheckedUpdateManyWithoutLot_Transfer_sourceLotIdToLotNestedInput
  }

  export type LotCreateManyInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    parentLotId?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
  }

  export type LotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LotBatchCreateInput = {
    id: string
    volumeContribution: Decimal | DecimalJsLike | number | string
    batchPercentage?: Decimal | DecimalJsLike | number | string
    addedAt?: Date | string
    Batch: BatchCreateNestedOneWithoutLotBatchInput
    Lot: LotCreateNestedOneWithoutLotBatchInput
  }

  export type LotBatchUncheckedCreateInput = {
    id: string
    lotId: string
    batchId: string
    volumeContribution: Decimal | DecimalJsLike | number | string
    batchPercentage?: Decimal | DecimalJsLike | number | string
    addedAt?: Date | string
  }

  export type LotBatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    volumeContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateOneRequiredWithoutLotBatchNestedInput
    Lot?: LotUpdateOneRequiredWithoutLotBatchNestedInput
  }

  export type LotBatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    volumeContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LotBatchCreateManyInput = {
    id: string
    lotId: string
    batchId: string
    volumeContribution: Decimal | DecimalJsLike | number | string
    batchPercentage?: Decimal | DecimalJsLike | number | string
    addedAt?: Date | string
  }

  export type LotBatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    volumeContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LotBatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    volumeContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LotReadingCreateInput = {
    id: string
    readingType: $Enums.ReadingType
    value: Decimal | DecimalJsLike | number | string
    unit: string
    notes?: string | null
    recordedBy: string
    recordedAt?: Date | string
    Lot: LotCreateNestedOneWithoutLotReadingInput
    Tank: TankCreateNestedOneWithoutLotReadingInput
  }

  export type LotReadingUncheckedCreateInput = {
    id: string
    lotId: string
    tankId: string
    readingType: $Enums.ReadingType
    value: Decimal | DecimalJsLike | number | string
    unit: string
    notes?: string | null
    recordedBy: string
    recordedAt?: Date | string
  }

  export type LotReadingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lot?: LotUpdateOneRequiredWithoutLotReadingNestedInput
    Tank?: TankUpdateOneRequiredWithoutLotReadingNestedInput
  }

  export type LotReadingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotId?: StringFieldUpdateOperationsInput | string
    tankId?: StringFieldUpdateOperationsInput | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LotReadingCreateManyInput = {
    id: string
    lotId: string
    tankId: string
    readingType: $Enums.ReadingType
    value: Decimal | DecimalJsLike | number | string
    unit: string
    notes?: string | null
    recordedBy: string
    recordedAt?: Date | string
  }

  export type LotReadingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LotReadingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotId?: StringFieldUpdateOperationsInput | string
    tankId?: StringFieldUpdateOperationsInput | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceLogCreateInput = {
    id: string
    type: string
    status: string
    priority?: string | null
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    duration?: number | null
    performedBy?: string | null
    cost?: number | null
    partsUsed?: MaintenanceLogCreatepartsUsedInput | string[]
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Equipment: EquipmentCreateNestedOneWithoutMaintenanceLogInput
  }

  export type MaintenanceLogUncheckedCreateInput = {
    id: string
    equipmentId: string
    type: string
    status: string
    priority?: string | null
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    duration?: number | null
    performedBy?: string | null
    cost?: number | null
    partsUsed?: MaintenanceLogCreatepartsUsedInput | string[]
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MaintenanceLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    partsUsed?: MaintenanceLogUpdatepartsUsedInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Equipment?: EquipmentUpdateOneRequiredWithoutMaintenanceLogNestedInput
  }

  export type MaintenanceLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    partsUsed?: MaintenanceLogUpdatepartsUsedInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceLogCreateManyInput = {
    id: string
    equipmentId: string
    type: string
    status: string
    priority?: string | null
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    duration?: number | null
    performedBy?: string | null
    cost?: number | null
    partsUsed?: MaintenanceLogCreatepartsUsedInput | string[]
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MaintenanceLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    partsUsed?: MaintenanceLogUpdatepartsUsedInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    partsUsed?: MaintenanceLogUpdatepartsUsedInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProblemReportCreateInput = {
    id: string
    problemType: string
    severity: string
    status?: string
    description: string
    reportedDate: Date | string
    reportedBy: string
    resolvedDate?: Date | string | null
    resolvedBy?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Equipment: EquipmentCreateNestedOneWithoutProblemReportInput
  }

  export type ProblemReportUncheckedCreateInput = {
    id: string
    equipmentId: string
    problemType: string
    severity: string
    status?: string
    description: string
    reportedDate: Date | string
    reportedBy: string
    resolvedDate?: Date | string | null
    resolvedBy?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ProblemReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    problemType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Equipment?: EquipmentUpdateOneRequiredWithoutProblemReportNestedInput
  }

  export type ProblemReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    problemType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProblemReportCreateManyInput = {
    id: string
    equipmentId: string
    problemType: string
    severity: string
    status?: string
    description: string
    reportedDate: Date | string
    reportedBy: string
    resolvedDate?: Date | string | null
    resolvedBy?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ProblemReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    problemType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProblemReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    problemType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TankAssignmentCreateInput = {
    id: string
    tenantId: string
    phase: $Enums.LotPhase
    plannedStart?: Date | string | null
    plannedEnd?: Date | string | null
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.AssignmentStatus
    plannedVolume?: Decimal | DecimalJsLike | number | string | null
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: boolean
    isSplitSource?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    notes?: string | null
    Lot: LotCreateNestedOneWithoutTankAssignmentInput
    Tank: TankCreateNestedOneWithoutTankAssignmentInput
  }

  export type TankAssignmentUncheckedCreateInput = {
    id: string
    tenantId: string
    tankId: string
    lotId: string
    phase: $Enums.LotPhase
    plannedStart?: Date | string | null
    plannedEnd?: Date | string | null
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.AssignmentStatus
    plannedVolume?: Decimal | DecimalJsLike | number | string | null
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: boolean
    isSplitSource?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    notes?: string | null
  }

  export type TankAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    plannedStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    plannedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: BoolFieldUpdateOperationsInput | boolean
    isSplitSource?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    Lot?: LotUpdateOneRequiredWithoutTankAssignmentNestedInput
    Tank?: TankUpdateOneRequiredWithoutTankAssignmentNestedInput
  }

  export type TankAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tankId?: StringFieldUpdateOperationsInput | string
    lotId?: StringFieldUpdateOperationsInput | string
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    plannedStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    plannedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: BoolFieldUpdateOperationsInput | boolean
    isSplitSource?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TankAssignmentCreateManyInput = {
    id: string
    tenantId: string
    tankId: string
    lotId: string
    phase: $Enums.LotPhase
    plannedStart?: Date | string | null
    plannedEnd?: Date | string | null
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.AssignmentStatus
    plannedVolume?: Decimal | DecimalJsLike | number | string | null
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: boolean
    isSplitSource?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    notes?: string | null
  }

  export type TankAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    plannedStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    plannedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: BoolFieldUpdateOperationsInput | boolean
    isSplitSource?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TankAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tankId?: StringFieldUpdateOperationsInput | string
    lotId?: StringFieldUpdateOperationsInput | string
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    plannedStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    plannedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: BoolFieldUpdateOperationsInput | boolean
    isSplitSource?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransferCreateInput = {
    id: string
    tenantId: string
    transferCode: string
    transferType: $Enums.TransferType
    volume: Decimal | DecimalJsLike | number | string
    plannedAt: Date | string
    executedAt?: Date | string | null
    status?: $Enums.TransferStatus
    measuredLoss?: Decimal | DecimalJsLike | number | string | null
    lossReason?: string | null
    performedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Lot_Transfer_destLotIdToLot?: LotCreateNestedOneWithoutTransfer_Transfer_destLotIdToLotInput
    Tank_Transfer_destTankIdToTank: TankCreateNestedOneWithoutTransfer_Transfer_destTankIdToTankInput
    Lot_Transfer_sourceLotIdToLot?: LotCreateNestedOneWithoutTransfer_Transfer_sourceLotIdToLotInput
    Tank_Transfer_sourceTankIdToTank: TankCreateNestedOneWithoutTransfer_Transfer_sourceTankIdToTankInput
  }

  export type TransferUncheckedCreateInput = {
    id: string
    tenantId: string
    transferCode: string
    sourceLotId?: string | null
    sourceTankId: string
    destLotId?: string | null
    destTankId: string
    transferType: $Enums.TransferType
    volume: Decimal | DecimalJsLike | number | string
    plannedAt: Date | string
    executedAt?: Date | string | null
    status?: $Enums.TransferStatus
    measuredLoss?: Decimal | DecimalJsLike | number | string | null
    lossReason?: string | null
    performedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    measuredLoss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lot_Transfer_destLotIdToLot?: LotUpdateOneWithoutTransfer_Transfer_destLotIdToLotNestedInput
    Tank_Transfer_destTankIdToTank?: TankUpdateOneRequiredWithoutTransfer_Transfer_destTankIdToTankNestedInput
    Lot_Transfer_sourceLotIdToLot?: LotUpdateOneWithoutTransfer_Transfer_sourceLotIdToLotNestedInput
    Tank_Transfer_sourceTankIdToTank?: TankUpdateOneRequiredWithoutTransfer_Transfer_sourceTankIdToTankNestedInput
  }

  export type TransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    sourceLotId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceTankId?: StringFieldUpdateOperationsInput | string
    destLotId?: NullableStringFieldUpdateOperationsInput | string | null
    destTankId?: StringFieldUpdateOperationsInput | string
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    measuredLoss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferCreateManyInput = {
    id: string
    tenantId: string
    transferCode: string
    sourceLotId?: string | null
    sourceTankId: string
    destLotId?: string | null
    destTankId: string
    transferType: $Enums.TransferType
    volume: Decimal | DecimalJsLike | number | string
    plannedAt: Date | string
    executedAt?: Date | string | null
    status?: $Enums.TransferStatus
    measuredLoss?: Decimal | DecimalJsLike | number | string | null
    lossReason?: string | null
    performedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    measuredLoss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    sourceLotId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceTankId?: StringFieldUpdateOperationsInput | string
    destLotId?: NullableStringFieldUpdateOperationsInput | string | null
    destTankId?: StringFieldUpdateOperationsInput | string
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    measuredLoss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KegCreateInput = {
    id?: string
    kegNumber: string
    size: number
    status?: $Enums.KegStatus
    condition?: $Enums.KegCondition
    filledAt?: Date | string | null
    productName?: string | null
    lotNumber?: string | null
    orderId?: string | null
    sentAt?: Date | string | null
    returnedAt?: Date | string | null
    deposit?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Batch?: BatchCreateNestedOneWithoutKegInput
    Customer?: CustomerCreateNestedOneWithoutKegInput
    Tenant: TenantCreateNestedOneWithoutKegInput
    movements?: KegMovementCreateNestedManyWithoutKegInput
  }

  export type KegUncheckedCreateInput = {
    id?: string
    tenantId: string
    kegNumber: string
    size: number
    status?: $Enums.KegStatus
    condition?: $Enums.KegCondition
    batchId?: string | null
    filledAt?: Date | string | null
    productName?: string | null
    lotNumber?: string | null
    customerId?: string | null
    orderId?: string | null
    sentAt?: Date | string | null
    returnedAt?: Date | string | null
    deposit?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movements?: KegMovementUncheckedCreateNestedManyWithoutKegInput
  }

  export type KegUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kegNumber?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    status?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    condition?: EnumKegConditionFieldUpdateOperationsInput | $Enums.KegCondition
    filledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateOneWithoutKegNestedInput
    Customer?: CustomerUpdateOneWithoutKegNestedInput
    Tenant?: TenantUpdateOneRequiredWithoutKegNestedInput
    movements?: KegMovementUpdateManyWithoutKegNestedInput
  }

  export type KegUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kegNumber?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    status?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    condition?: EnumKegConditionFieldUpdateOperationsInput | $Enums.KegCondition
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    filledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: KegMovementUncheckedUpdateManyWithoutKegNestedInput
  }

  export type KegCreateManyInput = {
    id?: string
    tenantId: string
    kegNumber: string
    size: number
    status?: $Enums.KegStatus
    condition?: $Enums.KegCondition
    batchId?: string | null
    filledAt?: Date | string | null
    productName?: string | null
    lotNumber?: string | null
    customerId?: string | null
    orderId?: string | null
    sentAt?: Date | string | null
    returnedAt?: Date | string | null
    deposit?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KegUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    kegNumber?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    status?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    condition?: EnumKegConditionFieldUpdateOperationsInput | $Enums.KegCondition
    filledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KegUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kegNumber?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    status?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    condition?: EnumKegConditionFieldUpdateOperationsInput | $Enums.KegCondition
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    filledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KegMovementCreateInput = {
    id?: string
    tenantId: string
    action: $Enums.KegAction
    fromStatus: $Enums.KegStatus
    toStatus: $Enums.KegStatus
    productId?: string | null
    productName?: string | null
    customerId?: string | null
    customerName?: string | null
    orderId?: string | null
    batchId?: string | null
    notes?: string | null
    createdAt?: Date | string
    createdBy?: string | null
    keg: KegCreateNestedOneWithoutMovementsInput
  }

  export type KegMovementUncheckedCreateInput = {
    id?: string
    tenantId: string
    kegId: string
    action: $Enums.KegAction
    fromStatus: $Enums.KegStatus
    toStatus: $Enums.KegStatus
    productId?: string | null
    productName?: string | null
    customerId?: string | null
    customerName?: string | null
    orderId?: string | null
    batchId?: string | null
    notes?: string | null
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type KegMovementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    action?: EnumKegActionFieldUpdateOperationsInput | $Enums.KegAction
    fromStatus?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    toStatus?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    keg?: KegUpdateOneRequiredWithoutMovementsNestedInput
  }

  export type KegMovementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kegId?: StringFieldUpdateOperationsInput | string
    action?: EnumKegActionFieldUpdateOperationsInput | $Enums.KegAction
    fromStatus?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    toStatus?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KegMovementCreateManyInput = {
    id?: string
    tenantId: string
    kegId: string
    action: $Enums.KegAction
    fromStatus: $Enums.KegStatus
    toStatus: $Enums.KegStatus
    productId?: string | null
    productName?: string | null
    customerId?: string | null
    customerName?: string | null
    orderId?: string | null
    batchId?: string | null
    notes?: string | null
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type KegMovementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    action?: EnumKegActionFieldUpdateOperationsInput | $Enums.KegAction
    fromStatus?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    toStatus?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KegMovementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kegId?: StringFieldUpdateOperationsInput | string
    action?: EnumKegActionFieldUpdateOperationsInput | $Enums.KegAction
    fromStatus?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    toStatus?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QCTestCreateInput = {
    id: string
    tenantId: string
    testType: $Enums.QCTestType
    status?: $Enums.QCTestStatus
    priority?: $Enums.QCTestPriority
    scheduledDate: Date | string
    completedDate?: Date | string | null
    minValue?: Decimal | DecimalJsLike | number | string | null
    maxValue?: Decimal | DecimalJsLike | number | string | null
    targetValue?: Decimal | DecimalJsLike | number | string | null
    result?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    performedBy?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
    Batch: BatchCreateNestedOneWithoutQCTestInput
    Lot?: LotCreateNestedOneWithoutQCTestInput
  }

  export type QCTestUncheckedCreateInput = {
    id: string
    tenantId: string
    batchId: string
    lotId?: string | null
    testType: $Enums.QCTestType
    status?: $Enums.QCTestStatus
    priority?: $Enums.QCTestPriority
    scheduledDate: Date | string
    completedDate?: Date | string | null
    minValue?: Decimal | DecimalJsLike | number | string | null
    maxValue?: Decimal | DecimalJsLike | number | string | null
    targetValue?: Decimal | DecimalJsLike | number | string | null
    result?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    performedBy?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type QCTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    testType?: EnumQCTestTypeFieldUpdateOperationsInput | $Enums.QCTestType
    status?: EnumQCTestStatusFieldUpdateOperationsInput | $Enums.QCTestStatus
    priority?: EnumQCTestPriorityFieldUpdateOperationsInput | $Enums.QCTestPriority
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    minValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateOneRequiredWithoutQCTestNestedInput
    Lot?: LotUpdateOneWithoutQCTestNestedInput
  }

  export type QCTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: EnumQCTestTypeFieldUpdateOperationsInput | $Enums.QCTestType
    status?: EnumQCTestStatusFieldUpdateOperationsInput | $Enums.QCTestStatus
    priority?: EnumQCTestPriorityFieldUpdateOperationsInput | $Enums.QCTestPriority
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    minValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QCTestCreateManyInput = {
    id: string
    tenantId: string
    batchId: string
    lotId?: string | null
    testType: $Enums.QCTestType
    status?: $Enums.QCTestStatus
    priority?: $Enums.QCTestPriority
    scheduledDate: Date | string
    completedDate?: Date | string | null
    minValue?: Decimal | DecimalJsLike | number | string | null
    maxValue?: Decimal | DecimalJsLike | number | string | null
    targetValue?: Decimal | DecimalJsLike | number | string | null
    result?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    performedBy?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type QCTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    testType?: EnumQCTestTypeFieldUpdateOperationsInput | $Enums.QCTestType
    status?: EnumQCTestStatusFieldUpdateOperationsInput | $Enums.QCTestStatus
    priority?: EnumQCTestPriorityFieldUpdateOperationsInput | $Enums.QCTestPriority
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    minValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QCTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: EnumQCTestTypeFieldUpdateOperationsInput | $Enums.QCTestType
    status?: EnumQCTestStatusFieldUpdateOperationsInput | $Enums.QCTestStatus
    priority?: EnumQCTestPriorityFieldUpdateOperationsInput | $Enums.QCTestPriority
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    minValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type ConfigurationUncheckedCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type ConfigurationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationCreateManyInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type ConfigurationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuseumCreateInput = {
    id?: string
    name: string
    description?: string | null
    city?: string | null
    address?: string | null
    nameEn?: string | null
    descriptionEn?: string | null
    cityEn?: string | null
    addressEn?: string | null
    nameRu?: string | null
    descriptionRu?: string | null
    cityRu?: string | null
    addressRu?: string | null
    nameDe?: string | null
    descriptionDe?: string | null
    cityDe?: string | null
    addressDe?: string | null
    nameFr?: string | null
    descriptionFr?: string | null
    cityFr?: string | null
    addressFr?: string | null
    slug: string
    coverImage?: string | null
    latitude?: number | null
    longitude?: number | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    showMap?: boolean
    showQrScanner?: boolean
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tours?: TourCreateNestedManyWithoutMuseumInput
  }

  export type MuseumUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    city?: string | null
    address?: string | null
    nameEn?: string | null
    descriptionEn?: string | null
    cityEn?: string | null
    addressEn?: string | null
    nameRu?: string | null
    descriptionRu?: string | null
    cityRu?: string | null
    addressRu?: string | null
    nameDe?: string | null
    descriptionDe?: string | null
    cityDe?: string | null
    addressDe?: string | null
    nameFr?: string | null
    descriptionFr?: string | null
    cityFr?: string | null
    addressFr?: string | null
    slug: string
    coverImage?: string | null
    latitude?: number | null
    longitude?: number | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    showMap?: boolean
    showQrScanner?: boolean
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tours?: TourUncheckedCreateNestedManyWithoutMuseumInput
  }

  export type MuseumUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    cityEn?: NullableStringFieldUpdateOperationsInput | string | null
    addressEn?: NullableStringFieldUpdateOperationsInput | string | null
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionRu?: NullableStringFieldUpdateOperationsInput | string | null
    cityRu?: NullableStringFieldUpdateOperationsInput | string | null
    addressRu?: NullableStringFieldUpdateOperationsInput | string | null
    nameDe?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionDe?: NullableStringFieldUpdateOperationsInput | string | null
    cityDe?: NullableStringFieldUpdateOperationsInput | string | null
    addressDe?: NullableStringFieldUpdateOperationsInput | string | null
    nameFr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFr?: NullableStringFieldUpdateOperationsInput | string | null
    cityFr?: NullableStringFieldUpdateOperationsInput | string | null
    addressFr?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    showMap?: BoolFieldUpdateOperationsInput | boolean
    showQrScanner?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tours?: TourUpdateManyWithoutMuseumNestedInput
  }

  export type MuseumUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    cityEn?: NullableStringFieldUpdateOperationsInput | string | null
    addressEn?: NullableStringFieldUpdateOperationsInput | string | null
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionRu?: NullableStringFieldUpdateOperationsInput | string | null
    cityRu?: NullableStringFieldUpdateOperationsInput | string | null
    addressRu?: NullableStringFieldUpdateOperationsInput | string | null
    nameDe?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionDe?: NullableStringFieldUpdateOperationsInput | string | null
    cityDe?: NullableStringFieldUpdateOperationsInput | string | null
    addressDe?: NullableStringFieldUpdateOperationsInput | string | null
    nameFr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFr?: NullableStringFieldUpdateOperationsInput | string | null
    cityFr?: NullableStringFieldUpdateOperationsInput | string | null
    addressFr?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    showMap?: BoolFieldUpdateOperationsInput | boolean
    showQrScanner?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tours?: TourUncheckedUpdateManyWithoutMuseumNestedInput
  }

  export type MuseumCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    city?: string | null
    address?: string | null
    nameEn?: string | null
    descriptionEn?: string | null
    cityEn?: string | null
    addressEn?: string | null
    nameRu?: string | null
    descriptionRu?: string | null
    cityRu?: string | null
    addressRu?: string | null
    nameDe?: string | null
    descriptionDe?: string | null
    cityDe?: string | null
    addressDe?: string | null
    nameFr?: string | null
    descriptionFr?: string | null
    cityFr?: string | null
    addressFr?: string | null
    slug: string
    coverImage?: string | null
    latitude?: number | null
    longitude?: number | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    showMap?: boolean
    showQrScanner?: boolean
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MuseumUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    cityEn?: NullableStringFieldUpdateOperationsInput | string | null
    addressEn?: NullableStringFieldUpdateOperationsInput | string | null
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionRu?: NullableStringFieldUpdateOperationsInput | string | null
    cityRu?: NullableStringFieldUpdateOperationsInput | string | null
    addressRu?: NullableStringFieldUpdateOperationsInput | string | null
    nameDe?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionDe?: NullableStringFieldUpdateOperationsInput | string | null
    cityDe?: NullableStringFieldUpdateOperationsInput | string | null
    addressDe?: NullableStringFieldUpdateOperationsInput | string | null
    nameFr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFr?: NullableStringFieldUpdateOperationsInput | string | null
    cityFr?: NullableStringFieldUpdateOperationsInput | string | null
    addressFr?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    showMap?: BoolFieldUpdateOperationsInput | boolean
    showQrScanner?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuseumUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    cityEn?: NullableStringFieldUpdateOperationsInput | string | null
    addressEn?: NullableStringFieldUpdateOperationsInput | string | null
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionRu?: NullableStringFieldUpdateOperationsInput | string | null
    cityRu?: NullableStringFieldUpdateOperationsInput | string | null
    addressRu?: NullableStringFieldUpdateOperationsInput | string | null
    nameDe?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionDe?: NullableStringFieldUpdateOperationsInput | string | null
    cityDe?: NullableStringFieldUpdateOperationsInput | string | null
    addressDe?: NullableStringFieldUpdateOperationsInput | string | null
    nameFr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFr?: NullableStringFieldUpdateOperationsInput | string | null
    cityFr?: NullableStringFieldUpdateOperationsInput | string | null
    addressFr?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    showMap?: BoolFieldUpdateOperationsInput | boolean
    showQrScanner?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    museum: MuseumCreateNestedOneWithoutToursInput
  }

  export type TourUncheckedCreateInput = {
    id?: string
    museumId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    museum?: MuseumUpdateOneRequiredWithoutToursNestedInput
  }

  export type TourUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    museumId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourCreateManyInput = {
    id?: string
    museumId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    museumId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumPlanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeFilter<$PrismaModel> | $Enums.PlanType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BatchListRelationFilter = {
    every?: BatchWhereInput
    some?: BatchWhereInput
    none?: BatchWhereInput
  }

  export type BudgetListRelationFilter = {
    every?: BudgetWhereInput
    some?: BudgetWhereInput
    none?: BudgetWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type EquipmentListRelationFilter = {
    every?: EquipmentWhereInput
    some?: EquipmentWhereInput
    none?: EquipmentWhereInput
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type InventoryItemListRelationFilter = {
    every?: InventoryItemWhereInput
    some?: InventoryItemWhereInput
    none?: InventoryItemWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type KegListRelationFilter = {
    every?: KegWhereInput
    some?: KegWhereInput
    none?: KegWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type RecipeListRelationFilter = {
    every?: RecipeWhereInput
    some?: RecipeWhereInput
    none?: RecipeWhereInput
  }

  export type SalesOrderListRelationFilter = {
    every?: SalesOrderWhereInput
    some?: SalesOrderWhereInput
    none?: SalesOrderWhereInput
  }

  export type SupplierListRelationFilter = {
    every?: SupplierWhereInput
    some?: SupplierWhereInput
    none?: SupplierWhereInput
  }

  export type TankListRelationFilter = {
    every?: TankWhereInput
    some?: TankWhereInput
    none?: TankWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudgetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KegOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TankOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    plan?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    legalName?: SortOrder
    taxId?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    website?: SortOrder
    bankName?: SortOrder
    bankAccount?: SortOrder
    bankSwift?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    plan?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    legalName?: SortOrder
    taxId?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    website?: SortOrder
    bankName?: SortOrder
    bankAccount?: SortOrder
    bankSwift?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    plan?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
    legalName?: SortOrder
    taxId?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    website?: SortOrder
    bankName?: SortOrder
    bankAccount?: SortOrder
    bankSwift?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumPlanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TenantRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type UserTenantIdEmailCompoundUniqueInput = {
    tenantId: string
    email: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumRecipeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RecipeStatus | EnumRecipeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecipeStatus[] | ListEnumRecipeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecipeStatus[] | ListEnumRecipeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecipeStatusFilter<$PrismaModel> | $Enums.RecipeStatus
  }

  export type RecipeIngredientListRelationFilter = {
    every?: RecipeIngredientWhereInput
    some?: RecipeIngredientWhereInput
    none?: RecipeIngredientWhereInput
  }

  export type RecipeIngredientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeTenantIdNameCompoundUniqueInput = {
    tenantId: string
    name: string
  }

  export type RecipeCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    createdBy?: SortOrder
    name?: SortOrder
    style?: SortOrder
    abv?: SortOrder
    ibu?: SortOrder
    color?: SortOrder
    og?: SortOrder
    fg?: SortOrder
    batchSize?: SortOrder
    boilTime?: SortOrder
    efficiency?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    process?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yeastStrain?: SortOrder
  }

  export type RecipeAvgOrderByAggregateInput = {
    abv?: SortOrder
    ibu?: SortOrder
    color?: SortOrder
    og?: SortOrder
    fg?: SortOrder
    batchSize?: SortOrder
    boilTime?: SortOrder
    efficiency?: SortOrder
  }

  export type RecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    createdBy?: SortOrder
    name?: SortOrder
    style?: SortOrder
    abv?: SortOrder
    ibu?: SortOrder
    color?: SortOrder
    og?: SortOrder
    fg?: SortOrder
    batchSize?: SortOrder
    boilTime?: SortOrder
    efficiency?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yeastStrain?: SortOrder
  }

  export type RecipeMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    createdBy?: SortOrder
    name?: SortOrder
    style?: SortOrder
    abv?: SortOrder
    ibu?: SortOrder
    color?: SortOrder
    og?: SortOrder
    fg?: SortOrder
    batchSize?: SortOrder
    boilTime?: SortOrder
    efficiency?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yeastStrain?: SortOrder
  }

  export type RecipeSumOrderByAggregateInput = {
    abv?: SortOrder
    ibu?: SortOrder
    color?: SortOrder
    og?: SortOrder
    fg?: SortOrder
    batchSize?: SortOrder
    boilTime?: SortOrder
    efficiency?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumRecipeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecipeStatus | EnumRecipeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecipeStatus[] | ListEnumRecipeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecipeStatus[] | ListEnumRecipeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecipeStatusWithAggregatesFilter<$PrismaModel> | $Enums.RecipeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecipeStatusFilter<$PrismaModel>
    _max?: NestedEnumRecipeStatusFilter<$PrismaModel>
  }

  export type EnumIngredientCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.IngredientCategory | EnumIngredientCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IngredientCategory[] | ListEnumIngredientCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.IngredientCategory[] | ListEnumIngredientCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumIngredientCategoryFilter<$PrismaModel> | $Enums.IngredientCategory
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type InventoryItemNullableRelationFilter = {
    is?: InventoryItemWhereInput | null
    isNot?: InventoryItemWhereInput | null
  }

  export type RecipeRelationFilter = {
    is?: RecipeWhereInput
    isNot?: RecipeWhereInput
  }

  export type RecipeIngredientCountOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    inventoryItemId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    additionTime?: SortOrder
    specs?: SortOrder
  }

  export type RecipeIngredientAvgOrderByAggregateInput = {
    amount?: SortOrder
    additionTime?: SortOrder
  }

  export type RecipeIngredientMaxOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    inventoryItemId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    additionTime?: SortOrder
  }

  export type RecipeIngredientMinOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    inventoryItemId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    additionTime?: SortOrder
  }

  export type RecipeIngredientSumOrderByAggregateInput = {
    amount?: SortOrder
    additionTime?: SortOrder
  }

  export type EnumIngredientCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IngredientCategory | EnumIngredientCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IngredientCategory[] | ListEnumIngredientCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.IngredientCategory[] | ListEnumIngredientCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumIngredientCategoryWithAggregatesFilter<$PrismaModel> | $Enums.IngredientCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIngredientCategoryFilter<$PrismaModel>
    _max?: NestedEnumIngredientCategoryFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumInventoryCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryCategory | EnumInventoryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryCategory[] | ListEnumInventoryCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryCategory[] | ListEnumInventoryCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryCategoryFilter<$PrismaModel> | $Enums.InventoryCategory
  }

  export type InventoryLedgerListRelationFilter = {
    every?: InventoryLedgerWhereInput
    some?: InventoryLedgerWhereInput
    none?: InventoryLedgerWhereInput
  }

  export type InventoryLedgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryItemTenantIdSkuCompoundUniqueInput = {
    tenantId: string
    sku: string
  }

  export type InventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    category?: SortOrder
    ingredientType?: SortOrder
    unit?: SortOrder
    reorderPoint?: SortOrder
    supplier?: SortOrder
    location?: SortOrder
    specs?: SortOrder
    cachedBalance?: SortOrder
    costPerUnit?: SortOrder
    balanceUpdatedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemAvgOrderByAggregateInput = {
    reorderPoint?: SortOrder
    cachedBalance?: SortOrder
    costPerUnit?: SortOrder
  }

  export type InventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    category?: SortOrder
    ingredientType?: SortOrder
    unit?: SortOrder
    reorderPoint?: SortOrder
    supplier?: SortOrder
    location?: SortOrder
    cachedBalance?: SortOrder
    costPerUnit?: SortOrder
    balanceUpdatedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    category?: SortOrder
    ingredientType?: SortOrder
    unit?: SortOrder
    reorderPoint?: SortOrder
    supplier?: SortOrder
    location?: SortOrder
    cachedBalance?: SortOrder
    costPerUnit?: SortOrder
    balanceUpdatedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemSumOrderByAggregateInput = {
    reorderPoint?: SortOrder
    cachedBalance?: SortOrder
    costPerUnit?: SortOrder
  }

  export type EnumInventoryCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryCategory | EnumInventoryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryCategory[] | ListEnumInventoryCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryCategory[] | ListEnumInventoryCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryCategoryWithAggregatesFilter<$PrismaModel> | $Enums.InventoryCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryCategoryFilter<$PrismaModel>
    _max?: NestedEnumInventoryCategoryFilter<$PrismaModel>
  }

  export type EnumLedgerEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryType | EnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryTypeFilter<$PrismaModel> | $Enums.LedgerEntryType
  }

  export type BatchNullableRelationFilter = {
    is?: BatchWhereInput | null
    isNot?: BatchWhereInput | null
  }

  export type InventoryItemRelationFilter = {
    is?: InventoryItemWhereInput
    isNot?: InventoryItemWhereInput
  }

  export type InventoryLedgerCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    batchId?: SortOrder
    orderId?: SortOrder
    packagingId?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryLedgerAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type InventoryLedgerMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    batchId?: SortOrder
    orderId?: SortOrder
    packagingId?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryLedgerMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    type?: SortOrder
    batchId?: SortOrder
    orderId?: SortOrder
    packagingId?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryLedgerSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumLedgerEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryType | EnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.LedgerEntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumLedgerEntryTypeFilter<$PrismaModel>
  }

  export type IngredientCatalogCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    supplier?: SortOrder
    origin?: SortOrder
    specs?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IngredientCatalogMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    supplier?: SortOrder
    origin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IngredientCatalogMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    supplier?: SortOrder
    origin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusFilter<$PrismaModel> | $Enums.BatchStatus
  }

  export type TankNullableRelationFilter = {
    is?: TankWhereInput | null
    isNot?: TankWhereInput | null
  }

  export type BatchIngredientListRelationFilter = {
    every?: BatchIngredientWhereInput
    some?: BatchIngredientWhereInput
    none?: BatchIngredientWhereInput
  }

  export type BatchTimelineListRelationFilter = {
    every?: BatchTimelineWhereInput
    some?: BatchTimelineWhereInput
    none?: BatchTimelineWhereInput
  }

  export type GravityReadingListRelationFilter = {
    every?: GravityReadingWhereInput
    some?: GravityReadingWhereInput
    none?: GravityReadingWhereInput
  }

  export type LotBatchListRelationFilter = {
    every?: LotBatchWhereInput
    some?: LotBatchWhereInput
    none?: LotBatchWhereInput
  }

  export type PackagingRunListRelationFilter = {
    every?: PackagingRunWhereInput
    some?: PackagingRunWhereInput
    none?: PackagingRunWhereInput
  }

  export type QCTestListRelationFilter = {
    every?: QCTestWhereInput
    some?: QCTestWhereInput
    none?: QCTestWhereInput
  }

  export type BatchIngredientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BatchTimelineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GravityReadingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LotBatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PackagingRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QCTestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BatchTenantIdBatchNumberCompoundUniqueInput = {
    tenantId: string
    batchNumber: string
  }

  export type BatchCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    batchNumber?: SortOrder
    recipeId?: SortOrder
    status?: SortOrder
    volume?: SortOrder
    packagedVolume?: SortOrder
    originalGravity?: SortOrder
    currentGravity?: SortOrder
    finalGravity?: SortOrder
    abv?: SortOrder
    tankId?: SortOrder
    plannedDate?: SortOrder
    brewedAt?: SortOrder
    fermentationStartedAt?: SortOrder
    conditioningStartedAt?: SortOrder
    readyAt?: SortOrder
    completedAt?: SortOrder
    createdBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    targetOg?: SortOrder
    fermentationTankId?: SortOrder
  }

  export type BatchAvgOrderByAggregateInput = {
    volume?: SortOrder
    packagedVolume?: SortOrder
    originalGravity?: SortOrder
    currentGravity?: SortOrder
    finalGravity?: SortOrder
    abv?: SortOrder
    targetOg?: SortOrder
  }

  export type BatchMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    batchNumber?: SortOrder
    recipeId?: SortOrder
    status?: SortOrder
    volume?: SortOrder
    packagedVolume?: SortOrder
    originalGravity?: SortOrder
    currentGravity?: SortOrder
    finalGravity?: SortOrder
    abv?: SortOrder
    tankId?: SortOrder
    plannedDate?: SortOrder
    brewedAt?: SortOrder
    fermentationStartedAt?: SortOrder
    conditioningStartedAt?: SortOrder
    readyAt?: SortOrder
    completedAt?: SortOrder
    createdBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    targetOg?: SortOrder
    fermentationTankId?: SortOrder
  }

  export type BatchMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    batchNumber?: SortOrder
    recipeId?: SortOrder
    status?: SortOrder
    volume?: SortOrder
    packagedVolume?: SortOrder
    originalGravity?: SortOrder
    currentGravity?: SortOrder
    finalGravity?: SortOrder
    abv?: SortOrder
    tankId?: SortOrder
    plannedDate?: SortOrder
    brewedAt?: SortOrder
    fermentationStartedAt?: SortOrder
    conditioningStartedAt?: SortOrder
    readyAt?: SortOrder
    completedAt?: SortOrder
    createdBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    targetOg?: SortOrder
    fermentationTankId?: SortOrder
  }

  export type BatchSumOrderByAggregateInput = {
    volume?: SortOrder
    packagedVolume?: SortOrder
    originalGravity?: SortOrder
    currentGravity?: SortOrder
    finalGravity?: SortOrder
    abv?: SortOrder
    targetOg?: SortOrder
  }

  export type EnumBatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.BatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBatchStatusFilter<$PrismaModel>
    _max?: NestedEnumBatchStatusFilter<$PrismaModel>
  }

  export type BatchRelationFilter = {
    is?: BatchWhereInput
    isNot?: BatchWhereInput
  }

  export type BatchIngredientCountOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    inventoryItemId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    plannedAmount?: SortOrder
    actualAmount?: SortOrder
    unit?: SortOrder
    lotNumber?: SortOrder
    addedAt?: SortOrder
  }

  export type BatchIngredientAvgOrderByAggregateInput = {
    plannedAmount?: SortOrder
    actualAmount?: SortOrder
  }

  export type BatchIngredientMaxOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    inventoryItemId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    plannedAmount?: SortOrder
    actualAmount?: SortOrder
    unit?: SortOrder
    lotNumber?: SortOrder
    addedAt?: SortOrder
  }

  export type BatchIngredientMinOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    inventoryItemId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    plannedAmount?: SortOrder
    actualAmount?: SortOrder
    unit?: SortOrder
    lotNumber?: SortOrder
    addedAt?: SortOrder
  }

  export type BatchIngredientSumOrderByAggregateInput = {
    plannedAmount?: SortOrder
    actualAmount?: SortOrder
  }

  export type GravityReadingCountOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    gravity?: SortOrder
    temperature?: SortOrder
    notes?: SortOrder
    recordedBy?: SortOrder
    recordedAt?: SortOrder
  }

  export type GravityReadingAvgOrderByAggregateInput = {
    gravity?: SortOrder
    temperature?: SortOrder
  }

  export type GravityReadingMaxOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    gravity?: SortOrder
    temperature?: SortOrder
    notes?: SortOrder
    recordedBy?: SortOrder
    recordedAt?: SortOrder
  }

  export type GravityReadingMinOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    gravity?: SortOrder
    temperature?: SortOrder
    notes?: SortOrder
    recordedBy?: SortOrder
    recordedAt?: SortOrder
  }

  export type GravityReadingSumOrderByAggregateInput = {
    gravity?: SortOrder
    temperature?: SortOrder
  }

  export type EnumTimelineEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TimelineEventType | EnumTimelineEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TimelineEventType[] | ListEnumTimelineEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimelineEventType[] | ListEnumTimelineEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTimelineEventTypeFilter<$PrismaModel> | $Enums.TimelineEventType
  }

  export type BatchTimelineCountOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    data?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type BatchTimelineMaxOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type BatchTimelineMinOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumTimelineEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TimelineEventType | EnumTimelineEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TimelineEventType[] | ListEnumTimelineEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimelineEventType[] | ListEnumTimelineEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTimelineEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.TimelineEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTimelineEventTypeFilter<$PrismaModel>
    _max?: NestedEnumTimelineEventTypeFilter<$PrismaModel>
  }

  export type EnumTankTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TankType | EnumTankTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TankType[] | ListEnumTankTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TankType[] | ListEnumTankTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTankTypeFilter<$PrismaModel> | $Enums.TankType
  }

  export type EnumTankStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TankStatus | EnumTankStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TankStatus[] | ListEnumTankStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TankStatus[] | ListEnumTankStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTankStatusFilter<$PrismaModel> | $Enums.TankStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumTankCapabilityNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.TankCapability[] | ListEnumTankCapabilityFieldRefInput<$PrismaModel> | null
    has?: $Enums.TankCapability | EnumTankCapabilityFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.TankCapability[] | ListEnumTankCapabilityFieldRefInput<$PrismaModel>
    hasSome?: $Enums.TankCapability[] | ListEnumTankCapabilityFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumLotPhaseNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LotPhase | EnumLotPhaseFieldRefInput<$PrismaModel> | null
    in?: $Enums.LotPhase[] | ListEnumLotPhaseFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LotPhase[] | ListEnumLotPhaseFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLotPhaseNullableFilter<$PrismaModel> | $Enums.LotPhase | null
  }

  export type LotReadingListRelationFilter = {
    every?: LotReadingWhereInput
    some?: LotReadingWhereInput
    none?: LotReadingWhereInput
  }

  export type TankAssignmentListRelationFilter = {
    every?: TankAssignmentWhereInput
    some?: TankAssignmentWhereInput
    none?: TankAssignmentWhereInput
  }

  export type TankOccupationListRelationFilter = {
    every?: TankOccupationWhereInput
    some?: TankOccupationWhereInput
    none?: TankOccupationWhereInput
  }

  export type TransferListRelationFilter = {
    every?: TransferWhereInput
    some?: TransferWhereInput
    none?: TransferWhereInput
  }

  export type LotReadingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TankAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TankOccupationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TankTenantIdNameCompoundUniqueInput = {
    tenantId: string
    name: string
  }

  export type TankCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    currentBatchId?: SortOrder
    location?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    capabilities?: SortOrder
    currentLotId?: SortOrder
    currentPhase?: SortOrder
    defaultTurnaroundHours?: SortOrder
    maxFillPercent?: SortOrder
    minFillPercent?: SortOrder
  }

  export type TankAvgOrderByAggregateInput = {
    capacity?: SortOrder
    version?: SortOrder
    defaultTurnaroundHours?: SortOrder
    maxFillPercent?: SortOrder
    minFillPercent?: SortOrder
  }

  export type TankMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    currentBatchId?: SortOrder
    location?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentLotId?: SortOrder
    currentPhase?: SortOrder
    defaultTurnaroundHours?: SortOrder
    maxFillPercent?: SortOrder
    minFillPercent?: SortOrder
  }

  export type TankMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    currentBatchId?: SortOrder
    location?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentLotId?: SortOrder
    currentPhase?: SortOrder
    defaultTurnaroundHours?: SortOrder
    maxFillPercent?: SortOrder
    minFillPercent?: SortOrder
  }

  export type TankSumOrderByAggregateInput = {
    capacity?: SortOrder
    version?: SortOrder
    defaultTurnaroundHours?: SortOrder
    maxFillPercent?: SortOrder
    minFillPercent?: SortOrder
  }

  export type EnumTankTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TankType | EnumTankTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TankType[] | ListEnumTankTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TankType[] | ListEnumTankTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTankTypeWithAggregatesFilter<$PrismaModel> | $Enums.TankType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTankTypeFilter<$PrismaModel>
    _max?: NestedEnumTankTypeFilter<$PrismaModel>
  }

  export type EnumTankStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TankStatus | EnumTankStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TankStatus[] | ListEnumTankStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TankStatus[] | ListEnumTankStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTankStatusWithAggregatesFilter<$PrismaModel> | $Enums.TankStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTankStatusFilter<$PrismaModel>
    _max?: NestedEnumTankStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumLotPhaseNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LotPhase | EnumLotPhaseFieldRefInput<$PrismaModel> | null
    in?: $Enums.LotPhase[] | ListEnumLotPhaseFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LotPhase[] | ListEnumLotPhaseFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLotPhaseNullableWithAggregatesFilter<$PrismaModel> | $Enums.LotPhase | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLotPhaseNullableFilter<$PrismaModel>
    _max?: NestedEnumLotPhaseNullableFilter<$PrismaModel>
  }

  export type EnumOccupationPhaseFilter<$PrismaModel = never> = {
    equals?: $Enums.OccupationPhase | EnumOccupationPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.OccupationPhase[] | ListEnumOccupationPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccupationPhase[] | ListEnumOccupationPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumOccupationPhaseFilter<$PrismaModel> | $Enums.OccupationPhase
  }

  export type TankRelationFilter = {
    is?: TankWhereInput
    isNot?: TankWhereInput
  }

  export type TankOccupationCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tankId?: SortOrder
    batchId?: SortOrder
    phase?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
  }

  export type TankOccupationMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tankId?: SortOrder
    batchId?: SortOrder
    phase?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
  }

  export type TankOccupationMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tankId?: SortOrder
    batchId?: SortOrder
    phase?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
  }

  export type EnumOccupationPhaseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OccupationPhase | EnumOccupationPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.OccupationPhase[] | ListEnumOccupationPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccupationPhase[] | ListEnumOccupationPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumOccupationPhaseWithAggregatesFilter<$PrismaModel> | $Enums.OccupationPhase
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOccupationPhaseFilter<$PrismaModel>
    _max?: NestedEnumOccupationPhaseFilter<$PrismaModel>
  }

  export type EnumPackageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PackageType | EnumPackageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPackageTypeFilter<$PrismaModel> | $Enums.PackageType
  }

  export type PackagingRunCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    batchId?: SortOrder
    packageType?: SortOrder
    quantity?: SortOrder
    volumeTotal?: SortOrder
    lotNumber?: SortOrder
    performedBy?: SortOrder
    notes?: SortOrder
    performedAt?: SortOrder
  }

  export type PackagingRunAvgOrderByAggregateInput = {
    quantity?: SortOrder
    volumeTotal?: SortOrder
  }

  export type PackagingRunMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    batchId?: SortOrder
    packageType?: SortOrder
    quantity?: SortOrder
    volumeTotal?: SortOrder
    lotNumber?: SortOrder
    performedBy?: SortOrder
    notes?: SortOrder
    performedAt?: SortOrder
  }

  export type PackagingRunMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    batchId?: SortOrder
    packageType?: SortOrder
    quantity?: SortOrder
    volumeTotal?: SortOrder
    lotNumber?: SortOrder
    performedBy?: SortOrder
    notes?: SortOrder
    performedAt?: SortOrder
  }

  export type PackagingRunSumOrderByAggregateInput = {
    quantity?: SortOrder
    volumeTotal?: SortOrder
  }

  export type EnumPackageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PackageType | EnumPackageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPackageTypeWithAggregatesFilter<$PrismaModel> | $Enums.PackageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPackageTypeFilter<$PrismaModel>
    _max?: NestedEnumPackageTypeFilter<$PrismaModel>
  }

  export type EnumCustomerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeFilter<$PrismaModel> | $Enums.CustomerType
  }

  export type CustomerTenantIdNameCompoundUniqueInput = {
    tenantId: string
    name: string
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    taxId?: SortOrder
    kegReturnDays?: SortOrder
    kegDepositRequired?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    kegReturnDays?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    taxId?: SortOrder
    kegReturnDays?: SortOrder
    kegDepositRequired?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    taxId?: SortOrder
    kegReturnDays?: SortOrder
    kegDepositRequired?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    kegReturnDays?: SortOrder
  }

  export type EnumCustomerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomerTypeFilter<$PrismaModel>
  }

  export type SupplierTenantIdNameCompoundUniqueInput = {
    tenantId: string
    name: string
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    taxId?: SortOrder
    bankAccount?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    taxId?: SortOrder
    bankAccount?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    taxId?: SortOrder
    bankAccount?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type InvoiceNullableRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type CustomerRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesOrderTenantIdOrderNumberCompoundUniqueInput = {
    tenantId: string
    orderNumber: string
  }

  export type SalesOrderCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    notes?: SortOrder
    orderedAt?: SortOrder
    shippedAt?: SortOrder
    deliveredAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesOrderAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type SalesOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    notes?: SortOrder
    orderedAt?: SortOrder
    shippedAt?: SortOrder
    deliveredAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesOrderMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    notes?: SortOrder
    orderedAt?: SortOrder
    shippedAt?: SortOrder
    deliveredAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesOrderSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type SalesOrderRelationFilter = {
    is?: SalesOrderWhereInput
    isNot?: SalesOrderWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productName?: SortOrder
    packageType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    batchId?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productName?: SortOrder
    packageType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    batchId?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productName?: SortOrder
    packageType?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    batchId?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumIncomeCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeCategory | EnumIncomeCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.IncomeCategory[] | ListEnumIncomeCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IncomeCategory[] | ListEnumIncomeCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIncomeCategoryNullableFilter<$PrismaModel> | $Enums.IncomeCategory | null
  }

  export type EnumExpenseCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumExpenseCategoryNullableFilter<$PrismaModel> | $Enums.ExpenseCategory | null
  }

  export type EnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type CustomerNullableRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type ExpenseNullableRelationFilter = {
    is?: ExpenseWhereInput | null
    isNot?: ExpenseWhereInput | null
  }

  export type SalesOrderNullableRelationFilter = {
    is?: SalesOrderWhereInput | null
    isNot?: SalesOrderWhereInput | null
  }

  export type SupplierNullableRelationFilter = {
    is?: SupplierWhereInput | null
    isNot?: SupplierWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    incomeCategory?: SortOrder
    expenseCategory?: SortOrder
    description?: SortOrder
    customerId?: SortOrder
    supplierId?: SortOrder
    orderId?: SortOrder
    invoiceId?: SortOrder
    expenseId?: SortOrder
    paymentId?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    incomeCategory?: SortOrder
    expenseCategory?: SortOrder
    description?: SortOrder
    customerId?: SortOrder
    supplierId?: SortOrder
    orderId?: SortOrder
    invoiceId?: SortOrder
    expenseId?: SortOrder
    paymentId?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    type?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    incomeCategory?: SortOrder
    expenseCategory?: SortOrder
    description?: SortOrder
    customerId?: SortOrder
    supplierId?: SortOrder
    orderId?: SortOrder
    invoiceId?: SortOrder
    expenseId?: SortOrder
    paymentId?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumIncomeCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeCategory | EnumIncomeCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.IncomeCategory[] | ListEnumIncomeCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IncomeCategory[] | ListEnumIncomeCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIncomeCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.IncomeCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumIncomeCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumIncomeCategoryNullableFilter<$PrismaModel>
  }

  export type EnumExpenseCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumExpenseCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumExpenseCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumExpenseCategoryNullableFilter<$PrismaModel>
  }

  export type EnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type EnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceTenantIdInvoiceNumberCompoundUniqueInput = {
    tenantId: string
    invoiceNumber: string
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    customerId?: SortOrder
    supplierId?: SortOrder
    orderId?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    notes?: SortOrder
    terms?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    customerId?: SortOrder
    supplierId?: SortOrder
    orderId?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    notes?: SortOrder
    terms?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    customerId?: SortOrder
    supplierId?: SortOrder
    orderId?: SortOrder
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    notes?: SortOrder
    terms?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    discount?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
  }

  export type EnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type EnumPackageTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PackageType | EnumPackageTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPackageTypeNullableFilter<$PrismaModel> | $Enums.PackageType | null
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    productName?: SortOrder
    packageType?: SortOrder
    batchId?: SortOrder
    sortOrder?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    sortOrder?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    productName?: SortOrder
    packageType?: SortOrder
    batchId?: SortOrder
    sortOrder?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    productName?: SortOrder
    packageType?: SortOrder
    batchId?: SortOrder
    sortOrder?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    sortOrder?: SortOrder
  }

  export type EnumPackageTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PackageType | EnumPackageTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPackageTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PackageType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPackageTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPackageTypeNullableFilter<$PrismaModel>
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    date?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    date?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    date?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumExpenseCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseCategoryFilter<$PrismaModel> | $Enums.ExpenseCategory
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    category?: SortOrder
    supplierId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    invoiceNumber?: SortOrder
    invoiceId?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrder
    paymentMethod?: SortOrder
    receiptUrl?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    category?: SortOrder
    supplierId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    invoiceNumber?: SortOrder
    invoiceId?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrder
    paymentMethod?: SortOrder
    receiptUrl?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    category?: SortOrder
    supplierId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    description?: SortOrder
    invoiceNumber?: SortOrder
    invoiceId?: SortOrder
    isPaid?: SortOrder
    paidAt?: SortOrder
    paymentMethod?: SortOrder
    receiptUrl?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumExpenseCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseCategoryFilter<$PrismaModel>
    _max?: NestedEnumExpenseCategoryFilter<$PrismaModel>
  }

  export type BudgetTenantIdCategoryYearMonthCompoundUniqueInput = {
    tenantId: string
    category: $Enums.ExpenseCategory
    year: number
    month: number
  }

  export type BudgetCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    category?: SortOrder
    year?: SortOrder
    month?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetAvgOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
    amount?: SortOrder
  }

  export type BudgetMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    category?: SortOrder
    year?: SortOrder
    month?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    category?: SortOrder
    year?: SortOrder
    month?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetSumOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
    amount?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldData?: SortOrder
    newData?: SortOrder
    metadata?: SortOrder
    correlationId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    correlationId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    correlationId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type BlendingConfigCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    requireRecipeMatch?: SortOrder
    requireYeastMatch?: SortOrder
    requirePhaseMatch?: SortOrder
    requireStyleMatch?: SortOrder
    maxBlendSources?: SortOrder
    allowOverCapacity?: SortOrder
    maxAgeDifferenceHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlendingConfigAvgOrderByAggregateInput = {
    maxBlendSources?: SortOrder
    maxAgeDifferenceHours?: SortOrder
  }

  export type BlendingConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    requireRecipeMatch?: SortOrder
    requireYeastMatch?: SortOrder
    requirePhaseMatch?: SortOrder
    requireStyleMatch?: SortOrder
    maxBlendSources?: SortOrder
    allowOverCapacity?: SortOrder
    maxAgeDifferenceHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlendingConfigMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    requireRecipeMatch?: SortOrder
    requireYeastMatch?: SortOrder
    requirePhaseMatch?: SortOrder
    requireStyleMatch?: SortOrder
    maxBlendSources?: SortOrder
    allowOverCapacity?: SortOrder
    maxAgeDifferenceHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlendingConfigSumOrderByAggregateInput = {
    maxBlendSources?: SortOrder
    maxAgeDifferenceHours?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EquipmentRelationFilter = {
    is?: EquipmentWhereInput
    isNot?: EquipmentWhereInput
  }

  export type CIPLogCountOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    cipType?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    temperature?: SortOrder
    causticConcentration?: SortOrder
    performedBy?: SortOrder
    result?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type CIPLogAvgOrderByAggregateInput = {
    duration?: SortOrder
    temperature?: SortOrder
    causticConcentration?: SortOrder
  }

  export type CIPLogMaxOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    cipType?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    temperature?: SortOrder
    causticConcentration?: SortOrder
    performedBy?: SortOrder
    result?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type CIPLogMinOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    cipType?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    temperature?: SortOrder
    causticConcentration?: SortOrder
    performedBy?: SortOrder
    result?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type CIPLogSumOrderByAggregateInput = {
    duration?: SortOrder
    temperature?: SortOrder
    causticConcentration?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CIPLogListRelationFilter = {
    every?: CIPLogWhereInput
    some?: CIPLogWhereInput
    none?: CIPLogWhereInput
  }

  export type MaintenanceLogListRelationFilter = {
    every?: MaintenanceLogWhereInput
    some?: MaintenanceLogWhereInput
    none?: MaintenanceLogWhereInput
  }

  export type ProblemReportListRelationFilter = {
    every?: ProblemReportWhereInput
    some?: ProblemReportWhereInput
    none?: ProblemReportWhereInput
  }

  export type CIPLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaintenanceLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProblemReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    serialNumber?: SortOrder
    location?: SortOrder
    workingPressure?: SortOrder
    currentTemp?: SortOrder
    currentPressure?: SortOrder
    installationDate?: SortOrder
    warrantyDate?: SortOrder
    lastCIP?: SortOrder
    nextCIP?: SortOrder
    lastMaintenance?: SortOrder
    nextMaintenance?: SortOrder
    cipIntervalDays?: SortOrder
    inspectionIntervalDays?: SortOrder
    annualMaintenanceDays?: SortOrder
    currentBatchId?: SortOrder
    currentBatchNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseDate?: SortOrder
    capabilities?: SortOrder
  }

  export type EquipmentAvgOrderByAggregateInput = {
    capacity?: SortOrder
    workingPressure?: SortOrder
    currentTemp?: SortOrder
    currentPressure?: SortOrder
    cipIntervalDays?: SortOrder
    inspectionIntervalDays?: SortOrder
    annualMaintenanceDays?: SortOrder
  }

  export type EquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    serialNumber?: SortOrder
    location?: SortOrder
    workingPressure?: SortOrder
    currentTemp?: SortOrder
    currentPressure?: SortOrder
    installationDate?: SortOrder
    warrantyDate?: SortOrder
    lastCIP?: SortOrder
    nextCIP?: SortOrder
    lastMaintenance?: SortOrder
    nextMaintenance?: SortOrder
    cipIntervalDays?: SortOrder
    inspectionIntervalDays?: SortOrder
    annualMaintenanceDays?: SortOrder
    currentBatchId?: SortOrder
    currentBatchNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseDate?: SortOrder
  }

  export type EquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    serialNumber?: SortOrder
    location?: SortOrder
    workingPressure?: SortOrder
    currentTemp?: SortOrder
    currentPressure?: SortOrder
    installationDate?: SortOrder
    warrantyDate?: SortOrder
    lastCIP?: SortOrder
    nextCIP?: SortOrder
    lastMaintenance?: SortOrder
    nextMaintenance?: SortOrder
    cipIntervalDays?: SortOrder
    inspectionIntervalDays?: SortOrder
    annualMaintenanceDays?: SortOrder
    currentBatchId?: SortOrder
    currentBatchNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseDate?: SortOrder
  }

  export type EquipmentSumOrderByAggregateInput = {
    capacity?: SortOrder
    workingPressure?: SortOrder
    currentTemp?: SortOrder
    currentPressure?: SortOrder
    cipIntervalDays?: SortOrder
    inspectionIntervalDays?: SortOrder
    annualMaintenanceDays?: SortOrder
  }

  export type EnumLotPhaseFilter<$PrismaModel = never> = {
    equals?: $Enums.LotPhase | EnumLotPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.LotPhase[] | ListEnumLotPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.LotPhase[] | ListEnumLotPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumLotPhaseFilter<$PrismaModel> | $Enums.LotPhase
  }

  export type EnumLotStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LotStatus | EnumLotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LotStatus[] | ListEnumLotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LotStatus[] | ListEnumLotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLotStatusFilter<$PrismaModel> | $Enums.LotStatus
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type LotNullableRelationFilter = {
    is?: LotWhereInput | null
    isNot?: LotWhereInput | null
  }

  export type LotListRelationFilter = {
    every?: LotWhereInput
    some?: LotWhereInput
    none?: LotWhereInput
  }

  export type LotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LotTenantIdLotCodeCompoundUniqueInput = {
    tenantId: string
    lotCode: string
  }

  export type LotCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    lotCode?: SortOrder
    phase?: SortOrder
    status?: SortOrder
    plannedVolume?: SortOrder
    actualVolume?: SortOrder
    notes?: SortOrder
    parentLotId?: SortOrder
    splitRatio?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    lotNumber?: SortOrder
    blendedAt?: SortOrder
    isBlendResult?: SortOrder
    splitAt?: SortOrder
  }

  export type LotAvgOrderByAggregateInput = {
    plannedVolume?: SortOrder
    actualVolume?: SortOrder
    splitRatio?: SortOrder
  }

  export type LotMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    lotCode?: SortOrder
    phase?: SortOrder
    status?: SortOrder
    plannedVolume?: SortOrder
    actualVolume?: SortOrder
    notes?: SortOrder
    parentLotId?: SortOrder
    splitRatio?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    lotNumber?: SortOrder
    blendedAt?: SortOrder
    isBlendResult?: SortOrder
    splitAt?: SortOrder
  }

  export type LotMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    lotCode?: SortOrder
    phase?: SortOrder
    status?: SortOrder
    plannedVolume?: SortOrder
    actualVolume?: SortOrder
    notes?: SortOrder
    parentLotId?: SortOrder
    splitRatio?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    lotNumber?: SortOrder
    blendedAt?: SortOrder
    isBlendResult?: SortOrder
    splitAt?: SortOrder
  }

  export type LotSumOrderByAggregateInput = {
    plannedVolume?: SortOrder
    actualVolume?: SortOrder
    splitRatio?: SortOrder
  }

  export type EnumLotPhaseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LotPhase | EnumLotPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.LotPhase[] | ListEnumLotPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.LotPhase[] | ListEnumLotPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumLotPhaseWithAggregatesFilter<$PrismaModel> | $Enums.LotPhase
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLotPhaseFilter<$PrismaModel>
    _max?: NestedEnumLotPhaseFilter<$PrismaModel>
  }

  export type EnumLotStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LotStatus | EnumLotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LotStatus[] | ListEnumLotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LotStatus[] | ListEnumLotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLotStatusWithAggregatesFilter<$PrismaModel> | $Enums.LotStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLotStatusFilter<$PrismaModel>
    _max?: NestedEnumLotStatusFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type LotRelationFilter = {
    is?: LotWhereInput
    isNot?: LotWhereInput
  }

  export type LotBatchLotIdBatchIdCompoundUniqueInput = {
    lotId: string
    batchId: string
  }

  export type LotBatchCountOrderByAggregateInput = {
    id?: SortOrder
    lotId?: SortOrder
    batchId?: SortOrder
    volumeContribution?: SortOrder
    batchPercentage?: SortOrder
    addedAt?: SortOrder
  }

  export type LotBatchAvgOrderByAggregateInput = {
    volumeContribution?: SortOrder
    batchPercentage?: SortOrder
  }

  export type LotBatchMaxOrderByAggregateInput = {
    id?: SortOrder
    lotId?: SortOrder
    batchId?: SortOrder
    volumeContribution?: SortOrder
    batchPercentage?: SortOrder
    addedAt?: SortOrder
  }

  export type LotBatchMinOrderByAggregateInput = {
    id?: SortOrder
    lotId?: SortOrder
    batchId?: SortOrder
    volumeContribution?: SortOrder
    batchPercentage?: SortOrder
    addedAt?: SortOrder
  }

  export type LotBatchSumOrderByAggregateInput = {
    volumeContribution?: SortOrder
    batchPercentage?: SortOrder
  }

  export type EnumReadingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReadingType | EnumReadingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReadingType[] | ListEnumReadingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReadingType[] | ListEnumReadingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReadingTypeFilter<$PrismaModel> | $Enums.ReadingType
  }

  export type LotReadingCountOrderByAggregateInput = {
    id?: SortOrder
    lotId?: SortOrder
    tankId?: SortOrder
    readingType?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    recordedBy?: SortOrder
    recordedAt?: SortOrder
  }

  export type LotReadingAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type LotReadingMaxOrderByAggregateInput = {
    id?: SortOrder
    lotId?: SortOrder
    tankId?: SortOrder
    readingType?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    recordedBy?: SortOrder
    recordedAt?: SortOrder
  }

  export type LotReadingMinOrderByAggregateInput = {
    id?: SortOrder
    lotId?: SortOrder
    tankId?: SortOrder
    readingType?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    recordedBy?: SortOrder
    recordedAt?: SortOrder
  }

  export type LotReadingSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumReadingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReadingType | EnumReadingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReadingType[] | ListEnumReadingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReadingType[] | ListEnumReadingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReadingTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReadingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReadingTypeFilter<$PrismaModel>
    _max?: NestedEnumReadingTypeFilter<$PrismaModel>
  }

  export type MaintenanceLogCountOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    duration?: SortOrder
    performedBy?: SortOrder
    cost?: SortOrder
    partsUsed?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceLogAvgOrderByAggregateInput = {
    duration?: SortOrder
    cost?: SortOrder
  }

  export type MaintenanceLogMaxOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    duration?: SortOrder
    performedBy?: SortOrder
    cost?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceLogMinOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    duration?: SortOrder
    performedBy?: SortOrder
    cost?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceLogSumOrderByAggregateInput = {
    duration?: SortOrder
    cost?: SortOrder
  }

  export type ProblemReportCountOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    problemType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    description?: SortOrder
    reportedDate?: SortOrder
    reportedBy?: SortOrder
    resolvedDate?: SortOrder
    resolvedBy?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProblemReportMaxOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    problemType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    description?: SortOrder
    reportedDate?: SortOrder
    reportedBy?: SortOrder
    resolvedDate?: SortOrder
    resolvedBy?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProblemReportMinOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    problemType?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    description?: SortOrder
    reportedDate?: SortOrder
    reportedBy?: SortOrder
    resolvedDate?: SortOrder
    resolvedBy?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAssignmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusFilter<$PrismaModel> | $Enums.AssignmentStatus
  }

  export type TankAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tankId?: SortOrder
    lotId?: SortOrder
    phase?: SortOrder
    plannedStart?: SortOrder
    plannedEnd?: SortOrder
    actualStart?: SortOrder
    actualEnd?: SortOrder
    status?: SortOrder
    plannedVolume?: SortOrder
    actualVolume?: SortOrder
    isBlendTarget?: SortOrder
    isSplitSource?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    notes?: SortOrder
  }

  export type TankAssignmentAvgOrderByAggregateInput = {
    plannedVolume?: SortOrder
    actualVolume?: SortOrder
  }

  export type TankAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tankId?: SortOrder
    lotId?: SortOrder
    phase?: SortOrder
    plannedStart?: SortOrder
    plannedEnd?: SortOrder
    actualStart?: SortOrder
    actualEnd?: SortOrder
    status?: SortOrder
    plannedVolume?: SortOrder
    actualVolume?: SortOrder
    isBlendTarget?: SortOrder
    isSplitSource?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    notes?: SortOrder
  }

  export type TankAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tankId?: SortOrder
    lotId?: SortOrder
    phase?: SortOrder
    plannedStart?: SortOrder
    plannedEnd?: SortOrder
    actualStart?: SortOrder
    actualEnd?: SortOrder
    status?: SortOrder
    plannedVolume?: SortOrder
    actualVolume?: SortOrder
    isBlendTarget?: SortOrder
    isSplitSource?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    notes?: SortOrder
  }

  export type TankAssignmentSumOrderByAggregateInput = {
    plannedVolume?: SortOrder
    actualVolume?: SortOrder
  }

  export type EnumAssignmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAssignmentStatusFilter<$PrismaModel>
  }

  export type EnumTransferTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferType | EnumTransferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferTypeFilter<$PrismaModel> | $Enums.TransferType
  }

  export type EnumTransferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusFilter<$PrismaModel> | $Enums.TransferStatus
  }

  export type TransferTenantIdTransferCodeCompoundUniqueInput = {
    tenantId: string
    transferCode: string
  }

  export type TransferCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    transferCode?: SortOrder
    sourceLotId?: SortOrder
    sourceTankId?: SortOrder
    destLotId?: SortOrder
    destTankId?: SortOrder
    transferType?: SortOrder
    volume?: SortOrder
    plannedAt?: SortOrder
    executedAt?: SortOrder
    status?: SortOrder
    measuredLoss?: SortOrder
    lossReason?: SortOrder
    performedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferAvgOrderByAggregateInput = {
    volume?: SortOrder
    measuredLoss?: SortOrder
  }

  export type TransferMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    transferCode?: SortOrder
    sourceLotId?: SortOrder
    sourceTankId?: SortOrder
    destLotId?: SortOrder
    destTankId?: SortOrder
    transferType?: SortOrder
    volume?: SortOrder
    plannedAt?: SortOrder
    executedAt?: SortOrder
    status?: SortOrder
    measuredLoss?: SortOrder
    lossReason?: SortOrder
    performedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    transferCode?: SortOrder
    sourceLotId?: SortOrder
    sourceTankId?: SortOrder
    destLotId?: SortOrder
    destTankId?: SortOrder
    transferType?: SortOrder
    volume?: SortOrder
    plannedAt?: SortOrder
    executedAt?: SortOrder
    status?: SortOrder
    measuredLoss?: SortOrder
    lossReason?: SortOrder
    performedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransferSumOrderByAggregateInput = {
    volume?: SortOrder
    measuredLoss?: SortOrder
  }

  export type EnumTransferTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferType | EnumTransferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransferType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferTypeFilter<$PrismaModel>
    _max?: NestedEnumTransferTypeFilter<$PrismaModel>
  }

  export type EnumTransferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusFilter<$PrismaModel>
  }

  export type EnumKegStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KegStatus | EnumKegStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KegStatus[] | ListEnumKegStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KegStatus[] | ListEnumKegStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKegStatusFilter<$PrismaModel> | $Enums.KegStatus
  }

  export type EnumKegConditionFilter<$PrismaModel = never> = {
    equals?: $Enums.KegCondition | EnumKegConditionFieldRefInput<$PrismaModel>
    in?: $Enums.KegCondition[] | ListEnumKegConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.KegCondition[] | ListEnumKegConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumKegConditionFilter<$PrismaModel> | $Enums.KegCondition
  }

  export type KegMovementListRelationFilter = {
    every?: KegMovementWhereInput
    some?: KegMovementWhereInput
    none?: KegMovementWhereInput
  }

  export type KegMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KegTenantIdKegNumberCompoundUniqueInput = {
    tenantId: string
    kegNumber: string
  }

  export type KegCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kegNumber?: SortOrder
    size?: SortOrder
    status?: SortOrder
    condition?: SortOrder
    batchId?: SortOrder
    filledAt?: SortOrder
    productName?: SortOrder
    lotNumber?: SortOrder
    customerId?: SortOrder
    orderId?: SortOrder
    sentAt?: SortOrder
    returnedAt?: SortOrder
    deposit?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KegAvgOrderByAggregateInput = {
    size?: SortOrder
    deposit?: SortOrder
  }

  export type KegMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kegNumber?: SortOrder
    size?: SortOrder
    status?: SortOrder
    condition?: SortOrder
    batchId?: SortOrder
    filledAt?: SortOrder
    productName?: SortOrder
    lotNumber?: SortOrder
    customerId?: SortOrder
    orderId?: SortOrder
    sentAt?: SortOrder
    returnedAt?: SortOrder
    deposit?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KegMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kegNumber?: SortOrder
    size?: SortOrder
    status?: SortOrder
    condition?: SortOrder
    batchId?: SortOrder
    filledAt?: SortOrder
    productName?: SortOrder
    lotNumber?: SortOrder
    customerId?: SortOrder
    orderId?: SortOrder
    sentAt?: SortOrder
    returnedAt?: SortOrder
    deposit?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KegSumOrderByAggregateInput = {
    size?: SortOrder
    deposit?: SortOrder
  }

  export type EnumKegStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KegStatus | EnumKegStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KegStatus[] | ListEnumKegStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KegStatus[] | ListEnumKegStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKegStatusWithAggregatesFilter<$PrismaModel> | $Enums.KegStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKegStatusFilter<$PrismaModel>
    _max?: NestedEnumKegStatusFilter<$PrismaModel>
  }

  export type EnumKegConditionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KegCondition | EnumKegConditionFieldRefInput<$PrismaModel>
    in?: $Enums.KegCondition[] | ListEnumKegConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.KegCondition[] | ListEnumKegConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumKegConditionWithAggregatesFilter<$PrismaModel> | $Enums.KegCondition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKegConditionFilter<$PrismaModel>
    _max?: NestedEnumKegConditionFilter<$PrismaModel>
  }

  export type EnumKegActionFilter<$PrismaModel = never> = {
    equals?: $Enums.KegAction | EnumKegActionFieldRefInput<$PrismaModel>
    in?: $Enums.KegAction[] | ListEnumKegActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.KegAction[] | ListEnumKegActionFieldRefInput<$PrismaModel>
    not?: NestedEnumKegActionFilter<$PrismaModel> | $Enums.KegAction
  }

  export type KegRelationFilter = {
    is?: KegWhereInput
    isNot?: KegWhereInput
  }

  export type KegMovementCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kegId?: SortOrder
    action?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    productId?: SortOrder
    productName?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    orderId?: SortOrder
    batchId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type KegMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kegId?: SortOrder
    action?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    productId?: SortOrder
    productName?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    orderId?: SortOrder
    batchId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type KegMovementMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kegId?: SortOrder
    action?: SortOrder
    fromStatus?: SortOrder
    toStatus?: SortOrder
    productId?: SortOrder
    productName?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    orderId?: SortOrder
    batchId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumKegActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KegAction | EnumKegActionFieldRefInput<$PrismaModel>
    in?: $Enums.KegAction[] | ListEnumKegActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.KegAction[] | ListEnumKegActionFieldRefInput<$PrismaModel>
    not?: NestedEnumKegActionWithAggregatesFilter<$PrismaModel> | $Enums.KegAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKegActionFilter<$PrismaModel>
    _max?: NestedEnumKegActionFilter<$PrismaModel>
  }

  export type EnumQCTestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QCTestType | EnumQCTestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QCTestType[] | ListEnumQCTestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCTestType[] | ListEnumQCTestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQCTestTypeFilter<$PrismaModel> | $Enums.QCTestType
  }

  export type EnumQCTestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QCTestStatus | EnumQCTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QCTestStatus[] | ListEnumQCTestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCTestStatus[] | ListEnumQCTestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQCTestStatusFilter<$PrismaModel> | $Enums.QCTestStatus
  }

  export type EnumQCTestPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.QCTestPriority | EnumQCTestPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.QCTestPriority[] | ListEnumQCTestPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCTestPriority[] | ListEnumQCTestPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumQCTestPriorityFilter<$PrismaModel> | $Enums.QCTestPriority
  }

  export type QCTestCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    batchId?: SortOrder
    lotId?: SortOrder
    testType?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
    targetValue?: SortOrder
    result?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    performedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QCTestAvgOrderByAggregateInput = {
    minValue?: SortOrder
    maxValue?: SortOrder
    targetValue?: SortOrder
    result?: SortOrder
  }

  export type QCTestMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    batchId?: SortOrder
    lotId?: SortOrder
    testType?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
    targetValue?: SortOrder
    result?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    performedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QCTestMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    batchId?: SortOrder
    lotId?: SortOrder
    testType?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
    targetValue?: SortOrder
    result?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    performedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QCTestSumOrderByAggregateInput = {
    minValue?: SortOrder
    maxValue?: SortOrder
    targetValue?: SortOrder
    result?: SortOrder
  }

  export type EnumQCTestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QCTestType | EnumQCTestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QCTestType[] | ListEnumQCTestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCTestType[] | ListEnumQCTestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQCTestTypeWithAggregatesFilter<$PrismaModel> | $Enums.QCTestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQCTestTypeFilter<$PrismaModel>
    _max?: NestedEnumQCTestTypeFilter<$PrismaModel>
  }

  export type EnumQCTestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QCTestStatus | EnumQCTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QCTestStatus[] | ListEnumQCTestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCTestStatus[] | ListEnumQCTestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQCTestStatusWithAggregatesFilter<$PrismaModel> | $Enums.QCTestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQCTestStatusFilter<$PrismaModel>
    _max?: NestedEnumQCTestStatusFilter<$PrismaModel>
  }

  export type EnumQCTestPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QCTestPriority | EnumQCTestPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.QCTestPriority[] | ListEnumQCTestPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCTestPriority[] | ListEnumQCTestPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumQCTestPriorityWithAggregatesFilter<$PrismaModel> | $Enums.QCTestPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQCTestPriorityFilter<$PrismaModel>
    _max?: NestedEnumQCTestPriorityFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type TourListRelationFilter = {
    every?: TourWhereInput
    some?: TourWhereInput
    none?: TourWhereInput
  }

  export type TourOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MuseumCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    city?: SortOrder
    address?: SortOrder
    nameEn?: SortOrder
    descriptionEn?: SortOrder
    cityEn?: SortOrder
    addressEn?: SortOrder
    nameRu?: SortOrder
    descriptionRu?: SortOrder
    cityRu?: SortOrder
    addressRu?: SortOrder
    nameDe?: SortOrder
    descriptionDe?: SortOrder
    cityDe?: SortOrder
    addressDe?: SortOrder
    nameFr?: SortOrder
    descriptionFr?: SortOrder
    cityFr?: SortOrder
    addressFr?: SortOrder
    slug?: SortOrder
    coverImage?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    showMap?: SortOrder
    showQrScanner?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MuseumAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type MuseumMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    city?: SortOrder
    address?: SortOrder
    nameEn?: SortOrder
    descriptionEn?: SortOrder
    cityEn?: SortOrder
    addressEn?: SortOrder
    nameRu?: SortOrder
    descriptionRu?: SortOrder
    cityRu?: SortOrder
    addressRu?: SortOrder
    nameDe?: SortOrder
    descriptionDe?: SortOrder
    cityDe?: SortOrder
    addressDe?: SortOrder
    nameFr?: SortOrder
    descriptionFr?: SortOrder
    cityFr?: SortOrder
    addressFr?: SortOrder
    slug?: SortOrder
    coverImage?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    showMap?: SortOrder
    showQrScanner?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MuseumMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    city?: SortOrder
    address?: SortOrder
    nameEn?: SortOrder
    descriptionEn?: SortOrder
    cityEn?: SortOrder
    addressEn?: SortOrder
    nameRu?: SortOrder
    descriptionRu?: SortOrder
    cityRu?: SortOrder
    addressRu?: SortOrder
    nameDe?: SortOrder
    descriptionDe?: SortOrder
    cityDe?: SortOrder
    addressDe?: SortOrder
    nameFr?: SortOrder
    descriptionFr?: SortOrder
    cityFr?: SortOrder
    addressFr?: SortOrder
    slug?: SortOrder
    coverImage?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    showMap?: SortOrder
    showQrScanner?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MuseumSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type MuseumRelationFilter = {
    is?: MuseumWhereInput
    isNot?: MuseumWhereInput
  }

  export type TourCountOrderByAggregateInput = {
    id?: SortOrder
    museumId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TourMaxOrderByAggregateInput = {
    id?: SortOrder
    museumId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TourMinOrderByAggregateInput = {
    id?: SortOrder
    museumId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchCreateNestedManyWithoutTenantInput = {
    create?: XOR<BatchCreateWithoutTenantInput, BatchUncheckedCreateWithoutTenantInput> | BatchCreateWithoutTenantInput[] | BatchUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutTenantInput | BatchCreateOrConnectWithoutTenantInput[]
    createMany?: BatchCreateManyTenantInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BudgetCreateNestedManyWithoutTenantInput = {
    create?: XOR<BudgetCreateWithoutTenantInput, BudgetUncheckedCreateWithoutTenantInput> | BudgetCreateWithoutTenantInput[] | BudgetUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutTenantInput | BudgetCreateOrConnectWithoutTenantInput[]
    createMany?: BudgetCreateManyTenantInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutTenantInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type EquipmentCreateNestedManyWithoutTenantInput = {
    create?: XOR<EquipmentCreateWithoutTenantInput, EquipmentUncheckedCreateWithoutTenantInput> | EquipmentCreateWithoutTenantInput[] | EquipmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutTenantInput | EquipmentCreateOrConnectWithoutTenantInput[]
    createMany?: EquipmentCreateManyTenantInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutTenantInput = {
    create?: XOR<ExpenseCreateWithoutTenantInput, ExpenseUncheckedCreateWithoutTenantInput> | ExpenseCreateWithoutTenantInput[] | ExpenseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutTenantInput | ExpenseCreateOrConnectWithoutTenantInput[]
    createMany?: ExpenseCreateManyTenantInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type InventoryItemCreateNestedManyWithoutTenantInput = {
    create?: XOR<InventoryItemCreateWithoutTenantInput, InventoryItemUncheckedCreateWithoutTenantInput> | InventoryItemCreateWithoutTenantInput[] | InventoryItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutTenantInput | InventoryItemCreateOrConnectWithoutTenantInput[]
    createMany?: InventoryItemCreateManyTenantInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type KegCreateNestedManyWithoutTenantInput = {
    create?: XOR<KegCreateWithoutTenantInput, KegUncheckedCreateWithoutTenantInput> | KegCreateWithoutTenantInput[] | KegUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: KegCreateOrConnectWithoutTenantInput | KegCreateOrConnectWithoutTenantInput[]
    createMany?: KegCreateManyTenantInputEnvelope
    connect?: KegWhereUniqueInput | KegWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RecipeCreateNestedManyWithoutTenantInput = {
    create?: XOR<RecipeCreateWithoutTenantInput, RecipeUncheckedCreateWithoutTenantInput> | RecipeCreateWithoutTenantInput[] | RecipeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutTenantInput | RecipeCreateOrConnectWithoutTenantInput[]
    createMany?: RecipeCreateManyTenantInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type SalesOrderCreateNestedManyWithoutTenantInput = {
    create?: XOR<SalesOrderCreateWithoutTenantInput, SalesOrderUncheckedCreateWithoutTenantInput> | SalesOrderCreateWithoutTenantInput[] | SalesOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutTenantInput | SalesOrderCreateOrConnectWithoutTenantInput[]
    createMany?: SalesOrderCreateManyTenantInputEnvelope
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
  }

  export type SupplierCreateNestedManyWithoutTenantInput = {
    create?: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput> | SupplierCreateWithoutTenantInput[] | SupplierUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutTenantInput | SupplierCreateOrConnectWithoutTenantInput[]
    createMany?: SupplierCreateManyTenantInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type TankCreateNestedManyWithoutTenantInput = {
    create?: XOR<TankCreateWithoutTenantInput, TankUncheckedCreateWithoutTenantInput> | TankCreateWithoutTenantInput[] | TankUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TankCreateOrConnectWithoutTenantInput | TankCreateOrConnectWithoutTenantInput[]
    createMany?: TankCreateManyTenantInputEnvelope
    connect?: TankWhereUniqueInput | TankWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutTenantInput = {
    create?: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput> | TransactionCreateWithoutTenantInput[] | TransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTenantInput | TransactionCreateOrConnectWithoutTenantInput[]
    createMany?: TransactionCreateManyTenantInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<BatchCreateWithoutTenantInput, BatchUncheckedCreateWithoutTenantInput> | BatchCreateWithoutTenantInput[] | BatchUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutTenantInput | BatchCreateOrConnectWithoutTenantInput[]
    createMany?: BatchCreateManyTenantInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type BudgetUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<BudgetCreateWithoutTenantInput, BudgetUncheckedCreateWithoutTenantInput> | BudgetCreateWithoutTenantInput[] | BudgetUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutTenantInput | BudgetCreateOrConnectWithoutTenantInput[]
    createMany?: BudgetCreateManyTenantInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type EquipmentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<EquipmentCreateWithoutTenantInput, EquipmentUncheckedCreateWithoutTenantInput> | EquipmentCreateWithoutTenantInput[] | EquipmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutTenantInput | EquipmentCreateOrConnectWithoutTenantInput[]
    createMany?: EquipmentCreateManyTenantInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ExpenseCreateWithoutTenantInput, ExpenseUncheckedCreateWithoutTenantInput> | ExpenseCreateWithoutTenantInput[] | ExpenseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutTenantInput | ExpenseCreateOrConnectWithoutTenantInput[]
    createMany?: ExpenseCreateManyTenantInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InventoryItemCreateWithoutTenantInput, InventoryItemUncheckedCreateWithoutTenantInput> | InventoryItemCreateWithoutTenantInput[] | InventoryItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutTenantInput | InventoryItemCreateOrConnectWithoutTenantInput[]
    createMany?: InventoryItemCreateManyTenantInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type KegUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<KegCreateWithoutTenantInput, KegUncheckedCreateWithoutTenantInput> | KegCreateWithoutTenantInput[] | KegUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: KegCreateOrConnectWithoutTenantInput | KegCreateOrConnectWithoutTenantInput[]
    createMany?: KegCreateManyTenantInputEnvelope
    connect?: KegWhereUniqueInput | KegWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type RecipeUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<RecipeCreateWithoutTenantInput, RecipeUncheckedCreateWithoutTenantInput> | RecipeCreateWithoutTenantInput[] | RecipeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutTenantInput | RecipeCreateOrConnectWithoutTenantInput[]
    createMany?: RecipeCreateManyTenantInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type SalesOrderUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SalesOrderCreateWithoutTenantInput, SalesOrderUncheckedCreateWithoutTenantInput> | SalesOrderCreateWithoutTenantInput[] | SalesOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutTenantInput | SalesOrderCreateOrConnectWithoutTenantInput[]
    createMany?: SalesOrderCreateManyTenantInputEnvelope
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
  }

  export type SupplierUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput> | SupplierCreateWithoutTenantInput[] | SupplierUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutTenantInput | SupplierCreateOrConnectWithoutTenantInput[]
    createMany?: SupplierCreateManyTenantInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type TankUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TankCreateWithoutTenantInput, TankUncheckedCreateWithoutTenantInput> | TankCreateWithoutTenantInput[] | TankUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TankCreateOrConnectWithoutTenantInput | TankCreateOrConnectWithoutTenantInput[]
    createMany?: TankCreateManyTenantInputEnvelope
    connect?: TankWhereUniqueInput | TankWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput> | TransactionCreateWithoutTenantInput[] | TransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTenantInput | TransactionCreateOrConnectWithoutTenantInput[]
    createMany?: TransactionCreateManyTenantInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumPlanTypeFieldUpdateOperationsInput = {
    set?: $Enums.PlanType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BatchUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BatchCreateWithoutTenantInput, BatchUncheckedCreateWithoutTenantInput> | BatchCreateWithoutTenantInput[] | BatchUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutTenantInput | BatchCreateOrConnectWithoutTenantInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutTenantInput | BatchUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BatchCreateManyTenantInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutTenantInput | BatchUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutTenantInput | BatchUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type BudgetUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BudgetCreateWithoutTenantInput, BudgetUncheckedCreateWithoutTenantInput> | BudgetCreateWithoutTenantInput[] | BudgetUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutTenantInput | BudgetCreateOrConnectWithoutTenantInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutTenantInput | BudgetUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BudgetCreateManyTenantInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutTenantInput | BudgetUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutTenantInput | BudgetUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutTenantInput | CustomerUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutTenantInput | CustomerUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutTenantInput | CustomerUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type EquipmentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EquipmentCreateWithoutTenantInput, EquipmentUncheckedCreateWithoutTenantInput> | EquipmentCreateWithoutTenantInput[] | EquipmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutTenantInput | EquipmentCreateOrConnectWithoutTenantInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutTenantInput | EquipmentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EquipmentCreateManyTenantInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutTenantInput | EquipmentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutTenantInput | EquipmentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ExpenseCreateWithoutTenantInput, ExpenseUncheckedCreateWithoutTenantInput> | ExpenseCreateWithoutTenantInput[] | ExpenseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutTenantInput | ExpenseCreateOrConnectWithoutTenantInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutTenantInput | ExpenseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ExpenseCreateManyTenantInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutTenantInput | ExpenseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutTenantInput | ExpenseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type InventoryItemUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InventoryItemCreateWithoutTenantInput, InventoryItemUncheckedCreateWithoutTenantInput> | InventoryItemCreateWithoutTenantInput[] | InventoryItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutTenantInput | InventoryItemCreateOrConnectWithoutTenantInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutTenantInput | InventoryItemUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InventoryItemCreateManyTenantInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutTenantInput | InventoryItemUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutTenantInput | InventoryItemUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTenantInput | InvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTenantInput | InvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTenantInput | InvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type KegUpdateManyWithoutTenantNestedInput = {
    create?: XOR<KegCreateWithoutTenantInput, KegUncheckedCreateWithoutTenantInput> | KegCreateWithoutTenantInput[] | KegUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: KegCreateOrConnectWithoutTenantInput | KegCreateOrConnectWithoutTenantInput[]
    upsert?: KegUpsertWithWhereUniqueWithoutTenantInput | KegUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: KegCreateManyTenantInputEnvelope
    set?: KegWhereUniqueInput | KegWhereUniqueInput[]
    disconnect?: KegWhereUniqueInput | KegWhereUniqueInput[]
    delete?: KegWhereUniqueInput | KegWhereUniqueInput[]
    connect?: KegWhereUniqueInput | KegWhereUniqueInput[]
    update?: KegUpdateWithWhereUniqueWithoutTenantInput | KegUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: KegUpdateManyWithWhereWithoutTenantInput | KegUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: KegScalarWhereInput | KegScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutTenantInput | PaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutTenantInput | PaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutTenantInput | PaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RecipeUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RecipeCreateWithoutTenantInput, RecipeUncheckedCreateWithoutTenantInput> | RecipeCreateWithoutTenantInput[] | RecipeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutTenantInput | RecipeCreateOrConnectWithoutTenantInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutTenantInput | RecipeUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RecipeCreateManyTenantInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutTenantInput | RecipeUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutTenantInput | RecipeUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type SalesOrderUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SalesOrderCreateWithoutTenantInput, SalesOrderUncheckedCreateWithoutTenantInput> | SalesOrderCreateWithoutTenantInput[] | SalesOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutTenantInput | SalesOrderCreateOrConnectWithoutTenantInput[]
    upsert?: SalesOrderUpsertWithWhereUniqueWithoutTenantInput | SalesOrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SalesOrderCreateManyTenantInputEnvelope
    set?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    disconnect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    delete?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    update?: SalesOrderUpdateWithWhereUniqueWithoutTenantInput | SalesOrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SalesOrderUpdateManyWithWhereWithoutTenantInput | SalesOrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
  }

  export type SupplierUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput> | SupplierCreateWithoutTenantInput[] | SupplierUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutTenantInput | SupplierCreateOrConnectWithoutTenantInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutTenantInput | SupplierUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SupplierCreateManyTenantInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutTenantInput | SupplierUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutTenantInput | SupplierUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type TankUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TankCreateWithoutTenantInput, TankUncheckedCreateWithoutTenantInput> | TankCreateWithoutTenantInput[] | TankUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TankCreateOrConnectWithoutTenantInput | TankCreateOrConnectWithoutTenantInput[]
    upsert?: TankUpsertWithWhereUniqueWithoutTenantInput | TankUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TankCreateManyTenantInputEnvelope
    set?: TankWhereUniqueInput | TankWhereUniqueInput[]
    disconnect?: TankWhereUniqueInput | TankWhereUniqueInput[]
    delete?: TankWhereUniqueInput | TankWhereUniqueInput[]
    connect?: TankWhereUniqueInput | TankWhereUniqueInput[]
    update?: TankUpdateWithWhereUniqueWithoutTenantInput | TankUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TankUpdateManyWithWhereWithoutTenantInput | TankUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TankScalarWhereInput | TankScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput> | TransactionCreateWithoutTenantInput[] | TransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTenantInput | TransactionCreateOrConnectWithoutTenantInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutTenantInput | TransactionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TransactionCreateManyTenantInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutTenantInput | TransactionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutTenantInput | TransactionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BatchCreateWithoutTenantInput, BatchUncheckedCreateWithoutTenantInput> | BatchCreateWithoutTenantInput[] | BatchUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutTenantInput | BatchCreateOrConnectWithoutTenantInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutTenantInput | BatchUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BatchCreateManyTenantInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutTenantInput | BatchUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutTenantInput | BatchUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type BudgetUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BudgetCreateWithoutTenantInput, BudgetUncheckedCreateWithoutTenantInput> | BudgetCreateWithoutTenantInput[] | BudgetUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutTenantInput | BudgetCreateOrConnectWithoutTenantInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutTenantInput | BudgetUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BudgetCreateManyTenantInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutTenantInput | BudgetUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutTenantInput | BudgetUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutTenantInput | CustomerUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutTenantInput | CustomerUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutTenantInput | CustomerUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type EquipmentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EquipmentCreateWithoutTenantInput, EquipmentUncheckedCreateWithoutTenantInput> | EquipmentCreateWithoutTenantInput[] | EquipmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutTenantInput | EquipmentCreateOrConnectWithoutTenantInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutTenantInput | EquipmentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EquipmentCreateManyTenantInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutTenantInput | EquipmentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutTenantInput | EquipmentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ExpenseCreateWithoutTenantInput, ExpenseUncheckedCreateWithoutTenantInput> | ExpenseCreateWithoutTenantInput[] | ExpenseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutTenantInput | ExpenseCreateOrConnectWithoutTenantInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutTenantInput | ExpenseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ExpenseCreateManyTenantInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutTenantInput | ExpenseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutTenantInput | ExpenseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InventoryItemCreateWithoutTenantInput, InventoryItemUncheckedCreateWithoutTenantInput> | InventoryItemCreateWithoutTenantInput[] | InventoryItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutTenantInput | InventoryItemCreateOrConnectWithoutTenantInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutTenantInput | InventoryItemUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InventoryItemCreateManyTenantInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutTenantInput | InventoryItemUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutTenantInput | InventoryItemUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTenantInput | InvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTenantInput | InvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTenantInput | InvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type KegUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<KegCreateWithoutTenantInput, KegUncheckedCreateWithoutTenantInput> | KegCreateWithoutTenantInput[] | KegUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: KegCreateOrConnectWithoutTenantInput | KegCreateOrConnectWithoutTenantInput[]
    upsert?: KegUpsertWithWhereUniqueWithoutTenantInput | KegUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: KegCreateManyTenantInputEnvelope
    set?: KegWhereUniqueInput | KegWhereUniqueInput[]
    disconnect?: KegWhereUniqueInput | KegWhereUniqueInput[]
    delete?: KegWhereUniqueInput | KegWhereUniqueInput[]
    connect?: KegWhereUniqueInput | KegWhereUniqueInput[]
    update?: KegUpdateWithWhereUniqueWithoutTenantInput | KegUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: KegUpdateManyWithWhereWithoutTenantInput | KegUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: KegScalarWhereInput | KegScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutTenantInput | PaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutTenantInput | PaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutTenantInput | PaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type RecipeUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RecipeCreateWithoutTenantInput, RecipeUncheckedCreateWithoutTenantInput> | RecipeCreateWithoutTenantInput[] | RecipeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutTenantInput | RecipeCreateOrConnectWithoutTenantInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutTenantInput | RecipeUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RecipeCreateManyTenantInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutTenantInput | RecipeUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutTenantInput | RecipeUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type SalesOrderUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SalesOrderCreateWithoutTenantInput, SalesOrderUncheckedCreateWithoutTenantInput> | SalesOrderCreateWithoutTenantInput[] | SalesOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutTenantInput | SalesOrderCreateOrConnectWithoutTenantInput[]
    upsert?: SalesOrderUpsertWithWhereUniqueWithoutTenantInput | SalesOrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SalesOrderCreateManyTenantInputEnvelope
    set?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    disconnect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    delete?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    update?: SalesOrderUpdateWithWhereUniqueWithoutTenantInput | SalesOrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SalesOrderUpdateManyWithWhereWithoutTenantInput | SalesOrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
  }

  export type SupplierUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput> | SupplierCreateWithoutTenantInput[] | SupplierUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutTenantInput | SupplierCreateOrConnectWithoutTenantInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutTenantInput | SupplierUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SupplierCreateManyTenantInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutTenantInput | SupplierUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutTenantInput | SupplierUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type TankUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TankCreateWithoutTenantInput, TankUncheckedCreateWithoutTenantInput> | TankCreateWithoutTenantInput[] | TankUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TankCreateOrConnectWithoutTenantInput | TankCreateOrConnectWithoutTenantInput[]
    upsert?: TankUpsertWithWhereUniqueWithoutTenantInput | TankUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TankCreateManyTenantInputEnvelope
    set?: TankWhereUniqueInput | TankWhereUniqueInput[]
    disconnect?: TankWhereUniqueInput | TankWhereUniqueInput[]
    delete?: TankWhereUniqueInput | TankWhereUniqueInput[]
    connect?: TankWhereUniqueInput | TankWhereUniqueInput[]
    update?: TankUpdateWithWhereUniqueWithoutTenantInput | TankUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TankUpdateManyWithWhereWithoutTenantInput | TankUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TankScalarWhereInput | TankScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput> | TransactionCreateWithoutTenantInput[] | TransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTenantInput | TransactionCreateOrConnectWithoutTenantInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutTenantInput | TransactionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TransactionCreateManyTenantInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutTenantInput | TransactionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutTenantInput | TransactionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type BatchCreateNestedManyWithoutRecipeInput = {
    create?: XOR<BatchCreateWithoutRecipeInput, BatchUncheckedCreateWithoutRecipeInput> | BatchCreateWithoutRecipeInput[] | BatchUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutRecipeInput | BatchCreateOrConnectWithoutRecipeInput[]
    createMany?: BatchCreateManyRecipeInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutRecipesInput = {
    create?: XOR<TenantCreateWithoutRecipesInput, TenantUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRecipesInput
    connect?: TenantWhereUniqueInput
  }

  export type RecipeIngredientCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<BatchCreateWithoutRecipeInput, BatchUncheckedCreateWithoutRecipeInput> | BatchCreateWithoutRecipeInput[] | BatchUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutRecipeInput | BatchCreateOrConnectWithoutRecipeInput[]
    createMany?: BatchCreateManyRecipeInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumRecipeStatusFieldUpdateOperationsInput = {
    set?: $Enums.RecipeStatus
  }

  export type BatchUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<BatchCreateWithoutRecipeInput, BatchUncheckedCreateWithoutRecipeInput> | BatchCreateWithoutRecipeInput[] | BatchUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutRecipeInput | BatchCreateOrConnectWithoutRecipeInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutRecipeInput | BatchUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: BatchCreateManyRecipeInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutRecipeInput | BatchUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutRecipeInput | BatchUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutRecipesNestedInput = {
    create?: XOR<TenantCreateWithoutRecipesInput, TenantUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRecipesInput
    upsert?: TenantUpsertWithoutRecipesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutRecipesInput, TenantUpdateWithoutRecipesInput>, TenantUncheckedUpdateWithoutRecipesInput>
  }

  export type RecipeIngredientUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    set?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    disconnect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    delete?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    update?: RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeIngredientUpdateManyWithWhereWithoutRecipeInput | RecipeIngredientUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<BatchCreateWithoutRecipeInput, BatchUncheckedCreateWithoutRecipeInput> | BatchCreateWithoutRecipeInput[] | BatchUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutRecipeInput | BatchCreateOrConnectWithoutRecipeInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutRecipeInput | BatchUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: BatchCreateManyRecipeInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutRecipeInput | BatchUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutRecipeInput | BatchUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    set?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    disconnect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    delete?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    update?: RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeIngredientUpdateManyWithWhereWithoutRecipeInput | RecipeIngredientUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
  }

  export type InventoryItemCreateNestedOneWithoutRecipeIngredientsInput = {
    create?: XOR<InventoryItemCreateWithoutRecipeIngredientsInput, InventoryItemUncheckedCreateWithoutRecipeIngredientsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutRecipeIngredientsInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type RecipeCreateNestedOneWithoutIngredientsInput = {
    create?: XOR<RecipeCreateWithoutIngredientsInput, RecipeUncheckedCreateWithoutIngredientsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutIngredientsInput
    connect?: RecipeWhereUniqueInput
  }

  export type EnumIngredientCategoryFieldUpdateOperationsInput = {
    set?: $Enums.IngredientCategory
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type InventoryItemUpdateOneWithoutRecipeIngredientsNestedInput = {
    create?: XOR<InventoryItemCreateWithoutRecipeIngredientsInput, InventoryItemUncheckedCreateWithoutRecipeIngredientsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutRecipeIngredientsInput
    upsert?: InventoryItemUpsertWithoutRecipeIngredientsInput
    disconnect?: InventoryItemWhereInput | boolean
    delete?: InventoryItemWhereInput | boolean
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutRecipeIngredientsInput, InventoryItemUpdateWithoutRecipeIngredientsInput>, InventoryItemUncheckedUpdateWithoutRecipeIngredientsInput>
  }

  export type RecipeUpdateOneRequiredWithoutIngredientsNestedInput = {
    create?: XOR<RecipeCreateWithoutIngredientsInput, RecipeUncheckedCreateWithoutIngredientsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutIngredientsInput
    upsert?: RecipeUpsertWithoutIngredientsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutIngredientsInput, RecipeUpdateWithoutIngredientsInput>, RecipeUncheckedUpdateWithoutIngredientsInput>
  }

  export type TenantCreateNestedOneWithoutInventoryInput = {
    create?: XOR<TenantCreateWithoutInventoryInput, TenantUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInventoryInput
    connect?: TenantWhereUniqueInput
  }

  export type InventoryLedgerCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryLedgerCreateWithoutItemInput, InventoryLedgerUncheckedCreateWithoutItemInput> | InventoryLedgerCreateWithoutItemInput[] | InventoryLedgerUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutItemInput | InventoryLedgerCreateOrConnectWithoutItemInput[]
    createMany?: InventoryLedgerCreateManyItemInputEnvelope
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
  }

  export type RecipeIngredientCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<RecipeIngredientCreateWithoutInventoryItemInput, RecipeIngredientUncheckedCreateWithoutInventoryItemInput> | RecipeIngredientCreateWithoutInventoryItemInput[] | RecipeIngredientUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutInventoryItemInput | RecipeIngredientCreateOrConnectWithoutInventoryItemInput[]
    createMany?: RecipeIngredientCreateManyInventoryItemInputEnvelope
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
  }

  export type InventoryLedgerUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryLedgerCreateWithoutItemInput, InventoryLedgerUncheckedCreateWithoutItemInput> | InventoryLedgerCreateWithoutItemInput[] | InventoryLedgerUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutItemInput | InventoryLedgerCreateOrConnectWithoutItemInput[]
    createMany?: InventoryLedgerCreateManyItemInputEnvelope
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
  }

  export type RecipeIngredientUncheckedCreateNestedManyWithoutInventoryItemInput = {
    create?: XOR<RecipeIngredientCreateWithoutInventoryItemInput, RecipeIngredientUncheckedCreateWithoutInventoryItemInput> | RecipeIngredientCreateWithoutInventoryItemInput[] | RecipeIngredientUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutInventoryItemInput | RecipeIngredientCreateOrConnectWithoutInventoryItemInput[]
    createMany?: RecipeIngredientCreateManyInventoryItemInputEnvelope
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
  }

  export type EnumInventoryCategoryFieldUpdateOperationsInput = {
    set?: $Enums.InventoryCategory
  }

  export type TenantUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<TenantCreateWithoutInventoryInput, TenantUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInventoryInput
    upsert?: TenantUpsertWithoutInventoryInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInventoryInput, TenantUpdateWithoutInventoryInput>, TenantUncheckedUpdateWithoutInventoryInput>
  }

  export type InventoryLedgerUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryLedgerCreateWithoutItemInput, InventoryLedgerUncheckedCreateWithoutItemInput> | InventoryLedgerCreateWithoutItemInput[] | InventoryLedgerUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutItemInput | InventoryLedgerCreateOrConnectWithoutItemInput[]
    upsert?: InventoryLedgerUpsertWithWhereUniqueWithoutItemInput | InventoryLedgerUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryLedgerCreateManyItemInputEnvelope
    set?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    disconnect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    delete?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    update?: InventoryLedgerUpdateWithWhereUniqueWithoutItemInput | InventoryLedgerUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryLedgerUpdateManyWithWhereWithoutItemInput | InventoryLedgerUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryLedgerScalarWhereInput | InventoryLedgerScalarWhereInput[]
  }

  export type RecipeIngredientUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<RecipeIngredientCreateWithoutInventoryItemInput, RecipeIngredientUncheckedCreateWithoutInventoryItemInput> | RecipeIngredientCreateWithoutInventoryItemInput[] | RecipeIngredientUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutInventoryItemInput | RecipeIngredientCreateOrConnectWithoutInventoryItemInput[]
    upsert?: RecipeIngredientUpsertWithWhereUniqueWithoutInventoryItemInput | RecipeIngredientUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: RecipeIngredientCreateManyInventoryItemInputEnvelope
    set?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    disconnect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    delete?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    update?: RecipeIngredientUpdateWithWhereUniqueWithoutInventoryItemInput | RecipeIngredientUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: RecipeIngredientUpdateManyWithWhereWithoutInventoryItemInput | RecipeIngredientUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
  }

  export type InventoryLedgerUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryLedgerCreateWithoutItemInput, InventoryLedgerUncheckedCreateWithoutItemInput> | InventoryLedgerCreateWithoutItemInput[] | InventoryLedgerUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutItemInput | InventoryLedgerCreateOrConnectWithoutItemInput[]
    upsert?: InventoryLedgerUpsertWithWhereUniqueWithoutItemInput | InventoryLedgerUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryLedgerCreateManyItemInputEnvelope
    set?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    disconnect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    delete?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    update?: InventoryLedgerUpdateWithWhereUniqueWithoutItemInput | InventoryLedgerUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryLedgerUpdateManyWithWhereWithoutItemInput | InventoryLedgerUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryLedgerScalarWhereInput | InventoryLedgerScalarWhereInput[]
  }

  export type RecipeIngredientUncheckedUpdateManyWithoutInventoryItemNestedInput = {
    create?: XOR<RecipeIngredientCreateWithoutInventoryItemInput, RecipeIngredientUncheckedCreateWithoutInventoryItemInput> | RecipeIngredientCreateWithoutInventoryItemInput[] | RecipeIngredientUncheckedCreateWithoutInventoryItemInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutInventoryItemInput | RecipeIngredientCreateOrConnectWithoutInventoryItemInput[]
    upsert?: RecipeIngredientUpsertWithWhereUniqueWithoutInventoryItemInput | RecipeIngredientUpsertWithWhereUniqueWithoutInventoryItemInput[]
    createMany?: RecipeIngredientCreateManyInventoryItemInputEnvelope
    set?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    disconnect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    delete?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    update?: RecipeIngredientUpdateWithWhereUniqueWithoutInventoryItemInput | RecipeIngredientUpdateWithWhereUniqueWithoutInventoryItemInput[]
    updateMany?: RecipeIngredientUpdateManyWithWhereWithoutInventoryItemInput | RecipeIngredientUpdateManyWithWhereWithoutInventoryItemInput[]
    deleteMany?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
  }

  export type BatchCreateNestedOneWithoutLedgerEntriesInput = {
    create?: XOR<BatchCreateWithoutLedgerEntriesInput, BatchUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: BatchCreateOrConnectWithoutLedgerEntriesInput
    connect?: BatchWhereUniqueInput
  }

  export type InventoryItemCreateNestedOneWithoutLedgerInput = {
    create?: XOR<InventoryItemCreateWithoutLedgerInput, InventoryItemUncheckedCreateWithoutLedgerInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutLedgerInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type EnumLedgerEntryTypeFieldUpdateOperationsInput = {
    set?: $Enums.LedgerEntryType
  }

  export type BatchUpdateOneWithoutLedgerEntriesNestedInput = {
    create?: XOR<BatchCreateWithoutLedgerEntriesInput, BatchUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: BatchCreateOrConnectWithoutLedgerEntriesInput
    upsert?: BatchUpsertWithoutLedgerEntriesInput
    disconnect?: BatchWhereInput | boolean
    delete?: BatchWhereInput | boolean
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutLedgerEntriesInput, BatchUpdateWithoutLedgerEntriesInput>, BatchUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type InventoryItemUpdateOneRequiredWithoutLedgerNestedInput = {
    create?: XOR<InventoryItemCreateWithoutLedgerInput, InventoryItemUncheckedCreateWithoutLedgerInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutLedgerInput
    upsert?: InventoryItemUpsertWithoutLedgerInput
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutLedgerInput, InventoryItemUpdateWithoutLedgerInput>, InventoryItemUncheckedUpdateWithoutLedgerInput>
  }

  export type RecipeCreateNestedOneWithoutBatchesInput = {
    create?: XOR<RecipeCreateWithoutBatchesInput, RecipeUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutBatchesInput
    connect?: RecipeWhereUniqueInput
  }

  export type TankCreateNestedOneWithoutBatchesInput = {
    create?: XOR<TankCreateWithoutBatchesInput, TankUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: TankCreateOrConnectWithoutBatchesInput
    connect?: TankWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutBatchesInput = {
    create?: XOR<TenantCreateWithoutBatchesInput, TenantUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBatchesInput
    connect?: TenantWhereUniqueInput
  }

  export type BatchIngredientCreateNestedManyWithoutBatchInput = {
    create?: XOR<BatchIngredientCreateWithoutBatchInput, BatchIngredientUncheckedCreateWithoutBatchInput> | BatchIngredientCreateWithoutBatchInput[] | BatchIngredientUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchIngredientCreateOrConnectWithoutBatchInput | BatchIngredientCreateOrConnectWithoutBatchInput[]
    createMany?: BatchIngredientCreateManyBatchInputEnvelope
    connect?: BatchIngredientWhereUniqueInput | BatchIngredientWhereUniqueInput[]
  }

  export type BatchTimelineCreateNestedManyWithoutBatchInput = {
    create?: XOR<BatchTimelineCreateWithoutBatchInput, BatchTimelineUncheckedCreateWithoutBatchInput> | BatchTimelineCreateWithoutBatchInput[] | BatchTimelineUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchTimelineCreateOrConnectWithoutBatchInput | BatchTimelineCreateOrConnectWithoutBatchInput[]
    createMany?: BatchTimelineCreateManyBatchInputEnvelope
    connect?: BatchTimelineWhereUniqueInput | BatchTimelineWhereUniqueInput[]
  }

  export type GravityReadingCreateNestedManyWithoutBatchInput = {
    create?: XOR<GravityReadingCreateWithoutBatchInput, GravityReadingUncheckedCreateWithoutBatchInput> | GravityReadingCreateWithoutBatchInput[] | GravityReadingUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: GravityReadingCreateOrConnectWithoutBatchInput | GravityReadingCreateOrConnectWithoutBatchInput[]
    createMany?: GravityReadingCreateManyBatchInputEnvelope
    connect?: GravityReadingWhereUniqueInput | GravityReadingWhereUniqueInput[]
  }

  export type InventoryLedgerCreateNestedManyWithoutBatchInput = {
    create?: XOR<InventoryLedgerCreateWithoutBatchInput, InventoryLedgerUncheckedCreateWithoutBatchInput> | InventoryLedgerCreateWithoutBatchInput[] | InventoryLedgerUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutBatchInput | InventoryLedgerCreateOrConnectWithoutBatchInput[]
    createMany?: InventoryLedgerCreateManyBatchInputEnvelope
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
  }

  export type KegCreateNestedManyWithoutBatchInput = {
    create?: XOR<KegCreateWithoutBatchInput, KegUncheckedCreateWithoutBatchInput> | KegCreateWithoutBatchInput[] | KegUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: KegCreateOrConnectWithoutBatchInput | KegCreateOrConnectWithoutBatchInput[]
    createMany?: KegCreateManyBatchInputEnvelope
    connect?: KegWhereUniqueInput | KegWhereUniqueInput[]
  }

  export type LotBatchCreateNestedManyWithoutBatchInput = {
    create?: XOR<LotBatchCreateWithoutBatchInput, LotBatchUncheckedCreateWithoutBatchInput> | LotBatchCreateWithoutBatchInput[] | LotBatchUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: LotBatchCreateOrConnectWithoutBatchInput | LotBatchCreateOrConnectWithoutBatchInput[]
    createMany?: LotBatchCreateManyBatchInputEnvelope
    connect?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
  }

  export type PackagingRunCreateNestedManyWithoutBatchInput = {
    create?: XOR<PackagingRunCreateWithoutBatchInput, PackagingRunUncheckedCreateWithoutBatchInput> | PackagingRunCreateWithoutBatchInput[] | PackagingRunUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: PackagingRunCreateOrConnectWithoutBatchInput | PackagingRunCreateOrConnectWithoutBatchInput[]
    createMany?: PackagingRunCreateManyBatchInputEnvelope
    connect?: PackagingRunWhereUniqueInput | PackagingRunWhereUniqueInput[]
  }

  export type QCTestCreateNestedManyWithoutBatchInput = {
    create?: XOR<QCTestCreateWithoutBatchInput, QCTestUncheckedCreateWithoutBatchInput> | QCTestCreateWithoutBatchInput[] | QCTestUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: QCTestCreateOrConnectWithoutBatchInput | QCTestCreateOrConnectWithoutBatchInput[]
    createMany?: QCTestCreateManyBatchInputEnvelope
    connect?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
  }

  export type BatchIngredientUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<BatchIngredientCreateWithoutBatchInput, BatchIngredientUncheckedCreateWithoutBatchInput> | BatchIngredientCreateWithoutBatchInput[] | BatchIngredientUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchIngredientCreateOrConnectWithoutBatchInput | BatchIngredientCreateOrConnectWithoutBatchInput[]
    createMany?: BatchIngredientCreateManyBatchInputEnvelope
    connect?: BatchIngredientWhereUniqueInput | BatchIngredientWhereUniqueInput[]
  }

  export type BatchTimelineUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<BatchTimelineCreateWithoutBatchInput, BatchTimelineUncheckedCreateWithoutBatchInput> | BatchTimelineCreateWithoutBatchInput[] | BatchTimelineUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchTimelineCreateOrConnectWithoutBatchInput | BatchTimelineCreateOrConnectWithoutBatchInput[]
    createMany?: BatchTimelineCreateManyBatchInputEnvelope
    connect?: BatchTimelineWhereUniqueInput | BatchTimelineWhereUniqueInput[]
  }

  export type GravityReadingUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<GravityReadingCreateWithoutBatchInput, GravityReadingUncheckedCreateWithoutBatchInput> | GravityReadingCreateWithoutBatchInput[] | GravityReadingUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: GravityReadingCreateOrConnectWithoutBatchInput | GravityReadingCreateOrConnectWithoutBatchInput[]
    createMany?: GravityReadingCreateManyBatchInputEnvelope
    connect?: GravityReadingWhereUniqueInput | GravityReadingWhereUniqueInput[]
  }

  export type InventoryLedgerUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<InventoryLedgerCreateWithoutBatchInput, InventoryLedgerUncheckedCreateWithoutBatchInput> | InventoryLedgerCreateWithoutBatchInput[] | InventoryLedgerUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutBatchInput | InventoryLedgerCreateOrConnectWithoutBatchInput[]
    createMany?: InventoryLedgerCreateManyBatchInputEnvelope
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
  }

  export type KegUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<KegCreateWithoutBatchInput, KegUncheckedCreateWithoutBatchInput> | KegCreateWithoutBatchInput[] | KegUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: KegCreateOrConnectWithoutBatchInput | KegCreateOrConnectWithoutBatchInput[]
    createMany?: KegCreateManyBatchInputEnvelope
    connect?: KegWhereUniqueInput | KegWhereUniqueInput[]
  }

  export type LotBatchUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<LotBatchCreateWithoutBatchInput, LotBatchUncheckedCreateWithoutBatchInput> | LotBatchCreateWithoutBatchInput[] | LotBatchUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: LotBatchCreateOrConnectWithoutBatchInput | LotBatchCreateOrConnectWithoutBatchInput[]
    createMany?: LotBatchCreateManyBatchInputEnvelope
    connect?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
  }

  export type PackagingRunUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<PackagingRunCreateWithoutBatchInput, PackagingRunUncheckedCreateWithoutBatchInput> | PackagingRunCreateWithoutBatchInput[] | PackagingRunUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: PackagingRunCreateOrConnectWithoutBatchInput | PackagingRunCreateOrConnectWithoutBatchInput[]
    createMany?: PackagingRunCreateManyBatchInputEnvelope
    connect?: PackagingRunWhereUniqueInput | PackagingRunWhereUniqueInput[]
  }

  export type QCTestUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<QCTestCreateWithoutBatchInput, QCTestUncheckedCreateWithoutBatchInput> | QCTestCreateWithoutBatchInput[] | QCTestUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: QCTestCreateOrConnectWithoutBatchInput | QCTestCreateOrConnectWithoutBatchInput[]
    createMany?: QCTestCreateManyBatchInputEnvelope
    connect?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
  }

  export type EnumBatchStatusFieldUpdateOperationsInput = {
    set?: $Enums.BatchStatus
  }

  export type RecipeUpdateOneRequiredWithoutBatchesNestedInput = {
    create?: XOR<RecipeCreateWithoutBatchesInput, RecipeUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutBatchesInput
    upsert?: RecipeUpsertWithoutBatchesInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutBatchesInput, RecipeUpdateWithoutBatchesInput>, RecipeUncheckedUpdateWithoutBatchesInput>
  }

  export type TankUpdateOneWithoutBatchesNestedInput = {
    create?: XOR<TankCreateWithoutBatchesInput, TankUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: TankCreateOrConnectWithoutBatchesInput
    upsert?: TankUpsertWithoutBatchesInput
    disconnect?: TankWhereInput | boolean
    delete?: TankWhereInput | boolean
    connect?: TankWhereUniqueInput
    update?: XOR<XOR<TankUpdateToOneWithWhereWithoutBatchesInput, TankUpdateWithoutBatchesInput>, TankUncheckedUpdateWithoutBatchesInput>
  }

  export type TenantUpdateOneRequiredWithoutBatchesNestedInput = {
    create?: XOR<TenantCreateWithoutBatchesInput, TenantUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBatchesInput
    upsert?: TenantUpsertWithoutBatchesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutBatchesInput, TenantUpdateWithoutBatchesInput>, TenantUncheckedUpdateWithoutBatchesInput>
  }

  export type BatchIngredientUpdateManyWithoutBatchNestedInput = {
    create?: XOR<BatchIngredientCreateWithoutBatchInput, BatchIngredientUncheckedCreateWithoutBatchInput> | BatchIngredientCreateWithoutBatchInput[] | BatchIngredientUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchIngredientCreateOrConnectWithoutBatchInput | BatchIngredientCreateOrConnectWithoutBatchInput[]
    upsert?: BatchIngredientUpsertWithWhereUniqueWithoutBatchInput | BatchIngredientUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: BatchIngredientCreateManyBatchInputEnvelope
    set?: BatchIngredientWhereUniqueInput | BatchIngredientWhereUniqueInput[]
    disconnect?: BatchIngredientWhereUniqueInput | BatchIngredientWhereUniqueInput[]
    delete?: BatchIngredientWhereUniqueInput | BatchIngredientWhereUniqueInput[]
    connect?: BatchIngredientWhereUniqueInput | BatchIngredientWhereUniqueInput[]
    update?: BatchIngredientUpdateWithWhereUniqueWithoutBatchInput | BatchIngredientUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: BatchIngredientUpdateManyWithWhereWithoutBatchInput | BatchIngredientUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: BatchIngredientScalarWhereInput | BatchIngredientScalarWhereInput[]
  }

  export type BatchTimelineUpdateManyWithoutBatchNestedInput = {
    create?: XOR<BatchTimelineCreateWithoutBatchInput, BatchTimelineUncheckedCreateWithoutBatchInput> | BatchTimelineCreateWithoutBatchInput[] | BatchTimelineUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchTimelineCreateOrConnectWithoutBatchInput | BatchTimelineCreateOrConnectWithoutBatchInput[]
    upsert?: BatchTimelineUpsertWithWhereUniqueWithoutBatchInput | BatchTimelineUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: BatchTimelineCreateManyBatchInputEnvelope
    set?: BatchTimelineWhereUniqueInput | BatchTimelineWhereUniqueInput[]
    disconnect?: BatchTimelineWhereUniqueInput | BatchTimelineWhereUniqueInput[]
    delete?: BatchTimelineWhereUniqueInput | BatchTimelineWhereUniqueInput[]
    connect?: BatchTimelineWhereUniqueInput | BatchTimelineWhereUniqueInput[]
    update?: BatchTimelineUpdateWithWhereUniqueWithoutBatchInput | BatchTimelineUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: BatchTimelineUpdateManyWithWhereWithoutBatchInput | BatchTimelineUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: BatchTimelineScalarWhereInput | BatchTimelineScalarWhereInput[]
  }

  export type GravityReadingUpdateManyWithoutBatchNestedInput = {
    create?: XOR<GravityReadingCreateWithoutBatchInput, GravityReadingUncheckedCreateWithoutBatchInput> | GravityReadingCreateWithoutBatchInput[] | GravityReadingUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: GravityReadingCreateOrConnectWithoutBatchInput | GravityReadingCreateOrConnectWithoutBatchInput[]
    upsert?: GravityReadingUpsertWithWhereUniqueWithoutBatchInput | GravityReadingUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: GravityReadingCreateManyBatchInputEnvelope
    set?: GravityReadingWhereUniqueInput | GravityReadingWhereUniqueInput[]
    disconnect?: GravityReadingWhereUniqueInput | GravityReadingWhereUniqueInput[]
    delete?: GravityReadingWhereUniqueInput | GravityReadingWhereUniqueInput[]
    connect?: GravityReadingWhereUniqueInput | GravityReadingWhereUniqueInput[]
    update?: GravityReadingUpdateWithWhereUniqueWithoutBatchInput | GravityReadingUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: GravityReadingUpdateManyWithWhereWithoutBatchInput | GravityReadingUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: GravityReadingScalarWhereInput | GravityReadingScalarWhereInput[]
  }

  export type InventoryLedgerUpdateManyWithoutBatchNestedInput = {
    create?: XOR<InventoryLedgerCreateWithoutBatchInput, InventoryLedgerUncheckedCreateWithoutBatchInput> | InventoryLedgerCreateWithoutBatchInput[] | InventoryLedgerUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutBatchInput | InventoryLedgerCreateOrConnectWithoutBatchInput[]
    upsert?: InventoryLedgerUpsertWithWhereUniqueWithoutBatchInput | InventoryLedgerUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: InventoryLedgerCreateManyBatchInputEnvelope
    set?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    disconnect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    delete?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    update?: InventoryLedgerUpdateWithWhereUniqueWithoutBatchInput | InventoryLedgerUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: InventoryLedgerUpdateManyWithWhereWithoutBatchInput | InventoryLedgerUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: InventoryLedgerScalarWhereInput | InventoryLedgerScalarWhereInput[]
  }

  export type KegUpdateManyWithoutBatchNestedInput = {
    create?: XOR<KegCreateWithoutBatchInput, KegUncheckedCreateWithoutBatchInput> | KegCreateWithoutBatchInput[] | KegUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: KegCreateOrConnectWithoutBatchInput | KegCreateOrConnectWithoutBatchInput[]
    upsert?: KegUpsertWithWhereUniqueWithoutBatchInput | KegUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: KegCreateManyBatchInputEnvelope
    set?: KegWhereUniqueInput | KegWhereUniqueInput[]
    disconnect?: KegWhereUniqueInput | KegWhereUniqueInput[]
    delete?: KegWhereUniqueInput | KegWhereUniqueInput[]
    connect?: KegWhereUniqueInput | KegWhereUniqueInput[]
    update?: KegUpdateWithWhereUniqueWithoutBatchInput | KegUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: KegUpdateManyWithWhereWithoutBatchInput | KegUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: KegScalarWhereInput | KegScalarWhereInput[]
  }

  export type LotBatchUpdateManyWithoutBatchNestedInput = {
    create?: XOR<LotBatchCreateWithoutBatchInput, LotBatchUncheckedCreateWithoutBatchInput> | LotBatchCreateWithoutBatchInput[] | LotBatchUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: LotBatchCreateOrConnectWithoutBatchInput | LotBatchCreateOrConnectWithoutBatchInput[]
    upsert?: LotBatchUpsertWithWhereUniqueWithoutBatchInput | LotBatchUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: LotBatchCreateManyBatchInputEnvelope
    set?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
    disconnect?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
    delete?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
    connect?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
    update?: LotBatchUpdateWithWhereUniqueWithoutBatchInput | LotBatchUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: LotBatchUpdateManyWithWhereWithoutBatchInput | LotBatchUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: LotBatchScalarWhereInput | LotBatchScalarWhereInput[]
  }

  export type PackagingRunUpdateManyWithoutBatchNestedInput = {
    create?: XOR<PackagingRunCreateWithoutBatchInput, PackagingRunUncheckedCreateWithoutBatchInput> | PackagingRunCreateWithoutBatchInput[] | PackagingRunUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: PackagingRunCreateOrConnectWithoutBatchInput | PackagingRunCreateOrConnectWithoutBatchInput[]
    upsert?: PackagingRunUpsertWithWhereUniqueWithoutBatchInput | PackagingRunUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: PackagingRunCreateManyBatchInputEnvelope
    set?: PackagingRunWhereUniqueInput | PackagingRunWhereUniqueInput[]
    disconnect?: PackagingRunWhereUniqueInput | PackagingRunWhereUniqueInput[]
    delete?: PackagingRunWhereUniqueInput | PackagingRunWhereUniqueInput[]
    connect?: PackagingRunWhereUniqueInput | PackagingRunWhereUniqueInput[]
    update?: PackagingRunUpdateWithWhereUniqueWithoutBatchInput | PackagingRunUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: PackagingRunUpdateManyWithWhereWithoutBatchInput | PackagingRunUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: PackagingRunScalarWhereInput | PackagingRunScalarWhereInput[]
  }

  export type QCTestUpdateManyWithoutBatchNestedInput = {
    create?: XOR<QCTestCreateWithoutBatchInput, QCTestUncheckedCreateWithoutBatchInput> | QCTestCreateWithoutBatchInput[] | QCTestUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: QCTestCreateOrConnectWithoutBatchInput | QCTestCreateOrConnectWithoutBatchInput[]
    upsert?: QCTestUpsertWithWhereUniqueWithoutBatchInput | QCTestUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: QCTestCreateManyBatchInputEnvelope
    set?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
    disconnect?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
    delete?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
    connect?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
    update?: QCTestUpdateWithWhereUniqueWithoutBatchInput | QCTestUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: QCTestUpdateManyWithWhereWithoutBatchInput | QCTestUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: QCTestScalarWhereInput | QCTestScalarWhereInput[]
  }

  export type BatchIngredientUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<BatchIngredientCreateWithoutBatchInput, BatchIngredientUncheckedCreateWithoutBatchInput> | BatchIngredientCreateWithoutBatchInput[] | BatchIngredientUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchIngredientCreateOrConnectWithoutBatchInput | BatchIngredientCreateOrConnectWithoutBatchInput[]
    upsert?: BatchIngredientUpsertWithWhereUniqueWithoutBatchInput | BatchIngredientUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: BatchIngredientCreateManyBatchInputEnvelope
    set?: BatchIngredientWhereUniqueInput | BatchIngredientWhereUniqueInput[]
    disconnect?: BatchIngredientWhereUniqueInput | BatchIngredientWhereUniqueInput[]
    delete?: BatchIngredientWhereUniqueInput | BatchIngredientWhereUniqueInput[]
    connect?: BatchIngredientWhereUniqueInput | BatchIngredientWhereUniqueInput[]
    update?: BatchIngredientUpdateWithWhereUniqueWithoutBatchInput | BatchIngredientUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: BatchIngredientUpdateManyWithWhereWithoutBatchInput | BatchIngredientUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: BatchIngredientScalarWhereInput | BatchIngredientScalarWhereInput[]
  }

  export type BatchTimelineUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<BatchTimelineCreateWithoutBatchInput, BatchTimelineUncheckedCreateWithoutBatchInput> | BatchTimelineCreateWithoutBatchInput[] | BatchTimelineUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchTimelineCreateOrConnectWithoutBatchInput | BatchTimelineCreateOrConnectWithoutBatchInput[]
    upsert?: BatchTimelineUpsertWithWhereUniqueWithoutBatchInput | BatchTimelineUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: BatchTimelineCreateManyBatchInputEnvelope
    set?: BatchTimelineWhereUniqueInput | BatchTimelineWhereUniqueInput[]
    disconnect?: BatchTimelineWhereUniqueInput | BatchTimelineWhereUniqueInput[]
    delete?: BatchTimelineWhereUniqueInput | BatchTimelineWhereUniqueInput[]
    connect?: BatchTimelineWhereUniqueInput | BatchTimelineWhereUniqueInput[]
    update?: BatchTimelineUpdateWithWhereUniqueWithoutBatchInput | BatchTimelineUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: BatchTimelineUpdateManyWithWhereWithoutBatchInput | BatchTimelineUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: BatchTimelineScalarWhereInput | BatchTimelineScalarWhereInput[]
  }

  export type GravityReadingUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<GravityReadingCreateWithoutBatchInput, GravityReadingUncheckedCreateWithoutBatchInput> | GravityReadingCreateWithoutBatchInput[] | GravityReadingUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: GravityReadingCreateOrConnectWithoutBatchInput | GravityReadingCreateOrConnectWithoutBatchInput[]
    upsert?: GravityReadingUpsertWithWhereUniqueWithoutBatchInput | GravityReadingUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: GravityReadingCreateManyBatchInputEnvelope
    set?: GravityReadingWhereUniqueInput | GravityReadingWhereUniqueInput[]
    disconnect?: GravityReadingWhereUniqueInput | GravityReadingWhereUniqueInput[]
    delete?: GravityReadingWhereUniqueInput | GravityReadingWhereUniqueInput[]
    connect?: GravityReadingWhereUniqueInput | GravityReadingWhereUniqueInput[]
    update?: GravityReadingUpdateWithWhereUniqueWithoutBatchInput | GravityReadingUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: GravityReadingUpdateManyWithWhereWithoutBatchInput | GravityReadingUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: GravityReadingScalarWhereInput | GravityReadingScalarWhereInput[]
  }

  export type InventoryLedgerUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<InventoryLedgerCreateWithoutBatchInput, InventoryLedgerUncheckedCreateWithoutBatchInput> | InventoryLedgerCreateWithoutBatchInput[] | InventoryLedgerUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutBatchInput | InventoryLedgerCreateOrConnectWithoutBatchInput[]
    upsert?: InventoryLedgerUpsertWithWhereUniqueWithoutBatchInput | InventoryLedgerUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: InventoryLedgerCreateManyBatchInputEnvelope
    set?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    disconnect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    delete?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    update?: InventoryLedgerUpdateWithWhereUniqueWithoutBatchInput | InventoryLedgerUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: InventoryLedgerUpdateManyWithWhereWithoutBatchInput | InventoryLedgerUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: InventoryLedgerScalarWhereInput | InventoryLedgerScalarWhereInput[]
  }

  export type KegUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<KegCreateWithoutBatchInput, KegUncheckedCreateWithoutBatchInput> | KegCreateWithoutBatchInput[] | KegUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: KegCreateOrConnectWithoutBatchInput | KegCreateOrConnectWithoutBatchInput[]
    upsert?: KegUpsertWithWhereUniqueWithoutBatchInput | KegUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: KegCreateManyBatchInputEnvelope
    set?: KegWhereUniqueInput | KegWhereUniqueInput[]
    disconnect?: KegWhereUniqueInput | KegWhereUniqueInput[]
    delete?: KegWhereUniqueInput | KegWhereUniqueInput[]
    connect?: KegWhereUniqueInput | KegWhereUniqueInput[]
    update?: KegUpdateWithWhereUniqueWithoutBatchInput | KegUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: KegUpdateManyWithWhereWithoutBatchInput | KegUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: KegScalarWhereInput | KegScalarWhereInput[]
  }

  export type LotBatchUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<LotBatchCreateWithoutBatchInput, LotBatchUncheckedCreateWithoutBatchInput> | LotBatchCreateWithoutBatchInput[] | LotBatchUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: LotBatchCreateOrConnectWithoutBatchInput | LotBatchCreateOrConnectWithoutBatchInput[]
    upsert?: LotBatchUpsertWithWhereUniqueWithoutBatchInput | LotBatchUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: LotBatchCreateManyBatchInputEnvelope
    set?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
    disconnect?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
    delete?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
    connect?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
    update?: LotBatchUpdateWithWhereUniqueWithoutBatchInput | LotBatchUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: LotBatchUpdateManyWithWhereWithoutBatchInput | LotBatchUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: LotBatchScalarWhereInput | LotBatchScalarWhereInput[]
  }

  export type PackagingRunUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<PackagingRunCreateWithoutBatchInput, PackagingRunUncheckedCreateWithoutBatchInput> | PackagingRunCreateWithoutBatchInput[] | PackagingRunUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: PackagingRunCreateOrConnectWithoutBatchInput | PackagingRunCreateOrConnectWithoutBatchInput[]
    upsert?: PackagingRunUpsertWithWhereUniqueWithoutBatchInput | PackagingRunUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: PackagingRunCreateManyBatchInputEnvelope
    set?: PackagingRunWhereUniqueInput | PackagingRunWhereUniqueInput[]
    disconnect?: PackagingRunWhereUniqueInput | PackagingRunWhereUniqueInput[]
    delete?: PackagingRunWhereUniqueInput | PackagingRunWhereUniqueInput[]
    connect?: PackagingRunWhereUniqueInput | PackagingRunWhereUniqueInput[]
    update?: PackagingRunUpdateWithWhereUniqueWithoutBatchInput | PackagingRunUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: PackagingRunUpdateManyWithWhereWithoutBatchInput | PackagingRunUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: PackagingRunScalarWhereInput | PackagingRunScalarWhereInput[]
  }

  export type QCTestUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<QCTestCreateWithoutBatchInput, QCTestUncheckedCreateWithoutBatchInput> | QCTestCreateWithoutBatchInput[] | QCTestUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: QCTestCreateOrConnectWithoutBatchInput | QCTestCreateOrConnectWithoutBatchInput[]
    upsert?: QCTestUpsertWithWhereUniqueWithoutBatchInput | QCTestUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: QCTestCreateManyBatchInputEnvelope
    set?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
    disconnect?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
    delete?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
    connect?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
    update?: QCTestUpdateWithWhereUniqueWithoutBatchInput | QCTestUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: QCTestUpdateManyWithWhereWithoutBatchInput | QCTestUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: QCTestScalarWhereInput | QCTestScalarWhereInput[]
  }

  export type BatchCreateNestedOneWithoutIngredientsInput = {
    create?: XOR<BatchCreateWithoutIngredientsInput, BatchUncheckedCreateWithoutIngredientsInput>
    connectOrCreate?: BatchCreateOrConnectWithoutIngredientsInput
    connect?: BatchWhereUniqueInput
  }

  export type BatchUpdateOneRequiredWithoutIngredientsNestedInput = {
    create?: XOR<BatchCreateWithoutIngredientsInput, BatchUncheckedCreateWithoutIngredientsInput>
    connectOrCreate?: BatchCreateOrConnectWithoutIngredientsInput
    upsert?: BatchUpsertWithoutIngredientsInput
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutIngredientsInput, BatchUpdateWithoutIngredientsInput>, BatchUncheckedUpdateWithoutIngredientsInput>
  }

  export type BatchCreateNestedOneWithoutGravityReadingsInput = {
    create?: XOR<BatchCreateWithoutGravityReadingsInput, BatchUncheckedCreateWithoutGravityReadingsInput>
    connectOrCreate?: BatchCreateOrConnectWithoutGravityReadingsInput
    connect?: BatchWhereUniqueInput
  }

  export type BatchUpdateOneRequiredWithoutGravityReadingsNestedInput = {
    create?: XOR<BatchCreateWithoutGravityReadingsInput, BatchUncheckedCreateWithoutGravityReadingsInput>
    connectOrCreate?: BatchCreateOrConnectWithoutGravityReadingsInput
    upsert?: BatchUpsertWithoutGravityReadingsInput
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutGravityReadingsInput, BatchUpdateWithoutGravityReadingsInput>, BatchUncheckedUpdateWithoutGravityReadingsInput>
  }

  export type BatchCreateNestedOneWithoutTimelineInput = {
    create?: XOR<BatchCreateWithoutTimelineInput, BatchUncheckedCreateWithoutTimelineInput>
    connectOrCreate?: BatchCreateOrConnectWithoutTimelineInput
    connect?: BatchWhereUniqueInput
  }

  export type EnumTimelineEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.TimelineEventType
  }

  export type BatchUpdateOneRequiredWithoutTimelineNestedInput = {
    create?: XOR<BatchCreateWithoutTimelineInput, BatchUncheckedCreateWithoutTimelineInput>
    connectOrCreate?: BatchCreateOrConnectWithoutTimelineInput
    upsert?: BatchUpsertWithoutTimelineInput
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutTimelineInput, BatchUpdateWithoutTimelineInput>, BatchUncheckedUpdateWithoutTimelineInput>
  }

  export type TankCreatecapabilitiesInput = {
    set: $Enums.TankCapability[]
  }

  export type BatchCreateNestedManyWithoutTankInput = {
    create?: XOR<BatchCreateWithoutTankInput, BatchUncheckedCreateWithoutTankInput> | BatchCreateWithoutTankInput[] | BatchUncheckedCreateWithoutTankInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutTankInput | BatchCreateOrConnectWithoutTankInput[]
    createMany?: BatchCreateManyTankInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type LotReadingCreateNestedManyWithoutTankInput = {
    create?: XOR<LotReadingCreateWithoutTankInput, LotReadingUncheckedCreateWithoutTankInput> | LotReadingCreateWithoutTankInput[] | LotReadingUncheckedCreateWithoutTankInput[]
    connectOrCreate?: LotReadingCreateOrConnectWithoutTankInput | LotReadingCreateOrConnectWithoutTankInput[]
    createMany?: LotReadingCreateManyTankInputEnvelope
    connect?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutTanksInput = {
    create?: XOR<TenantCreateWithoutTanksInput, TenantUncheckedCreateWithoutTanksInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTanksInput
    connect?: TenantWhereUniqueInput
  }

  export type TankAssignmentCreateNestedManyWithoutTankInput = {
    create?: XOR<TankAssignmentCreateWithoutTankInput, TankAssignmentUncheckedCreateWithoutTankInput> | TankAssignmentCreateWithoutTankInput[] | TankAssignmentUncheckedCreateWithoutTankInput[]
    connectOrCreate?: TankAssignmentCreateOrConnectWithoutTankInput | TankAssignmentCreateOrConnectWithoutTankInput[]
    createMany?: TankAssignmentCreateManyTankInputEnvelope
    connect?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
  }

  export type TankOccupationCreateNestedManyWithoutTankInput = {
    create?: XOR<TankOccupationCreateWithoutTankInput, TankOccupationUncheckedCreateWithoutTankInput> | TankOccupationCreateWithoutTankInput[] | TankOccupationUncheckedCreateWithoutTankInput[]
    connectOrCreate?: TankOccupationCreateOrConnectWithoutTankInput | TankOccupationCreateOrConnectWithoutTankInput[]
    createMany?: TankOccupationCreateManyTankInputEnvelope
    connect?: TankOccupationWhereUniqueInput | TankOccupationWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutTank_Transfer_destTankIdToTankInput = {
    create?: XOR<TransferCreateWithoutTank_Transfer_destTankIdToTankInput, TransferUncheckedCreateWithoutTank_Transfer_destTankIdToTankInput> | TransferCreateWithoutTank_Transfer_destTankIdToTankInput[] | TransferUncheckedCreateWithoutTank_Transfer_destTankIdToTankInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutTank_Transfer_destTankIdToTankInput | TransferCreateOrConnectWithoutTank_Transfer_destTankIdToTankInput[]
    createMany?: TransferCreateManyTank_Transfer_destTankIdToTankInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutTank_Transfer_sourceTankIdToTankInput = {
    create?: XOR<TransferCreateWithoutTank_Transfer_sourceTankIdToTankInput, TransferUncheckedCreateWithoutTank_Transfer_sourceTankIdToTankInput> | TransferCreateWithoutTank_Transfer_sourceTankIdToTankInput[] | TransferUncheckedCreateWithoutTank_Transfer_sourceTankIdToTankInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutTank_Transfer_sourceTankIdToTankInput | TransferCreateOrConnectWithoutTank_Transfer_sourceTankIdToTankInput[]
    createMany?: TransferCreateManyTank_Transfer_sourceTankIdToTankInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutTankInput = {
    create?: XOR<BatchCreateWithoutTankInput, BatchUncheckedCreateWithoutTankInput> | BatchCreateWithoutTankInput[] | BatchUncheckedCreateWithoutTankInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutTankInput | BatchCreateOrConnectWithoutTankInput[]
    createMany?: BatchCreateManyTankInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type LotReadingUncheckedCreateNestedManyWithoutTankInput = {
    create?: XOR<LotReadingCreateWithoutTankInput, LotReadingUncheckedCreateWithoutTankInput> | LotReadingCreateWithoutTankInput[] | LotReadingUncheckedCreateWithoutTankInput[]
    connectOrCreate?: LotReadingCreateOrConnectWithoutTankInput | LotReadingCreateOrConnectWithoutTankInput[]
    createMany?: LotReadingCreateManyTankInputEnvelope
    connect?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
  }

  export type TankAssignmentUncheckedCreateNestedManyWithoutTankInput = {
    create?: XOR<TankAssignmentCreateWithoutTankInput, TankAssignmentUncheckedCreateWithoutTankInput> | TankAssignmentCreateWithoutTankInput[] | TankAssignmentUncheckedCreateWithoutTankInput[]
    connectOrCreate?: TankAssignmentCreateOrConnectWithoutTankInput | TankAssignmentCreateOrConnectWithoutTankInput[]
    createMany?: TankAssignmentCreateManyTankInputEnvelope
    connect?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
  }

  export type TankOccupationUncheckedCreateNestedManyWithoutTankInput = {
    create?: XOR<TankOccupationCreateWithoutTankInput, TankOccupationUncheckedCreateWithoutTankInput> | TankOccupationCreateWithoutTankInput[] | TankOccupationUncheckedCreateWithoutTankInput[]
    connectOrCreate?: TankOccupationCreateOrConnectWithoutTankInput | TankOccupationCreateOrConnectWithoutTankInput[]
    createMany?: TankOccupationCreateManyTankInputEnvelope
    connect?: TankOccupationWhereUniqueInput | TankOccupationWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutTank_Transfer_destTankIdToTankInput = {
    create?: XOR<TransferCreateWithoutTank_Transfer_destTankIdToTankInput, TransferUncheckedCreateWithoutTank_Transfer_destTankIdToTankInput> | TransferCreateWithoutTank_Transfer_destTankIdToTankInput[] | TransferUncheckedCreateWithoutTank_Transfer_destTankIdToTankInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutTank_Transfer_destTankIdToTankInput | TransferCreateOrConnectWithoutTank_Transfer_destTankIdToTankInput[]
    createMany?: TransferCreateManyTank_Transfer_destTankIdToTankInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutTank_Transfer_sourceTankIdToTankInput = {
    create?: XOR<TransferCreateWithoutTank_Transfer_sourceTankIdToTankInput, TransferUncheckedCreateWithoutTank_Transfer_sourceTankIdToTankInput> | TransferCreateWithoutTank_Transfer_sourceTankIdToTankInput[] | TransferUncheckedCreateWithoutTank_Transfer_sourceTankIdToTankInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutTank_Transfer_sourceTankIdToTankInput | TransferCreateOrConnectWithoutTank_Transfer_sourceTankIdToTankInput[]
    createMany?: TransferCreateManyTank_Transfer_sourceTankIdToTankInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type EnumTankTypeFieldUpdateOperationsInput = {
    set?: $Enums.TankType
  }

  export type EnumTankStatusFieldUpdateOperationsInput = {
    set?: $Enums.TankStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TankUpdatecapabilitiesInput = {
    set?: $Enums.TankCapability[]
    push?: $Enums.TankCapability | $Enums.TankCapability[]
  }

  export type NullableEnumLotPhaseFieldUpdateOperationsInput = {
    set?: $Enums.LotPhase | null
  }

  export type BatchUpdateManyWithoutTankNestedInput = {
    create?: XOR<BatchCreateWithoutTankInput, BatchUncheckedCreateWithoutTankInput> | BatchCreateWithoutTankInput[] | BatchUncheckedCreateWithoutTankInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutTankInput | BatchCreateOrConnectWithoutTankInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutTankInput | BatchUpsertWithWhereUniqueWithoutTankInput[]
    createMany?: BatchCreateManyTankInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutTankInput | BatchUpdateWithWhereUniqueWithoutTankInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutTankInput | BatchUpdateManyWithWhereWithoutTankInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type LotReadingUpdateManyWithoutTankNestedInput = {
    create?: XOR<LotReadingCreateWithoutTankInput, LotReadingUncheckedCreateWithoutTankInput> | LotReadingCreateWithoutTankInput[] | LotReadingUncheckedCreateWithoutTankInput[]
    connectOrCreate?: LotReadingCreateOrConnectWithoutTankInput | LotReadingCreateOrConnectWithoutTankInput[]
    upsert?: LotReadingUpsertWithWhereUniqueWithoutTankInput | LotReadingUpsertWithWhereUniqueWithoutTankInput[]
    createMany?: LotReadingCreateManyTankInputEnvelope
    set?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
    disconnect?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
    delete?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
    connect?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
    update?: LotReadingUpdateWithWhereUniqueWithoutTankInput | LotReadingUpdateWithWhereUniqueWithoutTankInput[]
    updateMany?: LotReadingUpdateManyWithWhereWithoutTankInput | LotReadingUpdateManyWithWhereWithoutTankInput[]
    deleteMany?: LotReadingScalarWhereInput | LotReadingScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutTanksNestedInput = {
    create?: XOR<TenantCreateWithoutTanksInput, TenantUncheckedCreateWithoutTanksInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTanksInput
    upsert?: TenantUpsertWithoutTanksInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTanksInput, TenantUpdateWithoutTanksInput>, TenantUncheckedUpdateWithoutTanksInput>
  }

  export type TankAssignmentUpdateManyWithoutTankNestedInput = {
    create?: XOR<TankAssignmentCreateWithoutTankInput, TankAssignmentUncheckedCreateWithoutTankInput> | TankAssignmentCreateWithoutTankInput[] | TankAssignmentUncheckedCreateWithoutTankInput[]
    connectOrCreate?: TankAssignmentCreateOrConnectWithoutTankInput | TankAssignmentCreateOrConnectWithoutTankInput[]
    upsert?: TankAssignmentUpsertWithWhereUniqueWithoutTankInput | TankAssignmentUpsertWithWhereUniqueWithoutTankInput[]
    createMany?: TankAssignmentCreateManyTankInputEnvelope
    set?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
    disconnect?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
    delete?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
    connect?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
    update?: TankAssignmentUpdateWithWhereUniqueWithoutTankInput | TankAssignmentUpdateWithWhereUniqueWithoutTankInput[]
    updateMany?: TankAssignmentUpdateManyWithWhereWithoutTankInput | TankAssignmentUpdateManyWithWhereWithoutTankInput[]
    deleteMany?: TankAssignmentScalarWhereInput | TankAssignmentScalarWhereInput[]
  }

  export type TankOccupationUpdateManyWithoutTankNestedInput = {
    create?: XOR<TankOccupationCreateWithoutTankInput, TankOccupationUncheckedCreateWithoutTankInput> | TankOccupationCreateWithoutTankInput[] | TankOccupationUncheckedCreateWithoutTankInput[]
    connectOrCreate?: TankOccupationCreateOrConnectWithoutTankInput | TankOccupationCreateOrConnectWithoutTankInput[]
    upsert?: TankOccupationUpsertWithWhereUniqueWithoutTankInput | TankOccupationUpsertWithWhereUniqueWithoutTankInput[]
    createMany?: TankOccupationCreateManyTankInputEnvelope
    set?: TankOccupationWhereUniqueInput | TankOccupationWhereUniqueInput[]
    disconnect?: TankOccupationWhereUniqueInput | TankOccupationWhereUniqueInput[]
    delete?: TankOccupationWhereUniqueInput | TankOccupationWhereUniqueInput[]
    connect?: TankOccupationWhereUniqueInput | TankOccupationWhereUniqueInput[]
    update?: TankOccupationUpdateWithWhereUniqueWithoutTankInput | TankOccupationUpdateWithWhereUniqueWithoutTankInput[]
    updateMany?: TankOccupationUpdateManyWithWhereWithoutTankInput | TankOccupationUpdateManyWithWhereWithoutTankInput[]
    deleteMany?: TankOccupationScalarWhereInput | TankOccupationScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutTank_Transfer_destTankIdToTankNestedInput = {
    create?: XOR<TransferCreateWithoutTank_Transfer_destTankIdToTankInput, TransferUncheckedCreateWithoutTank_Transfer_destTankIdToTankInput> | TransferCreateWithoutTank_Transfer_destTankIdToTankInput[] | TransferUncheckedCreateWithoutTank_Transfer_destTankIdToTankInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutTank_Transfer_destTankIdToTankInput | TransferCreateOrConnectWithoutTank_Transfer_destTankIdToTankInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutTank_Transfer_destTankIdToTankInput | TransferUpsertWithWhereUniqueWithoutTank_Transfer_destTankIdToTankInput[]
    createMany?: TransferCreateManyTank_Transfer_destTankIdToTankInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutTank_Transfer_destTankIdToTankInput | TransferUpdateWithWhereUniqueWithoutTank_Transfer_destTankIdToTankInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutTank_Transfer_destTankIdToTankInput | TransferUpdateManyWithWhereWithoutTank_Transfer_destTankIdToTankInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutTank_Transfer_sourceTankIdToTankNestedInput = {
    create?: XOR<TransferCreateWithoutTank_Transfer_sourceTankIdToTankInput, TransferUncheckedCreateWithoutTank_Transfer_sourceTankIdToTankInput> | TransferCreateWithoutTank_Transfer_sourceTankIdToTankInput[] | TransferUncheckedCreateWithoutTank_Transfer_sourceTankIdToTankInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutTank_Transfer_sourceTankIdToTankInput | TransferCreateOrConnectWithoutTank_Transfer_sourceTankIdToTankInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutTank_Transfer_sourceTankIdToTankInput | TransferUpsertWithWhereUniqueWithoutTank_Transfer_sourceTankIdToTankInput[]
    createMany?: TransferCreateManyTank_Transfer_sourceTankIdToTankInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutTank_Transfer_sourceTankIdToTankInput | TransferUpdateWithWhereUniqueWithoutTank_Transfer_sourceTankIdToTankInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutTank_Transfer_sourceTankIdToTankInput | TransferUpdateManyWithWhereWithoutTank_Transfer_sourceTankIdToTankInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutTankNestedInput = {
    create?: XOR<BatchCreateWithoutTankInput, BatchUncheckedCreateWithoutTankInput> | BatchCreateWithoutTankInput[] | BatchUncheckedCreateWithoutTankInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutTankInput | BatchCreateOrConnectWithoutTankInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutTankInput | BatchUpsertWithWhereUniqueWithoutTankInput[]
    createMany?: BatchCreateManyTankInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutTankInput | BatchUpdateWithWhereUniqueWithoutTankInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutTankInput | BatchUpdateManyWithWhereWithoutTankInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type LotReadingUncheckedUpdateManyWithoutTankNestedInput = {
    create?: XOR<LotReadingCreateWithoutTankInput, LotReadingUncheckedCreateWithoutTankInput> | LotReadingCreateWithoutTankInput[] | LotReadingUncheckedCreateWithoutTankInput[]
    connectOrCreate?: LotReadingCreateOrConnectWithoutTankInput | LotReadingCreateOrConnectWithoutTankInput[]
    upsert?: LotReadingUpsertWithWhereUniqueWithoutTankInput | LotReadingUpsertWithWhereUniqueWithoutTankInput[]
    createMany?: LotReadingCreateManyTankInputEnvelope
    set?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
    disconnect?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
    delete?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
    connect?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
    update?: LotReadingUpdateWithWhereUniqueWithoutTankInput | LotReadingUpdateWithWhereUniqueWithoutTankInput[]
    updateMany?: LotReadingUpdateManyWithWhereWithoutTankInput | LotReadingUpdateManyWithWhereWithoutTankInput[]
    deleteMany?: LotReadingScalarWhereInput | LotReadingScalarWhereInput[]
  }

  export type TankAssignmentUncheckedUpdateManyWithoutTankNestedInput = {
    create?: XOR<TankAssignmentCreateWithoutTankInput, TankAssignmentUncheckedCreateWithoutTankInput> | TankAssignmentCreateWithoutTankInput[] | TankAssignmentUncheckedCreateWithoutTankInput[]
    connectOrCreate?: TankAssignmentCreateOrConnectWithoutTankInput | TankAssignmentCreateOrConnectWithoutTankInput[]
    upsert?: TankAssignmentUpsertWithWhereUniqueWithoutTankInput | TankAssignmentUpsertWithWhereUniqueWithoutTankInput[]
    createMany?: TankAssignmentCreateManyTankInputEnvelope
    set?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
    disconnect?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
    delete?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
    connect?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
    update?: TankAssignmentUpdateWithWhereUniqueWithoutTankInput | TankAssignmentUpdateWithWhereUniqueWithoutTankInput[]
    updateMany?: TankAssignmentUpdateManyWithWhereWithoutTankInput | TankAssignmentUpdateManyWithWhereWithoutTankInput[]
    deleteMany?: TankAssignmentScalarWhereInput | TankAssignmentScalarWhereInput[]
  }

  export type TankOccupationUncheckedUpdateManyWithoutTankNestedInput = {
    create?: XOR<TankOccupationCreateWithoutTankInput, TankOccupationUncheckedCreateWithoutTankInput> | TankOccupationCreateWithoutTankInput[] | TankOccupationUncheckedCreateWithoutTankInput[]
    connectOrCreate?: TankOccupationCreateOrConnectWithoutTankInput | TankOccupationCreateOrConnectWithoutTankInput[]
    upsert?: TankOccupationUpsertWithWhereUniqueWithoutTankInput | TankOccupationUpsertWithWhereUniqueWithoutTankInput[]
    createMany?: TankOccupationCreateManyTankInputEnvelope
    set?: TankOccupationWhereUniqueInput | TankOccupationWhereUniqueInput[]
    disconnect?: TankOccupationWhereUniqueInput | TankOccupationWhereUniqueInput[]
    delete?: TankOccupationWhereUniqueInput | TankOccupationWhereUniqueInput[]
    connect?: TankOccupationWhereUniqueInput | TankOccupationWhereUniqueInput[]
    update?: TankOccupationUpdateWithWhereUniqueWithoutTankInput | TankOccupationUpdateWithWhereUniqueWithoutTankInput[]
    updateMany?: TankOccupationUpdateManyWithWhereWithoutTankInput | TankOccupationUpdateManyWithWhereWithoutTankInput[]
    deleteMany?: TankOccupationScalarWhereInput | TankOccupationScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutTank_Transfer_destTankIdToTankNestedInput = {
    create?: XOR<TransferCreateWithoutTank_Transfer_destTankIdToTankInput, TransferUncheckedCreateWithoutTank_Transfer_destTankIdToTankInput> | TransferCreateWithoutTank_Transfer_destTankIdToTankInput[] | TransferUncheckedCreateWithoutTank_Transfer_destTankIdToTankInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutTank_Transfer_destTankIdToTankInput | TransferCreateOrConnectWithoutTank_Transfer_destTankIdToTankInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutTank_Transfer_destTankIdToTankInput | TransferUpsertWithWhereUniqueWithoutTank_Transfer_destTankIdToTankInput[]
    createMany?: TransferCreateManyTank_Transfer_destTankIdToTankInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutTank_Transfer_destTankIdToTankInput | TransferUpdateWithWhereUniqueWithoutTank_Transfer_destTankIdToTankInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutTank_Transfer_destTankIdToTankInput | TransferUpdateManyWithWhereWithoutTank_Transfer_destTankIdToTankInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutTank_Transfer_sourceTankIdToTankNestedInput = {
    create?: XOR<TransferCreateWithoutTank_Transfer_sourceTankIdToTankInput, TransferUncheckedCreateWithoutTank_Transfer_sourceTankIdToTankInput> | TransferCreateWithoutTank_Transfer_sourceTankIdToTankInput[] | TransferUncheckedCreateWithoutTank_Transfer_sourceTankIdToTankInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutTank_Transfer_sourceTankIdToTankInput | TransferCreateOrConnectWithoutTank_Transfer_sourceTankIdToTankInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutTank_Transfer_sourceTankIdToTankInput | TransferUpsertWithWhereUniqueWithoutTank_Transfer_sourceTankIdToTankInput[]
    createMany?: TransferCreateManyTank_Transfer_sourceTankIdToTankInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutTank_Transfer_sourceTankIdToTankInput | TransferUpdateWithWhereUniqueWithoutTank_Transfer_sourceTankIdToTankInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutTank_Transfer_sourceTankIdToTankInput | TransferUpdateManyWithWhereWithoutTank_Transfer_sourceTankIdToTankInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TankCreateNestedOneWithoutOccupationsInput = {
    create?: XOR<TankCreateWithoutOccupationsInput, TankUncheckedCreateWithoutOccupationsInput>
    connectOrCreate?: TankCreateOrConnectWithoutOccupationsInput
    connect?: TankWhereUniqueInput
  }

  export type EnumOccupationPhaseFieldUpdateOperationsInput = {
    set?: $Enums.OccupationPhase
  }

  export type TankUpdateOneRequiredWithoutOccupationsNestedInput = {
    create?: XOR<TankCreateWithoutOccupationsInput, TankUncheckedCreateWithoutOccupationsInput>
    connectOrCreate?: TankCreateOrConnectWithoutOccupationsInput
    upsert?: TankUpsertWithoutOccupationsInput
    connect?: TankWhereUniqueInput
    update?: XOR<XOR<TankUpdateToOneWithWhereWithoutOccupationsInput, TankUpdateWithoutOccupationsInput>, TankUncheckedUpdateWithoutOccupationsInput>
  }

  export type BatchCreateNestedOneWithoutPackagingRunsInput = {
    create?: XOR<BatchCreateWithoutPackagingRunsInput, BatchUncheckedCreateWithoutPackagingRunsInput>
    connectOrCreate?: BatchCreateOrConnectWithoutPackagingRunsInput
    connect?: BatchWhereUniqueInput
  }

  export type EnumPackageTypeFieldUpdateOperationsInput = {
    set?: $Enums.PackageType
  }

  export type BatchUpdateOneRequiredWithoutPackagingRunsNestedInput = {
    create?: XOR<BatchCreateWithoutPackagingRunsInput, BatchUncheckedCreateWithoutPackagingRunsInput>
    connectOrCreate?: BatchCreateOrConnectWithoutPackagingRunsInput
    upsert?: BatchUpsertWithoutPackagingRunsInput
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutPackagingRunsInput, BatchUpdateWithoutPackagingRunsInput>, BatchUncheckedUpdateWithoutPackagingRunsInput>
  }

  export type TenantCreateNestedOneWithoutCustomersInput = {
    create?: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCustomersInput
    connect?: TenantWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type KegCreateNestedManyWithoutCustomerInput = {
    create?: XOR<KegCreateWithoutCustomerInput, KegUncheckedCreateWithoutCustomerInput> | KegCreateWithoutCustomerInput[] | KegUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: KegCreateOrConnectWithoutCustomerInput | KegCreateOrConnectWithoutCustomerInput[]
    createMany?: KegCreateManyCustomerInputEnvelope
    connect?: KegWhereUniqueInput | KegWhereUniqueInput[]
  }

  export type SalesOrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput> | SalesOrderCreateWithoutCustomerInput[] | SalesOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCustomerInput | SalesOrderCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesOrderCreateManyCustomerInputEnvelope
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type KegUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<KegCreateWithoutCustomerInput, KegUncheckedCreateWithoutCustomerInput> | KegCreateWithoutCustomerInput[] | KegUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: KegCreateOrConnectWithoutCustomerInput | KegCreateOrConnectWithoutCustomerInput[]
    createMany?: KegCreateManyCustomerInputEnvelope
    connect?: KegWhereUniqueInput | KegWhereUniqueInput[]
  }

  export type SalesOrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput> | SalesOrderCreateWithoutCustomerInput[] | SalesOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCustomerInput | SalesOrderCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesOrderCreateManyCustomerInputEnvelope
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EnumCustomerTypeFieldUpdateOperationsInput = {
    set?: $Enums.CustomerType
  }

  export type TenantUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCustomersInput
    upsert?: TenantUpsertWithoutCustomersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCustomersInput, TenantUpdateWithoutCustomersInput>, TenantUncheckedUpdateWithoutCustomersInput>
  }

  export type InvoiceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerInput | InvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerInput | InvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerInput | InvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type KegUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<KegCreateWithoutCustomerInput, KegUncheckedCreateWithoutCustomerInput> | KegCreateWithoutCustomerInput[] | KegUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: KegCreateOrConnectWithoutCustomerInput | KegCreateOrConnectWithoutCustomerInput[]
    upsert?: KegUpsertWithWhereUniqueWithoutCustomerInput | KegUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: KegCreateManyCustomerInputEnvelope
    set?: KegWhereUniqueInput | KegWhereUniqueInput[]
    disconnect?: KegWhereUniqueInput | KegWhereUniqueInput[]
    delete?: KegWhereUniqueInput | KegWhereUniqueInput[]
    connect?: KegWhereUniqueInput | KegWhereUniqueInput[]
    update?: KegUpdateWithWhereUniqueWithoutCustomerInput | KegUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: KegUpdateManyWithWhereWithoutCustomerInput | KegUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: KegScalarWhereInput | KegScalarWhereInput[]
  }

  export type SalesOrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput> | SalesOrderCreateWithoutCustomerInput[] | SalesOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCustomerInput | SalesOrderCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesOrderUpsertWithWhereUniqueWithoutCustomerInput | SalesOrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesOrderCreateManyCustomerInputEnvelope
    set?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    disconnect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    delete?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    update?: SalesOrderUpdateWithWhereUniqueWithoutCustomerInput | SalesOrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesOrderUpdateManyWithWhereWithoutCustomerInput | SalesOrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCustomerInput | TransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCustomerInput | TransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCustomerInput | TransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerInput | InvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerInput | InvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerInput | InvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type KegUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<KegCreateWithoutCustomerInput, KegUncheckedCreateWithoutCustomerInput> | KegCreateWithoutCustomerInput[] | KegUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: KegCreateOrConnectWithoutCustomerInput | KegCreateOrConnectWithoutCustomerInput[]
    upsert?: KegUpsertWithWhereUniqueWithoutCustomerInput | KegUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: KegCreateManyCustomerInputEnvelope
    set?: KegWhereUniqueInput | KegWhereUniqueInput[]
    disconnect?: KegWhereUniqueInput | KegWhereUniqueInput[]
    delete?: KegWhereUniqueInput | KegWhereUniqueInput[]
    connect?: KegWhereUniqueInput | KegWhereUniqueInput[]
    update?: KegUpdateWithWhereUniqueWithoutCustomerInput | KegUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: KegUpdateManyWithWhereWithoutCustomerInput | KegUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: KegScalarWhereInput | KegScalarWhereInput[]
  }

  export type SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput> | SalesOrderCreateWithoutCustomerInput[] | SalesOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCustomerInput | SalesOrderCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesOrderUpsertWithWhereUniqueWithoutCustomerInput | SalesOrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesOrderCreateManyCustomerInputEnvelope
    set?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    disconnect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    delete?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    update?: SalesOrderUpdateWithWhereUniqueWithoutCustomerInput | SalesOrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesOrderUpdateManyWithWhereWithoutCustomerInput | SalesOrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCustomerInput | TransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCustomerInput | TransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCustomerInput | TransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ExpenseCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ExpenseCreateWithoutSupplierInput, ExpenseUncheckedCreateWithoutSupplierInput> | ExpenseCreateWithoutSupplierInput[] | ExpenseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutSupplierInput | ExpenseCreateOrConnectWithoutSupplierInput[]
    createMany?: ExpenseCreateManySupplierInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutSupplierInput = {
    create?: XOR<InvoiceCreateWithoutSupplierInput, InvoiceUncheckedCreateWithoutSupplierInput> | InvoiceCreateWithoutSupplierInput[] | InvoiceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSupplierInput | InvoiceCreateOrConnectWithoutSupplierInput[]
    createMany?: InvoiceCreateManySupplierInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<TenantCreateWithoutSuppliersInput, TenantUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSuppliersInput
    connect?: TenantWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutSupplierInput = {
    create?: XOR<TransactionCreateWithoutSupplierInput, TransactionUncheckedCreateWithoutSupplierInput> | TransactionCreateWithoutSupplierInput[] | TransactionUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSupplierInput | TransactionCreateOrConnectWithoutSupplierInput[]
    createMany?: TransactionCreateManySupplierInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ExpenseCreateWithoutSupplierInput, ExpenseUncheckedCreateWithoutSupplierInput> | ExpenseCreateWithoutSupplierInput[] | ExpenseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutSupplierInput | ExpenseCreateOrConnectWithoutSupplierInput[]
    createMany?: ExpenseCreateManySupplierInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<InvoiceCreateWithoutSupplierInput, InvoiceUncheckedCreateWithoutSupplierInput> | InvoiceCreateWithoutSupplierInput[] | InvoiceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSupplierInput | InvoiceCreateOrConnectWithoutSupplierInput[]
    createMany?: InvoiceCreateManySupplierInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<TransactionCreateWithoutSupplierInput, TransactionUncheckedCreateWithoutSupplierInput> | TransactionCreateWithoutSupplierInput[] | TransactionUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSupplierInput | TransactionCreateOrConnectWithoutSupplierInput[]
    createMany?: TransactionCreateManySupplierInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ExpenseUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ExpenseCreateWithoutSupplierInput, ExpenseUncheckedCreateWithoutSupplierInput> | ExpenseCreateWithoutSupplierInput[] | ExpenseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutSupplierInput | ExpenseCreateOrConnectWithoutSupplierInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutSupplierInput | ExpenseUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ExpenseCreateManySupplierInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutSupplierInput | ExpenseUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutSupplierInput | ExpenseUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<InvoiceCreateWithoutSupplierInput, InvoiceUncheckedCreateWithoutSupplierInput> | InvoiceCreateWithoutSupplierInput[] | InvoiceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSupplierInput | InvoiceCreateOrConnectWithoutSupplierInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSupplierInput | InvoiceUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: InvoiceCreateManySupplierInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSupplierInput | InvoiceUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSupplierInput | InvoiceUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutSuppliersNestedInput = {
    create?: XOR<TenantCreateWithoutSuppliersInput, TenantUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSuppliersInput
    upsert?: TenantUpsertWithoutSuppliersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSuppliersInput, TenantUpdateWithoutSuppliersInput>, TenantUncheckedUpdateWithoutSuppliersInput>
  }

  export type TransactionUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<TransactionCreateWithoutSupplierInput, TransactionUncheckedCreateWithoutSupplierInput> | TransactionCreateWithoutSupplierInput[] | TransactionUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSupplierInput | TransactionCreateOrConnectWithoutSupplierInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutSupplierInput | TransactionUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: TransactionCreateManySupplierInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutSupplierInput | TransactionUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutSupplierInput | TransactionUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ExpenseCreateWithoutSupplierInput, ExpenseUncheckedCreateWithoutSupplierInput> | ExpenseCreateWithoutSupplierInput[] | ExpenseUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutSupplierInput | ExpenseCreateOrConnectWithoutSupplierInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutSupplierInput | ExpenseUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ExpenseCreateManySupplierInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutSupplierInput | ExpenseUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutSupplierInput | ExpenseUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<InvoiceCreateWithoutSupplierInput, InvoiceUncheckedCreateWithoutSupplierInput> | InvoiceCreateWithoutSupplierInput[] | InvoiceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSupplierInput | InvoiceCreateOrConnectWithoutSupplierInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSupplierInput | InvoiceUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: InvoiceCreateManySupplierInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSupplierInput | InvoiceUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSupplierInput | InvoiceUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<TransactionCreateWithoutSupplierInput, TransactionUncheckedCreateWithoutSupplierInput> | TransactionCreateWithoutSupplierInput[] | TransactionUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutSupplierInput | TransactionCreateOrConnectWithoutSupplierInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutSupplierInput | TransactionUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: TransactionCreateManySupplierInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutSupplierInput | TransactionUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutSupplierInput | TransactionUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutOrderInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput
    connect?: InvoiceWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutOrdersInput = {
    create?: XOR<TenantCreateWithoutOrdersInput, TenantUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOrdersInput
    connect?: TenantWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutOrderInput = {
    create?: XOR<TransactionCreateWithoutOrderInput, TransactionUncheckedCreateWithoutOrderInput> | TransactionCreateWithoutOrderInput[] | TransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutOrderInput | TransactionCreateOrConnectWithoutOrderInput[]
    createMany?: TransactionCreateManyOrderInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput
    connect?: InvoiceWhereUniqueInput
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<TransactionCreateWithoutOrderInput, TransactionUncheckedCreateWithoutOrderInput> | TransactionCreateWithoutOrderInput[] | TransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutOrderInput | TransactionCreateOrConnectWithoutOrderInput[]
    createMany?: TransactionCreateManyOrderInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type InvoiceUpdateOneWithoutOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput
    upsert?: InvoiceUpsertWithoutOrderInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutOrderInput, InvoiceUpdateWithoutOrderInput>, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CustomerUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type TenantUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<TenantCreateWithoutOrdersInput, TenantUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOrdersInput
    upsert?: TenantUpsertWithoutOrdersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutOrdersInput, TenantUpdateWithoutOrdersInput>, TenantUncheckedUpdateWithoutOrdersInput>
  }

  export type TransactionUpdateManyWithoutOrderNestedInput = {
    create?: XOR<TransactionCreateWithoutOrderInput, TransactionUncheckedCreateWithoutOrderInput> | TransactionCreateWithoutOrderInput[] | TransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutOrderInput | TransactionCreateOrConnectWithoutOrderInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutOrderInput | TransactionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: TransactionCreateManyOrderInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutOrderInput | TransactionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutOrderInput | TransactionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput
    upsert?: InvoiceUpsertWithoutOrderInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutOrderInput, InvoiceUpdateWithoutOrderInput>, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<TransactionCreateWithoutOrderInput, TransactionUncheckedCreateWithoutOrderInput> | TransactionCreateWithoutOrderInput[] | TransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutOrderInput | TransactionCreateOrConnectWithoutOrderInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutOrderInput | TransactionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: TransactionCreateManyOrderInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutOrderInput | TransactionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutOrderInput | TransactionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type SalesOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<SalesOrderCreateWithoutItemsInput, SalesOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutItemsInput
    connect?: SalesOrderWhereUniqueInput
  }

  export type SalesOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SalesOrderCreateWithoutItemsInput, SalesOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutItemsInput
    upsert?: SalesOrderUpsertWithoutItemsInput
    connect?: SalesOrderWhereUniqueInput
    update?: XOR<XOR<SalesOrderUpdateToOneWithWhereWithoutItemsInput, SalesOrderUpdateWithoutItemsInput>, SalesOrderUncheckedUpdateWithoutItemsInput>
  }

  export type CustomerCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionsInput
    connect?: CustomerWhereUniqueInput
  }

  export type ExpenseCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<ExpenseCreateWithoutTransactionsInput, ExpenseUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ExpenseCreateOrConnectWithoutTransactionsInput
    connect?: ExpenseWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTransactionsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type SalesOrderCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<SalesOrderCreateWithoutTransactionsInput, SalesOrderUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutTransactionsInput
    connect?: SalesOrderWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<SupplierCreateWithoutTransactionsInput, SupplierUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutTransactionsInput
    connect?: SupplierWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<TenantCreateWithoutTransactionsInput, TenantUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTransactionsInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type NullableEnumIncomeCategoryFieldUpdateOperationsInput = {
    set?: $Enums.IncomeCategory | null
  }

  export type NullableEnumExpenseCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ExpenseCategory | null
  }

  export type NullableEnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod | null
  }

  export type CustomerUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionsInput
    upsert?: CustomerUpsertWithoutTransactionsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutTransactionsInput, CustomerUpdateWithoutTransactionsInput>, CustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type ExpenseUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<ExpenseCreateWithoutTransactionsInput, ExpenseUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ExpenseCreateOrConnectWithoutTransactionsInput
    upsert?: ExpenseUpsertWithoutTransactionsInput
    disconnect?: ExpenseWhereInput | boolean
    delete?: ExpenseWhereInput | boolean
    connect?: ExpenseWhereUniqueInput
    update?: XOR<XOR<ExpenseUpdateToOneWithWhereWithoutTransactionsInput, ExpenseUpdateWithoutTransactionsInput>, ExpenseUncheckedUpdateWithoutTransactionsInput>
  }

  export type InvoiceUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTransactionsInput
    upsert?: InvoiceUpsertWithoutTransactionsInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutTransactionsInput, InvoiceUpdateWithoutTransactionsInput>, InvoiceUncheckedUpdateWithoutTransactionsInput>
  }

  export type SalesOrderUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<SalesOrderCreateWithoutTransactionsInput, SalesOrderUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutTransactionsInput
    upsert?: SalesOrderUpsertWithoutTransactionsInput
    disconnect?: SalesOrderWhereInput | boolean
    delete?: SalesOrderWhereInput | boolean
    connect?: SalesOrderWhereUniqueInput
    update?: XOR<XOR<SalesOrderUpdateToOneWithWhereWithoutTransactionsInput, SalesOrderUpdateWithoutTransactionsInput>, SalesOrderUncheckedUpdateWithoutTransactionsInput>
  }

  export type SupplierUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<SupplierCreateWithoutTransactionsInput, SupplierUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutTransactionsInput
    upsert?: SupplierUpsertWithoutTransactionsInput
    disconnect?: SupplierWhereInput | boolean
    delete?: SupplierWhereInput | boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutTransactionsInput, SupplierUpdateWithoutTransactionsInput>, SupplierUncheckedUpdateWithoutTransactionsInput>
  }

  export type TenantUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<TenantCreateWithoutTransactionsInput, TenantUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTransactionsInput
    upsert?: TenantUpsertWithoutTransactionsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTransactionsInput, TenantUpdateWithoutTransactionsInput>, TenantUncheckedUpdateWithoutTransactionsInput>
  }

  export type CustomerCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoicesInput
    connect?: CustomerWhereUniqueInput
  }

  export type SalesOrderCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<SalesOrderCreateWithoutInvoiceInput, SalesOrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutInvoiceInput
    connect?: SalesOrderWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<SupplierCreateWithoutInvoicesInput, SupplierUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutInvoicesInput
    connect?: SupplierWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoicesInput
    connect?: TenantWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EnumInvoiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceType
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type CustomerUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoicesInput
    upsert?: CustomerUpsertWithoutInvoicesInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutInvoicesInput, CustomerUpdateWithoutInvoicesInput>, CustomerUncheckedUpdateWithoutInvoicesInput>
  }

  export type SalesOrderUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<SalesOrderCreateWithoutInvoiceInput, SalesOrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutInvoiceInput
    upsert?: SalesOrderUpsertWithoutInvoiceInput
    disconnect?: SalesOrderWhereInput | boolean
    delete?: SalesOrderWhereInput | boolean
    connect?: SalesOrderWhereUniqueInput
    update?: XOR<XOR<SalesOrderUpdateToOneWithWhereWithoutInvoiceInput, SalesOrderUpdateWithoutInvoiceInput>, SalesOrderUncheckedUpdateWithoutInvoiceInput>
  }

  export type SupplierUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<SupplierCreateWithoutInvoicesInput, SupplierUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutInvoicesInput
    upsert?: SupplierUpsertWithoutInvoicesInput
    disconnect?: SupplierWhereInput | boolean
    delete?: SupplierWhereInput | boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutInvoicesInput, SupplierUpdateWithoutInvoicesInput>, SupplierUncheckedUpdateWithoutInvoicesInput>
  }

  export type TenantUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoicesInput
    upsert?: TenantUpsertWithoutInvoicesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInvoicesInput, TenantUpdateWithoutInvoicesInput>, TenantUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutInvoiceInput | TransactionUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutInvoiceInput | TransactionUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutInvoiceInput | TransactionUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutInvoiceInput | TransactionUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutInvoiceInput | TransactionUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutInvoiceInput | TransactionUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type NullableEnumPackageTypeFieldUpdateOperationsInput = {
    set?: $Enums.PackageType | null
  }

  export type InvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    upsert?: InvoiceUpsertWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutItemsInput, InvoiceUpdateWithoutItemsInput>, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type SalesOrderCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SalesOrderCreateWithoutPaymentsInput, SalesOrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutPaymentsInput
    connect?: SalesOrderWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentsInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type InvoiceUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type SalesOrderUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<SalesOrderCreateWithoutPaymentsInput, SalesOrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutPaymentsInput
    upsert?: SalesOrderUpsertWithoutPaymentsInput
    disconnect?: SalesOrderWhereInput | boolean
    delete?: SalesOrderWhereInput | boolean
    connect?: SalesOrderWhereUniqueInput
    update?: XOR<XOR<SalesOrderUpdateToOneWithWhereWithoutPaymentsInput, SalesOrderUpdateWithoutPaymentsInput>, SalesOrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type TenantUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentsInput
    upsert?: TenantUpsertWithoutPaymentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPaymentsInput, TenantUpdateWithoutPaymentsInput>, TenantUncheckedUpdateWithoutPaymentsInput>
  }

  export type SupplierCreateNestedOneWithoutExpensesInput = {
    create?: XOR<SupplierCreateWithoutExpensesInput, SupplierUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutExpensesInput
    connect?: SupplierWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutExpensesInput = {
    create?: XOR<TenantCreateWithoutExpensesInput, TenantUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutExpensesInput
    connect?: TenantWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutExpenseInput = {
    create?: XOR<TransactionCreateWithoutExpenseInput, TransactionUncheckedCreateWithoutExpenseInput> | TransactionCreateWithoutExpenseInput[] | TransactionUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutExpenseInput | TransactionCreateOrConnectWithoutExpenseInput[]
    createMany?: TransactionCreateManyExpenseInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutExpenseInput = {
    create?: XOR<TransactionCreateWithoutExpenseInput, TransactionUncheckedCreateWithoutExpenseInput> | TransactionCreateWithoutExpenseInput[] | TransactionUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutExpenseInput | TransactionCreateOrConnectWithoutExpenseInput[]
    createMany?: TransactionCreateManyExpenseInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EnumExpenseCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ExpenseCategory
  }

  export type SupplierUpdateOneWithoutExpensesNestedInput = {
    create?: XOR<SupplierCreateWithoutExpensesInput, SupplierUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutExpensesInput
    upsert?: SupplierUpsertWithoutExpensesInput
    disconnect?: SupplierWhereInput | boolean
    delete?: SupplierWhereInput | boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutExpensesInput, SupplierUpdateWithoutExpensesInput>, SupplierUncheckedUpdateWithoutExpensesInput>
  }

  export type TenantUpdateOneRequiredWithoutExpensesNestedInput = {
    create?: XOR<TenantCreateWithoutExpensesInput, TenantUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutExpensesInput
    upsert?: TenantUpsertWithoutExpensesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutExpensesInput, TenantUpdateWithoutExpensesInput>, TenantUncheckedUpdateWithoutExpensesInput>
  }

  export type TransactionUpdateManyWithoutExpenseNestedInput = {
    create?: XOR<TransactionCreateWithoutExpenseInput, TransactionUncheckedCreateWithoutExpenseInput> | TransactionCreateWithoutExpenseInput[] | TransactionUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutExpenseInput | TransactionCreateOrConnectWithoutExpenseInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutExpenseInput | TransactionUpsertWithWhereUniqueWithoutExpenseInput[]
    createMany?: TransactionCreateManyExpenseInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutExpenseInput | TransactionUpdateWithWhereUniqueWithoutExpenseInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutExpenseInput | TransactionUpdateManyWithWhereWithoutExpenseInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutExpenseNestedInput = {
    create?: XOR<TransactionCreateWithoutExpenseInput, TransactionUncheckedCreateWithoutExpenseInput> | TransactionCreateWithoutExpenseInput[] | TransactionUncheckedCreateWithoutExpenseInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutExpenseInput | TransactionCreateOrConnectWithoutExpenseInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutExpenseInput | TransactionUpsertWithWhereUniqueWithoutExpenseInput[]
    createMany?: TransactionCreateManyExpenseInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutExpenseInput | TransactionUpdateWithWhereUniqueWithoutExpenseInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutExpenseInput | TransactionUpdateManyWithWhereWithoutExpenseInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutBudgetsInput = {
    create?: XOR<TenantCreateWithoutBudgetsInput, TenantUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBudgetsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutBudgetsNestedInput = {
    create?: XOR<TenantCreateWithoutBudgetsInput, TenantUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBudgetsInput
    upsert?: TenantUpsertWithoutBudgetsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutBudgetsInput, TenantUpdateWithoutBudgetsInput>, TenantUncheckedUpdateWithoutBudgetsInput>
  }

  export type EquipmentCreateNestedOneWithoutCIPLogInput = {
    create?: XOR<EquipmentCreateWithoutCIPLogInput, EquipmentUncheckedCreateWithoutCIPLogInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutCIPLogInput
    connect?: EquipmentWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EquipmentUpdateOneRequiredWithoutCIPLogNestedInput = {
    create?: XOR<EquipmentCreateWithoutCIPLogInput, EquipmentUncheckedCreateWithoutCIPLogInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutCIPLogInput
    upsert?: EquipmentUpsertWithoutCIPLogInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutCIPLogInput, EquipmentUpdateWithoutCIPLogInput>, EquipmentUncheckedUpdateWithoutCIPLogInput>
  }

  export type EquipmentCreatecapabilitiesInput = {
    set: string[]
  }

  export type CIPLogCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<CIPLogCreateWithoutEquipmentInput, CIPLogUncheckedCreateWithoutEquipmentInput> | CIPLogCreateWithoutEquipmentInput[] | CIPLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: CIPLogCreateOrConnectWithoutEquipmentInput | CIPLogCreateOrConnectWithoutEquipmentInput[]
    createMany?: CIPLogCreateManyEquipmentInputEnvelope
    connect?: CIPLogWhereUniqueInput | CIPLogWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutEquipmentInput = {
    create?: XOR<TenantCreateWithoutEquipmentInput, TenantUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEquipmentInput
    connect?: TenantWhereUniqueInput
  }

  export type MaintenanceLogCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<MaintenanceLogCreateWithoutEquipmentInput, MaintenanceLogUncheckedCreateWithoutEquipmentInput> | MaintenanceLogCreateWithoutEquipmentInput[] | MaintenanceLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutEquipmentInput | MaintenanceLogCreateOrConnectWithoutEquipmentInput[]
    createMany?: MaintenanceLogCreateManyEquipmentInputEnvelope
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
  }

  export type ProblemReportCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<ProblemReportCreateWithoutEquipmentInput, ProblemReportUncheckedCreateWithoutEquipmentInput> | ProblemReportCreateWithoutEquipmentInput[] | ProblemReportUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: ProblemReportCreateOrConnectWithoutEquipmentInput | ProblemReportCreateOrConnectWithoutEquipmentInput[]
    createMany?: ProblemReportCreateManyEquipmentInputEnvelope
    connect?: ProblemReportWhereUniqueInput | ProblemReportWhereUniqueInput[]
  }

  export type CIPLogUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<CIPLogCreateWithoutEquipmentInput, CIPLogUncheckedCreateWithoutEquipmentInput> | CIPLogCreateWithoutEquipmentInput[] | CIPLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: CIPLogCreateOrConnectWithoutEquipmentInput | CIPLogCreateOrConnectWithoutEquipmentInput[]
    createMany?: CIPLogCreateManyEquipmentInputEnvelope
    connect?: CIPLogWhereUniqueInput | CIPLogWhereUniqueInput[]
  }

  export type MaintenanceLogUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<MaintenanceLogCreateWithoutEquipmentInput, MaintenanceLogUncheckedCreateWithoutEquipmentInput> | MaintenanceLogCreateWithoutEquipmentInput[] | MaintenanceLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutEquipmentInput | MaintenanceLogCreateOrConnectWithoutEquipmentInput[]
    createMany?: MaintenanceLogCreateManyEquipmentInputEnvelope
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
  }

  export type ProblemReportUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<ProblemReportCreateWithoutEquipmentInput, ProblemReportUncheckedCreateWithoutEquipmentInput> | ProblemReportCreateWithoutEquipmentInput[] | ProblemReportUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: ProblemReportCreateOrConnectWithoutEquipmentInput | ProblemReportCreateOrConnectWithoutEquipmentInput[]
    createMany?: ProblemReportCreateManyEquipmentInputEnvelope
    connect?: ProblemReportWhereUniqueInput | ProblemReportWhereUniqueInput[]
  }

  export type EquipmentUpdatecapabilitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CIPLogUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<CIPLogCreateWithoutEquipmentInput, CIPLogUncheckedCreateWithoutEquipmentInput> | CIPLogCreateWithoutEquipmentInput[] | CIPLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: CIPLogCreateOrConnectWithoutEquipmentInput | CIPLogCreateOrConnectWithoutEquipmentInput[]
    upsert?: CIPLogUpsertWithWhereUniqueWithoutEquipmentInput | CIPLogUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: CIPLogCreateManyEquipmentInputEnvelope
    set?: CIPLogWhereUniqueInput | CIPLogWhereUniqueInput[]
    disconnect?: CIPLogWhereUniqueInput | CIPLogWhereUniqueInput[]
    delete?: CIPLogWhereUniqueInput | CIPLogWhereUniqueInput[]
    connect?: CIPLogWhereUniqueInput | CIPLogWhereUniqueInput[]
    update?: CIPLogUpdateWithWhereUniqueWithoutEquipmentInput | CIPLogUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: CIPLogUpdateManyWithWhereWithoutEquipmentInput | CIPLogUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: CIPLogScalarWhereInput | CIPLogScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutEquipmentNestedInput = {
    create?: XOR<TenantCreateWithoutEquipmentInput, TenantUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEquipmentInput
    upsert?: TenantUpsertWithoutEquipmentInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutEquipmentInput, TenantUpdateWithoutEquipmentInput>, TenantUncheckedUpdateWithoutEquipmentInput>
  }

  export type MaintenanceLogUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<MaintenanceLogCreateWithoutEquipmentInput, MaintenanceLogUncheckedCreateWithoutEquipmentInput> | MaintenanceLogCreateWithoutEquipmentInput[] | MaintenanceLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutEquipmentInput | MaintenanceLogCreateOrConnectWithoutEquipmentInput[]
    upsert?: MaintenanceLogUpsertWithWhereUniqueWithoutEquipmentInput | MaintenanceLogUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: MaintenanceLogCreateManyEquipmentInputEnvelope
    set?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    disconnect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    delete?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    update?: MaintenanceLogUpdateWithWhereUniqueWithoutEquipmentInput | MaintenanceLogUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: MaintenanceLogUpdateManyWithWhereWithoutEquipmentInput | MaintenanceLogUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: MaintenanceLogScalarWhereInput | MaintenanceLogScalarWhereInput[]
  }

  export type ProblemReportUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<ProblemReportCreateWithoutEquipmentInput, ProblemReportUncheckedCreateWithoutEquipmentInput> | ProblemReportCreateWithoutEquipmentInput[] | ProblemReportUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: ProblemReportCreateOrConnectWithoutEquipmentInput | ProblemReportCreateOrConnectWithoutEquipmentInput[]
    upsert?: ProblemReportUpsertWithWhereUniqueWithoutEquipmentInput | ProblemReportUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: ProblemReportCreateManyEquipmentInputEnvelope
    set?: ProblemReportWhereUniqueInput | ProblemReportWhereUniqueInput[]
    disconnect?: ProblemReportWhereUniqueInput | ProblemReportWhereUniqueInput[]
    delete?: ProblemReportWhereUniqueInput | ProblemReportWhereUniqueInput[]
    connect?: ProblemReportWhereUniqueInput | ProblemReportWhereUniqueInput[]
    update?: ProblemReportUpdateWithWhereUniqueWithoutEquipmentInput | ProblemReportUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: ProblemReportUpdateManyWithWhereWithoutEquipmentInput | ProblemReportUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: ProblemReportScalarWhereInput | ProblemReportScalarWhereInput[]
  }

  export type CIPLogUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<CIPLogCreateWithoutEquipmentInput, CIPLogUncheckedCreateWithoutEquipmentInput> | CIPLogCreateWithoutEquipmentInput[] | CIPLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: CIPLogCreateOrConnectWithoutEquipmentInput | CIPLogCreateOrConnectWithoutEquipmentInput[]
    upsert?: CIPLogUpsertWithWhereUniqueWithoutEquipmentInput | CIPLogUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: CIPLogCreateManyEquipmentInputEnvelope
    set?: CIPLogWhereUniqueInput | CIPLogWhereUniqueInput[]
    disconnect?: CIPLogWhereUniqueInput | CIPLogWhereUniqueInput[]
    delete?: CIPLogWhereUniqueInput | CIPLogWhereUniqueInput[]
    connect?: CIPLogWhereUniqueInput | CIPLogWhereUniqueInput[]
    update?: CIPLogUpdateWithWhereUniqueWithoutEquipmentInput | CIPLogUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: CIPLogUpdateManyWithWhereWithoutEquipmentInput | CIPLogUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: CIPLogScalarWhereInput | CIPLogScalarWhereInput[]
  }

  export type MaintenanceLogUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<MaintenanceLogCreateWithoutEquipmentInput, MaintenanceLogUncheckedCreateWithoutEquipmentInput> | MaintenanceLogCreateWithoutEquipmentInput[] | MaintenanceLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutEquipmentInput | MaintenanceLogCreateOrConnectWithoutEquipmentInput[]
    upsert?: MaintenanceLogUpsertWithWhereUniqueWithoutEquipmentInput | MaintenanceLogUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: MaintenanceLogCreateManyEquipmentInputEnvelope
    set?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    disconnect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    delete?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    update?: MaintenanceLogUpdateWithWhereUniqueWithoutEquipmentInput | MaintenanceLogUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: MaintenanceLogUpdateManyWithWhereWithoutEquipmentInput | MaintenanceLogUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: MaintenanceLogScalarWhereInput | MaintenanceLogScalarWhereInput[]
  }

  export type ProblemReportUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<ProblemReportCreateWithoutEquipmentInput, ProblemReportUncheckedCreateWithoutEquipmentInput> | ProblemReportCreateWithoutEquipmentInput[] | ProblemReportUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: ProblemReportCreateOrConnectWithoutEquipmentInput | ProblemReportCreateOrConnectWithoutEquipmentInput[]
    upsert?: ProblemReportUpsertWithWhereUniqueWithoutEquipmentInput | ProblemReportUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: ProblemReportCreateManyEquipmentInputEnvelope
    set?: ProblemReportWhereUniqueInput | ProblemReportWhereUniqueInput[]
    disconnect?: ProblemReportWhereUniqueInput | ProblemReportWhereUniqueInput[]
    delete?: ProblemReportWhereUniqueInput | ProblemReportWhereUniqueInput[]
    connect?: ProblemReportWhereUniqueInput | ProblemReportWhereUniqueInput[]
    update?: ProblemReportUpdateWithWhereUniqueWithoutEquipmentInput | ProblemReportUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: ProblemReportUpdateManyWithWhereWithoutEquipmentInput | ProblemReportUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: ProblemReportScalarWhereInput | ProblemReportScalarWhereInput[]
  }

  export type LotCreateNestedOneWithoutOther_LotInput = {
    create?: XOR<LotCreateWithoutOther_LotInput, LotUncheckedCreateWithoutOther_LotInput>
    connectOrCreate?: LotCreateOrConnectWithoutOther_LotInput
    connect?: LotWhereUniqueInput
  }

  export type LotCreateNestedManyWithoutLotInput = {
    create?: XOR<LotCreateWithoutLotInput, LotUncheckedCreateWithoutLotInput> | LotCreateWithoutLotInput[] | LotUncheckedCreateWithoutLotInput[]
    connectOrCreate?: LotCreateOrConnectWithoutLotInput | LotCreateOrConnectWithoutLotInput[]
    createMany?: LotCreateManyLotInputEnvelope
    connect?: LotWhereUniqueInput | LotWhereUniqueInput[]
  }

  export type LotBatchCreateNestedManyWithoutLotInput = {
    create?: XOR<LotBatchCreateWithoutLotInput, LotBatchUncheckedCreateWithoutLotInput> | LotBatchCreateWithoutLotInput[] | LotBatchUncheckedCreateWithoutLotInput[]
    connectOrCreate?: LotBatchCreateOrConnectWithoutLotInput | LotBatchCreateOrConnectWithoutLotInput[]
    createMany?: LotBatchCreateManyLotInputEnvelope
    connect?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
  }

  export type LotReadingCreateNestedManyWithoutLotInput = {
    create?: XOR<LotReadingCreateWithoutLotInput, LotReadingUncheckedCreateWithoutLotInput> | LotReadingCreateWithoutLotInput[] | LotReadingUncheckedCreateWithoutLotInput[]
    connectOrCreate?: LotReadingCreateOrConnectWithoutLotInput | LotReadingCreateOrConnectWithoutLotInput[]
    createMany?: LotReadingCreateManyLotInputEnvelope
    connect?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
  }

  export type QCTestCreateNestedManyWithoutLotInput = {
    create?: XOR<QCTestCreateWithoutLotInput, QCTestUncheckedCreateWithoutLotInput> | QCTestCreateWithoutLotInput[] | QCTestUncheckedCreateWithoutLotInput[]
    connectOrCreate?: QCTestCreateOrConnectWithoutLotInput | QCTestCreateOrConnectWithoutLotInput[]
    createMany?: QCTestCreateManyLotInputEnvelope
    connect?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
  }

  export type TankAssignmentCreateNestedManyWithoutLotInput = {
    create?: XOR<TankAssignmentCreateWithoutLotInput, TankAssignmentUncheckedCreateWithoutLotInput> | TankAssignmentCreateWithoutLotInput[] | TankAssignmentUncheckedCreateWithoutLotInput[]
    connectOrCreate?: TankAssignmentCreateOrConnectWithoutLotInput | TankAssignmentCreateOrConnectWithoutLotInput[]
    createMany?: TankAssignmentCreateManyLotInputEnvelope
    connect?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutLot_Transfer_destLotIdToLotInput = {
    create?: XOR<TransferCreateWithoutLot_Transfer_destLotIdToLotInput, TransferUncheckedCreateWithoutLot_Transfer_destLotIdToLotInput> | TransferCreateWithoutLot_Transfer_destLotIdToLotInput[] | TransferUncheckedCreateWithoutLot_Transfer_destLotIdToLotInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutLot_Transfer_destLotIdToLotInput | TransferCreateOrConnectWithoutLot_Transfer_destLotIdToLotInput[]
    createMany?: TransferCreateManyLot_Transfer_destLotIdToLotInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferCreateNestedManyWithoutLot_Transfer_sourceLotIdToLotInput = {
    create?: XOR<TransferCreateWithoutLot_Transfer_sourceLotIdToLotInput, TransferUncheckedCreateWithoutLot_Transfer_sourceLotIdToLotInput> | TransferCreateWithoutLot_Transfer_sourceLotIdToLotInput[] | TransferUncheckedCreateWithoutLot_Transfer_sourceLotIdToLotInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutLot_Transfer_sourceLotIdToLotInput | TransferCreateOrConnectWithoutLot_Transfer_sourceLotIdToLotInput[]
    createMany?: TransferCreateManyLot_Transfer_sourceLotIdToLotInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type LotUncheckedCreateNestedManyWithoutLotInput = {
    create?: XOR<LotCreateWithoutLotInput, LotUncheckedCreateWithoutLotInput> | LotCreateWithoutLotInput[] | LotUncheckedCreateWithoutLotInput[]
    connectOrCreate?: LotCreateOrConnectWithoutLotInput | LotCreateOrConnectWithoutLotInput[]
    createMany?: LotCreateManyLotInputEnvelope
    connect?: LotWhereUniqueInput | LotWhereUniqueInput[]
  }

  export type LotBatchUncheckedCreateNestedManyWithoutLotInput = {
    create?: XOR<LotBatchCreateWithoutLotInput, LotBatchUncheckedCreateWithoutLotInput> | LotBatchCreateWithoutLotInput[] | LotBatchUncheckedCreateWithoutLotInput[]
    connectOrCreate?: LotBatchCreateOrConnectWithoutLotInput | LotBatchCreateOrConnectWithoutLotInput[]
    createMany?: LotBatchCreateManyLotInputEnvelope
    connect?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
  }

  export type LotReadingUncheckedCreateNestedManyWithoutLotInput = {
    create?: XOR<LotReadingCreateWithoutLotInput, LotReadingUncheckedCreateWithoutLotInput> | LotReadingCreateWithoutLotInput[] | LotReadingUncheckedCreateWithoutLotInput[]
    connectOrCreate?: LotReadingCreateOrConnectWithoutLotInput | LotReadingCreateOrConnectWithoutLotInput[]
    createMany?: LotReadingCreateManyLotInputEnvelope
    connect?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
  }

  export type QCTestUncheckedCreateNestedManyWithoutLotInput = {
    create?: XOR<QCTestCreateWithoutLotInput, QCTestUncheckedCreateWithoutLotInput> | QCTestCreateWithoutLotInput[] | QCTestUncheckedCreateWithoutLotInput[]
    connectOrCreate?: QCTestCreateOrConnectWithoutLotInput | QCTestCreateOrConnectWithoutLotInput[]
    createMany?: QCTestCreateManyLotInputEnvelope
    connect?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
  }

  export type TankAssignmentUncheckedCreateNestedManyWithoutLotInput = {
    create?: XOR<TankAssignmentCreateWithoutLotInput, TankAssignmentUncheckedCreateWithoutLotInput> | TankAssignmentCreateWithoutLotInput[] | TankAssignmentUncheckedCreateWithoutLotInput[]
    connectOrCreate?: TankAssignmentCreateOrConnectWithoutLotInput | TankAssignmentCreateOrConnectWithoutLotInput[]
    createMany?: TankAssignmentCreateManyLotInputEnvelope
    connect?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutLot_Transfer_destLotIdToLotInput = {
    create?: XOR<TransferCreateWithoutLot_Transfer_destLotIdToLotInput, TransferUncheckedCreateWithoutLot_Transfer_destLotIdToLotInput> | TransferCreateWithoutLot_Transfer_destLotIdToLotInput[] | TransferUncheckedCreateWithoutLot_Transfer_destLotIdToLotInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutLot_Transfer_destLotIdToLotInput | TransferCreateOrConnectWithoutLot_Transfer_destLotIdToLotInput[]
    createMany?: TransferCreateManyLot_Transfer_destLotIdToLotInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type TransferUncheckedCreateNestedManyWithoutLot_Transfer_sourceLotIdToLotInput = {
    create?: XOR<TransferCreateWithoutLot_Transfer_sourceLotIdToLotInput, TransferUncheckedCreateWithoutLot_Transfer_sourceLotIdToLotInput> | TransferCreateWithoutLot_Transfer_sourceLotIdToLotInput[] | TransferUncheckedCreateWithoutLot_Transfer_sourceLotIdToLotInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutLot_Transfer_sourceLotIdToLotInput | TransferCreateOrConnectWithoutLot_Transfer_sourceLotIdToLotInput[]
    createMany?: TransferCreateManyLot_Transfer_sourceLotIdToLotInputEnvelope
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
  }

  export type EnumLotPhaseFieldUpdateOperationsInput = {
    set?: $Enums.LotPhase
  }

  export type EnumLotStatusFieldUpdateOperationsInput = {
    set?: $Enums.LotStatus
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type LotUpdateOneWithoutOther_LotNestedInput = {
    create?: XOR<LotCreateWithoutOther_LotInput, LotUncheckedCreateWithoutOther_LotInput>
    connectOrCreate?: LotCreateOrConnectWithoutOther_LotInput
    upsert?: LotUpsertWithoutOther_LotInput
    disconnect?: LotWhereInput | boolean
    delete?: LotWhereInput | boolean
    connect?: LotWhereUniqueInput
    update?: XOR<XOR<LotUpdateToOneWithWhereWithoutOther_LotInput, LotUpdateWithoutOther_LotInput>, LotUncheckedUpdateWithoutOther_LotInput>
  }

  export type LotUpdateManyWithoutLotNestedInput = {
    create?: XOR<LotCreateWithoutLotInput, LotUncheckedCreateWithoutLotInput> | LotCreateWithoutLotInput[] | LotUncheckedCreateWithoutLotInput[]
    connectOrCreate?: LotCreateOrConnectWithoutLotInput | LotCreateOrConnectWithoutLotInput[]
    upsert?: LotUpsertWithWhereUniqueWithoutLotInput | LotUpsertWithWhereUniqueWithoutLotInput[]
    createMany?: LotCreateManyLotInputEnvelope
    set?: LotWhereUniqueInput | LotWhereUniqueInput[]
    disconnect?: LotWhereUniqueInput | LotWhereUniqueInput[]
    delete?: LotWhereUniqueInput | LotWhereUniqueInput[]
    connect?: LotWhereUniqueInput | LotWhereUniqueInput[]
    update?: LotUpdateWithWhereUniqueWithoutLotInput | LotUpdateWithWhereUniqueWithoutLotInput[]
    updateMany?: LotUpdateManyWithWhereWithoutLotInput | LotUpdateManyWithWhereWithoutLotInput[]
    deleteMany?: LotScalarWhereInput | LotScalarWhereInput[]
  }

  export type LotBatchUpdateManyWithoutLotNestedInput = {
    create?: XOR<LotBatchCreateWithoutLotInput, LotBatchUncheckedCreateWithoutLotInput> | LotBatchCreateWithoutLotInput[] | LotBatchUncheckedCreateWithoutLotInput[]
    connectOrCreate?: LotBatchCreateOrConnectWithoutLotInput | LotBatchCreateOrConnectWithoutLotInput[]
    upsert?: LotBatchUpsertWithWhereUniqueWithoutLotInput | LotBatchUpsertWithWhereUniqueWithoutLotInput[]
    createMany?: LotBatchCreateManyLotInputEnvelope
    set?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
    disconnect?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
    delete?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
    connect?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
    update?: LotBatchUpdateWithWhereUniqueWithoutLotInput | LotBatchUpdateWithWhereUniqueWithoutLotInput[]
    updateMany?: LotBatchUpdateManyWithWhereWithoutLotInput | LotBatchUpdateManyWithWhereWithoutLotInput[]
    deleteMany?: LotBatchScalarWhereInput | LotBatchScalarWhereInput[]
  }

  export type LotReadingUpdateManyWithoutLotNestedInput = {
    create?: XOR<LotReadingCreateWithoutLotInput, LotReadingUncheckedCreateWithoutLotInput> | LotReadingCreateWithoutLotInput[] | LotReadingUncheckedCreateWithoutLotInput[]
    connectOrCreate?: LotReadingCreateOrConnectWithoutLotInput | LotReadingCreateOrConnectWithoutLotInput[]
    upsert?: LotReadingUpsertWithWhereUniqueWithoutLotInput | LotReadingUpsertWithWhereUniqueWithoutLotInput[]
    createMany?: LotReadingCreateManyLotInputEnvelope
    set?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
    disconnect?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
    delete?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
    connect?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
    update?: LotReadingUpdateWithWhereUniqueWithoutLotInput | LotReadingUpdateWithWhereUniqueWithoutLotInput[]
    updateMany?: LotReadingUpdateManyWithWhereWithoutLotInput | LotReadingUpdateManyWithWhereWithoutLotInput[]
    deleteMany?: LotReadingScalarWhereInput | LotReadingScalarWhereInput[]
  }

  export type QCTestUpdateManyWithoutLotNestedInput = {
    create?: XOR<QCTestCreateWithoutLotInput, QCTestUncheckedCreateWithoutLotInput> | QCTestCreateWithoutLotInput[] | QCTestUncheckedCreateWithoutLotInput[]
    connectOrCreate?: QCTestCreateOrConnectWithoutLotInput | QCTestCreateOrConnectWithoutLotInput[]
    upsert?: QCTestUpsertWithWhereUniqueWithoutLotInput | QCTestUpsertWithWhereUniqueWithoutLotInput[]
    createMany?: QCTestCreateManyLotInputEnvelope
    set?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
    disconnect?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
    delete?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
    connect?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
    update?: QCTestUpdateWithWhereUniqueWithoutLotInput | QCTestUpdateWithWhereUniqueWithoutLotInput[]
    updateMany?: QCTestUpdateManyWithWhereWithoutLotInput | QCTestUpdateManyWithWhereWithoutLotInput[]
    deleteMany?: QCTestScalarWhereInput | QCTestScalarWhereInput[]
  }

  export type TankAssignmentUpdateManyWithoutLotNestedInput = {
    create?: XOR<TankAssignmentCreateWithoutLotInput, TankAssignmentUncheckedCreateWithoutLotInput> | TankAssignmentCreateWithoutLotInput[] | TankAssignmentUncheckedCreateWithoutLotInput[]
    connectOrCreate?: TankAssignmentCreateOrConnectWithoutLotInput | TankAssignmentCreateOrConnectWithoutLotInput[]
    upsert?: TankAssignmentUpsertWithWhereUniqueWithoutLotInput | TankAssignmentUpsertWithWhereUniqueWithoutLotInput[]
    createMany?: TankAssignmentCreateManyLotInputEnvelope
    set?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
    disconnect?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
    delete?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
    connect?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
    update?: TankAssignmentUpdateWithWhereUniqueWithoutLotInput | TankAssignmentUpdateWithWhereUniqueWithoutLotInput[]
    updateMany?: TankAssignmentUpdateManyWithWhereWithoutLotInput | TankAssignmentUpdateManyWithWhereWithoutLotInput[]
    deleteMany?: TankAssignmentScalarWhereInput | TankAssignmentScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutLot_Transfer_destLotIdToLotNestedInput = {
    create?: XOR<TransferCreateWithoutLot_Transfer_destLotIdToLotInput, TransferUncheckedCreateWithoutLot_Transfer_destLotIdToLotInput> | TransferCreateWithoutLot_Transfer_destLotIdToLotInput[] | TransferUncheckedCreateWithoutLot_Transfer_destLotIdToLotInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutLot_Transfer_destLotIdToLotInput | TransferCreateOrConnectWithoutLot_Transfer_destLotIdToLotInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutLot_Transfer_destLotIdToLotInput | TransferUpsertWithWhereUniqueWithoutLot_Transfer_destLotIdToLotInput[]
    createMany?: TransferCreateManyLot_Transfer_destLotIdToLotInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutLot_Transfer_destLotIdToLotInput | TransferUpdateWithWhereUniqueWithoutLot_Transfer_destLotIdToLotInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutLot_Transfer_destLotIdToLotInput | TransferUpdateManyWithWhereWithoutLot_Transfer_destLotIdToLotInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUpdateManyWithoutLot_Transfer_sourceLotIdToLotNestedInput = {
    create?: XOR<TransferCreateWithoutLot_Transfer_sourceLotIdToLotInput, TransferUncheckedCreateWithoutLot_Transfer_sourceLotIdToLotInput> | TransferCreateWithoutLot_Transfer_sourceLotIdToLotInput[] | TransferUncheckedCreateWithoutLot_Transfer_sourceLotIdToLotInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutLot_Transfer_sourceLotIdToLotInput | TransferCreateOrConnectWithoutLot_Transfer_sourceLotIdToLotInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutLot_Transfer_sourceLotIdToLotInput | TransferUpsertWithWhereUniqueWithoutLot_Transfer_sourceLotIdToLotInput[]
    createMany?: TransferCreateManyLot_Transfer_sourceLotIdToLotInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutLot_Transfer_sourceLotIdToLotInput | TransferUpdateWithWhereUniqueWithoutLot_Transfer_sourceLotIdToLotInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutLot_Transfer_sourceLotIdToLotInput | TransferUpdateManyWithWhereWithoutLot_Transfer_sourceLotIdToLotInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type LotUncheckedUpdateManyWithoutLotNestedInput = {
    create?: XOR<LotCreateWithoutLotInput, LotUncheckedCreateWithoutLotInput> | LotCreateWithoutLotInput[] | LotUncheckedCreateWithoutLotInput[]
    connectOrCreate?: LotCreateOrConnectWithoutLotInput | LotCreateOrConnectWithoutLotInput[]
    upsert?: LotUpsertWithWhereUniqueWithoutLotInput | LotUpsertWithWhereUniqueWithoutLotInput[]
    createMany?: LotCreateManyLotInputEnvelope
    set?: LotWhereUniqueInput | LotWhereUniqueInput[]
    disconnect?: LotWhereUniqueInput | LotWhereUniqueInput[]
    delete?: LotWhereUniqueInput | LotWhereUniqueInput[]
    connect?: LotWhereUniqueInput | LotWhereUniqueInput[]
    update?: LotUpdateWithWhereUniqueWithoutLotInput | LotUpdateWithWhereUniqueWithoutLotInput[]
    updateMany?: LotUpdateManyWithWhereWithoutLotInput | LotUpdateManyWithWhereWithoutLotInput[]
    deleteMany?: LotScalarWhereInput | LotScalarWhereInput[]
  }

  export type LotBatchUncheckedUpdateManyWithoutLotNestedInput = {
    create?: XOR<LotBatchCreateWithoutLotInput, LotBatchUncheckedCreateWithoutLotInput> | LotBatchCreateWithoutLotInput[] | LotBatchUncheckedCreateWithoutLotInput[]
    connectOrCreate?: LotBatchCreateOrConnectWithoutLotInput | LotBatchCreateOrConnectWithoutLotInput[]
    upsert?: LotBatchUpsertWithWhereUniqueWithoutLotInput | LotBatchUpsertWithWhereUniqueWithoutLotInput[]
    createMany?: LotBatchCreateManyLotInputEnvelope
    set?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
    disconnect?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
    delete?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
    connect?: LotBatchWhereUniqueInput | LotBatchWhereUniqueInput[]
    update?: LotBatchUpdateWithWhereUniqueWithoutLotInput | LotBatchUpdateWithWhereUniqueWithoutLotInput[]
    updateMany?: LotBatchUpdateManyWithWhereWithoutLotInput | LotBatchUpdateManyWithWhereWithoutLotInput[]
    deleteMany?: LotBatchScalarWhereInput | LotBatchScalarWhereInput[]
  }

  export type LotReadingUncheckedUpdateManyWithoutLotNestedInput = {
    create?: XOR<LotReadingCreateWithoutLotInput, LotReadingUncheckedCreateWithoutLotInput> | LotReadingCreateWithoutLotInput[] | LotReadingUncheckedCreateWithoutLotInput[]
    connectOrCreate?: LotReadingCreateOrConnectWithoutLotInput | LotReadingCreateOrConnectWithoutLotInput[]
    upsert?: LotReadingUpsertWithWhereUniqueWithoutLotInput | LotReadingUpsertWithWhereUniqueWithoutLotInput[]
    createMany?: LotReadingCreateManyLotInputEnvelope
    set?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
    disconnect?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
    delete?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
    connect?: LotReadingWhereUniqueInput | LotReadingWhereUniqueInput[]
    update?: LotReadingUpdateWithWhereUniqueWithoutLotInput | LotReadingUpdateWithWhereUniqueWithoutLotInput[]
    updateMany?: LotReadingUpdateManyWithWhereWithoutLotInput | LotReadingUpdateManyWithWhereWithoutLotInput[]
    deleteMany?: LotReadingScalarWhereInput | LotReadingScalarWhereInput[]
  }

  export type QCTestUncheckedUpdateManyWithoutLotNestedInput = {
    create?: XOR<QCTestCreateWithoutLotInput, QCTestUncheckedCreateWithoutLotInput> | QCTestCreateWithoutLotInput[] | QCTestUncheckedCreateWithoutLotInput[]
    connectOrCreate?: QCTestCreateOrConnectWithoutLotInput | QCTestCreateOrConnectWithoutLotInput[]
    upsert?: QCTestUpsertWithWhereUniqueWithoutLotInput | QCTestUpsertWithWhereUniqueWithoutLotInput[]
    createMany?: QCTestCreateManyLotInputEnvelope
    set?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
    disconnect?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
    delete?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
    connect?: QCTestWhereUniqueInput | QCTestWhereUniqueInput[]
    update?: QCTestUpdateWithWhereUniqueWithoutLotInput | QCTestUpdateWithWhereUniqueWithoutLotInput[]
    updateMany?: QCTestUpdateManyWithWhereWithoutLotInput | QCTestUpdateManyWithWhereWithoutLotInput[]
    deleteMany?: QCTestScalarWhereInput | QCTestScalarWhereInput[]
  }

  export type TankAssignmentUncheckedUpdateManyWithoutLotNestedInput = {
    create?: XOR<TankAssignmentCreateWithoutLotInput, TankAssignmentUncheckedCreateWithoutLotInput> | TankAssignmentCreateWithoutLotInput[] | TankAssignmentUncheckedCreateWithoutLotInput[]
    connectOrCreate?: TankAssignmentCreateOrConnectWithoutLotInput | TankAssignmentCreateOrConnectWithoutLotInput[]
    upsert?: TankAssignmentUpsertWithWhereUniqueWithoutLotInput | TankAssignmentUpsertWithWhereUniqueWithoutLotInput[]
    createMany?: TankAssignmentCreateManyLotInputEnvelope
    set?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
    disconnect?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
    delete?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
    connect?: TankAssignmentWhereUniqueInput | TankAssignmentWhereUniqueInput[]
    update?: TankAssignmentUpdateWithWhereUniqueWithoutLotInput | TankAssignmentUpdateWithWhereUniqueWithoutLotInput[]
    updateMany?: TankAssignmentUpdateManyWithWhereWithoutLotInput | TankAssignmentUpdateManyWithWhereWithoutLotInput[]
    deleteMany?: TankAssignmentScalarWhereInput | TankAssignmentScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutLot_Transfer_destLotIdToLotNestedInput = {
    create?: XOR<TransferCreateWithoutLot_Transfer_destLotIdToLotInput, TransferUncheckedCreateWithoutLot_Transfer_destLotIdToLotInput> | TransferCreateWithoutLot_Transfer_destLotIdToLotInput[] | TransferUncheckedCreateWithoutLot_Transfer_destLotIdToLotInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutLot_Transfer_destLotIdToLotInput | TransferCreateOrConnectWithoutLot_Transfer_destLotIdToLotInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutLot_Transfer_destLotIdToLotInput | TransferUpsertWithWhereUniqueWithoutLot_Transfer_destLotIdToLotInput[]
    createMany?: TransferCreateManyLot_Transfer_destLotIdToLotInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutLot_Transfer_destLotIdToLotInput | TransferUpdateWithWhereUniqueWithoutLot_Transfer_destLotIdToLotInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutLot_Transfer_destLotIdToLotInput | TransferUpdateManyWithWhereWithoutLot_Transfer_destLotIdToLotInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type TransferUncheckedUpdateManyWithoutLot_Transfer_sourceLotIdToLotNestedInput = {
    create?: XOR<TransferCreateWithoutLot_Transfer_sourceLotIdToLotInput, TransferUncheckedCreateWithoutLot_Transfer_sourceLotIdToLotInput> | TransferCreateWithoutLot_Transfer_sourceLotIdToLotInput[] | TransferUncheckedCreateWithoutLot_Transfer_sourceLotIdToLotInput[]
    connectOrCreate?: TransferCreateOrConnectWithoutLot_Transfer_sourceLotIdToLotInput | TransferCreateOrConnectWithoutLot_Transfer_sourceLotIdToLotInput[]
    upsert?: TransferUpsertWithWhereUniqueWithoutLot_Transfer_sourceLotIdToLotInput | TransferUpsertWithWhereUniqueWithoutLot_Transfer_sourceLotIdToLotInput[]
    createMany?: TransferCreateManyLot_Transfer_sourceLotIdToLotInputEnvelope
    set?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    disconnect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    delete?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    connect?: TransferWhereUniqueInput | TransferWhereUniqueInput[]
    update?: TransferUpdateWithWhereUniqueWithoutLot_Transfer_sourceLotIdToLotInput | TransferUpdateWithWhereUniqueWithoutLot_Transfer_sourceLotIdToLotInput[]
    updateMany?: TransferUpdateManyWithWhereWithoutLot_Transfer_sourceLotIdToLotInput | TransferUpdateManyWithWhereWithoutLot_Transfer_sourceLotIdToLotInput[]
    deleteMany?: TransferScalarWhereInput | TransferScalarWhereInput[]
  }

  export type BatchCreateNestedOneWithoutLotBatchInput = {
    create?: XOR<BatchCreateWithoutLotBatchInput, BatchUncheckedCreateWithoutLotBatchInput>
    connectOrCreate?: BatchCreateOrConnectWithoutLotBatchInput
    connect?: BatchWhereUniqueInput
  }

  export type LotCreateNestedOneWithoutLotBatchInput = {
    create?: XOR<LotCreateWithoutLotBatchInput, LotUncheckedCreateWithoutLotBatchInput>
    connectOrCreate?: LotCreateOrConnectWithoutLotBatchInput
    connect?: LotWhereUniqueInput
  }

  export type BatchUpdateOneRequiredWithoutLotBatchNestedInput = {
    create?: XOR<BatchCreateWithoutLotBatchInput, BatchUncheckedCreateWithoutLotBatchInput>
    connectOrCreate?: BatchCreateOrConnectWithoutLotBatchInput
    upsert?: BatchUpsertWithoutLotBatchInput
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutLotBatchInput, BatchUpdateWithoutLotBatchInput>, BatchUncheckedUpdateWithoutLotBatchInput>
  }

  export type LotUpdateOneRequiredWithoutLotBatchNestedInput = {
    create?: XOR<LotCreateWithoutLotBatchInput, LotUncheckedCreateWithoutLotBatchInput>
    connectOrCreate?: LotCreateOrConnectWithoutLotBatchInput
    upsert?: LotUpsertWithoutLotBatchInput
    connect?: LotWhereUniqueInput
    update?: XOR<XOR<LotUpdateToOneWithWhereWithoutLotBatchInput, LotUpdateWithoutLotBatchInput>, LotUncheckedUpdateWithoutLotBatchInput>
  }

  export type LotCreateNestedOneWithoutLotReadingInput = {
    create?: XOR<LotCreateWithoutLotReadingInput, LotUncheckedCreateWithoutLotReadingInput>
    connectOrCreate?: LotCreateOrConnectWithoutLotReadingInput
    connect?: LotWhereUniqueInput
  }

  export type TankCreateNestedOneWithoutLotReadingInput = {
    create?: XOR<TankCreateWithoutLotReadingInput, TankUncheckedCreateWithoutLotReadingInput>
    connectOrCreate?: TankCreateOrConnectWithoutLotReadingInput
    connect?: TankWhereUniqueInput
  }

  export type EnumReadingTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReadingType
  }

  export type LotUpdateOneRequiredWithoutLotReadingNestedInput = {
    create?: XOR<LotCreateWithoutLotReadingInput, LotUncheckedCreateWithoutLotReadingInput>
    connectOrCreate?: LotCreateOrConnectWithoutLotReadingInput
    upsert?: LotUpsertWithoutLotReadingInput
    connect?: LotWhereUniqueInput
    update?: XOR<XOR<LotUpdateToOneWithWhereWithoutLotReadingInput, LotUpdateWithoutLotReadingInput>, LotUncheckedUpdateWithoutLotReadingInput>
  }

  export type TankUpdateOneRequiredWithoutLotReadingNestedInput = {
    create?: XOR<TankCreateWithoutLotReadingInput, TankUncheckedCreateWithoutLotReadingInput>
    connectOrCreate?: TankCreateOrConnectWithoutLotReadingInput
    upsert?: TankUpsertWithoutLotReadingInput
    connect?: TankWhereUniqueInput
    update?: XOR<XOR<TankUpdateToOneWithWhereWithoutLotReadingInput, TankUpdateWithoutLotReadingInput>, TankUncheckedUpdateWithoutLotReadingInput>
  }

  export type MaintenanceLogCreatepartsUsedInput = {
    set: string[]
  }

  export type EquipmentCreateNestedOneWithoutMaintenanceLogInput = {
    create?: XOR<EquipmentCreateWithoutMaintenanceLogInput, EquipmentUncheckedCreateWithoutMaintenanceLogInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutMaintenanceLogInput
    connect?: EquipmentWhereUniqueInput
  }

  export type MaintenanceLogUpdatepartsUsedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EquipmentUpdateOneRequiredWithoutMaintenanceLogNestedInput = {
    create?: XOR<EquipmentCreateWithoutMaintenanceLogInput, EquipmentUncheckedCreateWithoutMaintenanceLogInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutMaintenanceLogInput
    upsert?: EquipmentUpsertWithoutMaintenanceLogInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutMaintenanceLogInput, EquipmentUpdateWithoutMaintenanceLogInput>, EquipmentUncheckedUpdateWithoutMaintenanceLogInput>
  }

  export type EquipmentCreateNestedOneWithoutProblemReportInput = {
    create?: XOR<EquipmentCreateWithoutProblemReportInput, EquipmentUncheckedCreateWithoutProblemReportInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutProblemReportInput
    connect?: EquipmentWhereUniqueInput
  }

  export type EquipmentUpdateOneRequiredWithoutProblemReportNestedInput = {
    create?: XOR<EquipmentCreateWithoutProblemReportInput, EquipmentUncheckedCreateWithoutProblemReportInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutProblemReportInput
    upsert?: EquipmentUpsertWithoutProblemReportInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutProblemReportInput, EquipmentUpdateWithoutProblemReportInput>, EquipmentUncheckedUpdateWithoutProblemReportInput>
  }

  export type LotCreateNestedOneWithoutTankAssignmentInput = {
    create?: XOR<LotCreateWithoutTankAssignmentInput, LotUncheckedCreateWithoutTankAssignmentInput>
    connectOrCreate?: LotCreateOrConnectWithoutTankAssignmentInput
    connect?: LotWhereUniqueInput
  }

  export type TankCreateNestedOneWithoutTankAssignmentInput = {
    create?: XOR<TankCreateWithoutTankAssignmentInput, TankUncheckedCreateWithoutTankAssignmentInput>
    connectOrCreate?: TankCreateOrConnectWithoutTankAssignmentInput
    connect?: TankWhereUniqueInput
  }

  export type EnumAssignmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AssignmentStatus
  }

  export type LotUpdateOneRequiredWithoutTankAssignmentNestedInput = {
    create?: XOR<LotCreateWithoutTankAssignmentInput, LotUncheckedCreateWithoutTankAssignmentInput>
    connectOrCreate?: LotCreateOrConnectWithoutTankAssignmentInput
    upsert?: LotUpsertWithoutTankAssignmentInput
    connect?: LotWhereUniqueInput
    update?: XOR<XOR<LotUpdateToOneWithWhereWithoutTankAssignmentInput, LotUpdateWithoutTankAssignmentInput>, LotUncheckedUpdateWithoutTankAssignmentInput>
  }

  export type TankUpdateOneRequiredWithoutTankAssignmentNestedInput = {
    create?: XOR<TankCreateWithoutTankAssignmentInput, TankUncheckedCreateWithoutTankAssignmentInput>
    connectOrCreate?: TankCreateOrConnectWithoutTankAssignmentInput
    upsert?: TankUpsertWithoutTankAssignmentInput
    connect?: TankWhereUniqueInput
    update?: XOR<XOR<TankUpdateToOneWithWhereWithoutTankAssignmentInput, TankUpdateWithoutTankAssignmentInput>, TankUncheckedUpdateWithoutTankAssignmentInput>
  }

  export type LotCreateNestedOneWithoutTransfer_Transfer_destLotIdToLotInput = {
    create?: XOR<LotCreateWithoutTransfer_Transfer_destLotIdToLotInput, LotUncheckedCreateWithoutTransfer_Transfer_destLotIdToLotInput>
    connectOrCreate?: LotCreateOrConnectWithoutTransfer_Transfer_destLotIdToLotInput
    connect?: LotWhereUniqueInput
  }

  export type TankCreateNestedOneWithoutTransfer_Transfer_destTankIdToTankInput = {
    create?: XOR<TankCreateWithoutTransfer_Transfer_destTankIdToTankInput, TankUncheckedCreateWithoutTransfer_Transfer_destTankIdToTankInput>
    connectOrCreate?: TankCreateOrConnectWithoutTransfer_Transfer_destTankIdToTankInput
    connect?: TankWhereUniqueInput
  }

  export type LotCreateNestedOneWithoutTransfer_Transfer_sourceLotIdToLotInput = {
    create?: XOR<LotCreateWithoutTransfer_Transfer_sourceLotIdToLotInput, LotUncheckedCreateWithoutTransfer_Transfer_sourceLotIdToLotInput>
    connectOrCreate?: LotCreateOrConnectWithoutTransfer_Transfer_sourceLotIdToLotInput
    connect?: LotWhereUniqueInput
  }

  export type TankCreateNestedOneWithoutTransfer_Transfer_sourceTankIdToTankInput = {
    create?: XOR<TankCreateWithoutTransfer_Transfer_sourceTankIdToTankInput, TankUncheckedCreateWithoutTransfer_Transfer_sourceTankIdToTankInput>
    connectOrCreate?: TankCreateOrConnectWithoutTransfer_Transfer_sourceTankIdToTankInput
    connect?: TankWhereUniqueInput
  }

  export type EnumTransferTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransferType
  }

  export type EnumTransferStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransferStatus
  }

  export type LotUpdateOneWithoutTransfer_Transfer_destLotIdToLotNestedInput = {
    create?: XOR<LotCreateWithoutTransfer_Transfer_destLotIdToLotInput, LotUncheckedCreateWithoutTransfer_Transfer_destLotIdToLotInput>
    connectOrCreate?: LotCreateOrConnectWithoutTransfer_Transfer_destLotIdToLotInput
    upsert?: LotUpsertWithoutTransfer_Transfer_destLotIdToLotInput
    disconnect?: LotWhereInput | boolean
    delete?: LotWhereInput | boolean
    connect?: LotWhereUniqueInput
    update?: XOR<XOR<LotUpdateToOneWithWhereWithoutTransfer_Transfer_destLotIdToLotInput, LotUpdateWithoutTransfer_Transfer_destLotIdToLotInput>, LotUncheckedUpdateWithoutTransfer_Transfer_destLotIdToLotInput>
  }

  export type TankUpdateOneRequiredWithoutTransfer_Transfer_destTankIdToTankNestedInput = {
    create?: XOR<TankCreateWithoutTransfer_Transfer_destTankIdToTankInput, TankUncheckedCreateWithoutTransfer_Transfer_destTankIdToTankInput>
    connectOrCreate?: TankCreateOrConnectWithoutTransfer_Transfer_destTankIdToTankInput
    upsert?: TankUpsertWithoutTransfer_Transfer_destTankIdToTankInput
    connect?: TankWhereUniqueInput
    update?: XOR<XOR<TankUpdateToOneWithWhereWithoutTransfer_Transfer_destTankIdToTankInput, TankUpdateWithoutTransfer_Transfer_destTankIdToTankInput>, TankUncheckedUpdateWithoutTransfer_Transfer_destTankIdToTankInput>
  }

  export type LotUpdateOneWithoutTransfer_Transfer_sourceLotIdToLotNestedInput = {
    create?: XOR<LotCreateWithoutTransfer_Transfer_sourceLotIdToLotInput, LotUncheckedCreateWithoutTransfer_Transfer_sourceLotIdToLotInput>
    connectOrCreate?: LotCreateOrConnectWithoutTransfer_Transfer_sourceLotIdToLotInput
    upsert?: LotUpsertWithoutTransfer_Transfer_sourceLotIdToLotInput
    disconnect?: LotWhereInput | boolean
    delete?: LotWhereInput | boolean
    connect?: LotWhereUniqueInput
    update?: XOR<XOR<LotUpdateToOneWithWhereWithoutTransfer_Transfer_sourceLotIdToLotInput, LotUpdateWithoutTransfer_Transfer_sourceLotIdToLotInput>, LotUncheckedUpdateWithoutTransfer_Transfer_sourceLotIdToLotInput>
  }

  export type TankUpdateOneRequiredWithoutTransfer_Transfer_sourceTankIdToTankNestedInput = {
    create?: XOR<TankCreateWithoutTransfer_Transfer_sourceTankIdToTankInput, TankUncheckedCreateWithoutTransfer_Transfer_sourceTankIdToTankInput>
    connectOrCreate?: TankCreateOrConnectWithoutTransfer_Transfer_sourceTankIdToTankInput
    upsert?: TankUpsertWithoutTransfer_Transfer_sourceTankIdToTankInput
    connect?: TankWhereUniqueInput
    update?: XOR<XOR<TankUpdateToOneWithWhereWithoutTransfer_Transfer_sourceTankIdToTankInput, TankUpdateWithoutTransfer_Transfer_sourceTankIdToTankInput>, TankUncheckedUpdateWithoutTransfer_Transfer_sourceTankIdToTankInput>
  }

  export type BatchCreateNestedOneWithoutKegInput = {
    create?: XOR<BatchCreateWithoutKegInput, BatchUncheckedCreateWithoutKegInput>
    connectOrCreate?: BatchCreateOrConnectWithoutKegInput
    connect?: BatchWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutKegInput = {
    create?: XOR<CustomerCreateWithoutKegInput, CustomerUncheckedCreateWithoutKegInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutKegInput
    connect?: CustomerWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutKegInput = {
    create?: XOR<TenantCreateWithoutKegInput, TenantUncheckedCreateWithoutKegInput>
    connectOrCreate?: TenantCreateOrConnectWithoutKegInput
    connect?: TenantWhereUniqueInput
  }

  export type KegMovementCreateNestedManyWithoutKegInput = {
    create?: XOR<KegMovementCreateWithoutKegInput, KegMovementUncheckedCreateWithoutKegInput> | KegMovementCreateWithoutKegInput[] | KegMovementUncheckedCreateWithoutKegInput[]
    connectOrCreate?: KegMovementCreateOrConnectWithoutKegInput | KegMovementCreateOrConnectWithoutKegInput[]
    createMany?: KegMovementCreateManyKegInputEnvelope
    connect?: KegMovementWhereUniqueInput | KegMovementWhereUniqueInput[]
  }

  export type KegMovementUncheckedCreateNestedManyWithoutKegInput = {
    create?: XOR<KegMovementCreateWithoutKegInput, KegMovementUncheckedCreateWithoutKegInput> | KegMovementCreateWithoutKegInput[] | KegMovementUncheckedCreateWithoutKegInput[]
    connectOrCreate?: KegMovementCreateOrConnectWithoutKegInput | KegMovementCreateOrConnectWithoutKegInput[]
    createMany?: KegMovementCreateManyKegInputEnvelope
    connect?: KegMovementWhereUniqueInput | KegMovementWhereUniqueInput[]
  }

  export type EnumKegStatusFieldUpdateOperationsInput = {
    set?: $Enums.KegStatus
  }

  export type EnumKegConditionFieldUpdateOperationsInput = {
    set?: $Enums.KegCondition
  }

  export type BatchUpdateOneWithoutKegNestedInput = {
    create?: XOR<BatchCreateWithoutKegInput, BatchUncheckedCreateWithoutKegInput>
    connectOrCreate?: BatchCreateOrConnectWithoutKegInput
    upsert?: BatchUpsertWithoutKegInput
    disconnect?: BatchWhereInput | boolean
    delete?: BatchWhereInput | boolean
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutKegInput, BatchUpdateWithoutKegInput>, BatchUncheckedUpdateWithoutKegInput>
  }

  export type CustomerUpdateOneWithoutKegNestedInput = {
    create?: XOR<CustomerCreateWithoutKegInput, CustomerUncheckedCreateWithoutKegInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutKegInput
    upsert?: CustomerUpsertWithoutKegInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutKegInput, CustomerUpdateWithoutKegInput>, CustomerUncheckedUpdateWithoutKegInput>
  }

  export type TenantUpdateOneRequiredWithoutKegNestedInput = {
    create?: XOR<TenantCreateWithoutKegInput, TenantUncheckedCreateWithoutKegInput>
    connectOrCreate?: TenantCreateOrConnectWithoutKegInput
    upsert?: TenantUpsertWithoutKegInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutKegInput, TenantUpdateWithoutKegInput>, TenantUncheckedUpdateWithoutKegInput>
  }

  export type KegMovementUpdateManyWithoutKegNestedInput = {
    create?: XOR<KegMovementCreateWithoutKegInput, KegMovementUncheckedCreateWithoutKegInput> | KegMovementCreateWithoutKegInput[] | KegMovementUncheckedCreateWithoutKegInput[]
    connectOrCreate?: KegMovementCreateOrConnectWithoutKegInput | KegMovementCreateOrConnectWithoutKegInput[]
    upsert?: KegMovementUpsertWithWhereUniqueWithoutKegInput | KegMovementUpsertWithWhereUniqueWithoutKegInput[]
    createMany?: KegMovementCreateManyKegInputEnvelope
    set?: KegMovementWhereUniqueInput | KegMovementWhereUniqueInput[]
    disconnect?: KegMovementWhereUniqueInput | KegMovementWhereUniqueInput[]
    delete?: KegMovementWhereUniqueInput | KegMovementWhereUniqueInput[]
    connect?: KegMovementWhereUniqueInput | KegMovementWhereUniqueInput[]
    update?: KegMovementUpdateWithWhereUniqueWithoutKegInput | KegMovementUpdateWithWhereUniqueWithoutKegInput[]
    updateMany?: KegMovementUpdateManyWithWhereWithoutKegInput | KegMovementUpdateManyWithWhereWithoutKegInput[]
    deleteMany?: KegMovementScalarWhereInput | KegMovementScalarWhereInput[]
  }

  export type KegMovementUncheckedUpdateManyWithoutKegNestedInput = {
    create?: XOR<KegMovementCreateWithoutKegInput, KegMovementUncheckedCreateWithoutKegInput> | KegMovementCreateWithoutKegInput[] | KegMovementUncheckedCreateWithoutKegInput[]
    connectOrCreate?: KegMovementCreateOrConnectWithoutKegInput | KegMovementCreateOrConnectWithoutKegInput[]
    upsert?: KegMovementUpsertWithWhereUniqueWithoutKegInput | KegMovementUpsertWithWhereUniqueWithoutKegInput[]
    createMany?: KegMovementCreateManyKegInputEnvelope
    set?: KegMovementWhereUniqueInput | KegMovementWhereUniqueInput[]
    disconnect?: KegMovementWhereUniqueInput | KegMovementWhereUniqueInput[]
    delete?: KegMovementWhereUniqueInput | KegMovementWhereUniqueInput[]
    connect?: KegMovementWhereUniqueInput | KegMovementWhereUniqueInput[]
    update?: KegMovementUpdateWithWhereUniqueWithoutKegInput | KegMovementUpdateWithWhereUniqueWithoutKegInput[]
    updateMany?: KegMovementUpdateManyWithWhereWithoutKegInput | KegMovementUpdateManyWithWhereWithoutKegInput[]
    deleteMany?: KegMovementScalarWhereInput | KegMovementScalarWhereInput[]
  }

  export type KegCreateNestedOneWithoutMovementsInput = {
    create?: XOR<KegCreateWithoutMovementsInput, KegUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: KegCreateOrConnectWithoutMovementsInput
    connect?: KegWhereUniqueInput
  }

  export type EnumKegActionFieldUpdateOperationsInput = {
    set?: $Enums.KegAction
  }

  export type KegUpdateOneRequiredWithoutMovementsNestedInput = {
    create?: XOR<KegCreateWithoutMovementsInput, KegUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: KegCreateOrConnectWithoutMovementsInput
    upsert?: KegUpsertWithoutMovementsInput
    connect?: KegWhereUniqueInput
    update?: XOR<XOR<KegUpdateToOneWithWhereWithoutMovementsInput, KegUpdateWithoutMovementsInput>, KegUncheckedUpdateWithoutMovementsInput>
  }

  export type BatchCreateNestedOneWithoutQCTestInput = {
    create?: XOR<BatchCreateWithoutQCTestInput, BatchUncheckedCreateWithoutQCTestInput>
    connectOrCreate?: BatchCreateOrConnectWithoutQCTestInput
    connect?: BatchWhereUniqueInput
  }

  export type LotCreateNestedOneWithoutQCTestInput = {
    create?: XOR<LotCreateWithoutQCTestInput, LotUncheckedCreateWithoutQCTestInput>
    connectOrCreate?: LotCreateOrConnectWithoutQCTestInput
    connect?: LotWhereUniqueInput
  }

  export type EnumQCTestTypeFieldUpdateOperationsInput = {
    set?: $Enums.QCTestType
  }

  export type EnumQCTestStatusFieldUpdateOperationsInput = {
    set?: $Enums.QCTestStatus
  }

  export type EnumQCTestPriorityFieldUpdateOperationsInput = {
    set?: $Enums.QCTestPriority
  }

  export type BatchUpdateOneRequiredWithoutQCTestNestedInput = {
    create?: XOR<BatchCreateWithoutQCTestInput, BatchUncheckedCreateWithoutQCTestInput>
    connectOrCreate?: BatchCreateOrConnectWithoutQCTestInput
    upsert?: BatchUpsertWithoutQCTestInput
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutQCTestInput, BatchUpdateWithoutQCTestInput>, BatchUncheckedUpdateWithoutQCTestInput>
  }

  export type LotUpdateOneWithoutQCTestNestedInput = {
    create?: XOR<LotCreateWithoutQCTestInput, LotUncheckedCreateWithoutQCTestInput>
    connectOrCreate?: LotCreateOrConnectWithoutQCTestInput
    upsert?: LotUpsertWithoutQCTestInput
    disconnect?: LotWhereInput | boolean
    delete?: LotWhereInput | boolean
    connect?: LotWhereUniqueInput
    update?: XOR<XOR<LotUpdateToOneWithWhereWithoutQCTestInput, LotUpdateWithoutQCTestInput>, LotUncheckedUpdateWithoutQCTestInput>
  }

  export type TourCreateNestedManyWithoutMuseumInput = {
    create?: XOR<TourCreateWithoutMuseumInput, TourUncheckedCreateWithoutMuseumInput> | TourCreateWithoutMuseumInput[] | TourUncheckedCreateWithoutMuseumInput[]
    connectOrCreate?: TourCreateOrConnectWithoutMuseumInput | TourCreateOrConnectWithoutMuseumInput[]
    createMany?: TourCreateManyMuseumInputEnvelope
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
  }

  export type TourUncheckedCreateNestedManyWithoutMuseumInput = {
    create?: XOR<TourCreateWithoutMuseumInput, TourUncheckedCreateWithoutMuseumInput> | TourCreateWithoutMuseumInput[] | TourUncheckedCreateWithoutMuseumInput[]
    connectOrCreate?: TourCreateOrConnectWithoutMuseumInput | TourCreateOrConnectWithoutMuseumInput[]
    createMany?: TourCreateManyMuseumInputEnvelope
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
  }

  export type TourUpdateManyWithoutMuseumNestedInput = {
    create?: XOR<TourCreateWithoutMuseumInput, TourUncheckedCreateWithoutMuseumInput> | TourCreateWithoutMuseumInput[] | TourUncheckedCreateWithoutMuseumInput[]
    connectOrCreate?: TourCreateOrConnectWithoutMuseumInput | TourCreateOrConnectWithoutMuseumInput[]
    upsert?: TourUpsertWithWhereUniqueWithoutMuseumInput | TourUpsertWithWhereUniqueWithoutMuseumInput[]
    createMany?: TourCreateManyMuseumInputEnvelope
    set?: TourWhereUniqueInput | TourWhereUniqueInput[]
    disconnect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    delete?: TourWhereUniqueInput | TourWhereUniqueInput[]
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    update?: TourUpdateWithWhereUniqueWithoutMuseumInput | TourUpdateWithWhereUniqueWithoutMuseumInput[]
    updateMany?: TourUpdateManyWithWhereWithoutMuseumInput | TourUpdateManyWithWhereWithoutMuseumInput[]
    deleteMany?: TourScalarWhereInput | TourScalarWhereInput[]
  }

  export type TourUncheckedUpdateManyWithoutMuseumNestedInput = {
    create?: XOR<TourCreateWithoutMuseumInput, TourUncheckedCreateWithoutMuseumInput> | TourCreateWithoutMuseumInput[] | TourUncheckedCreateWithoutMuseumInput[]
    connectOrCreate?: TourCreateOrConnectWithoutMuseumInput | TourCreateOrConnectWithoutMuseumInput[]
    upsert?: TourUpsertWithWhereUniqueWithoutMuseumInput | TourUpsertWithWhereUniqueWithoutMuseumInput[]
    createMany?: TourCreateManyMuseumInputEnvelope
    set?: TourWhereUniqueInput | TourWhereUniqueInput[]
    disconnect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    delete?: TourWhereUniqueInput | TourWhereUniqueInput[]
    connect?: TourWhereUniqueInput | TourWhereUniqueInput[]
    update?: TourUpdateWithWhereUniqueWithoutMuseumInput | TourUpdateWithWhereUniqueWithoutMuseumInput[]
    updateMany?: TourUpdateManyWithWhereWithoutMuseumInput | TourUpdateManyWithWhereWithoutMuseumInput[]
    deleteMany?: TourScalarWhereInput | TourScalarWhereInput[]
  }

  export type MuseumCreateNestedOneWithoutToursInput = {
    create?: XOR<MuseumCreateWithoutToursInput, MuseumUncheckedCreateWithoutToursInput>
    connectOrCreate?: MuseumCreateOrConnectWithoutToursInput
    connect?: MuseumWhereUniqueInput
  }

  export type MuseumUpdateOneRequiredWithoutToursNestedInput = {
    create?: XOR<MuseumCreateWithoutToursInput, MuseumUncheckedCreateWithoutToursInput>
    connectOrCreate?: MuseumCreateOrConnectWithoutToursInput
    upsert?: MuseumUpsertWithoutToursInput
    connect?: MuseumWhereUniqueInput
    update?: XOR<XOR<MuseumUpdateToOneWithWhereWithoutToursInput, MuseumUpdateWithoutToursInput>, MuseumUncheckedUpdateWithoutToursInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumPlanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeFilter<$PrismaModel> | $Enums.PlanType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumRecipeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RecipeStatus | EnumRecipeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecipeStatus[] | ListEnumRecipeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecipeStatus[] | ListEnumRecipeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecipeStatusFilter<$PrismaModel> | $Enums.RecipeStatus
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRecipeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecipeStatus | EnumRecipeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecipeStatus[] | ListEnumRecipeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecipeStatus[] | ListEnumRecipeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecipeStatusWithAggregatesFilter<$PrismaModel> | $Enums.RecipeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecipeStatusFilter<$PrismaModel>
    _max?: NestedEnumRecipeStatusFilter<$PrismaModel>
  }

  export type NestedEnumIngredientCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.IngredientCategory | EnumIngredientCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IngredientCategory[] | ListEnumIngredientCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.IngredientCategory[] | ListEnumIngredientCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumIngredientCategoryFilter<$PrismaModel> | $Enums.IngredientCategory
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumIngredientCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IngredientCategory | EnumIngredientCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IngredientCategory[] | ListEnumIngredientCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.IngredientCategory[] | ListEnumIngredientCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumIngredientCategoryWithAggregatesFilter<$PrismaModel> | $Enums.IngredientCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIngredientCategoryFilter<$PrismaModel>
    _max?: NestedEnumIngredientCategoryFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumInventoryCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryCategory | EnumInventoryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryCategory[] | ListEnumInventoryCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryCategory[] | ListEnumInventoryCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryCategoryFilter<$PrismaModel> | $Enums.InventoryCategory
  }

  export type NestedEnumInventoryCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryCategory | EnumInventoryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryCategory[] | ListEnumInventoryCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryCategory[] | ListEnumInventoryCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryCategoryWithAggregatesFilter<$PrismaModel> | $Enums.InventoryCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryCategoryFilter<$PrismaModel>
    _max?: NestedEnumInventoryCategoryFilter<$PrismaModel>
  }

  export type NestedEnumLedgerEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryType | EnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryTypeFilter<$PrismaModel> | $Enums.LedgerEntryType
  }

  export type NestedEnumLedgerEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryType | EnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.LedgerEntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumLedgerEntryTypeFilter<$PrismaModel>
  }

  export type NestedEnumBatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusFilter<$PrismaModel> | $Enums.BatchStatus
  }

  export type NestedEnumBatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.BatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBatchStatusFilter<$PrismaModel>
    _max?: NestedEnumBatchStatusFilter<$PrismaModel>
  }

  export type NestedEnumTimelineEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TimelineEventType | EnumTimelineEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TimelineEventType[] | ListEnumTimelineEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimelineEventType[] | ListEnumTimelineEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTimelineEventTypeFilter<$PrismaModel> | $Enums.TimelineEventType
  }

  export type NestedEnumTimelineEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TimelineEventType | EnumTimelineEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TimelineEventType[] | ListEnumTimelineEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimelineEventType[] | ListEnumTimelineEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTimelineEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.TimelineEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTimelineEventTypeFilter<$PrismaModel>
    _max?: NestedEnumTimelineEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumTankTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TankType | EnumTankTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TankType[] | ListEnumTankTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TankType[] | ListEnumTankTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTankTypeFilter<$PrismaModel> | $Enums.TankType
  }

  export type NestedEnumTankStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TankStatus | EnumTankStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TankStatus[] | ListEnumTankStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TankStatus[] | ListEnumTankStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTankStatusFilter<$PrismaModel> | $Enums.TankStatus
  }

  export type NestedEnumLotPhaseNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LotPhase | EnumLotPhaseFieldRefInput<$PrismaModel> | null
    in?: $Enums.LotPhase[] | ListEnumLotPhaseFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LotPhase[] | ListEnumLotPhaseFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLotPhaseNullableFilter<$PrismaModel> | $Enums.LotPhase | null
  }

  export type NestedEnumTankTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TankType | EnumTankTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TankType[] | ListEnumTankTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TankType[] | ListEnumTankTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTankTypeWithAggregatesFilter<$PrismaModel> | $Enums.TankType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTankTypeFilter<$PrismaModel>
    _max?: NestedEnumTankTypeFilter<$PrismaModel>
  }

  export type NestedEnumTankStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TankStatus | EnumTankStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TankStatus[] | ListEnumTankStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TankStatus[] | ListEnumTankStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTankStatusWithAggregatesFilter<$PrismaModel> | $Enums.TankStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTankStatusFilter<$PrismaModel>
    _max?: NestedEnumTankStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumLotPhaseNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LotPhase | EnumLotPhaseFieldRefInput<$PrismaModel> | null
    in?: $Enums.LotPhase[] | ListEnumLotPhaseFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LotPhase[] | ListEnumLotPhaseFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLotPhaseNullableWithAggregatesFilter<$PrismaModel> | $Enums.LotPhase | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLotPhaseNullableFilter<$PrismaModel>
    _max?: NestedEnumLotPhaseNullableFilter<$PrismaModel>
  }

  export type NestedEnumOccupationPhaseFilter<$PrismaModel = never> = {
    equals?: $Enums.OccupationPhase | EnumOccupationPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.OccupationPhase[] | ListEnumOccupationPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccupationPhase[] | ListEnumOccupationPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumOccupationPhaseFilter<$PrismaModel> | $Enums.OccupationPhase
  }

  export type NestedEnumOccupationPhaseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OccupationPhase | EnumOccupationPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.OccupationPhase[] | ListEnumOccupationPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.OccupationPhase[] | ListEnumOccupationPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumOccupationPhaseWithAggregatesFilter<$PrismaModel> | $Enums.OccupationPhase
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOccupationPhaseFilter<$PrismaModel>
    _max?: NestedEnumOccupationPhaseFilter<$PrismaModel>
  }

  export type NestedEnumPackageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PackageType | EnumPackageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPackageTypeFilter<$PrismaModel> | $Enums.PackageType
  }

  export type NestedEnumPackageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PackageType | EnumPackageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPackageTypeWithAggregatesFilter<$PrismaModel> | $Enums.PackageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPackageTypeFilter<$PrismaModel>
    _max?: NestedEnumPackageTypeFilter<$PrismaModel>
  }

  export type NestedEnumCustomerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeFilter<$PrismaModel> | $Enums.CustomerType
  }

  export type NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomerTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumIncomeCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeCategory | EnumIncomeCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.IncomeCategory[] | ListEnumIncomeCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IncomeCategory[] | ListEnumIncomeCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIncomeCategoryNullableFilter<$PrismaModel> | $Enums.IncomeCategory | null
  }

  export type NestedEnumExpenseCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumExpenseCategoryNullableFilter<$PrismaModel> | $Enums.ExpenseCategory | null
  }

  export type NestedEnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumIncomeCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeCategory | EnumIncomeCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.IncomeCategory[] | ListEnumIncomeCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IncomeCategory[] | ListEnumIncomeCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIncomeCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.IncomeCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumIncomeCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumIncomeCategoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumExpenseCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumExpenseCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumExpenseCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumExpenseCategoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumPackageTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PackageType | EnumPackageTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPackageTypeNullableFilter<$PrismaModel> | $Enums.PackageType | null
  }

  export type NestedEnumPackageTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PackageType | EnumPackageTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PackageType[] | ListEnumPackageTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPackageTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PackageType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPackageTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPackageTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumExpenseCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseCategoryFilter<$PrismaModel> | $Enums.ExpenseCategory
  }

  export type NestedEnumExpenseCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseCategory | EnumExpenseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseCategory[] | ListEnumExpenseCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseCategoryFilter<$PrismaModel>
    _max?: NestedEnumExpenseCategoryFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumLotPhaseFilter<$PrismaModel = never> = {
    equals?: $Enums.LotPhase | EnumLotPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.LotPhase[] | ListEnumLotPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.LotPhase[] | ListEnumLotPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumLotPhaseFilter<$PrismaModel> | $Enums.LotPhase
  }

  export type NestedEnumLotStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LotStatus | EnumLotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LotStatus[] | ListEnumLotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LotStatus[] | ListEnumLotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLotStatusFilter<$PrismaModel> | $Enums.LotStatus
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumLotPhaseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LotPhase | EnumLotPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.LotPhase[] | ListEnumLotPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.LotPhase[] | ListEnumLotPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumLotPhaseWithAggregatesFilter<$PrismaModel> | $Enums.LotPhase
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLotPhaseFilter<$PrismaModel>
    _max?: NestedEnumLotPhaseFilter<$PrismaModel>
  }

  export type NestedEnumLotStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LotStatus | EnumLotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LotStatus[] | ListEnumLotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LotStatus[] | ListEnumLotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLotStatusWithAggregatesFilter<$PrismaModel> | $Enums.LotStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLotStatusFilter<$PrismaModel>
    _max?: NestedEnumLotStatusFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumReadingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReadingType | EnumReadingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReadingType[] | ListEnumReadingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReadingType[] | ListEnumReadingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReadingTypeFilter<$PrismaModel> | $Enums.ReadingType
  }

  export type NestedEnumReadingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReadingType | EnumReadingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReadingType[] | ListEnumReadingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReadingType[] | ListEnumReadingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReadingTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReadingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReadingTypeFilter<$PrismaModel>
    _max?: NestedEnumReadingTypeFilter<$PrismaModel>
  }

  export type NestedEnumAssignmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusFilter<$PrismaModel> | $Enums.AssignmentStatus
  }

  export type NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAssignmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumTransferTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferType | EnumTransferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferTypeFilter<$PrismaModel> | $Enums.TransferType
  }

  export type NestedEnumTransferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusFilter<$PrismaModel> | $Enums.TransferStatus
  }

  export type NestedEnumTransferTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferType | EnumTransferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferType[] | ListEnumTransferTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransferType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferTypeFilter<$PrismaModel>
    _max?: NestedEnumTransferTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransferStatus[] | ListEnumTransferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusFilter<$PrismaModel>
  }

  export type NestedEnumKegStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KegStatus | EnumKegStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KegStatus[] | ListEnumKegStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KegStatus[] | ListEnumKegStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKegStatusFilter<$PrismaModel> | $Enums.KegStatus
  }

  export type NestedEnumKegConditionFilter<$PrismaModel = never> = {
    equals?: $Enums.KegCondition | EnumKegConditionFieldRefInput<$PrismaModel>
    in?: $Enums.KegCondition[] | ListEnumKegConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.KegCondition[] | ListEnumKegConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumKegConditionFilter<$PrismaModel> | $Enums.KegCondition
  }

  export type NestedEnumKegStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KegStatus | EnumKegStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KegStatus[] | ListEnumKegStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KegStatus[] | ListEnumKegStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKegStatusWithAggregatesFilter<$PrismaModel> | $Enums.KegStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKegStatusFilter<$PrismaModel>
    _max?: NestedEnumKegStatusFilter<$PrismaModel>
  }

  export type NestedEnumKegConditionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KegCondition | EnumKegConditionFieldRefInput<$PrismaModel>
    in?: $Enums.KegCondition[] | ListEnumKegConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.KegCondition[] | ListEnumKegConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumKegConditionWithAggregatesFilter<$PrismaModel> | $Enums.KegCondition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKegConditionFilter<$PrismaModel>
    _max?: NestedEnumKegConditionFilter<$PrismaModel>
  }

  export type NestedEnumKegActionFilter<$PrismaModel = never> = {
    equals?: $Enums.KegAction | EnumKegActionFieldRefInput<$PrismaModel>
    in?: $Enums.KegAction[] | ListEnumKegActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.KegAction[] | ListEnumKegActionFieldRefInput<$PrismaModel>
    not?: NestedEnumKegActionFilter<$PrismaModel> | $Enums.KegAction
  }

  export type NestedEnumKegActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KegAction | EnumKegActionFieldRefInput<$PrismaModel>
    in?: $Enums.KegAction[] | ListEnumKegActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.KegAction[] | ListEnumKegActionFieldRefInput<$PrismaModel>
    not?: NestedEnumKegActionWithAggregatesFilter<$PrismaModel> | $Enums.KegAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKegActionFilter<$PrismaModel>
    _max?: NestedEnumKegActionFilter<$PrismaModel>
  }

  export type NestedEnumQCTestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QCTestType | EnumQCTestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QCTestType[] | ListEnumQCTestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCTestType[] | ListEnumQCTestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQCTestTypeFilter<$PrismaModel> | $Enums.QCTestType
  }

  export type NestedEnumQCTestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QCTestStatus | EnumQCTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QCTestStatus[] | ListEnumQCTestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCTestStatus[] | ListEnumQCTestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQCTestStatusFilter<$PrismaModel> | $Enums.QCTestStatus
  }

  export type NestedEnumQCTestPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.QCTestPriority | EnumQCTestPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.QCTestPriority[] | ListEnumQCTestPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCTestPriority[] | ListEnumQCTestPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumQCTestPriorityFilter<$PrismaModel> | $Enums.QCTestPriority
  }

  export type NestedEnumQCTestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QCTestType | EnumQCTestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QCTestType[] | ListEnumQCTestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCTestType[] | ListEnumQCTestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQCTestTypeWithAggregatesFilter<$PrismaModel> | $Enums.QCTestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQCTestTypeFilter<$PrismaModel>
    _max?: NestedEnumQCTestTypeFilter<$PrismaModel>
  }

  export type NestedEnumQCTestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QCTestStatus | EnumQCTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QCTestStatus[] | ListEnumQCTestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCTestStatus[] | ListEnumQCTestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQCTestStatusWithAggregatesFilter<$PrismaModel> | $Enums.QCTestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQCTestStatusFilter<$PrismaModel>
    _max?: NestedEnumQCTestStatusFilter<$PrismaModel>
  }

  export type NestedEnumQCTestPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QCTestPriority | EnumQCTestPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.QCTestPriority[] | ListEnumQCTestPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.QCTestPriority[] | ListEnumQCTestPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumQCTestPriorityWithAggregatesFilter<$PrismaModel> | $Enums.QCTestPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQCTestPriorityFilter<$PrismaModel>
    _max?: NestedEnumQCTestPriorityFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BatchCreateWithoutTenantInput = {
    id?: string
    batchNumber: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    recipe: RecipeCreateNestedOneWithoutBatchesInput
    tank?: TankCreateNestedOneWithoutBatchesInput
    ingredients?: BatchIngredientCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerCreateNestedManyWithoutBatchInput
    Keg?: KegCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunCreateNestedManyWithoutBatchInput
    QCTest?: QCTestCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutTenantInput = {
    id?: string
    batchNumber: string
    recipeId: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    tankId?: string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    ingredients?: BatchIngredientUncheckedCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineUncheckedCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingUncheckedCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerUncheckedCreateNestedManyWithoutBatchInput
    Keg?: KegUncheckedCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchUncheckedCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunUncheckedCreateNestedManyWithoutBatchInput
    QCTest?: QCTestUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutTenantInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutTenantInput, BatchUncheckedCreateWithoutTenantInput>
  }

  export type BatchCreateManyTenantInputEnvelope = {
    data: BatchCreateManyTenantInput | BatchCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type BudgetCreateWithoutTenantInput = {
    id?: string
    category: $Enums.ExpenseCategory
    year: number
    month?: number | null
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetUncheckedCreateWithoutTenantInput = {
    id?: string
    category: $Enums.ExpenseCategory
    year: number
    month?: number | null
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCreateOrConnectWithoutTenantInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutTenantInput, BudgetUncheckedCreateWithoutTenantInput>
  }

  export type BudgetCreateManyTenantInputEnvelope = {
    data: BudgetCreateManyTenantInput | BudgetCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutTenantInput = {
    id?: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    kegReturnDays?: number
    kegDepositRequired?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    Keg?: KegCreateNestedManyWithoutCustomerInput
    orders?: SalesOrderCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    kegReturnDays?: number
    kegDepositRequired?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    Keg?: KegUncheckedCreateNestedManyWithoutCustomerInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutTenantInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput>
  }

  export type CustomerCreateManyTenantInputEnvelope = {
    data: CustomerCreateManyTenantInput | CustomerCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutTenantInput = {
    id: string
    name: string
    type: string
    status?: string
    capacity?: number | null
    model?: string | null
    manufacturer?: string | null
    serialNumber?: string | null
    location?: string | null
    workingPressure?: number | null
    currentTemp?: number | null
    currentPressure?: number | null
    installationDate?: Date | string | null
    warrantyDate?: Date | string | null
    lastCIP?: Date | string | null
    nextCIP?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    cipIntervalDays?: number
    inspectionIntervalDays?: number
    annualMaintenanceDays?: number
    currentBatchId?: string | null
    currentBatchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    purchaseDate?: Date | string | null
    capabilities?: EquipmentCreatecapabilitiesInput | string[]
    CIPLog?: CIPLogCreateNestedManyWithoutEquipmentInput
    MaintenanceLog?: MaintenanceLogCreateNestedManyWithoutEquipmentInput
    ProblemReport?: ProblemReportCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutTenantInput = {
    id: string
    name: string
    type: string
    status?: string
    capacity?: number | null
    model?: string | null
    manufacturer?: string | null
    serialNumber?: string | null
    location?: string | null
    workingPressure?: number | null
    currentTemp?: number | null
    currentPressure?: number | null
    installationDate?: Date | string | null
    warrantyDate?: Date | string | null
    lastCIP?: Date | string | null
    nextCIP?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    cipIntervalDays?: number
    inspectionIntervalDays?: number
    annualMaintenanceDays?: number
    currentBatchId?: string | null
    currentBatchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    purchaseDate?: Date | string | null
    capabilities?: EquipmentCreatecapabilitiesInput | string[]
    CIPLog?: CIPLogUncheckedCreateNestedManyWithoutEquipmentInput
    MaintenanceLog?: MaintenanceLogUncheckedCreateNestedManyWithoutEquipmentInput
    ProblemReport?: ProblemReportUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutTenantInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutTenantInput, EquipmentUncheckedCreateWithoutTenantInput>
  }

  export type EquipmentCreateManyTenantInputEnvelope = {
    data: EquipmentCreateManyTenantInput | EquipmentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutTenantInput = {
    id?: string
    category: $Enums.ExpenseCategory
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    invoiceNumber?: string | null
    invoiceId?: string | null
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    receiptUrl?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier?: SupplierCreateNestedOneWithoutExpensesInput
    transactions?: TransactionCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutTenantInput = {
    id?: string
    category: $Enums.ExpenseCategory
    supplierId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    invoiceNumber?: string | null
    invoiceId?: string | null
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    receiptUrl?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseCreateOrConnectWithoutTenantInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutTenantInput, ExpenseUncheckedCreateWithoutTenantInput>
  }

  export type ExpenseCreateManyTenantInputEnvelope = {
    data: ExpenseCreateManyTenantInput | ExpenseCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type InventoryItemCreateWithoutTenantInput = {
    id?: string
    sku: string
    name: string
    category?: $Enums.InventoryCategory
    ingredientType?: string | null
    unit?: string
    reorderPoint?: Decimal | DecimalJsLike | number | string | null
    supplier?: string | null
    location?: string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: Decimal | DecimalJsLike | number | string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ledger?: InventoryLedgerCreateNestedManyWithoutItemInput
    recipeIngredients?: RecipeIngredientCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutTenantInput = {
    id?: string
    sku: string
    name: string
    category?: $Enums.InventoryCategory
    ingredientType?: string | null
    unit?: string
    reorderPoint?: Decimal | DecimalJsLike | number | string | null
    supplier?: string | null
    location?: string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: Decimal | DecimalJsLike | number | string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ledger?: InventoryLedgerUncheckedCreateNestedManyWithoutItemInput
    recipeIngredients?: RecipeIngredientUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutTenantInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutTenantInput, InventoryItemUncheckedCreateWithoutTenantInput>
  }

  export type InventoryItemCreateManyTenantInputEnvelope = {
    data: InventoryItemCreateManyTenantInput | InventoryItemCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutTenantInput = {
    id?: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutInvoicesInput
    order?: SalesOrderCreateNestedOneWithoutInvoiceInput
    supplier?: SupplierCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutTenantInput = {
    id?: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    customerId?: string | null
    supplierId?: string | null
    orderId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceCreateManyTenantInputEnvelope = {
    data: InvoiceCreateManyTenantInput | InvoiceCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type KegCreateWithoutTenantInput = {
    id?: string
    kegNumber: string
    size: number
    status?: $Enums.KegStatus
    condition?: $Enums.KegCondition
    filledAt?: Date | string | null
    productName?: string | null
    lotNumber?: string | null
    orderId?: string | null
    sentAt?: Date | string | null
    returnedAt?: Date | string | null
    deposit?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Batch?: BatchCreateNestedOneWithoutKegInput
    Customer?: CustomerCreateNestedOneWithoutKegInput
    movements?: KegMovementCreateNestedManyWithoutKegInput
  }

  export type KegUncheckedCreateWithoutTenantInput = {
    id?: string
    kegNumber: string
    size: number
    status?: $Enums.KegStatus
    condition?: $Enums.KegCondition
    batchId?: string | null
    filledAt?: Date | string | null
    productName?: string | null
    lotNumber?: string | null
    customerId?: string | null
    orderId?: string | null
    sentAt?: Date | string | null
    returnedAt?: Date | string | null
    deposit?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movements?: KegMovementUncheckedCreateNestedManyWithoutKegInput
  }

  export type KegCreateOrConnectWithoutTenantInput = {
    where: KegWhereUniqueInput
    create: XOR<KegCreateWithoutTenantInput, KegUncheckedCreateWithoutTenantInput>
  }

  export type KegCreateManyTenantInputEnvelope = {
    data: KegCreateManyTenantInput | KegCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutTenantInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PaymentMethod
    date?: Date | string
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutPaymentsInput
    order?: SalesOrderCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutTenantInput = {
    id?: string
    invoiceId?: string | null
    orderId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PaymentMethod
    date?: Date | string
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput>
  }

  export type PaymentCreateManyTenantInputEnvelope = {
    data: PaymentCreateManyTenantInput | PaymentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type RecipeCreateWithoutTenantInput = {
    id?: string
    createdBy?: string | null
    name: string
    style?: string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    ibu?: number | null
    color?: number | null
    og?: Decimal | DecimalJsLike | number | string | null
    fg?: Decimal | DecimalJsLike | number | string | null
    batchSize?: Decimal | DecimalJsLike | number | string | null
    boilTime?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    notes?: string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.RecipeStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    yeastStrain?: string | null
    batches?: BatchCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutTenantInput = {
    id?: string
    createdBy?: string | null
    name: string
    style?: string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    ibu?: number | null
    color?: number | null
    og?: Decimal | DecimalJsLike | number | string | null
    fg?: Decimal | DecimalJsLike | number | string | null
    batchSize?: Decimal | DecimalJsLike | number | string | null
    boilTime?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    notes?: string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.RecipeStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    yeastStrain?: string | null
    batches?: BatchUncheckedCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutTenantInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutTenantInput, RecipeUncheckedCreateWithoutTenantInput>
  }

  export type RecipeCreateManyTenantInputEnvelope = {
    data: RecipeCreateManyTenantInput | RecipeCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SalesOrderCreateWithoutTenantInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    orderedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdBy: string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    transactions?: TransactionCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderUncheckedCreateWithoutTenantInput = {
    id?: string
    orderNumber: string
    customerId: string
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    orderedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdBy: string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderCreateOrConnectWithoutTenantInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutTenantInput, SalesOrderUncheckedCreateWithoutTenantInput>
  }

  export type SalesOrderCreateManyTenantInputEnvelope = {
    data: SalesOrderCreateManyTenantInput | SalesOrderCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SupplierCreateWithoutTenantInput = {
    id?: string
    name: string
    category?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expenses?: ExpenseCreateNestedManyWithoutSupplierInput
    invoices?: InvoiceCreateNestedManyWithoutSupplierInput
    transactions?: TransactionCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    category?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expenses?: ExpenseUncheckedCreateNestedManyWithoutSupplierInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSupplierInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutTenantInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput>
  }

  export type SupplierCreateManyTenantInputEnvelope = {
    data: SupplierCreateManyTenantInput | SupplierCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TankCreateWithoutTenantInput = {
    id?: string
    name: string
    type: $Enums.TankType
    capacity: Decimal | DecimalJsLike | number | string
    status?: $Enums.TankStatus
    currentBatchId?: string | null
    location?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: TankCreatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: string | null
    currentPhase?: $Enums.LotPhase | null
    defaultTurnaroundHours?: number | null
    maxFillPercent?: number | null
    minFillPercent?: number | null
    batches?: BatchCreateNestedManyWithoutTankInput
    LotReading?: LotReadingCreateNestedManyWithoutTankInput
    TankAssignment?: TankAssignmentCreateNestedManyWithoutTankInput
    occupations?: TankOccupationCreateNestedManyWithoutTankInput
    Transfer_Transfer_destTankIdToTank?: TransferCreateNestedManyWithoutTank_Transfer_destTankIdToTankInput
    Transfer_Transfer_sourceTankIdToTank?: TransferCreateNestedManyWithoutTank_Transfer_sourceTankIdToTankInput
  }

  export type TankUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    type: $Enums.TankType
    capacity: Decimal | DecimalJsLike | number | string
    status?: $Enums.TankStatus
    currentBatchId?: string | null
    location?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: TankCreatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: string | null
    currentPhase?: $Enums.LotPhase | null
    defaultTurnaroundHours?: number | null
    maxFillPercent?: number | null
    minFillPercent?: number | null
    batches?: BatchUncheckedCreateNestedManyWithoutTankInput
    LotReading?: LotReadingUncheckedCreateNestedManyWithoutTankInput
    TankAssignment?: TankAssignmentUncheckedCreateNestedManyWithoutTankInput
    occupations?: TankOccupationUncheckedCreateNestedManyWithoutTankInput
    Transfer_Transfer_destTankIdToTank?: TransferUncheckedCreateNestedManyWithoutTank_Transfer_destTankIdToTankInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUncheckedCreateNestedManyWithoutTank_Transfer_sourceTankIdToTankInput
  }

  export type TankCreateOrConnectWithoutTenantInput = {
    where: TankWhereUniqueInput
    create: XOR<TankCreateWithoutTenantInput, TankUncheckedCreateWithoutTenantInput>
  }

  export type TankCreateManyTenantInputEnvelope = {
    data: TankCreateManyTenantInput | TankCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutTenantInput = {
    id?: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    expense?: ExpenseCreateNestedOneWithoutTransactionsInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
    order?: SalesOrderCreateNestedOneWithoutTransactionsInput
    supplier?: SupplierCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutTenantInput = {
    id?: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    customerId?: string | null
    supplierId?: string | null
    orderId?: string | null
    invoiceId?: string | null
    expenseId?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutTenantInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput>
  }

  export type TransactionCreateManyTenantInputEnvelope = {
    data: TransactionCreateManyTenantInput | TransactionCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type BatchUpsertWithWhereUniqueWithoutTenantInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutTenantInput, BatchUncheckedUpdateWithoutTenantInput>
    create: XOR<BatchCreateWithoutTenantInput, BatchUncheckedCreateWithoutTenantInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutTenantInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutTenantInput, BatchUncheckedUpdateWithoutTenantInput>
  }

  export type BatchUpdateManyWithWhereWithoutTenantInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutTenantInput>
  }

  export type BatchScalarWhereInput = {
    AND?: BatchScalarWhereInput | BatchScalarWhereInput[]
    OR?: BatchScalarWhereInput[]
    NOT?: BatchScalarWhereInput | BatchScalarWhereInput[]
    id?: StringFilter<"Batch"> | string
    tenantId?: StringFilter<"Batch"> | string
    batchNumber?: StringFilter<"Batch"> | string
    recipeId?: StringFilter<"Batch"> | string
    status?: EnumBatchStatusFilter<"Batch"> | $Enums.BatchStatus
    volume?: DecimalFilter<"Batch"> | Decimal | DecimalJsLike | number | string
    packagedVolume?: DecimalNullableFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    originalGravity?: DecimalNullableFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    currentGravity?: DecimalNullableFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    finalGravity?: DecimalNullableFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    abv?: DecimalNullableFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    tankId?: StringNullableFilter<"Batch"> | string | null
    plannedDate?: DateTimeFilter<"Batch"> | Date | string
    brewedAt?: DateTimeNullableFilter<"Batch"> | Date | string | null
    fermentationStartedAt?: DateTimeNullableFilter<"Batch"> | Date | string | null
    conditioningStartedAt?: DateTimeNullableFilter<"Batch"> | Date | string | null
    readyAt?: DateTimeNullableFilter<"Batch"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Batch"> | Date | string | null
    createdBy?: StringFilter<"Batch"> | string
    notes?: StringNullableFilter<"Batch"> | string | null
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    updatedAt?: DateTimeFilter<"Batch"> | Date | string
    targetOg?: DecimalNullableFilter<"Batch"> | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: StringNullableFilter<"Batch"> | string | null
  }

  export type BudgetUpsertWithWhereUniqueWithoutTenantInput = {
    where: BudgetWhereUniqueInput
    update: XOR<BudgetUpdateWithoutTenantInput, BudgetUncheckedUpdateWithoutTenantInput>
    create: XOR<BudgetCreateWithoutTenantInput, BudgetUncheckedCreateWithoutTenantInput>
  }

  export type BudgetUpdateWithWhereUniqueWithoutTenantInput = {
    where: BudgetWhereUniqueInput
    data: XOR<BudgetUpdateWithoutTenantInput, BudgetUncheckedUpdateWithoutTenantInput>
  }

  export type BudgetUpdateManyWithWhereWithoutTenantInput = {
    where: BudgetScalarWhereInput
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyWithoutTenantInput>
  }

  export type BudgetScalarWhereInput = {
    AND?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    OR?: BudgetScalarWhereInput[]
    NOT?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    id?: StringFilter<"Budget"> | string
    tenantId?: StringFilter<"Budget"> | string
    category?: EnumExpenseCategoryFilter<"Budget"> | $Enums.ExpenseCategory
    year?: IntFilter<"Budget"> | number
    month?: IntNullableFilter<"Budget"> | number | null
    amount?: DecimalFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
  }

  export type CustomerUpsertWithWhereUniqueWithoutTenantInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutTenantInput, CustomerUncheckedUpdateWithoutTenantInput>
    create: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutTenantInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutTenantInput, CustomerUncheckedUpdateWithoutTenantInput>
  }

  export type CustomerUpdateManyWithWhereWithoutTenantInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutTenantInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: StringFilter<"Customer"> | string
    tenantId?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    type?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    city?: StringNullableFilter<"Customer"> | string | null
    taxId?: StringNullableFilter<"Customer"> | string | null
    kegReturnDays?: IntFilter<"Customer"> | number
    kegDepositRequired?: BoolFilter<"Customer"> | boolean
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
  }

  export type EquipmentUpsertWithWhereUniqueWithoutTenantInput = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutTenantInput, EquipmentUncheckedUpdateWithoutTenantInput>
    create: XOR<EquipmentCreateWithoutTenantInput, EquipmentUncheckedCreateWithoutTenantInput>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutTenantInput = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutTenantInput, EquipmentUncheckedUpdateWithoutTenantInput>
  }

  export type EquipmentUpdateManyWithWhereWithoutTenantInput = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutTenantInput>
  }

  export type EquipmentScalarWhereInput = {
    AND?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
    OR?: EquipmentScalarWhereInput[]
    NOT?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
    id?: StringFilter<"Equipment"> | string
    tenantId?: StringFilter<"Equipment"> | string
    name?: StringFilter<"Equipment"> | string
    type?: StringFilter<"Equipment"> | string
    status?: StringFilter<"Equipment"> | string
    capacity?: IntNullableFilter<"Equipment"> | number | null
    model?: StringNullableFilter<"Equipment"> | string | null
    manufacturer?: StringNullableFilter<"Equipment"> | string | null
    serialNumber?: StringNullableFilter<"Equipment"> | string | null
    location?: StringNullableFilter<"Equipment"> | string | null
    workingPressure?: FloatNullableFilter<"Equipment"> | number | null
    currentTemp?: FloatNullableFilter<"Equipment"> | number | null
    currentPressure?: FloatNullableFilter<"Equipment"> | number | null
    installationDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    warrantyDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    lastCIP?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    nextCIP?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    lastMaintenance?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    nextMaintenance?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    cipIntervalDays?: IntFilter<"Equipment"> | number
    inspectionIntervalDays?: IntFilter<"Equipment"> | number
    annualMaintenanceDays?: IntFilter<"Equipment"> | number
    currentBatchId?: StringNullableFilter<"Equipment"> | string | null
    currentBatchNumber?: StringNullableFilter<"Equipment"> | string | null
    notes?: StringNullableFilter<"Equipment"> | string | null
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    purchaseDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    capabilities?: StringNullableListFilter<"Equipment">
  }

  export type ExpenseUpsertWithWhereUniqueWithoutTenantInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutTenantInput, ExpenseUncheckedUpdateWithoutTenantInput>
    create: XOR<ExpenseCreateWithoutTenantInput, ExpenseUncheckedCreateWithoutTenantInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutTenantInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutTenantInput, ExpenseUncheckedUpdateWithoutTenantInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutTenantInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutTenantInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    id?: StringFilter<"Expense"> | string
    tenantId?: StringFilter<"Expense"> | string
    category?: EnumExpenseCategoryFilter<"Expense"> | $Enums.ExpenseCategory
    supplierId?: StringNullableFilter<"Expense"> | string | null
    amount?: DecimalFilter<"Expense"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"Expense"> | Date | string
    description?: StringNullableFilter<"Expense"> | string | null
    invoiceNumber?: StringNullableFilter<"Expense"> | string | null
    invoiceId?: StringNullableFilter<"Expense"> | string | null
    isPaid?: BoolFilter<"Expense"> | boolean
    paidAt?: DateTimeNullableFilter<"Expense"> | Date | string | null
    paymentMethod?: EnumPaymentMethodNullableFilter<"Expense"> | $Enums.PaymentMethod | null
    receiptUrl?: StringNullableFilter<"Expense"> | string | null
    notes?: StringNullableFilter<"Expense"> | string | null
    createdBy?: StringFilter<"Expense"> | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutTenantInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutTenantInput, InventoryItemUncheckedUpdateWithoutTenantInput>
    create: XOR<InventoryItemCreateWithoutTenantInput, InventoryItemUncheckedCreateWithoutTenantInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutTenantInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutTenantInput, InventoryItemUncheckedUpdateWithoutTenantInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutTenantInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutTenantInput>
  }

  export type InventoryItemScalarWhereInput = {
    AND?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    OR?: InventoryItemScalarWhereInput[]
    NOT?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    tenantId?: StringFilter<"InventoryItem"> | string
    sku?: StringFilter<"InventoryItem"> | string
    name?: StringFilter<"InventoryItem"> | string
    category?: EnumInventoryCategoryFilter<"InventoryItem"> | $Enums.InventoryCategory
    ingredientType?: StringNullableFilter<"InventoryItem"> | string | null
    unit?: StringFilter<"InventoryItem"> | string
    reorderPoint?: DecimalNullableFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string | null
    supplier?: StringNullableFilter<"InventoryItem"> | string | null
    location?: StringNullableFilter<"InventoryItem"> | string | null
    specs?: JsonNullableFilter<"InventoryItem">
    cachedBalance?: DecimalFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string
    costPerUnit?: DecimalNullableFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    isActive?: BoolFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutTenantInput, InvoiceUncheckedUpdateWithoutTenantInput>
    create: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutTenantInput, InvoiceUncheckedUpdateWithoutTenantInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutTenantInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutTenantInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    tenantId?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    customerId?: StringNullableFilter<"Invoice"> | string | null
    supplierId?: StringNullableFilter<"Invoice"> | string | null
    orderId?: StringNullableFilter<"Invoice"> | string | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Invoice"> | string | null
    terms?: StringNullableFilter<"Invoice"> | string | null
    createdBy?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type KegUpsertWithWhereUniqueWithoutTenantInput = {
    where: KegWhereUniqueInput
    update: XOR<KegUpdateWithoutTenantInput, KegUncheckedUpdateWithoutTenantInput>
    create: XOR<KegCreateWithoutTenantInput, KegUncheckedCreateWithoutTenantInput>
  }

  export type KegUpdateWithWhereUniqueWithoutTenantInput = {
    where: KegWhereUniqueInput
    data: XOR<KegUpdateWithoutTenantInput, KegUncheckedUpdateWithoutTenantInput>
  }

  export type KegUpdateManyWithWhereWithoutTenantInput = {
    where: KegScalarWhereInput
    data: XOR<KegUpdateManyMutationInput, KegUncheckedUpdateManyWithoutTenantInput>
  }

  export type KegScalarWhereInput = {
    AND?: KegScalarWhereInput | KegScalarWhereInput[]
    OR?: KegScalarWhereInput[]
    NOT?: KegScalarWhereInput | KegScalarWhereInput[]
    id?: StringFilter<"Keg"> | string
    tenantId?: StringFilter<"Keg"> | string
    kegNumber?: StringFilter<"Keg"> | string
    size?: IntFilter<"Keg"> | number
    status?: EnumKegStatusFilter<"Keg"> | $Enums.KegStatus
    condition?: EnumKegConditionFilter<"Keg"> | $Enums.KegCondition
    batchId?: StringNullableFilter<"Keg"> | string | null
    filledAt?: DateTimeNullableFilter<"Keg"> | Date | string | null
    productName?: StringNullableFilter<"Keg"> | string | null
    lotNumber?: StringNullableFilter<"Keg"> | string | null
    customerId?: StringNullableFilter<"Keg"> | string | null
    orderId?: StringNullableFilter<"Keg"> | string | null
    sentAt?: DateTimeNullableFilter<"Keg"> | Date | string | null
    returnedAt?: DateTimeNullableFilter<"Keg"> | Date | string | null
    deposit?: DecimalFilter<"Keg"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Keg"> | string | null
    createdAt?: DateTimeFilter<"Keg"> | Date | string
    updatedAt?: DateTimeFilter<"Keg"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutTenantInput, PaymentUncheckedUpdateWithoutTenantInput>
    create: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutTenantInput, PaymentUncheckedUpdateWithoutTenantInput>
  }

  export type PaymentUpdateManyWithWhereWithoutTenantInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutTenantInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    tenantId?: StringFilter<"Payment"> | string
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    orderId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    date?: DateTimeFilter<"Payment"> | Date | string
    reference?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    createdBy?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type RecipeUpsertWithWhereUniqueWithoutTenantInput = {
    where: RecipeWhereUniqueInput
    update: XOR<RecipeUpdateWithoutTenantInput, RecipeUncheckedUpdateWithoutTenantInput>
    create: XOR<RecipeCreateWithoutTenantInput, RecipeUncheckedCreateWithoutTenantInput>
  }

  export type RecipeUpdateWithWhereUniqueWithoutTenantInput = {
    where: RecipeWhereUniqueInput
    data: XOR<RecipeUpdateWithoutTenantInput, RecipeUncheckedUpdateWithoutTenantInput>
  }

  export type RecipeUpdateManyWithWhereWithoutTenantInput = {
    where: RecipeScalarWhereInput
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyWithoutTenantInput>
  }

  export type RecipeScalarWhereInput = {
    AND?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
    OR?: RecipeScalarWhereInput[]
    NOT?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
    id?: StringFilter<"Recipe"> | string
    tenantId?: StringFilter<"Recipe"> | string
    createdBy?: StringNullableFilter<"Recipe"> | string | null
    name?: StringFilter<"Recipe"> | string
    style?: StringNullableFilter<"Recipe"> | string | null
    abv?: DecimalNullableFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    ibu?: IntNullableFilter<"Recipe"> | number | null
    color?: IntNullableFilter<"Recipe"> | number | null
    og?: DecimalNullableFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    fg?: DecimalNullableFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    batchSize?: DecimalNullableFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    boilTime?: IntNullableFilter<"Recipe"> | number | null
    efficiency?: DecimalNullableFilter<"Recipe"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"Recipe"> | string | null
    notes?: StringNullableFilter<"Recipe"> | string | null
    process?: JsonNullableFilter<"Recipe">
    status?: EnumRecipeStatusFilter<"Recipe"> | $Enums.RecipeStatus
    isActive?: BoolFilter<"Recipe"> | boolean
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeFilter<"Recipe"> | Date | string
    yeastStrain?: StringNullableFilter<"Recipe"> | string | null
  }

  export type SalesOrderUpsertWithWhereUniqueWithoutTenantInput = {
    where: SalesOrderWhereUniqueInput
    update: XOR<SalesOrderUpdateWithoutTenantInput, SalesOrderUncheckedUpdateWithoutTenantInput>
    create: XOR<SalesOrderCreateWithoutTenantInput, SalesOrderUncheckedCreateWithoutTenantInput>
  }

  export type SalesOrderUpdateWithWhereUniqueWithoutTenantInput = {
    where: SalesOrderWhereUniqueInput
    data: XOR<SalesOrderUpdateWithoutTenantInput, SalesOrderUncheckedUpdateWithoutTenantInput>
  }

  export type SalesOrderUpdateManyWithWhereWithoutTenantInput = {
    where: SalesOrderScalarWhereInput
    data: XOR<SalesOrderUpdateManyMutationInput, SalesOrderUncheckedUpdateManyWithoutTenantInput>
  }

  export type SalesOrderScalarWhereInput = {
    AND?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
    OR?: SalesOrderScalarWhereInput[]
    NOT?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
    id?: StringFilter<"SalesOrder"> | string
    tenantId?: StringFilter<"SalesOrder"> | string
    orderNumber?: StringFilter<"SalesOrder"> | string
    customerId?: StringFilter<"SalesOrder"> | string
    status?: EnumOrderStatusFilter<"SalesOrder"> | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFilter<"SalesOrder"> | $Enums.PaymentStatus
    totalAmount?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"SalesOrder"> | string | null
    orderedAt?: DateTimeFilter<"SalesOrder"> | Date | string
    shippedAt?: DateTimeNullableFilter<"SalesOrder"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"SalesOrder"> | Date | string | null
    createdBy?: StringFilter<"SalesOrder"> | string
    updatedAt?: DateTimeFilter<"SalesOrder"> | Date | string
  }

  export type SupplierUpsertWithWhereUniqueWithoutTenantInput = {
    where: SupplierWhereUniqueInput
    update: XOR<SupplierUpdateWithoutTenantInput, SupplierUncheckedUpdateWithoutTenantInput>
    create: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput>
  }

  export type SupplierUpdateWithWhereUniqueWithoutTenantInput = {
    where: SupplierWhereUniqueInput
    data: XOR<SupplierUpdateWithoutTenantInput, SupplierUncheckedUpdateWithoutTenantInput>
  }

  export type SupplierUpdateManyWithWhereWithoutTenantInput = {
    where: SupplierScalarWhereInput
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyWithoutTenantInput>
  }

  export type SupplierScalarWhereInput = {
    AND?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    OR?: SupplierScalarWhereInput[]
    NOT?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    id?: StringFilter<"Supplier"> | string
    tenantId?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    category?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    city?: StringNullableFilter<"Supplier"> | string | null
    taxId?: StringNullableFilter<"Supplier"> | string | null
    bankAccount?: StringNullableFilter<"Supplier"> | string | null
    notes?: StringNullableFilter<"Supplier"> | string | null
    isActive?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
  }

  export type TankUpsertWithWhereUniqueWithoutTenantInput = {
    where: TankWhereUniqueInput
    update: XOR<TankUpdateWithoutTenantInput, TankUncheckedUpdateWithoutTenantInput>
    create: XOR<TankCreateWithoutTenantInput, TankUncheckedCreateWithoutTenantInput>
  }

  export type TankUpdateWithWhereUniqueWithoutTenantInput = {
    where: TankWhereUniqueInput
    data: XOR<TankUpdateWithoutTenantInput, TankUncheckedUpdateWithoutTenantInput>
  }

  export type TankUpdateManyWithWhereWithoutTenantInput = {
    where: TankScalarWhereInput
    data: XOR<TankUpdateManyMutationInput, TankUncheckedUpdateManyWithoutTenantInput>
  }

  export type TankScalarWhereInput = {
    AND?: TankScalarWhereInput | TankScalarWhereInput[]
    OR?: TankScalarWhereInput[]
    NOT?: TankScalarWhereInput | TankScalarWhereInput[]
    id?: StringFilter<"Tank"> | string
    tenantId?: StringFilter<"Tank"> | string
    name?: StringFilter<"Tank"> | string
    type?: EnumTankTypeFilter<"Tank"> | $Enums.TankType
    capacity?: DecimalFilter<"Tank"> | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFilter<"Tank"> | $Enums.TankStatus
    currentBatchId?: StringNullableFilter<"Tank"> | string | null
    location?: StringNullableFilter<"Tank"> | string | null
    version?: IntFilter<"Tank"> | number
    createdAt?: DateTimeFilter<"Tank"> | Date | string
    updatedAt?: DateTimeFilter<"Tank"> | Date | string
    capabilities?: EnumTankCapabilityNullableListFilter<"Tank">
    currentLotId?: StringNullableFilter<"Tank"> | string | null
    currentPhase?: EnumLotPhaseNullableFilter<"Tank"> | $Enums.LotPhase | null
    defaultTurnaroundHours?: IntNullableFilter<"Tank"> | number | null
    maxFillPercent?: IntNullableFilter<"Tank"> | number | null
    minFillPercent?: IntNullableFilter<"Tank"> | number | null
  }

  export type TransactionUpsertWithWhereUniqueWithoutTenantInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutTenantInput, TransactionUncheckedUpdateWithoutTenantInput>
    create: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutTenantInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutTenantInput, TransactionUncheckedUpdateWithoutTenantInput>
  }

  export type TransactionUpdateManyWithWhereWithoutTenantInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTenantInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    tenantId?: StringFilter<"Transaction"> | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    date?: DateTimeFilter<"Transaction"> | Date | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    incomeCategory?: EnumIncomeCategoryNullableFilter<"Transaction"> | $Enums.IncomeCategory | null
    expenseCategory?: EnumExpenseCategoryNullableFilter<"Transaction"> | $Enums.ExpenseCategory | null
    description?: StringNullableFilter<"Transaction"> | string | null
    customerId?: StringNullableFilter<"Transaction"> | string | null
    supplierId?: StringNullableFilter<"Transaction"> | string | null
    orderId?: StringNullableFilter<"Transaction"> | string | null
    invoiceId?: StringNullableFilter<"Transaction"> | string | null
    expenseId?: StringNullableFilter<"Transaction"> | string | null
    paymentId?: StringNullableFilter<"Transaction"> | string | null
    paymentMethod?: EnumPaymentMethodNullableFilter<"Transaction"> | $Enums.PaymentMethod | null
    reference?: StringNullableFilter<"Transaction"> | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    createdBy?: StringFilter<"Transaction"> | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    password?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchCreateNestedManyWithoutTenantInput
    budgets?: BudgetCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    Keg?: KegCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    recipes?: RecipeCreateNestedManyWithoutTenantInput
    orders?: SalesOrderCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    tanks?: TankCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchUncheckedCreateNestedManyWithoutTenantInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    Keg?: KegUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutTenantInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    tanks?: TankUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    Keg?: KegUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    tanks?: TankUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUncheckedUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    Keg?: KegUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    tanks?: TankUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type BatchCreateWithoutRecipeInput = {
    id?: string
    batchNumber: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    tank?: TankCreateNestedOneWithoutBatchesInput
    tenant: TenantCreateNestedOneWithoutBatchesInput
    ingredients?: BatchIngredientCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerCreateNestedManyWithoutBatchInput
    Keg?: KegCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunCreateNestedManyWithoutBatchInput
    QCTest?: QCTestCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutRecipeInput = {
    id?: string
    tenantId: string
    batchNumber: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    tankId?: string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    ingredients?: BatchIngredientUncheckedCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineUncheckedCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingUncheckedCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerUncheckedCreateNestedManyWithoutBatchInput
    Keg?: KegUncheckedCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchUncheckedCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunUncheckedCreateNestedManyWithoutBatchInput
    QCTest?: QCTestUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutRecipeInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutRecipeInput, BatchUncheckedCreateWithoutRecipeInput>
  }

  export type BatchCreateManyRecipeInputEnvelope = {
    data: BatchCreateManyRecipeInput | BatchCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutRecipesInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchCreateNestedManyWithoutTenantInput
    budgets?: BudgetCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    Keg?: KegCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    orders?: SalesOrderCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    tanks?: TankCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutRecipesInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchUncheckedCreateNestedManyWithoutTenantInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    Keg?: KegUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    tanks?: TankUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutRecipesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutRecipesInput, TenantUncheckedCreateWithoutRecipesInput>
  }

  export type RecipeIngredientCreateWithoutRecipeInput = {
    id?: string
    name: string
    category: $Enums.IngredientCategory
    amount: Decimal | DecimalJsLike | number | string
    unit: string
    additionTime?: number | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventoryItem?: InventoryItemCreateNestedOneWithoutRecipeIngredientsInput
  }

  export type RecipeIngredientUncheckedCreateWithoutRecipeInput = {
    id?: string
    inventoryItemId?: string | null
    name: string
    category: $Enums.IngredientCategory
    amount: Decimal | DecimalJsLike | number | string
    unit: string
    additionTime?: number | null
    specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RecipeIngredientCreateOrConnectWithoutRecipeInput = {
    where: RecipeIngredientWhereUniqueInput
    create: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeIngredientCreateManyRecipeInputEnvelope = {
    data: RecipeIngredientCreateManyRecipeInput | RecipeIngredientCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type BatchUpsertWithWhereUniqueWithoutRecipeInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutRecipeInput, BatchUncheckedUpdateWithoutRecipeInput>
    create: XOR<BatchCreateWithoutRecipeInput, BatchUncheckedCreateWithoutRecipeInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutRecipeInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutRecipeInput, BatchUncheckedUpdateWithoutRecipeInput>
  }

  export type BatchUpdateManyWithWhereWithoutRecipeInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutRecipeInput>
  }

  export type TenantUpsertWithoutRecipesInput = {
    update: XOR<TenantUpdateWithoutRecipesInput, TenantUncheckedUpdateWithoutRecipesInput>
    create: XOR<TenantCreateWithoutRecipesInput, TenantUncheckedCreateWithoutRecipesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutRecipesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutRecipesInput, TenantUncheckedUpdateWithoutRecipesInput>
  }

  export type TenantUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    Keg?: KegUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    tanks?: TankUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUncheckedUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    Keg?: KegUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    tanks?: TankUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput = {
    where: RecipeIngredientWhereUniqueInput
    update: XOR<RecipeIngredientUpdateWithoutRecipeInput, RecipeIngredientUncheckedUpdateWithoutRecipeInput>
    create: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput = {
    where: RecipeIngredientWhereUniqueInput
    data: XOR<RecipeIngredientUpdateWithoutRecipeInput, RecipeIngredientUncheckedUpdateWithoutRecipeInput>
  }

  export type RecipeIngredientUpdateManyWithWhereWithoutRecipeInput = {
    where: RecipeIngredientScalarWhereInput
    data: XOR<RecipeIngredientUpdateManyMutationInput, RecipeIngredientUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeIngredientScalarWhereInput = {
    AND?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
    OR?: RecipeIngredientScalarWhereInput[]
    NOT?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
    id?: StringFilter<"RecipeIngredient"> | string
    recipeId?: StringFilter<"RecipeIngredient"> | string
    inventoryItemId?: StringNullableFilter<"RecipeIngredient"> | string | null
    name?: StringFilter<"RecipeIngredient"> | string
    category?: EnumIngredientCategoryFilter<"RecipeIngredient"> | $Enums.IngredientCategory
    amount?: DecimalFilter<"RecipeIngredient"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"RecipeIngredient"> | string
    additionTime?: IntNullableFilter<"RecipeIngredient"> | number | null
    specs?: JsonNullableFilter<"RecipeIngredient">
  }

  export type InventoryItemCreateWithoutRecipeIngredientsInput = {
    id?: string
    sku: string
    name: string
    category?: $Enums.InventoryCategory
    ingredientType?: string | null
    unit?: string
    reorderPoint?: Decimal | DecimalJsLike | number | string | null
    supplier?: string | null
    location?: string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: Decimal | DecimalJsLike | number | string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInventoryInput
    ledger?: InventoryLedgerCreateNestedManyWithoutItemInput
  }

  export type InventoryItemUncheckedCreateWithoutRecipeIngredientsInput = {
    id?: string
    tenantId: string
    sku: string
    name: string
    category?: $Enums.InventoryCategory
    ingredientType?: string | null
    unit?: string
    reorderPoint?: Decimal | DecimalJsLike | number | string | null
    supplier?: string | null
    location?: string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: Decimal | DecimalJsLike | number | string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ledger?: InventoryLedgerUncheckedCreateNestedManyWithoutItemInput
  }

  export type InventoryItemCreateOrConnectWithoutRecipeIngredientsInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutRecipeIngredientsInput, InventoryItemUncheckedCreateWithoutRecipeIngredientsInput>
  }

  export type RecipeCreateWithoutIngredientsInput = {
    id?: string
    createdBy?: string | null
    name: string
    style?: string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    ibu?: number | null
    color?: number | null
    og?: Decimal | DecimalJsLike | number | string | null
    fg?: Decimal | DecimalJsLike | number | string | null
    batchSize?: Decimal | DecimalJsLike | number | string | null
    boilTime?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    notes?: string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.RecipeStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    yeastStrain?: string | null
    batches?: BatchCreateNestedManyWithoutRecipeInput
    tenant: TenantCreateNestedOneWithoutRecipesInput
  }

  export type RecipeUncheckedCreateWithoutIngredientsInput = {
    id?: string
    tenantId: string
    createdBy?: string | null
    name: string
    style?: string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    ibu?: number | null
    color?: number | null
    og?: Decimal | DecimalJsLike | number | string | null
    fg?: Decimal | DecimalJsLike | number | string | null
    batchSize?: Decimal | DecimalJsLike | number | string | null
    boilTime?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    notes?: string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.RecipeStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    yeastStrain?: string | null
    batches?: BatchUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutIngredientsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutIngredientsInput, RecipeUncheckedCreateWithoutIngredientsInput>
  }

  export type InventoryItemUpsertWithoutRecipeIngredientsInput = {
    update: XOR<InventoryItemUpdateWithoutRecipeIngredientsInput, InventoryItemUncheckedUpdateWithoutRecipeIngredientsInput>
    create: XOR<InventoryItemCreateWithoutRecipeIngredientsInput, InventoryItemUncheckedCreateWithoutRecipeIngredientsInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutRecipeIngredientsInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutRecipeIngredientsInput, InventoryItemUncheckedUpdateWithoutRecipeIngredientsInput>
  }

  export type InventoryItemUpdateWithoutRecipeIngredientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    ingredientType?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderPoint?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInventoryNestedInput
    ledger?: InventoryLedgerUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutRecipeIngredientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    ingredientType?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderPoint?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledger?: InventoryLedgerUncheckedUpdateManyWithoutItemNestedInput
  }

  export type RecipeUpsertWithoutIngredientsInput = {
    update: XOR<RecipeUpdateWithoutIngredientsInput, RecipeUncheckedUpdateWithoutIngredientsInput>
    create: XOR<RecipeCreateWithoutIngredientsInput, RecipeUncheckedCreateWithoutIngredientsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutIngredientsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutIngredientsInput, RecipeUncheckedUpdateWithoutIngredientsInput>
  }

  export type RecipeUpdateWithoutIngredientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    style?: NullableStringFieldUpdateOperationsInput | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ibu?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableIntFieldUpdateOperationsInput | number | null
    og?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    batchSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boilTime?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumRecipeStatusFieldUpdateOperationsInput | $Enums.RecipeStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yeastStrain?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUpdateManyWithoutRecipeNestedInput
    tenant?: TenantUpdateOneRequiredWithoutRecipesNestedInput
  }

  export type RecipeUncheckedUpdateWithoutIngredientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    style?: NullableStringFieldUpdateOperationsInput | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ibu?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableIntFieldUpdateOperationsInput | number | null
    og?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    batchSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boilTime?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumRecipeStatusFieldUpdateOperationsInput | $Enums.RecipeStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yeastStrain?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type TenantCreateWithoutInventoryInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchCreateNestedManyWithoutTenantInput
    budgets?: BudgetCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    Keg?: KegCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    recipes?: RecipeCreateNestedManyWithoutTenantInput
    orders?: SalesOrderCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    tanks?: TankCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInventoryInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchUncheckedCreateNestedManyWithoutTenantInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    Keg?: KegUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutTenantInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    tanks?: TankUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInventoryInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInventoryInput, TenantUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryLedgerCreateWithoutItemInput = {
    id?: string
    tenantId: string
    quantity: Decimal | DecimalJsLike | number | string
    type: $Enums.LedgerEntryType
    orderId?: string | null
    packagingId?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    batch?: BatchCreateNestedOneWithoutLedgerEntriesInput
  }

  export type InventoryLedgerUncheckedCreateWithoutItemInput = {
    id?: string
    tenantId: string
    quantity: Decimal | DecimalJsLike | number | string
    type: $Enums.LedgerEntryType
    batchId?: string | null
    orderId?: string | null
    packagingId?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type InventoryLedgerCreateOrConnectWithoutItemInput = {
    where: InventoryLedgerWhereUniqueInput
    create: XOR<InventoryLedgerCreateWithoutItemInput, InventoryLedgerUncheckedCreateWithoutItemInput>
  }

  export type InventoryLedgerCreateManyItemInputEnvelope = {
    data: InventoryLedgerCreateManyItemInput | InventoryLedgerCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type RecipeIngredientCreateWithoutInventoryItemInput = {
    id?: string
    name: string
    category: $Enums.IngredientCategory
    amount: Decimal | DecimalJsLike | number | string
    unit: string
    additionTime?: number | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    recipe: RecipeCreateNestedOneWithoutIngredientsInput
  }

  export type RecipeIngredientUncheckedCreateWithoutInventoryItemInput = {
    id?: string
    recipeId: string
    name: string
    category: $Enums.IngredientCategory
    amount: Decimal | DecimalJsLike | number | string
    unit: string
    additionTime?: number | null
    specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RecipeIngredientCreateOrConnectWithoutInventoryItemInput = {
    where: RecipeIngredientWhereUniqueInput
    create: XOR<RecipeIngredientCreateWithoutInventoryItemInput, RecipeIngredientUncheckedCreateWithoutInventoryItemInput>
  }

  export type RecipeIngredientCreateManyInventoryItemInputEnvelope = {
    data: RecipeIngredientCreateManyInventoryItemInput | RecipeIngredientCreateManyInventoryItemInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutInventoryInput = {
    update: XOR<TenantUpdateWithoutInventoryInput, TenantUncheckedUpdateWithoutInventoryInput>
    create: XOR<TenantCreateWithoutInventoryInput, TenantUncheckedCreateWithoutInventoryInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInventoryInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInventoryInput, TenantUncheckedUpdateWithoutInventoryInput>
  }

  export type TenantUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    Keg?: KegUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    tanks?: TankUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUncheckedUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    Keg?: KegUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    tanks?: TankUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type InventoryLedgerUpsertWithWhereUniqueWithoutItemInput = {
    where: InventoryLedgerWhereUniqueInput
    update: XOR<InventoryLedgerUpdateWithoutItemInput, InventoryLedgerUncheckedUpdateWithoutItemInput>
    create: XOR<InventoryLedgerCreateWithoutItemInput, InventoryLedgerUncheckedCreateWithoutItemInput>
  }

  export type InventoryLedgerUpdateWithWhereUniqueWithoutItemInput = {
    where: InventoryLedgerWhereUniqueInput
    data: XOR<InventoryLedgerUpdateWithoutItemInput, InventoryLedgerUncheckedUpdateWithoutItemInput>
  }

  export type InventoryLedgerUpdateManyWithWhereWithoutItemInput = {
    where: InventoryLedgerScalarWhereInput
    data: XOR<InventoryLedgerUpdateManyMutationInput, InventoryLedgerUncheckedUpdateManyWithoutItemInput>
  }

  export type InventoryLedgerScalarWhereInput = {
    AND?: InventoryLedgerScalarWhereInput | InventoryLedgerScalarWhereInput[]
    OR?: InventoryLedgerScalarWhereInput[]
    NOT?: InventoryLedgerScalarWhereInput | InventoryLedgerScalarWhereInput[]
    id?: StringFilter<"InventoryLedger"> | string
    tenantId?: StringFilter<"InventoryLedger"> | string
    itemId?: StringFilter<"InventoryLedger"> | string
    quantity?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    type?: EnumLedgerEntryTypeFilter<"InventoryLedger"> | $Enums.LedgerEntryType
    batchId?: StringNullableFilter<"InventoryLedger"> | string | null
    orderId?: StringNullableFilter<"InventoryLedger"> | string | null
    packagingId?: StringNullableFilter<"InventoryLedger"> | string | null
    notes?: StringNullableFilter<"InventoryLedger"> | string | null
    createdBy?: StringFilter<"InventoryLedger"> | string
    createdAt?: DateTimeFilter<"InventoryLedger"> | Date | string
  }

  export type RecipeIngredientUpsertWithWhereUniqueWithoutInventoryItemInput = {
    where: RecipeIngredientWhereUniqueInput
    update: XOR<RecipeIngredientUpdateWithoutInventoryItemInput, RecipeIngredientUncheckedUpdateWithoutInventoryItemInput>
    create: XOR<RecipeIngredientCreateWithoutInventoryItemInput, RecipeIngredientUncheckedCreateWithoutInventoryItemInput>
  }

  export type RecipeIngredientUpdateWithWhereUniqueWithoutInventoryItemInput = {
    where: RecipeIngredientWhereUniqueInput
    data: XOR<RecipeIngredientUpdateWithoutInventoryItemInput, RecipeIngredientUncheckedUpdateWithoutInventoryItemInput>
  }

  export type RecipeIngredientUpdateManyWithWhereWithoutInventoryItemInput = {
    where: RecipeIngredientScalarWhereInput
    data: XOR<RecipeIngredientUpdateManyMutationInput, RecipeIngredientUncheckedUpdateManyWithoutInventoryItemInput>
  }

  export type BatchCreateWithoutLedgerEntriesInput = {
    id?: string
    batchNumber: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    recipe: RecipeCreateNestedOneWithoutBatchesInput
    tank?: TankCreateNestedOneWithoutBatchesInput
    tenant: TenantCreateNestedOneWithoutBatchesInput
    ingredients?: BatchIngredientCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingCreateNestedManyWithoutBatchInput
    Keg?: KegCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunCreateNestedManyWithoutBatchInput
    QCTest?: QCTestCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutLedgerEntriesInput = {
    id?: string
    tenantId: string
    batchNumber: string
    recipeId: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    tankId?: string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    ingredients?: BatchIngredientUncheckedCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineUncheckedCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingUncheckedCreateNestedManyWithoutBatchInput
    Keg?: KegUncheckedCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchUncheckedCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunUncheckedCreateNestedManyWithoutBatchInput
    QCTest?: QCTestUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutLedgerEntriesInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutLedgerEntriesInput, BatchUncheckedCreateWithoutLedgerEntriesInput>
  }

  export type InventoryItemCreateWithoutLedgerInput = {
    id?: string
    sku: string
    name: string
    category?: $Enums.InventoryCategory
    ingredientType?: string | null
    unit?: string
    reorderPoint?: Decimal | DecimalJsLike | number | string | null
    supplier?: string | null
    location?: string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: Decimal | DecimalJsLike | number | string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInventoryInput
    recipeIngredients?: RecipeIngredientCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemUncheckedCreateWithoutLedgerInput = {
    id?: string
    tenantId: string
    sku: string
    name: string
    category?: $Enums.InventoryCategory
    ingredientType?: string | null
    unit?: string
    reorderPoint?: Decimal | DecimalJsLike | number | string | null
    supplier?: string | null
    location?: string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: Decimal | DecimalJsLike | number | string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recipeIngredients?: RecipeIngredientUncheckedCreateNestedManyWithoutInventoryItemInput
  }

  export type InventoryItemCreateOrConnectWithoutLedgerInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutLedgerInput, InventoryItemUncheckedCreateWithoutLedgerInput>
  }

  export type BatchUpsertWithoutLedgerEntriesInput = {
    update: XOR<BatchUpdateWithoutLedgerEntriesInput, BatchUncheckedUpdateWithoutLedgerEntriesInput>
    create: XOR<BatchCreateWithoutLedgerEntriesInput, BatchUncheckedCreateWithoutLedgerEntriesInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutLedgerEntriesInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutLedgerEntriesInput, BatchUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type BatchUpdateWithoutLedgerEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    recipe?: RecipeUpdateOneRequiredWithoutBatchesNestedInput
    tank?: TankUpdateOneWithoutBatchesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutBatchesNestedInput
    ingredients?: BatchIngredientUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUpdateManyWithoutBatchNestedInput
    Keg?: KegUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutLedgerEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tankId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: BatchIngredientUncheckedUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUncheckedUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUncheckedUpdateManyWithoutBatchNestedInput
    Keg?: KegUncheckedUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUncheckedUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUncheckedUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type InventoryItemUpsertWithoutLedgerInput = {
    update: XOR<InventoryItemUpdateWithoutLedgerInput, InventoryItemUncheckedUpdateWithoutLedgerInput>
    create: XOR<InventoryItemCreateWithoutLedgerInput, InventoryItemUncheckedCreateWithoutLedgerInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutLedgerInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutLedgerInput, InventoryItemUncheckedUpdateWithoutLedgerInput>
  }

  export type InventoryItemUpdateWithoutLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    ingredientType?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderPoint?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInventoryNestedInput
    recipeIngredients?: RecipeIngredientUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    ingredientType?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderPoint?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipeIngredients?: RecipeIngredientUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type RecipeCreateWithoutBatchesInput = {
    id?: string
    createdBy?: string | null
    name: string
    style?: string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    ibu?: number | null
    color?: number | null
    og?: Decimal | DecimalJsLike | number | string | null
    fg?: Decimal | DecimalJsLike | number | string | null
    batchSize?: Decimal | DecimalJsLike | number | string | null
    boilTime?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    notes?: string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.RecipeStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    yeastStrain?: string | null
    tenant: TenantCreateNestedOneWithoutRecipesInput
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutBatchesInput = {
    id?: string
    tenantId: string
    createdBy?: string | null
    name: string
    style?: string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    ibu?: number | null
    color?: number | null
    og?: Decimal | DecimalJsLike | number | string | null
    fg?: Decimal | DecimalJsLike | number | string | null
    batchSize?: Decimal | DecimalJsLike | number | string | null
    boilTime?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    notes?: string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.RecipeStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    yeastStrain?: string | null
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutBatchesInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutBatchesInput, RecipeUncheckedCreateWithoutBatchesInput>
  }

  export type TankCreateWithoutBatchesInput = {
    id?: string
    name: string
    type: $Enums.TankType
    capacity: Decimal | DecimalJsLike | number | string
    status?: $Enums.TankStatus
    currentBatchId?: string | null
    location?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: TankCreatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: string | null
    currentPhase?: $Enums.LotPhase | null
    defaultTurnaroundHours?: number | null
    maxFillPercent?: number | null
    minFillPercent?: number | null
    LotReading?: LotReadingCreateNestedManyWithoutTankInput
    tenant: TenantCreateNestedOneWithoutTanksInput
    TankAssignment?: TankAssignmentCreateNestedManyWithoutTankInput
    occupations?: TankOccupationCreateNestedManyWithoutTankInput
    Transfer_Transfer_destTankIdToTank?: TransferCreateNestedManyWithoutTank_Transfer_destTankIdToTankInput
    Transfer_Transfer_sourceTankIdToTank?: TransferCreateNestedManyWithoutTank_Transfer_sourceTankIdToTankInput
  }

  export type TankUncheckedCreateWithoutBatchesInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.TankType
    capacity: Decimal | DecimalJsLike | number | string
    status?: $Enums.TankStatus
    currentBatchId?: string | null
    location?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: TankCreatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: string | null
    currentPhase?: $Enums.LotPhase | null
    defaultTurnaroundHours?: number | null
    maxFillPercent?: number | null
    minFillPercent?: number | null
    LotReading?: LotReadingUncheckedCreateNestedManyWithoutTankInput
    TankAssignment?: TankAssignmentUncheckedCreateNestedManyWithoutTankInput
    occupations?: TankOccupationUncheckedCreateNestedManyWithoutTankInput
    Transfer_Transfer_destTankIdToTank?: TransferUncheckedCreateNestedManyWithoutTank_Transfer_destTankIdToTankInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUncheckedCreateNestedManyWithoutTank_Transfer_sourceTankIdToTankInput
  }

  export type TankCreateOrConnectWithoutBatchesInput = {
    where: TankWhereUniqueInput
    create: XOR<TankCreateWithoutBatchesInput, TankUncheckedCreateWithoutBatchesInput>
  }

  export type TenantCreateWithoutBatchesInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    budgets?: BudgetCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    Keg?: KegCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    recipes?: RecipeCreateNestedManyWithoutTenantInput
    orders?: SalesOrderCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    tanks?: TankCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutBatchesInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    budgets?: BudgetUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    Keg?: KegUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutTenantInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    tanks?: TankUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutBatchesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutBatchesInput, TenantUncheckedCreateWithoutBatchesInput>
  }

  export type BatchIngredientCreateWithoutBatchInput = {
    id?: string
    inventoryItemId?: string | null
    name: string
    category: $Enums.IngredientCategory
    plannedAmount: Decimal | DecimalJsLike | number | string
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    unit: string
    lotNumber?: string | null
    addedAt?: Date | string | null
  }

  export type BatchIngredientUncheckedCreateWithoutBatchInput = {
    id?: string
    inventoryItemId?: string | null
    name: string
    category: $Enums.IngredientCategory
    plannedAmount: Decimal | DecimalJsLike | number | string
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    unit: string
    lotNumber?: string | null
    addedAt?: Date | string | null
  }

  export type BatchIngredientCreateOrConnectWithoutBatchInput = {
    where: BatchIngredientWhereUniqueInput
    create: XOR<BatchIngredientCreateWithoutBatchInput, BatchIngredientUncheckedCreateWithoutBatchInput>
  }

  export type BatchIngredientCreateManyBatchInputEnvelope = {
    data: BatchIngredientCreateManyBatchInput | BatchIngredientCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type BatchTimelineCreateWithoutBatchInput = {
    id?: string
    type: $Enums.TimelineEventType
    title: string
    description?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
  }

  export type BatchTimelineUncheckedCreateWithoutBatchInput = {
    id?: string
    type: $Enums.TimelineEventType
    title: string
    description?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
  }

  export type BatchTimelineCreateOrConnectWithoutBatchInput = {
    where: BatchTimelineWhereUniqueInput
    create: XOR<BatchTimelineCreateWithoutBatchInput, BatchTimelineUncheckedCreateWithoutBatchInput>
  }

  export type BatchTimelineCreateManyBatchInputEnvelope = {
    data: BatchTimelineCreateManyBatchInput | BatchTimelineCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type GravityReadingCreateWithoutBatchInput = {
    id?: string
    gravity: Decimal | DecimalJsLike | number | string
    temperature: Decimal | DecimalJsLike | number | string
    notes?: string | null
    recordedBy: string
    recordedAt?: Date | string
  }

  export type GravityReadingUncheckedCreateWithoutBatchInput = {
    id?: string
    gravity: Decimal | DecimalJsLike | number | string
    temperature: Decimal | DecimalJsLike | number | string
    notes?: string | null
    recordedBy: string
    recordedAt?: Date | string
  }

  export type GravityReadingCreateOrConnectWithoutBatchInput = {
    where: GravityReadingWhereUniqueInput
    create: XOR<GravityReadingCreateWithoutBatchInput, GravityReadingUncheckedCreateWithoutBatchInput>
  }

  export type GravityReadingCreateManyBatchInputEnvelope = {
    data: GravityReadingCreateManyBatchInput | GravityReadingCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type InventoryLedgerCreateWithoutBatchInput = {
    id?: string
    tenantId: string
    quantity: Decimal | DecimalJsLike | number | string
    type: $Enums.LedgerEntryType
    orderId?: string | null
    packagingId?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    item: InventoryItemCreateNestedOneWithoutLedgerInput
  }

  export type InventoryLedgerUncheckedCreateWithoutBatchInput = {
    id?: string
    tenantId: string
    itemId: string
    quantity: Decimal | DecimalJsLike | number | string
    type: $Enums.LedgerEntryType
    orderId?: string | null
    packagingId?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type InventoryLedgerCreateOrConnectWithoutBatchInput = {
    where: InventoryLedgerWhereUniqueInput
    create: XOR<InventoryLedgerCreateWithoutBatchInput, InventoryLedgerUncheckedCreateWithoutBatchInput>
  }

  export type InventoryLedgerCreateManyBatchInputEnvelope = {
    data: InventoryLedgerCreateManyBatchInput | InventoryLedgerCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type KegCreateWithoutBatchInput = {
    id?: string
    kegNumber: string
    size: number
    status?: $Enums.KegStatus
    condition?: $Enums.KegCondition
    filledAt?: Date | string | null
    productName?: string | null
    lotNumber?: string | null
    orderId?: string | null
    sentAt?: Date | string | null
    returnedAt?: Date | string | null
    deposit?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Customer?: CustomerCreateNestedOneWithoutKegInput
    Tenant: TenantCreateNestedOneWithoutKegInput
    movements?: KegMovementCreateNestedManyWithoutKegInput
  }

  export type KegUncheckedCreateWithoutBatchInput = {
    id?: string
    tenantId: string
    kegNumber: string
    size: number
    status?: $Enums.KegStatus
    condition?: $Enums.KegCondition
    filledAt?: Date | string | null
    productName?: string | null
    lotNumber?: string | null
    customerId?: string | null
    orderId?: string | null
    sentAt?: Date | string | null
    returnedAt?: Date | string | null
    deposit?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movements?: KegMovementUncheckedCreateNestedManyWithoutKegInput
  }

  export type KegCreateOrConnectWithoutBatchInput = {
    where: KegWhereUniqueInput
    create: XOR<KegCreateWithoutBatchInput, KegUncheckedCreateWithoutBatchInput>
  }

  export type KegCreateManyBatchInputEnvelope = {
    data: KegCreateManyBatchInput | KegCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type LotBatchCreateWithoutBatchInput = {
    id: string
    volumeContribution: Decimal | DecimalJsLike | number | string
    batchPercentage?: Decimal | DecimalJsLike | number | string
    addedAt?: Date | string
    Lot: LotCreateNestedOneWithoutLotBatchInput
  }

  export type LotBatchUncheckedCreateWithoutBatchInput = {
    id: string
    lotId: string
    volumeContribution: Decimal | DecimalJsLike | number | string
    batchPercentage?: Decimal | DecimalJsLike | number | string
    addedAt?: Date | string
  }

  export type LotBatchCreateOrConnectWithoutBatchInput = {
    where: LotBatchWhereUniqueInput
    create: XOR<LotBatchCreateWithoutBatchInput, LotBatchUncheckedCreateWithoutBatchInput>
  }

  export type LotBatchCreateManyBatchInputEnvelope = {
    data: LotBatchCreateManyBatchInput | LotBatchCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type PackagingRunCreateWithoutBatchInput = {
    id?: string
    tenantId: string
    packageType: $Enums.PackageType
    quantity: number
    volumeTotal: Decimal | DecimalJsLike | number | string
    lotNumber?: string | null
    performedBy: string
    notes?: string | null
    performedAt?: Date | string
  }

  export type PackagingRunUncheckedCreateWithoutBatchInput = {
    id?: string
    tenantId: string
    packageType: $Enums.PackageType
    quantity: number
    volumeTotal: Decimal | DecimalJsLike | number | string
    lotNumber?: string | null
    performedBy: string
    notes?: string | null
    performedAt?: Date | string
  }

  export type PackagingRunCreateOrConnectWithoutBatchInput = {
    where: PackagingRunWhereUniqueInput
    create: XOR<PackagingRunCreateWithoutBatchInput, PackagingRunUncheckedCreateWithoutBatchInput>
  }

  export type PackagingRunCreateManyBatchInputEnvelope = {
    data: PackagingRunCreateManyBatchInput | PackagingRunCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type QCTestCreateWithoutBatchInput = {
    id: string
    tenantId: string
    testType: $Enums.QCTestType
    status?: $Enums.QCTestStatus
    priority?: $Enums.QCTestPriority
    scheduledDate: Date | string
    completedDate?: Date | string | null
    minValue?: Decimal | DecimalJsLike | number | string | null
    maxValue?: Decimal | DecimalJsLike | number | string | null
    targetValue?: Decimal | DecimalJsLike | number | string | null
    result?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    performedBy?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
    Lot?: LotCreateNestedOneWithoutQCTestInput
  }

  export type QCTestUncheckedCreateWithoutBatchInput = {
    id: string
    tenantId: string
    lotId?: string | null
    testType: $Enums.QCTestType
    status?: $Enums.QCTestStatus
    priority?: $Enums.QCTestPriority
    scheduledDate: Date | string
    completedDate?: Date | string | null
    minValue?: Decimal | DecimalJsLike | number | string | null
    maxValue?: Decimal | DecimalJsLike | number | string | null
    targetValue?: Decimal | DecimalJsLike | number | string | null
    result?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    performedBy?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type QCTestCreateOrConnectWithoutBatchInput = {
    where: QCTestWhereUniqueInput
    create: XOR<QCTestCreateWithoutBatchInput, QCTestUncheckedCreateWithoutBatchInput>
  }

  export type QCTestCreateManyBatchInputEnvelope = {
    data: QCTestCreateManyBatchInput | QCTestCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type RecipeUpsertWithoutBatchesInput = {
    update: XOR<RecipeUpdateWithoutBatchesInput, RecipeUncheckedUpdateWithoutBatchesInput>
    create: XOR<RecipeCreateWithoutBatchesInput, RecipeUncheckedCreateWithoutBatchesInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutBatchesInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutBatchesInput, RecipeUncheckedUpdateWithoutBatchesInput>
  }

  export type RecipeUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    style?: NullableStringFieldUpdateOperationsInput | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ibu?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableIntFieldUpdateOperationsInput | number | null
    og?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    batchSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boilTime?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumRecipeStatusFieldUpdateOperationsInput | $Enums.RecipeStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yeastStrain?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutRecipesNestedInput
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    style?: NullableStringFieldUpdateOperationsInput | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ibu?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableIntFieldUpdateOperationsInput | number | null
    og?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    batchSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boilTime?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumRecipeStatusFieldUpdateOperationsInput | $Enums.RecipeStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yeastStrain?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type TankUpsertWithoutBatchesInput = {
    update: XOR<TankUpdateWithoutBatchesInput, TankUncheckedUpdateWithoutBatchesInput>
    create: XOR<TankCreateWithoutBatchesInput, TankUncheckedCreateWithoutBatchesInput>
    where?: TankWhereInput
  }

  export type TankUpdateToOneWithWhereWithoutBatchesInput = {
    where?: TankWhereInput
    data: XOR<TankUpdateWithoutBatchesInput, TankUncheckedUpdateWithoutBatchesInput>
  }

  export type TankUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTankTypeFieldUpdateOperationsInput | $Enums.TankType
    capacity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFieldUpdateOperationsInput | $Enums.TankStatus
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: TankUpdatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPhase?: NullableEnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase | null
    defaultTurnaroundHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    minFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    LotReading?: LotReadingUpdateManyWithoutTankNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTanksNestedInput
    TankAssignment?: TankAssignmentUpdateManyWithoutTankNestedInput
    occupations?: TankOccupationUpdateManyWithoutTankNestedInput
    Transfer_Transfer_destTankIdToTank?: TransferUpdateManyWithoutTank_Transfer_destTankIdToTankNestedInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUpdateManyWithoutTank_Transfer_sourceTankIdToTankNestedInput
  }

  export type TankUncheckedUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTankTypeFieldUpdateOperationsInput | $Enums.TankType
    capacity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFieldUpdateOperationsInput | $Enums.TankStatus
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: TankUpdatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPhase?: NullableEnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase | null
    defaultTurnaroundHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    minFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    LotReading?: LotReadingUncheckedUpdateManyWithoutTankNestedInput
    TankAssignment?: TankAssignmentUncheckedUpdateManyWithoutTankNestedInput
    occupations?: TankOccupationUncheckedUpdateManyWithoutTankNestedInput
    Transfer_Transfer_destTankIdToTank?: TransferUncheckedUpdateManyWithoutTank_Transfer_destTankIdToTankNestedInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUncheckedUpdateManyWithoutTank_Transfer_sourceTankIdToTankNestedInput
  }

  export type TenantUpsertWithoutBatchesInput = {
    update: XOR<TenantUpdateWithoutBatchesInput, TenantUncheckedUpdateWithoutBatchesInput>
    create: XOR<TenantCreateWithoutBatchesInput, TenantUncheckedCreateWithoutBatchesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutBatchesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutBatchesInput, TenantUncheckedUpdateWithoutBatchesInput>
  }

  export type TenantUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    budgets?: BudgetUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    Keg?: KegUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    tanks?: TankUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    budgets?: BudgetUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    Keg?: KegUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    tanks?: TankUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type BatchIngredientUpsertWithWhereUniqueWithoutBatchInput = {
    where: BatchIngredientWhereUniqueInput
    update: XOR<BatchIngredientUpdateWithoutBatchInput, BatchIngredientUncheckedUpdateWithoutBatchInput>
    create: XOR<BatchIngredientCreateWithoutBatchInput, BatchIngredientUncheckedCreateWithoutBatchInput>
  }

  export type BatchIngredientUpdateWithWhereUniqueWithoutBatchInput = {
    where: BatchIngredientWhereUniqueInput
    data: XOR<BatchIngredientUpdateWithoutBatchInput, BatchIngredientUncheckedUpdateWithoutBatchInput>
  }

  export type BatchIngredientUpdateManyWithWhereWithoutBatchInput = {
    where: BatchIngredientScalarWhereInput
    data: XOR<BatchIngredientUpdateManyMutationInput, BatchIngredientUncheckedUpdateManyWithoutBatchInput>
  }

  export type BatchIngredientScalarWhereInput = {
    AND?: BatchIngredientScalarWhereInput | BatchIngredientScalarWhereInput[]
    OR?: BatchIngredientScalarWhereInput[]
    NOT?: BatchIngredientScalarWhereInput | BatchIngredientScalarWhereInput[]
    id?: StringFilter<"BatchIngredient"> | string
    batchId?: StringFilter<"BatchIngredient"> | string
    inventoryItemId?: StringNullableFilter<"BatchIngredient"> | string | null
    name?: StringFilter<"BatchIngredient"> | string
    category?: EnumIngredientCategoryFilter<"BatchIngredient"> | $Enums.IngredientCategory
    plannedAmount?: DecimalFilter<"BatchIngredient"> | Decimal | DecimalJsLike | number | string
    actualAmount?: DecimalNullableFilter<"BatchIngredient"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringFilter<"BatchIngredient"> | string
    lotNumber?: StringNullableFilter<"BatchIngredient"> | string | null
    addedAt?: DateTimeNullableFilter<"BatchIngredient"> | Date | string | null
  }

  export type BatchTimelineUpsertWithWhereUniqueWithoutBatchInput = {
    where: BatchTimelineWhereUniqueInput
    update: XOR<BatchTimelineUpdateWithoutBatchInput, BatchTimelineUncheckedUpdateWithoutBatchInput>
    create: XOR<BatchTimelineCreateWithoutBatchInput, BatchTimelineUncheckedCreateWithoutBatchInput>
  }

  export type BatchTimelineUpdateWithWhereUniqueWithoutBatchInput = {
    where: BatchTimelineWhereUniqueInput
    data: XOR<BatchTimelineUpdateWithoutBatchInput, BatchTimelineUncheckedUpdateWithoutBatchInput>
  }

  export type BatchTimelineUpdateManyWithWhereWithoutBatchInput = {
    where: BatchTimelineScalarWhereInput
    data: XOR<BatchTimelineUpdateManyMutationInput, BatchTimelineUncheckedUpdateManyWithoutBatchInput>
  }

  export type BatchTimelineScalarWhereInput = {
    AND?: BatchTimelineScalarWhereInput | BatchTimelineScalarWhereInput[]
    OR?: BatchTimelineScalarWhereInput[]
    NOT?: BatchTimelineScalarWhereInput | BatchTimelineScalarWhereInput[]
    id?: StringFilter<"BatchTimeline"> | string
    batchId?: StringFilter<"BatchTimeline"> | string
    type?: EnumTimelineEventTypeFilter<"BatchTimeline"> | $Enums.TimelineEventType
    title?: StringFilter<"BatchTimeline"> | string
    description?: StringNullableFilter<"BatchTimeline"> | string | null
    data?: JsonNullableFilter<"BatchTimeline">
    createdBy?: StringFilter<"BatchTimeline"> | string
    createdAt?: DateTimeFilter<"BatchTimeline"> | Date | string
  }

  export type GravityReadingUpsertWithWhereUniqueWithoutBatchInput = {
    where: GravityReadingWhereUniqueInput
    update: XOR<GravityReadingUpdateWithoutBatchInput, GravityReadingUncheckedUpdateWithoutBatchInput>
    create: XOR<GravityReadingCreateWithoutBatchInput, GravityReadingUncheckedCreateWithoutBatchInput>
  }

  export type GravityReadingUpdateWithWhereUniqueWithoutBatchInput = {
    where: GravityReadingWhereUniqueInput
    data: XOR<GravityReadingUpdateWithoutBatchInput, GravityReadingUncheckedUpdateWithoutBatchInput>
  }

  export type GravityReadingUpdateManyWithWhereWithoutBatchInput = {
    where: GravityReadingScalarWhereInput
    data: XOR<GravityReadingUpdateManyMutationInput, GravityReadingUncheckedUpdateManyWithoutBatchInput>
  }

  export type GravityReadingScalarWhereInput = {
    AND?: GravityReadingScalarWhereInput | GravityReadingScalarWhereInput[]
    OR?: GravityReadingScalarWhereInput[]
    NOT?: GravityReadingScalarWhereInput | GravityReadingScalarWhereInput[]
    id?: StringFilter<"GravityReading"> | string
    batchId?: StringFilter<"GravityReading"> | string
    gravity?: DecimalFilter<"GravityReading"> | Decimal | DecimalJsLike | number | string
    temperature?: DecimalFilter<"GravityReading"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"GravityReading"> | string | null
    recordedBy?: StringFilter<"GravityReading"> | string
    recordedAt?: DateTimeFilter<"GravityReading"> | Date | string
  }

  export type InventoryLedgerUpsertWithWhereUniqueWithoutBatchInput = {
    where: InventoryLedgerWhereUniqueInput
    update: XOR<InventoryLedgerUpdateWithoutBatchInput, InventoryLedgerUncheckedUpdateWithoutBatchInput>
    create: XOR<InventoryLedgerCreateWithoutBatchInput, InventoryLedgerUncheckedCreateWithoutBatchInput>
  }

  export type InventoryLedgerUpdateWithWhereUniqueWithoutBatchInput = {
    where: InventoryLedgerWhereUniqueInput
    data: XOR<InventoryLedgerUpdateWithoutBatchInput, InventoryLedgerUncheckedUpdateWithoutBatchInput>
  }

  export type InventoryLedgerUpdateManyWithWhereWithoutBatchInput = {
    where: InventoryLedgerScalarWhereInput
    data: XOR<InventoryLedgerUpdateManyMutationInput, InventoryLedgerUncheckedUpdateManyWithoutBatchInput>
  }

  export type KegUpsertWithWhereUniqueWithoutBatchInput = {
    where: KegWhereUniqueInput
    update: XOR<KegUpdateWithoutBatchInput, KegUncheckedUpdateWithoutBatchInput>
    create: XOR<KegCreateWithoutBatchInput, KegUncheckedCreateWithoutBatchInput>
  }

  export type KegUpdateWithWhereUniqueWithoutBatchInput = {
    where: KegWhereUniqueInput
    data: XOR<KegUpdateWithoutBatchInput, KegUncheckedUpdateWithoutBatchInput>
  }

  export type KegUpdateManyWithWhereWithoutBatchInput = {
    where: KegScalarWhereInput
    data: XOR<KegUpdateManyMutationInput, KegUncheckedUpdateManyWithoutBatchInput>
  }

  export type LotBatchUpsertWithWhereUniqueWithoutBatchInput = {
    where: LotBatchWhereUniqueInput
    update: XOR<LotBatchUpdateWithoutBatchInput, LotBatchUncheckedUpdateWithoutBatchInput>
    create: XOR<LotBatchCreateWithoutBatchInput, LotBatchUncheckedCreateWithoutBatchInput>
  }

  export type LotBatchUpdateWithWhereUniqueWithoutBatchInput = {
    where: LotBatchWhereUniqueInput
    data: XOR<LotBatchUpdateWithoutBatchInput, LotBatchUncheckedUpdateWithoutBatchInput>
  }

  export type LotBatchUpdateManyWithWhereWithoutBatchInput = {
    where: LotBatchScalarWhereInput
    data: XOR<LotBatchUpdateManyMutationInput, LotBatchUncheckedUpdateManyWithoutBatchInput>
  }

  export type LotBatchScalarWhereInput = {
    AND?: LotBatchScalarWhereInput | LotBatchScalarWhereInput[]
    OR?: LotBatchScalarWhereInput[]
    NOT?: LotBatchScalarWhereInput | LotBatchScalarWhereInput[]
    id?: StringFilter<"LotBatch"> | string
    lotId?: StringFilter<"LotBatch"> | string
    batchId?: StringFilter<"LotBatch"> | string
    volumeContribution?: DecimalFilter<"LotBatch"> | Decimal | DecimalJsLike | number | string
    batchPercentage?: DecimalFilter<"LotBatch"> | Decimal | DecimalJsLike | number | string
    addedAt?: DateTimeFilter<"LotBatch"> | Date | string
  }

  export type PackagingRunUpsertWithWhereUniqueWithoutBatchInput = {
    where: PackagingRunWhereUniqueInput
    update: XOR<PackagingRunUpdateWithoutBatchInput, PackagingRunUncheckedUpdateWithoutBatchInput>
    create: XOR<PackagingRunCreateWithoutBatchInput, PackagingRunUncheckedCreateWithoutBatchInput>
  }

  export type PackagingRunUpdateWithWhereUniqueWithoutBatchInput = {
    where: PackagingRunWhereUniqueInput
    data: XOR<PackagingRunUpdateWithoutBatchInput, PackagingRunUncheckedUpdateWithoutBatchInput>
  }

  export type PackagingRunUpdateManyWithWhereWithoutBatchInput = {
    where: PackagingRunScalarWhereInput
    data: XOR<PackagingRunUpdateManyMutationInput, PackagingRunUncheckedUpdateManyWithoutBatchInput>
  }

  export type PackagingRunScalarWhereInput = {
    AND?: PackagingRunScalarWhereInput | PackagingRunScalarWhereInput[]
    OR?: PackagingRunScalarWhereInput[]
    NOT?: PackagingRunScalarWhereInput | PackagingRunScalarWhereInput[]
    id?: StringFilter<"PackagingRun"> | string
    tenantId?: StringFilter<"PackagingRun"> | string
    batchId?: StringFilter<"PackagingRun"> | string
    packageType?: EnumPackageTypeFilter<"PackagingRun"> | $Enums.PackageType
    quantity?: IntFilter<"PackagingRun"> | number
    volumeTotal?: DecimalFilter<"PackagingRun"> | Decimal | DecimalJsLike | number | string
    lotNumber?: StringNullableFilter<"PackagingRun"> | string | null
    performedBy?: StringFilter<"PackagingRun"> | string
    notes?: StringNullableFilter<"PackagingRun"> | string | null
    performedAt?: DateTimeFilter<"PackagingRun"> | Date | string
  }

  export type QCTestUpsertWithWhereUniqueWithoutBatchInput = {
    where: QCTestWhereUniqueInput
    update: XOR<QCTestUpdateWithoutBatchInput, QCTestUncheckedUpdateWithoutBatchInput>
    create: XOR<QCTestCreateWithoutBatchInput, QCTestUncheckedCreateWithoutBatchInput>
  }

  export type QCTestUpdateWithWhereUniqueWithoutBatchInput = {
    where: QCTestWhereUniqueInput
    data: XOR<QCTestUpdateWithoutBatchInput, QCTestUncheckedUpdateWithoutBatchInput>
  }

  export type QCTestUpdateManyWithWhereWithoutBatchInput = {
    where: QCTestScalarWhereInput
    data: XOR<QCTestUpdateManyMutationInput, QCTestUncheckedUpdateManyWithoutBatchInput>
  }

  export type QCTestScalarWhereInput = {
    AND?: QCTestScalarWhereInput | QCTestScalarWhereInput[]
    OR?: QCTestScalarWhereInput[]
    NOT?: QCTestScalarWhereInput | QCTestScalarWhereInput[]
    id?: StringFilter<"QCTest"> | string
    tenantId?: StringFilter<"QCTest"> | string
    batchId?: StringFilter<"QCTest"> | string
    lotId?: StringNullableFilter<"QCTest"> | string | null
    testType?: EnumQCTestTypeFilter<"QCTest"> | $Enums.QCTestType
    status?: EnumQCTestStatusFilter<"QCTest"> | $Enums.QCTestStatus
    priority?: EnumQCTestPriorityFilter<"QCTest"> | $Enums.QCTestPriority
    scheduledDate?: DateTimeFilter<"QCTest"> | Date | string
    completedDate?: DateTimeNullableFilter<"QCTest"> | Date | string | null
    minValue?: DecimalNullableFilter<"QCTest"> | Decimal | DecimalJsLike | number | string | null
    maxValue?: DecimalNullableFilter<"QCTest"> | Decimal | DecimalJsLike | number | string | null
    targetValue?: DecimalNullableFilter<"QCTest"> | Decimal | DecimalJsLike | number | string | null
    result?: DecimalNullableFilter<"QCTest"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"QCTest"> | string | null
    notes?: StringNullableFilter<"QCTest"> | string | null
    performedBy?: StringNullableFilter<"QCTest"> | string | null
    createdBy?: StringFilter<"QCTest"> | string
    createdAt?: DateTimeFilter<"QCTest"> | Date | string
    updatedAt?: DateTimeFilter<"QCTest"> | Date | string
  }

  export type BatchCreateWithoutIngredientsInput = {
    id?: string
    batchNumber: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    recipe: RecipeCreateNestedOneWithoutBatchesInput
    tank?: TankCreateNestedOneWithoutBatchesInput
    tenant: TenantCreateNestedOneWithoutBatchesInput
    timeline?: BatchTimelineCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerCreateNestedManyWithoutBatchInput
    Keg?: KegCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunCreateNestedManyWithoutBatchInput
    QCTest?: QCTestCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutIngredientsInput = {
    id?: string
    tenantId: string
    batchNumber: string
    recipeId: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    tankId?: string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    timeline?: BatchTimelineUncheckedCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingUncheckedCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerUncheckedCreateNestedManyWithoutBatchInput
    Keg?: KegUncheckedCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchUncheckedCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunUncheckedCreateNestedManyWithoutBatchInput
    QCTest?: QCTestUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutIngredientsInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutIngredientsInput, BatchUncheckedCreateWithoutIngredientsInput>
  }

  export type BatchUpsertWithoutIngredientsInput = {
    update: XOR<BatchUpdateWithoutIngredientsInput, BatchUncheckedUpdateWithoutIngredientsInput>
    create: XOR<BatchCreateWithoutIngredientsInput, BatchUncheckedCreateWithoutIngredientsInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutIngredientsInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutIngredientsInput, BatchUncheckedUpdateWithoutIngredientsInput>
  }

  export type BatchUpdateWithoutIngredientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    recipe?: RecipeUpdateOneRequiredWithoutBatchesNestedInput
    tank?: TankUpdateOneWithoutBatchesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutBatchesNestedInput
    timeline?: BatchTimelineUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUpdateManyWithoutBatchNestedInput
    Keg?: KegUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutIngredientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tankId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: BatchTimelineUncheckedUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUncheckedUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUncheckedUpdateManyWithoutBatchNestedInput
    Keg?: KegUncheckedUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUncheckedUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUncheckedUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchCreateWithoutGravityReadingsInput = {
    id?: string
    batchNumber: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    recipe: RecipeCreateNestedOneWithoutBatchesInput
    tank?: TankCreateNestedOneWithoutBatchesInput
    tenant: TenantCreateNestedOneWithoutBatchesInput
    ingredients?: BatchIngredientCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerCreateNestedManyWithoutBatchInput
    Keg?: KegCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunCreateNestedManyWithoutBatchInput
    QCTest?: QCTestCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutGravityReadingsInput = {
    id?: string
    tenantId: string
    batchNumber: string
    recipeId: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    tankId?: string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    ingredients?: BatchIngredientUncheckedCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineUncheckedCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerUncheckedCreateNestedManyWithoutBatchInput
    Keg?: KegUncheckedCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchUncheckedCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunUncheckedCreateNestedManyWithoutBatchInput
    QCTest?: QCTestUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutGravityReadingsInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutGravityReadingsInput, BatchUncheckedCreateWithoutGravityReadingsInput>
  }

  export type BatchUpsertWithoutGravityReadingsInput = {
    update: XOR<BatchUpdateWithoutGravityReadingsInput, BatchUncheckedUpdateWithoutGravityReadingsInput>
    create: XOR<BatchCreateWithoutGravityReadingsInput, BatchUncheckedCreateWithoutGravityReadingsInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutGravityReadingsInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutGravityReadingsInput, BatchUncheckedUpdateWithoutGravityReadingsInput>
  }

  export type BatchUpdateWithoutGravityReadingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    recipe?: RecipeUpdateOneRequiredWithoutBatchesNestedInput
    tank?: TankUpdateOneWithoutBatchesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutBatchesNestedInput
    ingredients?: BatchIngredientUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUpdateManyWithoutBatchNestedInput
    Keg?: KegUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutGravityReadingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tankId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: BatchIngredientUncheckedUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUncheckedUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUncheckedUpdateManyWithoutBatchNestedInput
    Keg?: KegUncheckedUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUncheckedUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUncheckedUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchCreateWithoutTimelineInput = {
    id?: string
    batchNumber: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    recipe: RecipeCreateNestedOneWithoutBatchesInput
    tank?: TankCreateNestedOneWithoutBatchesInput
    tenant: TenantCreateNestedOneWithoutBatchesInput
    ingredients?: BatchIngredientCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerCreateNestedManyWithoutBatchInput
    Keg?: KegCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunCreateNestedManyWithoutBatchInput
    QCTest?: QCTestCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutTimelineInput = {
    id?: string
    tenantId: string
    batchNumber: string
    recipeId: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    tankId?: string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    ingredients?: BatchIngredientUncheckedCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingUncheckedCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerUncheckedCreateNestedManyWithoutBatchInput
    Keg?: KegUncheckedCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchUncheckedCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunUncheckedCreateNestedManyWithoutBatchInput
    QCTest?: QCTestUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutTimelineInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutTimelineInput, BatchUncheckedCreateWithoutTimelineInput>
  }

  export type BatchUpsertWithoutTimelineInput = {
    update: XOR<BatchUpdateWithoutTimelineInput, BatchUncheckedUpdateWithoutTimelineInput>
    create: XOR<BatchCreateWithoutTimelineInput, BatchUncheckedCreateWithoutTimelineInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutTimelineInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutTimelineInput, BatchUncheckedUpdateWithoutTimelineInput>
  }

  export type BatchUpdateWithoutTimelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    recipe?: RecipeUpdateOneRequiredWithoutBatchesNestedInput
    tank?: TankUpdateOneWithoutBatchesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutBatchesNestedInput
    ingredients?: BatchIngredientUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUpdateManyWithoutBatchNestedInput
    Keg?: KegUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutTimelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tankId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: BatchIngredientUncheckedUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUncheckedUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUncheckedUpdateManyWithoutBatchNestedInput
    Keg?: KegUncheckedUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUncheckedUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUncheckedUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchCreateWithoutTankInput = {
    id?: string
    batchNumber: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    recipe: RecipeCreateNestedOneWithoutBatchesInput
    tenant: TenantCreateNestedOneWithoutBatchesInput
    ingredients?: BatchIngredientCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerCreateNestedManyWithoutBatchInput
    Keg?: KegCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunCreateNestedManyWithoutBatchInput
    QCTest?: QCTestCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutTankInput = {
    id?: string
    tenantId: string
    batchNumber: string
    recipeId: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    ingredients?: BatchIngredientUncheckedCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineUncheckedCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingUncheckedCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerUncheckedCreateNestedManyWithoutBatchInput
    Keg?: KegUncheckedCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchUncheckedCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunUncheckedCreateNestedManyWithoutBatchInput
    QCTest?: QCTestUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutTankInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutTankInput, BatchUncheckedCreateWithoutTankInput>
  }

  export type BatchCreateManyTankInputEnvelope = {
    data: BatchCreateManyTankInput | BatchCreateManyTankInput[]
    skipDuplicates?: boolean
  }

  export type LotReadingCreateWithoutTankInput = {
    id: string
    readingType: $Enums.ReadingType
    value: Decimal | DecimalJsLike | number | string
    unit: string
    notes?: string | null
    recordedBy: string
    recordedAt?: Date | string
    Lot: LotCreateNestedOneWithoutLotReadingInput
  }

  export type LotReadingUncheckedCreateWithoutTankInput = {
    id: string
    lotId: string
    readingType: $Enums.ReadingType
    value: Decimal | DecimalJsLike | number | string
    unit: string
    notes?: string | null
    recordedBy: string
    recordedAt?: Date | string
  }

  export type LotReadingCreateOrConnectWithoutTankInput = {
    where: LotReadingWhereUniqueInput
    create: XOR<LotReadingCreateWithoutTankInput, LotReadingUncheckedCreateWithoutTankInput>
  }

  export type LotReadingCreateManyTankInputEnvelope = {
    data: LotReadingCreateManyTankInput | LotReadingCreateManyTankInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutTanksInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchCreateNestedManyWithoutTenantInput
    budgets?: BudgetCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    Keg?: KegCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    recipes?: RecipeCreateNestedManyWithoutTenantInput
    orders?: SalesOrderCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTanksInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchUncheckedCreateNestedManyWithoutTenantInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    Keg?: KegUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutTenantInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTanksInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTanksInput, TenantUncheckedCreateWithoutTanksInput>
  }

  export type TankAssignmentCreateWithoutTankInput = {
    id: string
    tenantId: string
    phase: $Enums.LotPhase
    plannedStart?: Date | string | null
    plannedEnd?: Date | string | null
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.AssignmentStatus
    plannedVolume?: Decimal | DecimalJsLike | number | string | null
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: boolean
    isSplitSource?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    notes?: string | null
    Lot: LotCreateNestedOneWithoutTankAssignmentInput
  }

  export type TankAssignmentUncheckedCreateWithoutTankInput = {
    id: string
    tenantId: string
    lotId: string
    phase: $Enums.LotPhase
    plannedStart?: Date | string | null
    plannedEnd?: Date | string | null
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.AssignmentStatus
    plannedVolume?: Decimal | DecimalJsLike | number | string | null
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: boolean
    isSplitSource?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    notes?: string | null
  }

  export type TankAssignmentCreateOrConnectWithoutTankInput = {
    where: TankAssignmentWhereUniqueInput
    create: XOR<TankAssignmentCreateWithoutTankInput, TankAssignmentUncheckedCreateWithoutTankInput>
  }

  export type TankAssignmentCreateManyTankInputEnvelope = {
    data: TankAssignmentCreateManyTankInput | TankAssignmentCreateManyTankInput[]
    skipDuplicates?: boolean
  }

  export type TankOccupationCreateWithoutTankInput = {
    id?: string
    tenantId: string
    batchId: string
    phase: $Enums.OccupationPhase
    startedAt?: Date | string
    endedAt?: Date | string | null
  }

  export type TankOccupationUncheckedCreateWithoutTankInput = {
    id?: string
    tenantId: string
    batchId: string
    phase: $Enums.OccupationPhase
    startedAt?: Date | string
    endedAt?: Date | string | null
  }

  export type TankOccupationCreateOrConnectWithoutTankInput = {
    where: TankOccupationWhereUniqueInput
    create: XOR<TankOccupationCreateWithoutTankInput, TankOccupationUncheckedCreateWithoutTankInput>
  }

  export type TankOccupationCreateManyTankInputEnvelope = {
    data: TankOccupationCreateManyTankInput | TankOccupationCreateManyTankInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutTank_Transfer_destTankIdToTankInput = {
    id: string
    tenantId: string
    transferCode: string
    transferType: $Enums.TransferType
    volume: Decimal | DecimalJsLike | number | string
    plannedAt: Date | string
    executedAt?: Date | string | null
    status?: $Enums.TransferStatus
    measuredLoss?: Decimal | DecimalJsLike | number | string | null
    lossReason?: string | null
    performedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Lot_Transfer_destLotIdToLot?: LotCreateNestedOneWithoutTransfer_Transfer_destLotIdToLotInput
    Lot_Transfer_sourceLotIdToLot?: LotCreateNestedOneWithoutTransfer_Transfer_sourceLotIdToLotInput
    Tank_Transfer_sourceTankIdToTank: TankCreateNestedOneWithoutTransfer_Transfer_sourceTankIdToTankInput
  }

  export type TransferUncheckedCreateWithoutTank_Transfer_destTankIdToTankInput = {
    id: string
    tenantId: string
    transferCode: string
    sourceLotId?: string | null
    sourceTankId: string
    destLotId?: string | null
    transferType: $Enums.TransferType
    volume: Decimal | DecimalJsLike | number | string
    plannedAt: Date | string
    executedAt?: Date | string | null
    status?: $Enums.TransferStatus
    measuredLoss?: Decimal | DecimalJsLike | number | string | null
    lossReason?: string | null
    performedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateOrConnectWithoutTank_Transfer_destTankIdToTankInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutTank_Transfer_destTankIdToTankInput, TransferUncheckedCreateWithoutTank_Transfer_destTankIdToTankInput>
  }

  export type TransferCreateManyTank_Transfer_destTankIdToTankInputEnvelope = {
    data: TransferCreateManyTank_Transfer_destTankIdToTankInput | TransferCreateManyTank_Transfer_destTankIdToTankInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutTank_Transfer_sourceTankIdToTankInput = {
    id: string
    tenantId: string
    transferCode: string
    transferType: $Enums.TransferType
    volume: Decimal | DecimalJsLike | number | string
    plannedAt: Date | string
    executedAt?: Date | string | null
    status?: $Enums.TransferStatus
    measuredLoss?: Decimal | DecimalJsLike | number | string | null
    lossReason?: string | null
    performedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Lot_Transfer_destLotIdToLot?: LotCreateNestedOneWithoutTransfer_Transfer_destLotIdToLotInput
    Tank_Transfer_destTankIdToTank: TankCreateNestedOneWithoutTransfer_Transfer_destTankIdToTankInput
    Lot_Transfer_sourceLotIdToLot?: LotCreateNestedOneWithoutTransfer_Transfer_sourceLotIdToLotInput
  }

  export type TransferUncheckedCreateWithoutTank_Transfer_sourceTankIdToTankInput = {
    id: string
    tenantId: string
    transferCode: string
    sourceLotId?: string | null
    destLotId?: string | null
    destTankId: string
    transferType: $Enums.TransferType
    volume: Decimal | DecimalJsLike | number | string
    plannedAt: Date | string
    executedAt?: Date | string | null
    status?: $Enums.TransferStatus
    measuredLoss?: Decimal | DecimalJsLike | number | string | null
    lossReason?: string | null
    performedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateOrConnectWithoutTank_Transfer_sourceTankIdToTankInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutTank_Transfer_sourceTankIdToTankInput, TransferUncheckedCreateWithoutTank_Transfer_sourceTankIdToTankInput>
  }

  export type TransferCreateManyTank_Transfer_sourceTankIdToTankInputEnvelope = {
    data: TransferCreateManyTank_Transfer_sourceTankIdToTankInput | TransferCreateManyTank_Transfer_sourceTankIdToTankInput[]
    skipDuplicates?: boolean
  }

  export type BatchUpsertWithWhereUniqueWithoutTankInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutTankInput, BatchUncheckedUpdateWithoutTankInput>
    create: XOR<BatchCreateWithoutTankInput, BatchUncheckedCreateWithoutTankInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutTankInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutTankInput, BatchUncheckedUpdateWithoutTankInput>
  }

  export type BatchUpdateManyWithWhereWithoutTankInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutTankInput>
  }

  export type LotReadingUpsertWithWhereUniqueWithoutTankInput = {
    where: LotReadingWhereUniqueInput
    update: XOR<LotReadingUpdateWithoutTankInput, LotReadingUncheckedUpdateWithoutTankInput>
    create: XOR<LotReadingCreateWithoutTankInput, LotReadingUncheckedCreateWithoutTankInput>
  }

  export type LotReadingUpdateWithWhereUniqueWithoutTankInput = {
    where: LotReadingWhereUniqueInput
    data: XOR<LotReadingUpdateWithoutTankInput, LotReadingUncheckedUpdateWithoutTankInput>
  }

  export type LotReadingUpdateManyWithWhereWithoutTankInput = {
    where: LotReadingScalarWhereInput
    data: XOR<LotReadingUpdateManyMutationInput, LotReadingUncheckedUpdateManyWithoutTankInput>
  }

  export type LotReadingScalarWhereInput = {
    AND?: LotReadingScalarWhereInput | LotReadingScalarWhereInput[]
    OR?: LotReadingScalarWhereInput[]
    NOT?: LotReadingScalarWhereInput | LotReadingScalarWhereInput[]
    id?: StringFilter<"LotReading"> | string
    lotId?: StringFilter<"LotReading"> | string
    tankId?: StringFilter<"LotReading"> | string
    readingType?: EnumReadingTypeFilter<"LotReading"> | $Enums.ReadingType
    value?: DecimalFilter<"LotReading"> | Decimal | DecimalJsLike | number | string
    unit?: StringFilter<"LotReading"> | string
    notes?: StringNullableFilter<"LotReading"> | string | null
    recordedBy?: StringFilter<"LotReading"> | string
    recordedAt?: DateTimeFilter<"LotReading"> | Date | string
  }

  export type TenantUpsertWithoutTanksInput = {
    update: XOR<TenantUpdateWithoutTanksInput, TenantUncheckedUpdateWithoutTanksInput>
    create: XOR<TenantCreateWithoutTanksInput, TenantUncheckedCreateWithoutTanksInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTanksInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTanksInput, TenantUncheckedUpdateWithoutTanksInput>
  }

  export type TenantUpdateWithoutTanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    Keg?: KegUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTanksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUncheckedUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    Keg?: KegUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TankAssignmentUpsertWithWhereUniqueWithoutTankInput = {
    where: TankAssignmentWhereUniqueInput
    update: XOR<TankAssignmentUpdateWithoutTankInput, TankAssignmentUncheckedUpdateWithoutTankInput>
    create: XOR<TankAssignmentCreateWithoutTankInput, TankAssignmentUncheckedCreateWithoutTankInput>
  }

  export type TankAssignmentUpdateWithWhereUniqueWithoutTankInput = {
    where: TankAssignmentWhereUniqueInput
    data: XOR<TankAssignmentUpdateWithoutTankInput, TankAssignmentUncheckedUpdateWithoutTankInput>
  }

  export type TankAssignmentUpdateManyWithWhereWithoutTankInput = {
    where: TankAssignmentScalarWhereInput
    data: XOR<TankAssignmentUpdateManyMutationInput, TankAssignmentUncheckedUpdateManyWithoutTankInput>
  }

  export type TankAssignmentScalarWhereInput = {
    AND?: TankAssignmentScalarWhereInput | TankAssignmentScalarWhereInput[]
    OR?: TankAssignmentScalarWhereInput[]
    NOT?: TankAssignmentScalarWhereInput | TankAssignmentScalarWhereInput[]
    id?: StringFilter<"TankAssignment"> | string
    tenantId?: StringFilter<"TankAssignment"> | string
    tankId?: StringFilter<"TankAssignment"> | string
    lotId?: StringFilter<"TankAssignment"> | string
    phase?: EnumLotPhaseFilter<"TankAssignment"> | $Enums.LotPhase
    plannedStart?: DateTimeNullableFilter<"TankAssignment"> | Date | string | null
    plannedEnd?: DateTimeNullableFilter<"TankAssignment"> | Date | string | null
    actualStart?: DateTimeNullableFilter<"TankAssignment"> | Date | string | null
    actualEnd?: DateTimeNullableFilter<"TankAssignment"> | Date | string | null
    status?: EnumAssignmentStatusFilter<"TankAssignment"> | $Enums.AssignmentStatus
    plannedVolume?: DecimalNullableFilter<"TankAssignment"> | Decimal | DecimalJsLike | number | string | null
    actualVolume?: DecimalNullableFilter<"TankAssignment"> | Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: BoolFilter<"TankAssignment"> | boolean
    isSplitSource?: BoolFilter<"TankAssignment"> | boolean
    createdBy?: StringNullableFilter<"TankAssignment"> | string | null
    createdAt?: DateTimeFilter<"TankAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"TankAssignment"> | Date | string
    startTime?: DateTimeNullableFilter<"TankAssignment"> | Date | string | null
    endTime?: DateTimeNullableFilter<"TankAssignment"> | Date | string | null
    notes?: StringNullableFilter<"TankAssignment"> | string | null
  }

  export type TankOccupationUpsertWithWhereUniqueWithoutTankInput = {
    where: TankOccupationWhereUniqueInput
    update: XOR<TankOccupationUpdateWithoutTankInput, TankOccupationUncheckedUpdateWithoutTankInput>
    create: XOR<TankOccupationCreateWithoutTankInput, TankOccupationUncheckedCreateWithoutTankInput>
  }

  export type TankOccupationUpdateWithWhereUniqueWithoutTankInput = {
    where: TankOccupationWhereUniqueInput
    data: XOR<TankOccupationUpdateWithoutTankInput, TankOccupationUncheckedUpdateWithoutTankInput>
  }

  export type TankOccupationUpdateManyWithWhereWithoutTankInput = {
    where: TankOccupationScalarWhereInput
    data: XOR<TankOccupationUpdateManyMutationInput, TankOccupationUncheckedUpdateManyWithoutTankInput>
  }

  export type TankOccupationScalarWhereInput = {
    AND?: TankOccupationScalarWhereInput | TankOccupationScalarWhereInput[]
    OR?: TankOccupationScalarWhereInput[]
    NOT?: TankOccupationScalarWhereInput | TankOccupationScalarWhereInput[]
    id?: StringFilter<"TankOccupation"> | string
    tenantId?: StringFilter<"TankOccupation"> | string
    tankId?: StringFilter<"TankOccupation"> | string
    batchId?: StringFilter<"TankOccupation"> | string
    phase?: EnumOccupationPhaseFilter<"TankOccupation"> | $Enums.OccupationPhase
    startedAt?: DateTimeFilter<"TankOccupation"> | Date | string
    endedAt?: DateTimeNullableFilter<"TankOccupation"> | Date | string | null
  }

  export type TransferUpsertWithWhereUniqueWithoutTank_Transfer_destTankIdToTankInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutTank_Transfer_destTankIdToTankInput, TransferUncheckedUpdateWithoutTank_Transfer_destTankIdToTankInput>
    create: XOR<TransferCreateWithoutTank_Transfer_destTankIdToTankInput, TransferUncheckedCreateWithoutTank_Transfer_destTankIdToTankInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutTank_Transfer_destTankIdToTankInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutTank_Transfer_destTankIdToTankInput, TransferUncheckedUpdateWithoutTank_Transfer_destTankIdToTankInput>
  }

  export type TransferUpdateManyWithWhereWithoutTank_Transfer_destTankIdToTankInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutTank_Transfer_destTankIdToTankInput>
  }

  export type TransferScalarWhereInput = {
    AND?: TransferScalarWhereInput | TransferScalarWhereInput[]
    OR?: TransferScalarWhereInput[]
    NOT?: TransferScalarWhereInput | TransferScalarWhereInput[]
    id?: StringFilter<"Transfer"> | string
    tenantId?: StringFilter<"Transfer"> | string
    transferCode?: StringFilter<"Transfer"> | string
    sourceLotId?: StringNullableFilter<"Transfer"> | string | null
    sourceTankId?: StringFilter<"Transfer"> | string
    destLotId?: StringNullableFilter<"Transfer"> | string | null
    destTankId?: StringFilter<"Transfer"> | string
    transferType?: EnumTransferTypeFilter<"Transfer"> | $Enums.TransferType
    volume?: DecimalFilter<"Transfer"> | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeFilter<"Transfer"> | Date | string
    executedAt?: DateTimeNullableFilter<"Transfer"> | Date | string | null
    status?: EnumTransferStatusFilter<"Transfer"> | $Enums.TransferStatus
    measuredLoss?: DecimalNullableFilter<"Transfer"> | Decimal | DecimalJsLike | number | string | null
    lossReason?: StringNullableFilter<"Transfer"> | string | null
    performedBy?: StringNullableFilter<"Transfer"> | string | null
    notes?: StringNullableFilter<"Transfer"> | string | null
    createdAt?: DateTimeFilter<"Transfer"> | Date | string
    updatedAt?: DateTimeFilter<"Transfer"> | Date | string
  }

  export type TransferUpsertWithWhereUniqueWithoutTank_Transfer_sourceTankIdToTankInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutTank_Transfer_sourceTankIdToTankInput, TransferUncheckedUpdateWithoutTank_Transfer_sourceTankIdToTankInput>
    create: XOR<TransferCreateWithoutTank_Transfer_sourceTankIdToTankInput, TransferUncheckedCreateWithoutTank_Transfer_sourceTankIdToTankInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutTank_Transfer_sourceTankIdToTankInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutTank_Transfer_sourceTankIdToTankInput, TransferUncheckedUpdateWithoutTank_Transfer_sourceTankIdToTankInput>
  }

  export type TransferUpdateManyWithWhereWithoutTank_Transfer_sourceTankIdToTankInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutTank_Transfer_sourceTankIdToTankInput>
  }

  export type TankCreateWithoutOccupationsInput = {
    id?: string
    name: string
    type: $Enums.TankType
    capacity: Decimal | DecimalJsLike | number | string
    status?: $Enums.TankStatus
    currentBatchId?: string | null
    location?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: TankCreatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: string | null
    currentPhase?: $Enums.LotPhase | null
    defaultTurnaroundHours?: number | null
    maxFillPercent?: number | null
    minFillPercent?: number | null
    batches?: BatchCreateNestedManyWithoutTankInput
    LotReading?: LotReadingCreateNestedManyWithoutTankInput
    tenant: TenantCreateNestedOneWithoutTanksInput
    TankAssignment?: TankAssignmentCreateNestedManyWithoutTankInput
    Transfer_Transfer_destTankIdToTank?: TransferCreateNestedManyWithoutTank_Transfer_destTankIdToTankInput
    Transfer_Transfer_sourceTankIdToTank?: TransferCreateNestedManyWithoutTank_Transfer_sourceTankIdToTankInput
  }

  export type TankUncheckedCreateWithoutOccupationsInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.TankType
    capacity: Decimal | DecimalJsLike | number | string
    status?: $Enums.TankStatus
    currentBatchId?: string | null
    location?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: TankCreatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: string | null
    currentPhase?: $Enums.LotPhase | null
    defaultTurnaroundHours?: number | null
    maxFillPercent?: number | null
    minFillPercent?: number | null
    batches?: BatchUncheckedCreateNestedManyWithoutTankInput
    LotReading?: LotReadingUncheckedCreateNestedManyWithoutTankInput
    TankAssignment?: TankAssignmentUncheckedCreateNestedManyWithoutTankInput
    Transfer_Transfer_destTankIdToTank?: TransferUncheckedCreateNestedManyWithoutTank_Transfer_destTankIdToTankInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUncheckedCreateNestedManyWithoutTank_Transfer_sourceTankIdToTankInput
  }

  export type TankCreateOrConnectWithoutOccupationsInput = {
    where: TankWhereUniqueInput
    create: XOR<TankCreateWithoutOccupationsInput, TankUncheckedCreateWithoutOccupationsInput>
  }

  export type TankUpsertWithoutOccupationsInput = {
    update: XOR<TankUpdateWithoutOccupationsInput, TankUncheckedUpdateWithoutOccupationsInput>
    create: XOR<TankCreateWithoutOccupationsInput, TankUncheckedCreateWithoutOccupationsInput>
    where?: TankWhereInput
  }

  export type TankUpdateToOneWithWhereWithoutOccupationsInput = {
    where?: TankWhereInput
    data: XOR<TankUpdateWithoutOccupationsInput, TankUncheckedUpdateWithoutOccupationsInput>
  }

  export type TankUpdateWithoutOccupationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTankTypeFieldUpdateOperationsInput | $Enums.TankType
    capacity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFieldUpdateOperationsInput | $Enums.TankStatus
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: TankUpdatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPhase?: NullableEnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase | null
    defaultTurnaroundHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    minFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    batches?: BatchUpdateManyWithoutTankNestedInput
    LotReading?: LotReadingUpdateManyWithoutTankNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTanksNestedInput
    TankAssignment?: TankAssignmentUpdateManyWithoutTankNestedInput
    Transfer_Transfer_destTankIdToTank?: TransferUpdateManyWithoutTank_Transfer_destTankIdToTankNestedInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUpdateManyWithoutTank_Transfer_sourceTankIdToTankNestedInput
  }

  export type TankUncheckedUpdateWithoutOccupationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTankTypeFieldUpdateOperationsInput | $Enums.TankType
    capacity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFieldUpdateOperationsInput | $Enums.TankStatus
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: TankUpdatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPhase?: NullableEnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase | null
    defaultTurnaroundHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    minFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    batches?: BatchUncheckedUpdateManyWithoutTankNestedInput
    LotReading?: LotReadingUncheckedUpdateManyWithoutTankNestedInput
    TankAssignment?: TankAssignmentUncheckedUpdateManyWithoutTankNestedInput
    Transfer_Transfer_destTankIdToTank?: TransferUncheckedUpdateManyWithoutTank_Transfer_destTankIdToTankNestedInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUncheckedUpdateManyWithoutTank_Transfer_sourceTankIdToTankNestedInput
  }

  export type BatchCreateWithoutPackagingRunsInput = {
    id?: string
    batchNumber: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    recipe: RecipeCreateNestedOneWithoutBatchesInput
    tank?: TankCreateNestedOneWithoutBatchesInput
    tenant: TenantCreateNestedOneWithoutBatchesInput
    ingredients?: BatchIngredientCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerCreateNestedManyWithoutBatchInput
    Keg?: KegCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchCreateNestedManyWithoutBatchInput
    QCTest?: QCTestCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutPackagingRunsInput = {
    id?: string
    tenantId: string
    batchNumber: string
    recipeId: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    tankId?: string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    ingredients?: BatchIngredientUncheckedCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineUncheckedCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingUncheckedCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerUncheckedCreateNestedManyWithoutBatchInput
    Keg?: KegUncheckedCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchUncheckedCreateNestedManyWithoutBatchInput
    QCTest?: QCTestUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutPackagingRunsInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutPackagingRunsInput, BatchUncheckedCreateWithoutPackagingRunsInput>
  }

  export type BatchUpsertWithoutPackagingRunsInput = {
    update: XOR<BatchUpdateWithoutPackagingRunsInput, BatchUncheckedUpdateWithoutPackagingRunsInput>
    create: XOR<BatchCreateWithoutPackagingRunsInput, BatchUncheckedCreateWithoutPackagingRunsInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutPackagingRunsInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutPackagingRunsInput, BatchUncheckedUpdateWithoutPackagingRunsInput>
  }

  export type BatchUpdateWithoutPackagingRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    recipe?: RecipeUpdateOneRequiredWithoutBatchesNestedInput
    tank?: TankUpdateOneWithoutBatchesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutBatchesNestedInput
    ingredients?: BatchIngredientUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUpdateManyWithoutBatchNestedInput
    Keg?: KegUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutPackagingRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tankId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: BatchIngredientUncheckedUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUncheckedUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUncheckedUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUncheckedUpdateManyWithoutBatchNestedInput
    Keg?: KegUncheckedUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUncheckedUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type TenantCreateWithoutCustomersInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchCreateNestedManyWithoutTenantInput
    budgets?: BudgetCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    Keg?: KegCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    recipes?: RecipeCreateNestedManyWithoutTenantInput
    orders?: SalesOrderCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    tanks?: TankCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCustomersInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchUncheckedCreateNestedManyWithoutTenantInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    Keg?: KegUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutTenantInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    tanks?: TankUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCustomersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
  }

  export type InvoiceCreateWithoutCustomerInput = {
    id?: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: SalesOrderCreateNestedOneWithoutInvoiceInput
    supplier?: SupplierCreateNestedOneWithoutInvoicesInput
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutCustomerInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    supplierId?: string | null
    orderId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceCreateManyCustomerInputEnvelope = {
    data: InvoiceCreateManyCustomerInput | InvoiceCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type KegCreateWithoutCustomerInput = {
    id?: string
    kegNumber: string
    size: number
    status?: $Enums.KegStatus
    condition?: $Enums.KegCondition
    filledAt?: Date | string | null
    productName?: string | null
    lotNumber?: string | null
    orderId?: string | null
    sentAt?: Date | string | null
    returnedAt?: Date | string | null
    deposit?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Batch?: BatchCreateNestedOneWithoutKegInput
    Tenant: TenantCreateNestedOneWithoutKegInput
    movements?: KegMovementCreateNestedManyWithoutKegInput
  }

  export type KegUncheckedCreateWithoutCustomerInput = {
    id?: string
    tenantId: string
    kegNumber: string
    size: number
    status?: $Enums.KegStatus
    condition?: $Enums.KegCondition
    batchId?: string | null
    filledAt?: Date | string | null
    productName?: string | null
    lotNumber?: string | null
    orderId?: string | null
    sentAt?: Date | string | null
    returnedAt?: Date | string | null
    deposit?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    movements?: KegMovementUncheckedCreateNestedManyWithoutKegInput
  }

  export type KegCreateOrConnectWithoutCustomerInput = {
    where: KegWhereUniqueInput
    create: XOR<KegCreateWithoutCustomerInput, KegUncheckedCreateWithoutCustomerInput>
  }

  export type KegCreateManyCustomerInputEnvelope = {
    data: KegCreateManyCustomerInput | KegCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SalesOrderCreateWithoutCustomerInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    orderedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdBy: string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    tenant: TenantCreateNestedOneWithoutOrdersInput
    transactions?: TransactionCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    tenantId: string
    orderNumber: string
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    orderedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdBy: string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderCreateOrConnectWithoutCustomerInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput>
  }

  export type SalesOrderCreateManyCustomerInputEnvelope = {
    data: SalesOrderCreateManyCustomerInput | SalesOrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutCustomerInput = {
    id?: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expense?: ExpenseCreateNestedOneWithoutTransactionsInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
    order?: SalesOrderCreateNestedOneWithoutTransactionsInput
    supplier?: SupplierCreateNestedOneWithoutTransactionsInput
    tenant: TenantCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutCustomerInput = {
    id?: string
    tenantId: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    supplierId?: string | null
    orderId?: string | null
    invoiceId?: string | null
    expenseId?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput>
  }

  export type TransactionCreateManyCustomerInputEnvelope = {
    data: TransactionCreateManyCustomerInput | TransactionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutCustomersInput = {
    update: XOR<TenantUpdateWithoutCustomersInput, TenantUncheckedUpdateWithoutCustomersInput>
    create: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCustomersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCustomersInput, TenantUncheckedUpdateWithoutCustomersInput>
  }

  export type TenantUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    Keg?: KegUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    tanks?: TankUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUncheckedUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    Keg?: KegUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    tanks?: TankUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCustomerInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCustomerInput>
  }

  export type KegUpsertWithWhereUniqueWithoutCustomerInput = {
    where: KegWhereUniqueInput
    update: XOR<KegUpdateWithoutCustomerInput, KegUncheckedUpdateWithoutCustomerInput>
    create: XOR<KegCreateWithoutCustomerInput, KegUncheckedCreateWithoutCustomerInput>
  }

  export type KegUpdateWithWhereUniqueWithoutCustomerInput = {
    where: KegWhereUniqueInput
    data: XOR<KegUpdateWithoutCustomerInput, KegUncheckedUpdateWithoutCustomerInput>
  }

  export type KegUpdateManyWithWhereWithoutCustomerInput = {
    where: KegScalarWhereInput
    data: XOR<KegUpdateManyMutationInput, KegUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SalesOrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SalesOrderWhereUniqueInput
    update: XOR<SalesOrderUpdateWithoutCustomerInput, SalesOrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput>
  }

  export type SalesOrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SalesOrderWhereUniqueInput
    data: XOR<SalesOrderUpdateWithoutCustomerInput, SalesOrderUncheckedUpdateWithoutCustomerInput>
  }

  export type SalesOrderUpdateManyWithWhereWithoutCustomerInput = {
    where: SalesOrderScalarWhereInput
    data: XOR<SalesOrderUpdateManyMutationInput, SalesOrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCustomerInput, TransactionUncheckedUpdateWithoutCustomerInput>
    create: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCustomerInput, TransactionUncheckedUpdateWithoutCustomerInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCustomerInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ExpenseCreateWithoutSupplierInput = {
    id?: string
    category: $Enums.ExpenseCategory
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    invoiceNumber?: string | null
    invoiceId?: string | null
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    receiptUrl?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutExpensesInput
    transactions?: TransactionCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutSupplierInput = {
    id?: string
    tenantId: string
    category: $Enums.ExpenseCategory
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    invoiceNumber?: string | null
    invoiceId?: string | null
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    receiptUrl?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseCreateOrConnectWithoutSupplierInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutSupplierInput, ExpenseUncheckedCreateWithoutSupplierInput>
  }

  export type ExpenseCreateManySupplierInputEnvelope = {
    data: ExpenseCreateManySupplierInput | ExpenseCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutSupplierInput = {
    id?: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutInvoicesInput
    order?: SalesOrderCreateNestedOneWithoutInvoiceInput
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutSupplierInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    customerId?: string | null
    orderId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutSupplierInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutSupplierInput, InvoiceUncheckedCreateWithoutSupplierInput>
  }

  export type InvoiceCreateManySupplierInputEnvelope = {
    data: InvoiceCreateManySupplierInput | InvoiceCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutSuppliersInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchCreateNestedManyWithoutTenantInput
    budgets?: BudgetCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    Keg?: KegCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    recipes?: RecipeCreateNestedManyWithoutTenantInput
    orders?: SalesOrderCreateNestedManyWithoutTenantInput
    tanks?: TankCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSuppliersInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchUncheckedCreateNestedManyWithoutTenantInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    Keg?: KegUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutTenantInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutTenantInput
    tanks?: TankUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSuppliersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSuppliersInput, TenantUncheckedCreateWithoutSuppliersInput>
  }

  export type TransactionCreateWithoutSupplierInput = {
    id?: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    expense?: ExpenseCreateNestedOneWithoutTransactionsInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
    order?: SalesOrderCreateNestedOneWithoutTransactionsInput
    tenant: TenantCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutSupplierInput = {
    id?: string
    tenantId: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    customerId?: string | null
    orderId?: string | null
    invoiceId?: string | null
    expenseId?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutSupplierInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutSupplierInput, TransactionUncheckedCreateWithoutSupplierInput>
  }

  export type TransactionCreateManySupplierInputEnvelope = {
    data: TransactionCreateManySupplierInput | TransactionCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseUpsertWithWhereUniqueWithoutSupplierInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutSupplierInput, ExpenseUncheckedUpdateWithoutSupplierInput>
    create: XOR<ExpenseCreateWithoutSupplierInput, ExpenseUncheckedCreateWithoutSupplierInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutSupplierInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutSupplierInput, ExpenseUncheckedUpdateWithoutSupplierInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutSupplierInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutSupplierInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutSupplierInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutSupplierInput, InvoiceUncheckedUpdateWithoutSupplierInput>
    create: XOR<InvoiceCreateWithoutSupplierInput, InvoiceUncheckedCreateWithoutSupplierInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutSupplierInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutSupplierInput, InvoiceUncheckedUpdateWithoutSupplierInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutSupplierInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutSupplierInput>
  }

  export type TenantUpsertWithoutSuppliersInput = {
    update: XOR<TenantUpdateWithoutSuppliersInput, TenantUncheckedUpdateWithoutSuppliersInput>
    create: XOR<TenantCreateWithoutSuppliersInput, TenantUncheckedCreateWithoutSuppliersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSuppliersInput, TenantUncheckedUpdateWithoutSuppliersInput>
  }

  export type TenantUpdateWithoutSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    Keg?: KegUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUpdateManyWithoutTenantNestedInput
    tanks?: TankUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUncheckedUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    Keg?: KegUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutTenantNestedInput
    tanks?: TankUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutSupplierInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutSupplierInput, TransactionUncheckedUpdateWithoutSupplierInput>
    create: XOR<TransactionCreateWithoutSupplierInput, TransactionUncheckedCreateWithoutSupplierInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutSupplierInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutSupplierInput, TransactionUncheckedUpdateWithoutSupplierInput>
  }

  export type TransactionUpdateManyWithWhereWithoutSupplierInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutSupplierInput>
  }

  export type InvoiceCreateWithoutOrderInput = {
    id?: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutInvoicesInput
    supplier?: SupplierCreateNestedOneWithoutInvoicesInput
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutOrderInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    customerId?: string | null
    supplierId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    productName: string
    packageType: $Enums.PackageType
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    batchId?: string | null
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    productName: string
    packageType: $Enums.PackageType
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    batchId?: string | null
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutOrderInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PaymentMethod
    date?: Date | string
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutPaymentsInput
    tenant: TenantCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutOrderInput = {
    id?: string
    tenantId: string
    invoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PaymentMethod
    date?: Date | string
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentCreateManyOrderInputEnvelope = {
    data: PaymentCreateManyOrderInput | PaymentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutOrdersInput = {
    id?: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    kegReturnDays?: number
    kegDepositRequired?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCustomersInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    Keg?: KegCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    id?: string
    tenantId: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    kegReturnDays?: number
    kegDepositRequired?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    Keg?: KegUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type TenantCreateWithoutOrdersInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchCreateNestedManyWithoutTenantInput
    budgets?: BudgetCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    Keg?: KegCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    recipes?: RecipeCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    tanks?: TankCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchUncheckedCreateNestedManyWithoutTenantInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    Keg?: KegUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    tanks?: TankUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutOrdersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutOrdersInput, TenantUncheckedCreateWithoutOrdersInput>
  }

  export type TransactionCreateWithoutOrderInput = {
    id?: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    expense?: ExpenseCreateNestedOneWithoutTransactionsInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
    supplier?: SupplierCreateNestedOneWithoutTransactionsInput
    tenant: TenantCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutOrderInput = {
    id?: string
    tenantId: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    customerId?: string | null
    supplierId?: string | null
    invoiceId?: string | null
    expenseId?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutOrderInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutOrderInput, TransactionUncheckedCreateWithoutOrderInput>
  }

  export type TransactionCreateManyOrderInputEnvelope = {
    data: TransactionCreateManyOrderInput | TransactionCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceUpsertWithoutOrderInput = {
    update: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutOrderInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type InvoiceUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutInvoicesNestedInput
    supplier?: SupplierUpdateOneWithoutInvoicesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productName?: StringFilter<"OrderItem"> | string
    packageType?: EnumPackageTypeFilter<"OrderItem"> | $Enums.PackageType
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    batchId?: StringNullableFilter<"OrderItem"> | string | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUpdateManyWithWhereWithoutOrderInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutOrderInput>
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    kegReturnDays?: IntFieldUpdateOperationsInput | number
    kegDepositRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    Keg?: KegUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    kegReturnDays?: IntFieldUpdateOperationsInput | number
    kegDepositRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    Keg?: KegUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type TenantUpsertWithoutOrdersInput = {
    update: XOR<TenantUpdateWithoutOrdersInput, TenantUncheckedUpdateWithoutOrdersInput>
    create: XOR<TenantCreateWithoutOrdersInput, TenantUncheckedCreateWithoutOrdersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutOrdersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutOrdersInput, TenantUncheckedUpdateWithoutOrdersInput>
  }

  export type TenantUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    Keg?: KegUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    tanks?: TankUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUncheckedUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    Keg?: KegUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    tanks?: TankUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutOrderInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutOrderInput, TransactionUncheckedUpdateWithoutOrderInput>
    create: XOR<TransactionCreateWithoutOrderInput, TransactionUncheckedCreateWithoutOrderInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutOrderInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutOrderInput, TransactionUncheckedUpdateWithoutOrderInput>
  }

  export type TransactionUpdateManyWithWhereWithoutOrderInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutOrderInput>
  }

  export type SalesOrderCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    orderedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdBy: string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    tenant: TenantCreateNestedOneWithoutOrdersInput
    transactions?: TransactionCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderUncheckedCreateWithoutItemsInput = {
    id?: string
    tenantId: string
    orderNumber: string
    customerId: string
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    orderedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdBy: string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderCreateOrConnectWithoutItemsInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutItemsInput, SalesOrderUncheckedCreateWithoutItemsInput>
  }

  export type SalesOrderUpsertWithoutItemsInput = {
    update: XOR<SalesOrderUpdateWithoutItemsInput, SalesOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<SalesOrderCreateWithoutItemsInput, SalesOrderUncheckedCreateWithoutItemsInput>
    where?: SalesOrderWhereInput
  }

  export type SalesOrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: SalesOrderWhereInput
    data: XOR<SalesOrderUpdateWithoutItemsInput, SalesOrderUncheckedUpdateWithoutItemsInput>
  }

  export type SalesOrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    transactions?: TransactionUpdateManyWithoutOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type CustomerCreateWithoutTransactionsInput = {
    id?: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    kegReturnDays?: number
    kegDepositRequired?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCustomersInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    Keg?: KegCreateNestedManyWithoutCustomerInput
    orders?: SalesOrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutTransactionsInput = {
    id?: string
    tenantId: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    kegReturnDays?: number
    kegDepositRequired?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    Keg?: KegUncheckedCreateNestedManyWithoutCustomerInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutTransactionsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
  }

  export type ExpenseCreateWithoutTransactionsInput = {
    id?: string
    category: $Enums.ExpenseCategory
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    invoiceNumber?: string | null
    invoiceId?: string | null
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    receiptUrl?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier?: SupplierCreateNestedOneWithoutExpensesInput
    tenant: TenantCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutTransactionsInput = {
    id?: string
    tenantId: string
    category: $Enums.ExpenseCategory
    supplierId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    invoiceNumber?: string | null
    invoiceId?: string | null
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    receiptUrl?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseCreateOrConnectWithoutTransactionsInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutTransactionsInput, ExpenseUncheckedCreateWithoutTransactionsInput>
  }

  export type InvoiceCreateWithoutTransactionsInput = {
    id?: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutInvoicesInput
    order?: SalesOrderCreateNestedOneWithoutInvoiceInput
    supplier?: SupplierCreateNestedOneWithoutInvoicesInput
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutTransactionsInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    customerId?: string | null
    supplierId?: string | null
    orderId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutTransactionsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
  }

  export type SalesOrderCreateWithoutTransactionsInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    orderedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdBy: string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    tenant: TenantCreateNestedOneWithoutOrdersInput
  }

  export type SalesOrderUncheckedCreateWithoutTransactionsInput = {
    id?: string
    tenantId: string
    orderNumber: string
    customerId: string
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    orderedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdBy: string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderCreateOrConnectWithoutTransactionsInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutTransactionsInput, SalesOrderUncheckedCreateWithoutTransactionsInput>
  }

  export type SupplierCreateWithoutTransactionsInput = {
    id?: string
    name: string
    category?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expenses?: ExpenseCreateNestedManyWithoutSupplierInput
    invoices?: InvoiceCreateNestedManyWithoutSupplierInput
    tenant: TenantCreateNestedOneWithoutSuppliersInput
  }

  export type SupplierUncheckedCreateWithoutTransactionsInput = {
    id?: string
    tenantId: string
    name: string
    category?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expenses?: ExpenseUncheckedCreateNestedManyWithoutSupplierInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutTransactionsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutTransactionsInput, SupplierUncheckedCreateWithoutTransactionsInput>
  }

  export type TenantCreateWithoutTransactionsInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchCreateNestedManyWithoutTenantInput
    budgets?: BudgetCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    Keg?: KegCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    recipes?: RecipeCreateNestedManyWithoutTenantInput
    orders?: SalesOrderCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    tanks?: TankCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchUncheckedCreateNestedManyWithoutTenantInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    Keg?: KegUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutTenantInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    tanks?: TankUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTransactionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTransactionsInput, TenantUncheckedCreateWithoutTransactionsInput>
  }

  export type CustomerUpsertWithoutTransactionsInput = {
    update: XOR<CustomerUpdateWithoutTransactionsInput, CustomerUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutTransactionsInput, CustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type CustomerUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    kegReturnDays?: IntFieldUpdateOperationsInput | number
    kegDepositRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    Keg?: KegUpdateManyWithoutCustomerNestedInput
    orders?: SalesOrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    kegReturnDays?: IntFieldUpdateOperationsInput | number
    kegDepositRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    Keg?: KegUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ExpenseUpsertWithoutTransactionsInput = {
    update: XOR<ExpenseUpdateWithoutTransactionsInput, ExpenseUncheckedUpdateWithoutTransactionsInput>
    create: XOR<ExpenseCreateWithoutTransactionsInput, ExpenseUncheckedCreateWithoutTransactionsInput>
    where?: ExpenseWhereInput
  }

  export type ExpenseUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: ExpenseWhereInput
    data: XOR<ExpenseUpdateWithoutTransactionsInput, ExpenseUncheckedUpdateWithoutTransactionsInput>
  }

  export type ExpenseUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneWithoutExpensesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpsertWithoutTransactionsInput = {
    update: XOR<InvoiceUpdateWithoutTransactionsInput, InvoiceUncheckedUpdateWithoutTransactionsInput>
    create: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutTransactionsInput, InvoiceUncheckedUpdateWithoutTransactionsInput>
  }

  export type InvoiceUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutInvoicesNestedInput
    order?: SalesOrderUpdateOneWithoutInvoiceNestedInput
    supplier?: SupplierUpdateOneWithoutInvoicesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type SalesOrderUpsertWithoutTransactionsInput = {
    update: XOR<SalesOrderUpdateWithoutTransactionsInput, SalesOrderUncheckedUpdateWithoutTransactionsInput>
    create: XOR<SalesOrderCreateWithoutTransactionsInput, SalesOrderUncheckedCreateWithoutTransactionsInput>
    where?: SalesOrderWhereInput
  }

  export type SalesOrderUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: SalesOrderWhereInput
    data: XOR<SalesOrderUpdateWithoutTransactionsInput, SalesOrderUncheckedUpdateWithoutTransactionsInput>
  }

  export type SalesOrderUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type SupplierUpsertWithoutTransactionsInput = {
    update: XOR<SupplierUpdateWithoutTransactionsInput, SupplierUncheckedUpdateWithoutTransactionsInput>
    create: XOR<SupplierCreateWithoutTransactionsInput, SupplierUncheckedCreateWithoutTransactionsInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutTransactionsInput, SupplierUncheckedUpdateWithoutTransactionsInput>
  }

  export type SupplierUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: ExpenseUpdateManyWithoutSupplierNestedInput
    invoices?: InvoiceUpdateManyWithoutSupplierNestedInput
    tenant?: TenantUpdateOneRequiredWithoutSuppliersNestedInput
  }

  export type SupplierUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: ExpenseUncheckedUpdateManyWithoutSupplierNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type TenantUpsertWithoutTransactionsInput = {
    update: XOR<TenantUpdateWithoutTransactionsInput, TenantUncheckedUpdateWithoutTransactionsInput>
    create: XOR<TenantCreateWithoutTransactionsInput, TenantUncheckedCreateWithoutTransactionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTransactionsInput, TenantUncheckedUpdateWithoutTransactionsInput>
  }

  export type TenantUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    Keg?: KegUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    tanks?: TankUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUncheckedUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    Keg?: KegUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    tanks?: TankUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CustomerCreateWithoutInvoicesInput = {
    id?: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    kegReturnDays?: number
    kegDepositRequired?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCustomersInput
    Keg?: KegCreateNestedManyWithoutCustomerInput
    orders?: SalesOrderCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutInvoicesInput = {
    id?: string
    tenantId: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    kegReturnDays?: number
    kegDepositRequired?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Keg?: KegUncheckedCreateNestedManyWithoutCustomerInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutInvoicesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
  }

  export type SalesOrderCreateWithoutInvoiceInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    orderedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdBy: string
    updatedAt?: Date | string
    items?: OrderItemCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    tenant: TenantCreateNestedOneWithoutOrdersInput
    transactions?: TransactionCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderUncheckedCreateWithoutInvoiceInput = {
    id?: string
    tenantId: string
    orderNumber: string
    customerId: string
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    orderedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdBy: string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderCreateOrConnectWithoutInvoiceInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutInvoiceInput, SalesOrderUncheckedCreateWithoutInvoiceInput>
  }

  export type SupplierCreateWithoutInvoicesInput = {
    id?: string
    name: string
    category?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expenses?: ExpenseCreateNestedManyWithoutSupplierInput
    tenant: TenantCreateNestedOneWithoutSuppliersInput
    transactions?: TransactionCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutInvoicesInput = {
    id?: string
    tenantId: string
    name: string
    category?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expenses?: ExpenseUncheckedCreateNestedManyWithoutSupplierInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutInvoicesInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutInvoicesInput, SupplierUncheckedCreateWithoutInvoicesInput>
  }

  export type TenantCreateWithoutInvoicesInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchCreateNestedManyWithoutTenantInput
    budgets?: BudgetCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemCreateNestedManyWithoutTenantInput
    Keg?: KegCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    recipes?: RecipeCreateNestedManyWithoutTenantInput
    orders?: SalesOrderCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    tanks?: TankCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchUncheckedCreateNestedManyWithoutTenantInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    Keg?: KegUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutTenantInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    tanks?: TankUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInvoicesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    productName?: string | null
    packageType?: $Enums.PackageType | null
    batchId?: string | null
    sortOrder?: number
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    productName?: string | null
    packageType?: $Enums.PackageType | null
    batchId?: string | null
    sortOrder?: number
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PaymentMethod
    date?: Date | string
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    order?: SalesOrderCreateNestedOneWithoutPaymentsInput
    tenant: TenantCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    tenantId: string
    orderId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PaymentMethod
    date?: Date | string
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutInvoiceInput = {
    id?: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    expense?: ExpenseCreateNestedOneWithoutTransactionsInput
    order?: SalesOrderCreateNestedOneWithoutTransactionsInput
    supplier?: SupplierCreateNestedOneWithoutTransactionsInput
    tenant: TenantCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutInvoiceInput = {
    id?: string
    tenantId: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    customerId?: string | null
    supplierId?: string | null
    orderId?: string | null
    expenseId?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutInvoiceInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput>
  }

  export type TransactionCreateManyInvoiceInputEnvelope = {
    data: TransactionCreateManyInvoiceInput | TransactionCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutInvoicesInput = {
    update: XOR<CustomerUpdateWithoutInvoicesInput, CustomerUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutInvoicesInput, CustomerUncheckedUpdateWithoutInvoicesInput>
  }

  export type CustomerUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    kegReturnDays?: IntFieldUpdateOperationsInput | number
    kegDepositRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    Keg?: KegUpdateManyWithoutCustomerNestedInput
    orders?: SalesOrderUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    kegReturnDays?: IntFieldUpdateOperationsInput | number
    kegDepositRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Keg?: KegUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type SalesOrderUpsertWithoutInvoiceInput = {
    update: XOR<SalesOrderUpdateWithoutInvoiceInput, SalesOrderUncheckedUpdateWithoutInvoiceInput>
    create: XOR<SalesOrderCreateWithoutInvoiceInput, SalesOrderUncheckedCreateWithoutInvoiceInput>
    where?: SalesOrderWhereInput
  }

  export type SalesOrderUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: SalesOrderWhereInput
    data: XOR<SalesOrderUpdateWithoutInvoiceInput, SalesOrderUncheckedUpdateWithoutInvoiceInput>
  }

  export type SalesOrderUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    transactions?: TransactionUpdateManyWithoutOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type SupplierUpsertWithoutInvoicesInput = {
    update: XOR<SupplierUpdateWithoutInvoicesInput, SupplierUncheckedUpdateWithoutInvoicesInput>
    create: XOR<SupplierCreateWithoutInvoicesInput, SupplierUncheckedCreateWithoutInvoicesInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutInvoicesInput, SupplierUncheckedUpdateWithoutInvoicesInput>
  }

  export type SupplierUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: ExpenseUpdateManyWithoutSupplierNestedInput
    tenant?: TenantUpdateOneRequiredWithoutSuppliersNestedInput
    transactions?: TransactionUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: ExpenseUncheckedUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type TenantUpsertWithoutInvoicesInput = {
    update: XOR<TenantUpdateWithoutInvoicesInput, TenantUncheckedUpdateWithoutInvoicesInput>
    create: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInvoicesInput, TenantUncheckedUpdateWithoutInvoicesInput>
  }

  export type TenantUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUpdateManyWithoutTenantNestedInput
    Keg?: KegUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    tanks?: TankUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUncheckedUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    Keg?: KegUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    tanks?: TankUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    unit?: StringNullableFilter<"InvoiceItem"> | string | null
    unitPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    productName?: StringNullableFilter<"InvoiceItem"> | string | null
    packageType?: EnumPackageTypeNullableFilter<"InvoiceItem"> | $Enums.PackageType | null
    batchId?: StringNullableFilter<"InvoiceItem"> | string | null
    sortOrder?: IntFilter<"InvoiceItem"> | number
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutInvoiceInput, TransactionUncheckedUpdateWithoutInvoiceInput>
    create: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutInvoiceInput, TransactionUncheckedUpdateWithoutInvoiceInput>
  }

  export type TransactionUpdateManyWithWhereWithoutInvoiceInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceCreateWithoutItemsInput = {
    id?: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutInvoicesInput
    order?: SalesOrderCreateNestedOneWithoutInvoiceInput
    supplier?: SupplierCreateNestedOneWithoutInvoicesInput
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    customerId?: string | null
    supplierId?: string | null
    orderId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
  }

  export type InvoiceUpsertWithoutItemsInput = {
    update: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutInvoicesNestedInput
    order?: SalesOrderUpdateOneWithoutInvoiceNestedInput
    supplier?: SupplierUpdateOneWithoutInvoicesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutInvoicesInput
    order?: SalesOrderCreateNestedOneWithoutInvoiceInput
    supplier?: SupplierCreateNestedOneWithoutInvoicesInput
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    customerId?: string | null
    supplierId?: string | null
    orderId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type SalesOrderCreateWithoutPaymentsInput = {
    id?: string
    orderNumber: string
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    orderedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdBy: string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    tenant: TenantCreateNestedOneWithoutOrdersInput
    transactions?: TransactionCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderUncheckedCreateWithoutPaymentsInput = {
    id?: string
    tenantId: string
    orderNumber: string
    customerId: string
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    orderedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdBy: string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderCreateOrConnectWithoutPaymentsInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutPaymentsInput, SalesOrderUncheckedCreateWithoutPaymentsInput>
  }

  export type TenantCreateWithoutPaymentsInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchCreateNestedManyWithoutTenantInput
    budgets?: BudgetCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    Keg?: KegCreateNestedManyWithoutTenantInput
    recipes?: RecipeCreateNestedManyWithoutTenantInput
    orders?: SalesOrderCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    tanks?: TankCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchUncheckedCreateNestedManyWithoutTenantInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    Keg?: KegUncheckedCreateNestedManyWithoutTenantInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutTenantInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    tanks?: TankUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPaymentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutInvoicesNestedInput
    order?: SalesOrderUpdateOneWithoutInvoiceNestedInput
    supplier?: SupplierUpdateOneWithoutInvoicesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type SalesOrderUpsertWithoutPaymentsInput = {
    update: XOR<SalesOrderUpdateWithoutPaymentsInput, SalesOrderUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SalesOrderCreateWithoutPaymentsInput, SalesOrderUncheckedCreateWithoutPaymentsInput>
    where?: SalesOrderWhereInput
  }

  export type SalesOrderUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SalesOrderWhereInput
    data: XOR<SalesOrderUpdateWithoutPaymentsInput, SalesOrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type SalesOrderUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    transactions?: TransactionUpdateManyWithoutOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type TenantUpsertWithoutPaymentsInput = {
    update: XOR<TenantUpdateWithoutPaymentsInput, TenantUncheckedUpdateWithoutPaymentsInput>
    create: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPaymentsInput, TenantUncheckedUpdateWithoutPaymentsInput>
  }

  export type TenantUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    Keg?: KegUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    tanks?: TankUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUncheckedUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    Keg?: KegUncheckedUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    tanks?: TankUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SupplierCreateWithoutExpensesInput = {
    id?: string
    name: string
    category?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutSupplierInput
    tenant: TenantCreateNestedOneWithoutSuppliersInput
    transactions?: TransactionCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutExpensesInput = {
    id?: string
    tenantId: string
    name: string
    category?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSupplierInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutExpensesInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutExpensesInput, SupplierUncheckedCreateWithoutExpensesInput>
  }

  export type TenantCreateWithoutExpensesInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchCreateNestedManyWithoutTenantInput
    budgets?: BudgetCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    Keg?: KegCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    recipes?: RecipeCreateNestedManyWithoutTenantInput
    orders?: SalesOrderCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    tanks?: TankCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutExpensesInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchUncheckedCreateNestedManyWithoutTenantInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    Keg?: KegUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutTenantInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    tanks?: TankUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutExpensesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutExpensesInput, TenantUncheckedCreateWithoutExpensesInput>
  }

  export type TransactionCreateWithoutExpenseInput = {
    id?: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    invoice?: InvoiceCreateNestedOneWithoutTransactionsInput
    order?: SalesOrderCreateNestedOneWithoutTransactionsInput
    supplier?: SupplierCreateNestedOneWithoutTransactionsInput
    tenant: TenantCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutExpenseInput = {
    id?: string
    tenantId: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    customerId?: string | null
    supplierId?: string | null
    orderId?: string | null
    invoiceId?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutExpenseInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutExpenseInput, TransactionUncheckedCreateWithoutExpenseInput>
  }

  export type TransactionCreateManyExpenseInputEnvelope = {
    data: TransactionCreateManyExpenseInput | TransactionCreateManyExpenseInput[]
    skipDuplicates?: boolean
  }

  export type SupplierUpsertWithoutExpensesInput = {
    update: XOR<SupplierUpdateWithoutExpensesInput, SupplierUncheckedUpdateWithoutExpensesInput>
    create: XOR<SupplierCreateWithoutExpensesInput, SupplierUncheckedCreateWithoutExpensesInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutExpensesInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutExpensesInput, SupplierUncheckedUpdateWithoutExpensesInput>
  }

  export type SupplierUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutSupplierNestedInput
    tenant?: TenantUpdateOneRequiredWithoutSuppliersNestedInput
    transactions?: TransactionUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type TenantUpsertWithoutExpensesInput = {
    update: XOR<TenantUpdateWithoutExpensesInput, TenantUncheckedUpdateWithoutExpensesInput>
    create: XOR<TenantCreateWithoutExpensesInput, TenantUncheckedCreateWithoutExpensesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutExpensesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutExpensesInput, TenantUncheckedUpdateWithoutExpensesInput>
  }

  export type TenantUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    Keg?: KegUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    tanks?: TankUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUncheckedUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    Keg?: KegUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    tanks?: TankUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutExpenseInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutExpenseInput, TransactionUncheckedUpdateWithoutExpenseInput>
    create: XOR<TransactionCreateWithoutExpenseInput, TransactionUncheckedCreateWithoutExpenseInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutExpenseInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutExpenseInput, TransactionUncheckedUpdateWithoutExpenseInput>
  }

  export type TransactionUpdateManyWithWhereWithoutExpenseInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutExpenseInput>
  }

  export type TenantCreateWithoutBudgetsInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    Keg?: KegCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    recipes?: RecipeCreateNestedManyWithoutTenantInput
    orders?: SalesOrderCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    tanks?: TankCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutBudgetsInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    Keg?: KegUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutTenantInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    tanks?: TankUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutBudgetsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutBudgetsInput, TenantUncheckedCreateWithoutBudgetsInput>
  }

  export type TenantUpsertWithoutBudgetsInput = {
    update: XOR<TenantUpdateWithoutBudgetsInput, TenantUncheckedUpdateWithoutBudgetsInput>
    create: XOR<TenantCreateWithoutBudgetsInput, TenantUncheckedCreateWithoutBudgetsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutBudgetsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutBudgetsInput, TenantUncheckedUpdateWithoutBudgetsInput>
  }

  export type TenantUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    Keg?: KegUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    tanks?: TankUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    Keg?: KegUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    tanks?: TankUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type EquipmentCreateWithoutCIPLogInput = {
    id: string
    name: string
    type: string
    status?: string
    capacity?: number | null
    model?: string | null
    manufacturer?: string | null
    serialNumber?: string | null
    location?: string | null
    workingPressure?: number | null
    currentTemp?: number | null
    currentPressure?: number | null
    installationDate?: Date | string | null
    warrantyDate?: Date | string | null
    lastCIP?: Date | string | null
    nextCIP?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    cipIntervalDays?: number
    inspectionIntervalDays?: number
    annualMaintenanceDays?: number
    currentBatchId?: string | null
    currentBatchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    purchaseDate?: Date | string | null
    capabilities?: EquipmentCreatecapabilitiesInput | string[]
    Tenant: TenantCreateNestedOneWithoutEquipmentInput
    MaintenanceLog?: MaintenanceLogCreateNestedManyWithoutEquipmentInput
    ProblemReport?: ProblemReportCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutCIPLogInput = {
    id: string
    tenantId: string
    name: string
    type: string
    status?: string
    capacity?: number | null
    model?: string | null
    manufacturer?: string | null
    serialNumber?: string | null
    location?: string | null
    workingPressure?: number | null
    currentTemp?: number | null
    currentPressure?: number | null
    installationDate?: Date | string | null
    warrantyDate?: Date | string | null
    lastCIP?: Date | string | null
    nextCIP?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    cipIntervalDays?: number
    inspectionIntervalDays?: number
    annualMaintenanceDays?: number
    currentBatchId?: string | null
    currentBatchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    purchaseDate?: Date | string | null
    capabilities?: EquipmentCreatecapabilitiesInput | string[]
    MaintenanceLog?: MaintenanceLogUncheckedCreateNestedManyWithoutEquipmentInput
    ProblemReport?: ProblemReportUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutCIPLogInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutCIPLogInput, EquipmentUncheckedCreateWithoutCIPLogInput>
  }

  export type EquipmentUpsertWithoutCIPLogInput = {
    update: XOR<EquipmentUpdateWithoutCIPLogInput, EquipmentUncheckedUpdateWithoutCIPLogInput>
    create: XOR<EquipmentCreateWithoutCIPLogInput, EquipmentUncheckedCreateWithoutCIPLogInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutCIPLogInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutCIPLogInput, EquipmentUncheckedUpdateWithoutCIPLogInput>
  }

  export type EquipmentUpdateWithoutCIPLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workingPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    currentTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cipIntervalDays?: IntFieldUpdateOperationsInput | number
    inspectionIntervalDays?: IntFieldUpdateOperationsInput | number
    annualMaintenanceDays?: IntFieldUpdateOperationsInput | number
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBatchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capabilities?: EquipmentUpdatecapabilitiesInput | string[]
    Tenant?: TenantUpdateOneRequiredWithoutEquipmentNestedInput
    MaintenanceLog?: MaintenanceLogUpdateManyWithoutEquipmentNestedInput
    ProblemReport?: ProblemReportUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutCIPLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workingPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    currentTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cipIntervalDays?: IntFieldUpdateOperationsInput | number
    inspectionIntervalDays?: IntFieldUpdateOperationsInput | number
    annualMaintenanceDays?: IntFieldUpdateOperationsInput | number
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBatchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capabilities?: EquipmentUpdatecapabilitiesInput | string[]
    MaintenanceLog?: MaintenanceLogUncheckedUpdateManyWithoutEquipmentNestedInput
    ProblemReport?: ProblemReportUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type CIPLogCreateWithoutEquipmentInput = {
    id: string
    cipType: string
    date: Date | string
    duration: number
    temperature?: number | null
    causticConcentration?: number | null
    performedBy: string
    result: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type CIPLogUncheckedCreateWithoutEquipmentInput = {
    id: string
    cipType: string
    date: Date | string
    duration: number
    temperature?: number | null
    causticConcentration?: number | null
    performedBy: string
    result: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type CIPLogCreateOrConnectWithoutEquipmentInput = {
    where: CIPLogWhereUniqueInput
    create: XOR<CIPLogCreateWithoutEquipmentInput, CIPLogUncheckedCreateWithoutEquipmentInput>
  }

  export type CIPLogCreateManyEquipmentInputEnvelope = {
    data: CIPLogCreateManyEquipmentInput | CIPLogCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutEquipmentInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchCreateNestedManyWithoutTenantInput
    budgets?: BudgetCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    Keg?: KegCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    recipes?: RecipeCreateNestedManyWithoutTenantInput
    orders?: SalesOrderCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    tanks?: TankCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutEquipmentInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchUncheckedCreateNestedManyWithoutTenantInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    Keg?: KegUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutTenantInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    tanks?: TankUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutEquipmentInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutEquipmentInput, TenantUncheckedCreateWithoutEquipmentInput>
  }

  export type MaintenanceLogCreateWithoutEquipmentInput = {
    id: string
    type: string
    status: string
    priority?: string | null
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    duration?: number | null
    performedBy?: string | null
    cost?: number | null
    partsUsed?: MaintenanceLogCreatepartsUsedInput | string[]
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MaintenanceLogUncheckedCreateWithoutEquipmentInput = {
    id: string
    type: string
    status: string
    priority?: string | null
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    duration?: number | null
    performedBy?: string | null
    cost?: number | null
    partsUsed?: MaintenanceLogCreatepartsUsedInput | string[]
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type MaintenanceLogCreateOrConnectWithoutEquipmentInput = {
    where: MaintenanceLogWhereUniqueInput
    create: XOR<MaintenanceLogCreateWithoutEquipmentInput, MaintenanceLogUncheckedCreateWithoutEquipmentInput>
  }

  export type MaintenanceLogCreateManyEquipmentInputEnvelope = {
    data: MaintenanceLogCreateManyEquipmentInput | MaintenanceLogCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type ProblemReportCreateWithoutEquipmentInput = {
    id: string
    problemType: string
    severity: string
    status?: string
    description: string
    reportedDate: Date | string
    reportedBy: string
    resolvedDate?: Date | string | null
    resolvedBy?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ProblemReportUncheckedCreateWithoutEquipmentInput = {
    id: string
    problemType: string
    severity: string
    status?: string
    description: string
    reportedDate: Date | string
    reportedBy: string
    resolvedDate?: Date | string | null
    resolvedBy?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ProblemReportCreateOrConnectWithoutEquipmentInput = {
    where: ProblemReportWhereUniqueInput
    create: XOR<ProblemReportCreateWithoutEquipmentInput, ProblemReportUncheckedCreateWithoutEquipmentInput>
  }

  export type ProblemReportCreateManyEquipmentInputEnvelope = {
    data: ProblemReportCreateManyEquipmentInput | ProblemReportCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type CIPLogUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: CIPLogWhereUniqueInput
    update: XOR<CIPLogUpdateWithoutEquipmentInput, CIPLogUncheckedUpdateWithoutEquipmentInput>
    create: XOR<CIPLogCreateWithoutEquipmentInput, CIPLogUncheckedCreateWithoutEquipmentInput>
  }

  export type CIPLogUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: CIPLogWhereUniqueInput
    data: XOR<CIPLogUpdateWithoutEquipmentInput, CIPLogUncheckedUpdateWithoutEquipmentInput>
  }

  export type CIPLogUpdateManyWithWhereWithoutEquipmentInput = {
    where: CIPLogScalarWhereInput
    data: XOR<CIPLogUpdateManyMutationInput, CIPLogUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type CIPLogScalarWhereInput = {
    AND?: CIPLogScalarWhereInput | CIPLogScalarWhereInput[]
    OR?: CIPLogScalarWhereInput[]
    NOT?: CIPLogScalarWhereInput | CIPLogScalarWhereInput[]
    id?: StringFilter<"CIPLog"> | string
    equipmentId?: StringFilter<"CIPLog"> | string
    cipType?: StringFilter<"CIPLog"> | string
    date?: DateTimeFilter<"CIPLog"> | Date | string
    duration?: IntFilter<"CIPLog"> | number
    temperature?: FloatNullableFilter<"CIPLog"> | number | null
    causticConcentration?: FloatNullableFilter<"CIPLog"> | number | null
    performedBy?: StringFilter<"CIPLog"> | string
    result?: StringFilter<"CIPLog"> | string
    notes?: StringNullableFilter<"CIPLog"> | string | null
    createdAt?: DateTimeFilter<"CIPLog"> | Date | string
  }

  export type TenantUpsertWithoutEquipmentInput = {
    update: XOR<TenantUpdateWithoutEquipmentInput, TenantUncheckedUpdateWithoutEquipmentInput>
    create: XOR<TenantCreateWithoutEquipmentInput, TenantUncheckedCreateWithoutEquipmentInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutEquipmentInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutEquipmentInput, TenantUncheckedUpdateWithoutEquipmentInput>
  }

  export type TenantUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    Keg?: KegUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    tanks?: TankUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUncheckedUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    Keg?: KegUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    tanks?: TankUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type MaintenanceLogUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: MaintenanceLogWhereUniqueInput
    update: XOR<MaintenanceLogUpdateWithoutEquipmentInput, MaintenanceLogUncheckedUpdateWithoutEquipmentInput>
    create: XOR<MaintenanceLogCreateWithoutEquipmentInput, MaintenanceLogUncheckedCreateWithoutEquipmentInput>
  }

  export type MaintenanceLogUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: MaintenanceLogWhereUniqueInput
    data: XOR<MaintenanceLogUpdateWithoutEquipmentInput, MaintenanceLogUncheckedUpdateWithoutEquipmentInput>
  }

  export type MaintenanceLogUpdateManyWithWhereWithoutEquipmentInput = {
    where: MaintenanceLogScalarWhereInput
    data: XOR<MaintenanceLogUpdateManyMutationInput, MaintenanceLogUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type MaintenanceLogScalarWhereInput = {
    AND?: MaintenanceLogScalarWhereInput | MaintenanceLogScalarWhereInput[]
    OR?: MaintenanceLogScalarWhereInput[]
    NOT?: MaintenanceLogScalarWhereInput | MaintenanceLogScalarWhereInput[]
    id?: StringFilter<"MaintenanceLog"> | string
    equipmentId?: StringFilter<"MaintenanceLog"> | string
    type?: StringFilter<"MaintenanceLog"> | string
    status?: StringFilter<"MaintenanceLog"> | string
    priority?: StringNullableFilter<"MaintenanceLog"> | string | null
    scheduledDate?: DateTimeNullableFilter<"MaintenanceLog"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"MaintenanceLog"> | Date | string | null
    duration?: IntNullableFilter<"MaintenanceLog"> | number | null
    performedBy?: StringNullableFilter<"MaintenanceLog"> | string | null
    cost?: FloatNullableFilter<"MaintenanceLog"> | number | null
    partsUsed?: StringNullableListFilter<"MaintenanceLog">
    description?: StringNullableFilter<"MaintenanceLog"> | string | null
    createdAt?: DateTimeFilter<"MaintenanceLog"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceLog"> | Date | string
  }

  export type ProblemReportUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: ProblemReportWhereUniqueInput
    update: XOR<ProblemReportUpdateWithoutEquipmentInput, ProblemReportUncheckedUpdateWithoutEquipmentInput>
    create: XOR<ProblemReportCreateWithoutEquipmentInput, ProblemReportUncheckedCreateWithoutEquipmentInput>
  }

  export type ProblemReportUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: ProblemReportWhereUniqueInput
    data: XOR<ProblemReportUpdateWithoutEquipmentInput, ProblemReportUncheckedUpdateWithoutEquipmentInput>
  }

  export type ProblemReportUpdateManyWithWhereWithoutEquipmentInput = {
    where: ProblemReportScalarWhereInput
    data: XOR<ProblemReportUpdateManyMutationInput, ProblemReportUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type ProblemReportScalarWhereInput = {
    AND?: ProblemReportScalarWhereInput | ProblemReportScalarWhereInput[]
    OR?: ProblemReportScalarWhereInput[]
    NOT?: ProblemReportScalarWhereInput | ProblemReportScalarWhereInput[]
    id?: StringFilter<"ProblemReport"> | string
    equipmentId?: StringFilter<"ProblemReport"> | string
    problemType?: StringFilter<"ProblemReport"> | string
    severity?: StringFilter<"ProblemReport"> | string
    status?: StringFilter<"ProblemReport"> | string
    description?: StringFilter<"ProblemReport"> | string
    reportedDate?: DateTimeFilter<"ProblemReport"> | Date | string
    reportedBy?: StringFilter<"ProblemReport"> | string
    resolvedDate?: DateTimeNullableFilter<"ProblemReport"> | Date | string | null
    resolvedBy?: StringNullableFilter<"ProblemReport"> | string | null
    resolution?: StringNullableFilter<"ProblemReport"> | string | null
    createdAt?: DateTimeFilter<"ProblemReport"> | Date | string
    updatedAt?: DateTimeFilter<"ProblemReport"> | Date | string
  }

  export type LotCreateWithoutOther_LotInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
    Lot?: LotCreateNestedOneWithoutOther_LotInput
    LotBatch?: LotBatchCreateNestedManyWithoutLotInput
    LotReading?: LotReadingCreateNestedManyWithoutLotInput
    QCTest?: QCTestCreateNestedManyWithoutLotInput
    TankAssignment?: TankAssignmentCreateNestedManyWithoutLotInput
    Transfer_Transfer_destLotIdToLot?: TransferCreateNestedManyWithoutLot_Transfer_destLotIdToLotInput
    Transfer_Transfer_sourceLotIdToLot?: TransferCreateNestedManyWithoutLot_Transfer_sourceLotIdToLotInput
  }

  export type LotUncheckedCreateWithoutOther_LotInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    parentLotId?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
    LotBatch?: LotBatchUncheckedCreateNestedManyWithoutLotInput
    LotReading?: LotReadingUncheckedCreateNestedManyWithoutLotInput
    QCTest?: QCTestUncheckedCreateNestedManyWithoutLotInput
    TankAssignment?: TankAssignmentUncheckedCreateNestedManyWithoutLotInput
    Transfer_Transfer_destLotIdToLot?: TransferUncheckedCreateNestedManyWithoutLot_Transfer_destLotIdToLotInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUncheckedCreateNestedManyWithoutLot_Transfer_sourceLotIdToLotInput
  }

  export type LotCreateOrConnectWithoutOther_LotInput = {
    where: LotWhereUniqueInput
    create: XOR<LotCreateWithoutOther_LotInput, LotUncheckedCreateWithoutOther_LotInput>
  }

  export type LotCreateWithoutLotInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
    other_Lot?: LotCreateNestedManyWithoutLotInput
    LotBatch?: LotBatchCreateNestedManyWithoutLotInput
    LotReading?: LotReadingCreateNestedManyWithoutLotInput
    QCTest?: QCTestCreateNestedManyWithoutLotInput
    TankAssignment?: TankAssignmentCreateNestedManyWithoutLotInput
    Transfer_Transfer_destLotIdToLot?: TransferCreateNestedManyWithoutLot_Transfer_destLotIdToLotInput
    Transfer_Transfer_sourceLotIdToLot?: TransferCreateNestedManyWithoutLot_Transfer_sourceLotIdToLotInput
  }

  export type LotUncheckedCreateWithoutLotInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
    other_Lot?: LotUncheckedCreateNestedManyWithoutLotInput
    LotBatch?: LotBatchUncheckedCreateNestedManyWithoutLotInput
    LotReading?: LotReadingUncheckedCreateNestedManyWithoutLotInput
    QCTest?: QCTestUncheckedCreateNestedManyWithoutLotInput
    TankAssignment?: TankAssignmentUncheckedCreateNestedManyWithoutLotInput
    Transfer_Transfer_destLotIdToLot?: TransferUncheckedCreateNestedManyWithoutLot_Transfer_destLotIdToLotInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUncheckedCreateNestedManyWithoutLot_Transfer_sourceLotIdToLotInput
  }

  export type LotCreateOrConnectWithoutLotInput = {
    where: LotWhereUniqueInput
    create: XOR<LotCreateWithoutLotInput, LotUncheckedCreateWithoutLotInput>
  }

  export type LotCreateManyLotInputEnvelope = {
    data: LotCreateManyLotInput | LotCreateManyLotInput[]
    skipDuplicates?: boolean
  }

  export type LotBatchCreateWithoutLotInput = {
    id: string
    volumeContribution: Decimal | DecimalJsLike | number | string
    batchPercentage?: Decimal | DecimalJsLike | number | string
    addedAt?: Date | string
    Batch: BatchCreateNestedOneWithoutLotBatchInput
  }

  export type LotBatchUncheckedCreateWithoutLotInput = {
    id: string
    batchId: string
    volumeContribution: Decimal | DecimalJsLike | number | string
    batchPercentage?: Decimal | DecimalJsLike | number | string
    addedAt?: Date | string
  }

  export type LotBatchCreateOrConnectWithoutLotInput = {
    where: LotBatchWhereUniqueInput
    create: XOR<LotBatchCreateWithoutLotInput, LotBatchUncheckedCreateWithoutLotInput>
  }

  export type LotBatchCreateManyLotInputEnvelope = {
    data: LotBatchCreateManyLotInput | LotBatchCreateManyLotInput[]
    skipDuplicates?: boolean
  }

  export type LotReadingCreateWithoutLotInput = {
    id: string
    readingType: $Enums.ReadingType
    value: Decimal | DecimalJsLike | number | string
    unit: string
    notes?: string | null
    recordedBy: string
    recordedAt?: Date | string
    Tank: TankCreateNestedOneWithoutLotReadingInput
  }

  export type LotReadingUncheckedCreateWithoutLotInput = {
    id: string
    tankId: string
    readingType: $Enums.ReadingType
    value: Decimal | DecimalJsLike | number | string
    unit: string
    notes?: string | null
    recordedBy: string
    recordedAt?: Date | string
  }

  export type LotReadingCreateOrConnectWithoutLotInput = {
    where: LotReadingWhereUniqueInput
    create: XOR<LotReadingCreateWithoutLotInput, LotReadingUncheckedCreateWithoutLotInput>
  }

  export type LotReadingCreateManyLotInputEnvelope = {
    data: LotReadingCreateManyLotInput | LotReadingCreateManyLotInput[]
    skipDuplicates?: boolean
  }

  export type QCTestCreateWithoutLotInput = {
    id: string
    tenantId: string
    testType: $Enums.QCTestType
    status?: $Enums.QCTestStatus
    priority?: $Enums.QCTestPriority
    scheduledDate: Date | string
    completedDate?: Date | string | null
    minValue?: Decimal | DecimalJsLike | number | string | null
    maxValue?: Decimal | DecimalJsLike | number | string | null
    targetValue?: Decimal | DecimalJsLike | number | string | null
    result?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    performedBy?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
    Batch: BatchCreateNestedOneWithoutQCTestInput
  }

  export type QCTestUncheckedCreateWithoutLotInput = {
    id: string
    tenantId: string
    batchId: string
    testType: $Enums.QCTestType
    status?: $Enums.QCTestStatus
    priority?: $Enums.QCTestPriority
    scheduledDate: Date | string
    completedDate?: Date | string | null
    minValue?: Decimal | DecimalJsLike | number | string | null
    maxValue?: Decimal | DecimalJsLike | number | string | null
    targetValue?: Decimal | DecimalJsLike | number | string | null
    result?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    performedBy?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type QCTestCreateOrConnectWithoutLotInput = {
    where: QCTestWhereUniqueInput
    create: XOR<QCTestCreateWithoutLotInput, QCTestUncheckedCreateWithoutLotInput>
  }

  export type QCTestCreateManyLotInputEnvelope = {
    data: QCTestCreateManyLotInput | QCTestCreateManyLotInput[]
    skipDuplicates?: boolean
  }

  export type TankAssignmentCreateWithoutLotInput = {
    id: string
    tenantId: string
    phase: $Enums.LotPhase
    plannedStart?: Date | string | null
    plannedEnd?: Date | string | null
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.AssignmentStatus
    plannedVolume?: Decimal | DecimalJsLike | number | string | null
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: boolean
    isSplitSource?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    notes?: string | null
    Tank: TankCreateNestedOneWithoutTankAssignmentInput
  }

  export type TankAssignmentUncheckedCreateWithoutLotInput = {
    id: string
    tenantId: string
    tankId: string
    phase: $Enums.LotPhase
    plannedStart?: Date | string | null
    plannedEnd?: Date | string | null
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.AssignmentStatus
    plannedVolume?: Decimal | DecimalJsLike | number | string | null
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: boolean
    isSplitSource?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    notes?: string | null
  }

  export type TankAssignmentCreateOrConnectWithoutLotInput = {
    where: TankAssignmentWhereUniqueInput
    create: XOR<TankAssignmentCreateWithoutLotInput, TankAssignmentUncheckedCreateWithoutLotInput>
  }

  export type TankAssignmentCreateManyLotInputEnvelope = {
    data: TankAssignmentCreateManyLotInput | TankAssignmentCreateManyLotInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutLot_Transfer_destLotIdToLotInput = {
    id: string
    tenantId: string
    transferCode: string
    transferType: $Enums.TransferType
    volume: Decimal | DecimalJsLike | number | string
    plannedAt: Date | string
    executedAt?: Date | string | null
    status?: $Enums.TransferStatus
    measuredLoss?: Decimal | DecimalJsLike | number | string | null
    lossReason?: string | null
    performedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Tank_Transfer_destTankIdToTank: TankCreateNestedOneWithoutTransfer_Transfer_destTankIdToTankInput
    Lot_Transfer_sourceLotIdToLot?: LotCreateNestedOneWithoutTransfer_Transfer_sourceLotIdToLotInput
    Tank_Transfer_sourceTankIdToTank: TankCreateNestedOneWithoutTransfer_Transfer_sourceTankIdToTankInput
  }

  export type TransferUncheckedCreateWithoutLot_Transfer_destLotIdToLotInput = {
    id: string
    tenantId: string
    transferCode: string
    sourceLotId?: string | null
    sourceTankId: string
    destTankId: string
    transferType: $Enums.TransferType
    volume: Decimal | DecimalJsLike | number | string
    plannedAt: Date | string
    executedAt?: Date | string | null
    status?: $Enums.TransferStatus
    measuredLoss?: Decimal | DecimalJsLike | number | string | null
    lossReason?: string | null
    performedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateOrConnectWithoutLot_Transfer_destLotIdToLotInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutLot_Transfer_destLotIdToLotInput, TransferUncheckedCreateWithoutLot_Transfer_destLotIdToLotInput>
  }

  export type TransferCreateManyLot_Transfer_destLotIdToLotInputEnvelope = {
    data: TransferCreateManyLot_Transfer_destLotIdToLotInput | TransferCreateManyLot_Transfer_destLotIdToLotInput[]
    skipDuplicates?: boolean
  }

  export type TransferCreateWithoutLot_Transfer_sourceLotIdToLotInput = {
    id: string
    tenantId: string
    transferCode: string
    transferType: $Enums.TransferType
    volume: Decimal | DecimalJsLike | number | string
    plannedAt: Date | string
    executedAt?: Date | string | null
    status?: $Enums.TransferStatus
    measuredLoss?: Decimal | DecimalJsLike | number | string | null
    lossReason?: string | null
    performedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Lot_Transfer_destLotIdToLot?: LotCreateNestedOneWithoutTransfer_Transfer_destLotIdToLotInput
    Tank_Transfer_destTankIdToTank: TankCreateNestedOneWithoutTransfer_Transfer_destTankIdToTankInput
    Tank_Transfer_sourceTankIdToTank: TankCreateNestedOneWithoutTransfer_Transfer_sourceTankIdToTankInput
  }

  export type TransferUncheckedCreateWithoutLot_Transfer_sourceLotIdToLotInput = {
    id: string
    tenantId: string
    transferCode: string
    sourceTankId: string
    destLotId?: string | null
    destTankId: string
    transferType: $Enums.TransferType
    volume: Decimal | DecimalJsLike | number | string
    plannedAt: Date | string
    executedAt?: Date | string | null
    status?: $Enums.TransferStatus
    measuredLoss?: Decimal | DecimalJsLike | number | string | null
    lossReason?: string | null
    performedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateOrConnectWithoutLot_Transfer_sourceLotIdToLotInput = {
    where: TransferWhereUniqueInput
    create: XOR<TransferCreateWithoutLot_Transfer_sourceLotIdToLotInput, TransferUncheckedCreateWithoutLot_Transfer_sourceLotIdToLotInput>
  }

  export type TransferCreateManyLot_Transfer_sourceLotIdToLotInputEnvelope = {
    data: TransferCreateManyLot_Transfer_sourceLotIdToLotInput | TransferCreateManyLot_Transfer_sourceLotIdToLotInput[]
    skipDuplicates?: boolean
  }

  export type LotUpsertWithoutOther_LotInput = {
    update: XOR<LotUpdateWithoutOther_LotInput, LotUncheckedUpdateWithoutOther_LotInput>
    create: XOR<LotCreateWithoutOther_LotInput, LotUncheckedCreateWithoutOther_LotInput>
    where?: LotWhereInput
  }

  export type LotUpdateToOneWithWhereWithoutOther_LotInput = {
    where?: LotWhereInput
    data: XOR<LotUpdateWithoutOther_LotInput, LotUncheckedUpdateWithoutOther_LotInput>
  }

  export type LotUpdateWithoutOther_LotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Lot?: LotUpdateOneWithoutOther_LotNestedInput
    LotBatch?: LotBatchUpdateManyWithoutLotNestedInput
    LotReading?: LotReadingUpdateManyWithoutLotNestedInput
    QCTest?: QCTestUpdateManyWithoutLotNestedInput
    TankAssignment?: TankAssignmentUpdateManyWithoutLotNestedInput
    Transfer_Transfer_destLotIdToLot?: TransferUpdateManyWithoutLot_Transfer_destLotIdToLotNestedInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUpdateManyWithoutLot_Transfer_sourceLotIdToLotNestedInput
  }

  export type LotUncheckedUpdateWithoutOther_LotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LotBatch?: LotBatchUncheckedUpdateManyWithoutLotNestedInput
    LotReading?: LotReadingUncheckedUpdateManyWithoutLotNestedInput
    QCTest?: QCTestUncheckedUpdateManyWithoutLotNestedInput
    TankAssignment?: TankAssignmentUncheckedUpdateManyWithoutLotNestedInput
    Transfer_Transfer_destLotIdToLot?: TransferUncheckedUpdateManyWithoutLot_Transfer_destLotIdToLotNestedInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUncheckedUpdateManyWithoutLot_Transfer_sourceLotIdToLotNestedInput
  }

  export type LotUpsertWithWhereUniqueWithoutLotInput = {
    where: LotWhereUniqueInput
    update: XOR<LotUpdateWithoutLotInput, LotUncheckedUpdateWithoutLotInput>
    create: XOR<LotCreateWithoutLotInput, LotUncheckedCreateWithoutLotInput>
  }

  export type LotUpdateWithWhereUniqueWithoutLotInput = {
    where: LotWhereUniqueInput
    data: XOR<LotUpdateWithoutLotInput, LotUncheckedUpdateWithoutLotInput>
  }

  export type LotUpdateManyWithWhereWithoutLotInput = {
    where: LotScalarWhereInput
    data: XOR<LotUpdateManyMutationInput, LotUncheckedUpdateManyWithoutLotInput>
  }

  export type LotScalarWhereInput = {
    AND?: LotScalarWhereInput | LotScalarWhereInput[]
    OR?: LotScalarWhereInput[]
    NOT?: LotScalarWhereInput | LotScalarWhereInput[]
    id?: StringFilter<"Lot"> | string
    tenantId?: StringFilter<"Lot"> | string
    lotCode?: StringNullableFilter<"Lot"> | string | null
    phase?: EnumLotPhaseFilter<"Lot"> | $Enums.LotPhase
    status?: EnumLotStatusFilter<"Lot"> | $Enums.LotStatus
    plannedVolume?: DecimalFilter<"Lot"> | Decimal | DecimalJsLike | number | string
    actualVolume?: DecimalNullableFilter<"Lot"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Lot"> | string | null
    parentLotId?: StringNullableFilter<"Lot"> | string | null
    splitRatio?: DecimalNullableFilter<"Lot"> | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFilter<"Lot"> | string
    createdAt?: DateTimeFilter<"Lot"> | Date | string
    updatedAt?: DateTimeFilter<"Lot"> | Date | string
    completedAt?: DateTimeNullableFilter<"Lot"> | Date | string | null
    lotNumber?: StringNullableFilter<"Lot"> | string | null
    blendedAt?: DateTimeNullableFilter<"Lot"> | Date | string | null
    isBlendResult?: BoolNullableFilter<"Lot"> | boolean | null
    splitAt?: DateTimeNullableFilter<"Lot"> | Date | string | null
  }

  export type LotBatchUpsertWithWhereUniqueWithoutLotInput = {
    where: LotBatchWhereUniqueInput
    update: XOR<LotBatchUpdateWithoutLotInput, LotBatchUncheckedUpdateWithoutLotInput>
    create: XOR<LotBatchCreateWithoutLotInput, LotBatchUncheckedCreateWithoutLotInput>
  }

  export type LotBatchUpdateWithWhereUniqueWithoutLotInput = {
    where: LotBatchWhereUniqueInput
    data: XOR<LotBatchUpdateWithoutLotInput, LotBatchUncheckedUpdateWithoutLotInput>
  }

  export type LotBatchUpdateManyWithWhereWithoutLotInput = {
    where: LotBatchScalarWhereInput
    data: XOR<LotBatchUpdateManyMutationInput, LotBatchUncheckedUpdateManyWithoutLotInput>
  }

  export type LotReadingUpsertWithWhereUniqueWithoutLotInput = {
    where: LotReadingWhereUniqueInput
    update: XOR<LotReadingUpdateWithoutLotInput, LotReadingUncheckedUpdateWithoutLotInput>
    create: XOR<LotReadingCreateWithoutLotInput, LotReadingUncheckedCreateWithoutLotInput>
  }

  export type LotReadingUpdateWithWhereUniqueWithoutLotInput = {
    where: LotReadingWhereUniqueInput
    data: XOR<LotReadingUpdateWithoutLotInput, LotReadingUncheckedUpdateWithoutLotInput>
  }

  export type LotReadingUpdateManyWithWhereWithoutLotInput = {
    where: LotReadingScalarWhereInput
    data: XOR<LotReadingUpdateManyMutationInput, LotReadingUncheckedUpdateManyWithoutLotInput>
  }

  export type QCTestUpsertWithWhereUniqueWithoutLotInput = {
    where: QCTestWhereUniqueInput
    update: XOR<QCTestUpdateWithoutLotInput, QCTestUncheckedUpdateWithoutLotInput>
    create: XOR<QCTestCreateWithoutLotInput, QCTestUncheckedCreateWithoutLotInput>
  }

  export type QCTestUpdateWithWhereUniqueWithoutLotInput = {
    where: QCTestWhereUniqueInput
    data: XOR<QCTestUpdateWithoutLotInput, QCTestUncheckedUpdateWithoutLotInput>
  }

  export type QCTestUpdateManyWithWhereWithoutLotInput = {
    where: QCTestScalarWhereInput
    data: XOR<QCTestUpdateManyMutationInput, QCTestUncheckedUpdateManyWithoutLotInput>
  }

  export type TankAssignmentUpsertWithWhereUniqueWithoutLotInput = {
    where: TankAssignmentWhereUniqueInput
    update: XOR<TankAssignmentUpdateWithoutLotInput, TankAssignmentUncheckedUpdateWithoutLotInput>
    create: XOR<TankAssignmentCreateWithoutLotInput, TankAssignmentUncheckedCreateWithoutLotInput>
  }

  export type TankAssignmentUpdateWithWhereUniqueWithoutLotInput = {
    where: TankAssignmentWhereUniqueInput
    data: XOR<TankAssignmentUpdateWithoutLotInput, TankAssignmentUncheckedUpdateWithoutLotInput>
  }

  export type TankAssignmentUpdateManyWithWhereWithoutLotInput = {
    where: TankAssignmentScalarWhereInput
    data: XOR<TankAssignmentUpdateManyMutationInput, TankAssignmentUncheckedUpdateManyWithoutLotInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutLot_Transfer_destLotIdToLotInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutLot_Transfer_destLotIdToLotInput, TransferUncheckedUpdateWithoutLot_Transfer_destLotIdToLotInput>
    create: XOR<TransferCreateWithoutLot_Transfer_destLotIdToLotInput, TransferUncheckedCreateWithoutLot_Transfer_destLotIdToLotInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutLot_Transfer_destLotIdToLotInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutLot_Transfer_destLotIdToLotInput, TransferUncheckedUpdateWithoutLot_Transfer_destLotIdToLotInput>
  }

  export type TransferUpdateManyWithWhereWithoutLot_Transfer_destLotIdToLotInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutLot_Transfer_destLotIdToLotInput>
  }

  export type TransferUpsertWithWhereUniqueWithoutLot_Transfer_sourceLotIdToLotInput = {
    where: TransferWhereUniqueInput
    update: XOR<TransferUpdateWithoutLot_Transfer_sourceLotIdToLotInput, TransferUncheckedUpdateWithoutLot_Transfer_sourceLotIdToLotInput>
    create: XOR<TransferCreateWithoutLot_Transfer_sourceLotIdToLotInput, TransferUncheckedCreateWithoutLot_Transfer_sourceLotIdToLotInput>
  }

  export type TransferUpdateWithWhereUniqueWithoutLot_Transfer_sourceLotIdToLotInput = {
    where: TransferWhereUniqueInput
    data: XOR<TransferUpdateWithoutLot_Transfer_sourceLotIdToLotInput, TransferUncheckedUpdateWithoutLot_Transfer_sourceLotIdToLotInput>
  }

  export type TransferUpdateManyWithWhereWithoutLot_Transfer_sourceLotIdToLotInput = {
    where: TransferScalarWhereInput
    data: XOR<TransferUpdateManyMutationInput, TransferUncheckedUpdateManyWithoutLot_Transfer_sourceLotIdToLotInput>
  }

  export type BatchCreateWithoutLotBatchInput = {
    id?: string
    batchNumber: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    recipe: RecipeCreateNestedOneWithoutBatchesInput
    tank?: TankCreateNestedOneWithoutBatchesInput
    tenant: TenantCreateNestedOneWithoutBatchesInput
    ingredients?: BatchIngredientCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerCreateNestedManyWithoutBatchInput
    Keg?: KegCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunCreateNestedManyWithoutBatchInput
    QCTest?: QCTestCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutLotBatchInput = {
    id?: string
    tenantId: string
    batchNumber: string
    recipeId: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    tankId?: string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    ingredients?: BatchIngredientUncheckedCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineUncheckedCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingUncheckedCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerUncheckedCreateNestedManyWithoutBatchInput
    Keg?: KegUncheckedCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunUncheckedCreateNestedManyWithoutBatchInput
    QCTest?: QCTestUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutLotBatchInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutLotBatchInput, BatchUncheckedCreateWithoutLotBatchInput>
  }

  export type LotCreateWithoutLotBatchInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
    Lot?: LotCreateNestedOneWithoutOther_LotInput
    other_Lot?: LotCreateNestedManyWithoutLotInput
    LotReading?: LotReadingCreateNestedManyWithoutLotInput
    QCTest?: QCTestCreateNestedManyWithoutLotInput
    TankAssignment?: TankAssignmentCreateNestedManyWithoutLotInput
    Transfer_Transfer_destLotIdToLot?: TransferCreateNestedManyWithoutLot_Transfer_destLotIdToLotInput
    Transfer_Transfer_sourceLotIdToLot?: TransferCreateNestedManyWithoutLot_Transfer_sourceLotIdToLotInput
  }

  export type LotUncheckedCreateWithoutLotBatchInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    parentLotId?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
    other_Lot?: LotUncheckedCreateNestedManyWithoutLotInput
    LotReading?: LotReadingUncheckedCreateNestedManyWithoutLotInput
    QCTest?: QCTestUncheckedCreateNestedManyWithoutLotInput
    TankAssignment?: TankAssignmentUncheckedCreateNestedManyWithoutLotInput
    Transfer_Transfer_destLotIdToLot?: TransferUncheckedCreateNestedManyWithoutLot_Transfer_destLotIdToLotInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUncheckedCreateNestedManyWithoutLot_Transfer_sourceLotIdToLotInput
  }

  export type LotCreateOrConnectWithoutLotBatchInput = {
    where: LotWhereUniqueInput
    create: XOR<LotCreateWithoutLotBatchInput, LotUncheckedCreateWithoutLotBatchInput>
  }

  export type BatchUpsertWithoutLotBatchInput = {
    update: XOR<BatchUpdateWithoutLotBatchInput, BatchUncheckedUpdateWithoutLotBatchInput>
    create: XOR<BatchCreateWithoutLotBatchInput, BatchUncheckedCreateWithoutLotBatchInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutLotBatchInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutLotBatchInput, BatchUncheckedUpdateWithoutLotBatchInput>
  }

  export type BatchUpdateWithoutLotBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    recipe?: RecipeUpdateOneRequiredWithoutBatchesNestedInput
    tank?: TankUpdateOneWithoutBatchesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutBatchesNestedInput
    ingredients?: BatchIngredientUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUpdateManyWithoutBatchNestedInput
    Keg?: KegUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutLotBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tankId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: BatchIngredientUncheckedUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUncheckedUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUncheckedUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUncheckedUpdateManyWithoutBatchNestedInput
    Keg?: KegUncheckedUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUncheckedUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type LotUpsertWithoutLotBatchInput = {
    update: XOR<LotUpdateWithoutLotBatchInput, LotUncheckedUpdateWithoutLotBatchInput>
    create: XOR<LotCreateWithoutLotBatchInput, LotUncheckedCreateWithoutLotBatchInput>
    where?: LotWhereInput
  }

  export type LotUpdateToOneWithWhereWithoutLotBatchInput = {
    where?: LotWhereInput
    data: XOR<LotUpdateWithoutLotBatchInput, LotUncheckedUpdateWithoutLotBatchInput>
  }

  export type LotUpdateWithoutLotBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Lot?: LotUpdateOneWithoutOther_LotNestedInput
    other_Lot?: LotUpdateManyWithoutLotNestedInput
    LotReading?: LotReadingUpdateManyWithoutLotNestedInput
    QCTest?: QCTestUpdateManyWithoutLotNestedInput
    TankAssignment?: TankAssignmentUpdateManyWithoutLotNestedInput
    Transfer_Transfer_destLotIdToLot?: TransferUpdateManyWithoutLot_Transfer_destLotIdToLotNestedInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUpdateManyWithoutLot_Transfer_sourceLotIdToLotNestedInput
  }

  export type LotUncheckedUpdateWithoutLotBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_Lot?: LotUncheckedUpdateManyWithoutLotNestedInput
    LotReading?: LotReadingUncheckedUpdateManyWithoutLotNestedInput
    QCTest?: QCTestUncheckedUpdateManyWithoutLotNestedInput
    TankAssignment?: TankAssignmentUncheckedUpdateManyWithoutLotNestedInput
    Transfer_Transfer_destLotIdToLot?: TransferUncheckedUpdateManyWithoutLot_Transfer_destLotIdToLotNestedInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUncheckedUpdateManyWithoutLot_Transfer_sourceLotIdToLotNestedInput
  }

  export type LotCreateWithoutLotReadingInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
    Lot?: LotCreateNestedOneWithoutOther_LotInput
    other_Lot?: LotCreateNestedManyWithoutLotInput
    LotBatch?: LotBatchCreateNestedManyWithoutLotInput
    QCTest?: QCTestCreateNestedManyWithoutLotInput
    TankAssignment?: TankAssignmentCreateNestedManyWithoutLotInput
    Transfer_Transfer_destLotIdToLot?: TransferCreateNestedManyWithoutLot_Transfer_destLotIdToLotInput
    Transfer_Transfer_sourceLotIdToLot?: TransferCreateNestedManyWithoutLot_Transfer_sourceLotIdToLotInput
  }

  export type LotUncheckedCreateWithoutLotReadingInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    parentLotId?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
    other_Lot?: LotUncheckedCreateNestedManyWithoutLotInput
    LotBatch?: LotBatchUncheckedCreateNestedManyWithoutLotInput
    QCTest?: QCTestUncheckedCreateNestedManyWithoutLotInput
    TankAssignment?: TankAssignmentUncheckedCreateNestedManyWithoutLotInput
    Transfer_Transfer_destLotIdToLot?: TransferUncheckedCreateNestedManyWithoutLot_Transfer_destLotIdToLotInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUncheckedCreateNestedManyWithoutLot_Transfer_sourceLotIdToLotInput
  }

  export type LotCreateOrConnectWithoutLotReadingInput = {
    where: LotWhereUniqueInput
    create: XOR<LotCreateWithoutLotReadingInput, LotUncheckedCreateWithoutLotReadingInput>
  }

  export type TankCreateWithoutLotReadingInput = {
    id?: string
    name: string
    type: $Enums.TankType
    capacity: Decimal | DecimalJsLike | number | string
    status?: $Enums.TankStatus
    currentBatchId?: string | null
    location?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: TankCreatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: string | null
    currentPhase?: $Enums.LotPhase | null
    defaultTurnaroundHours?: number | null
    maxFillPercent?: number | null
    minFillPercent?: number | null
    batches?: BatchCreateNestedManyWithoutTankInput
    tenant: TenantCreateNestedOneWithoutTanksInput
    TankAssignment?: TankAssignmentCreateNestedManyWithoutTankInput
    occupations?: TankOccupationCreateNestedManyWithoutTankInput
    Transfer_Transfer_destTankIdToTank?: TransferCreateNestedManyWithoutTank_Transfer_destTankIdToTankInput
    Transfer_Transfer_sourceTankIdToTank?: TransferCreateNestedManyWithoutTank_Transfer_sourceTankIdToTankInput
  }

  export type TankUncheckedCreateWithoutLotReadingInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.TankType
    capacity: Decimal | DecimalJsLike | number | string
    status?: $Enums.TankStatus
    currentBatchId?: string | null
    location?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: TankCreatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: string | null
    currentPhase?: $Enums.LotPhase | null
    defaultTurnaroundHours?: number | null
    maxFillPercent?: number | null
    minFillPercent?: number | null
    batches?: BatchUncheckedCreateNestedManyWithoutTankInput
    TankAssignment?: TankAssignmentUncheckedCreateNestedManyWithoutTankInput
    occupations?: TankOccupationUncheckedCreateNestedManyWithoutTankInput
    Transfer_Transfer_destTankIdToTank?: TransferUncheckedCreateNestedManyWithoutTank_Transfer_destTankIdToTankInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUncheckedCreateNestedManyWithoutTank_Transfer_sourceTankIdToTankInput
  }

  export type TankCreateOrConnectWithoutLotReadingInput = {
    where: TankWhereUniqueInput
    create: XOR<TankCreateWithoutLotReadingInput, TankUncheckedCreateWithoutLotReadingInput>
  }

  export type LotUpsertWithoutLotReadingInput = {
    update: XOR<LotUpdateWithoutLotReadingInput, LotUncheckedUpdateWithoutLotReadingInput>
    create: XOR<LotCreateWithoutLotReadingInput, LotUncheckedCreateWithoutLotReadingInput>
    where?: LotWhereInput
  }

  export type LotUpdateToOneWithWhereWithoutLotReadingInput = {
    where?: LotWhereInput
    data: XOR<LotUpdateWithoutLotReadingInput, LotUncheckedUpdateWithoutLotReadingInput>
  }

  export type LotUpdateWithoutLotReadingInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Lot?: LotUpdateOneWithoutOther_LotNestedInput
    other_Lot?: LotUpdateManyWithoutLotNestedInput
    LotBatch?: LotBatchUpdateManyWithoutLotNestedInput
    QCTest?: QCTestUpdateManyWithoutLotNestedInput
    TankAssignment?: TankAssignmentUpdateManyWithoutLotNestedInput
    Transfer_Transfer_destLotIdToLot?: TransferUpdateManyWithoutLot_Transfer_destLotIdToLotNestedInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUpdateManyWithoutLot_Transfer_sourceLotIdToLotNestedInput
  }

  export type LotUncheckedUpdateWithoutLotReadingInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_Lot?: LotUncheckedUpdateManyWithoutLotNestedInput
    LotBatch?: LotBatchUncheckedUpdateManyWithoutLotNestedInput
    QCTest?: QCTestUncheckedUpdateManyWithoutLotNestedInput
    TankAssignment?: TankAssignmentUncheckedUpdateManyWithoutLotNestedInput
    Transfer_Transfer_destLotIdToLot?: TransferUncheckedUpdateManyWithoutLot_Transfer_destLotIdToLotNestedInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUncheckedUpdateManyWithoutLot_Transfer_sourceLotIdToLotNestedInput
  }

  export type TankUpsertWithoutLotReadingInput = {
    update: XOR<TankUpdateWithoutLotReadingInput, TankUncheckedUpdateWithoutLotReadingInput>
    create: XOR<TankCreateWithoutLotReadingInput, TankUncheckedCreateWithoutLotReadingInput>
    where?: TankWhereInput
  }

  export type TankUpdateToOneWithWhereWithoutLotReadingInput = {
    where?: TankWhereInput
    data: XOR<TankUpdateWithoutLotReadingInput, TankUncheckedUpdateWithoutLotReadingInput>
  }

  export type TankUpdateWithoutLotReadingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTankTypeFieldUpdateOperationsInput | $Enums.TankType
    capacity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFieldUpdateOperationsInput | $Enums.TankStatus
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: TankUpdatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPhase?: NullableEnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase | null
    defaultTurnaroundHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    minFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    batches?: BatchUpdateManyWithoutTankNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTanksNestedInput
    TankAssignment?: TankAssignmentUpdateManyWithoutTankNestedInput
    occupations?: TankOccupationUpdateManyWithoutTankNestedInput
    Transfer_Transfer_destTankIdToTank?: TransferUpdateManyWithoutTank_Transfer_destTankIdToTankNestedInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUpdateManyWithoutTank_Transfer_sourceTankIdToTankNestedInput
  }

  export type TankUncheckedUpdateWithoutLotReadingInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTankTypeFieldUpdateOperationsInput | $Enums.TankType
    capacity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFieldUpdateOperationsInput | $Enums.TankStatus
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: TankUpdatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPhase?: NullableEnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase | null
    defaultTurnaroundHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    minFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    batches?: BatchUncheckedUpdateManyWithoutTankNestedInput
    TankAssignment?: TankAssignmentUncheckedUpdateManyWithoutTankNestedInput
    occupations?: TankOccupationUncheckedUpdateManyWithoutTankNestedInput
    Transfer_Transfer_destTankIdToTank?: TransferUncheckedUpdateManyWithoutTank_Transfer_destTankIdToTankNestedInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUncheckedUpdateManyWithoutTank_Transfer_sourceTankIdToTankNestedInput
  }

  export type EquipmentCreateWithoutMaintenanceLogInput = {
    id: string
    name: string
    type: string
    status?: string
    capacity?: number | null
    model?: string | null
    manufacturer?: string | null
    serialNumber?: string | null
    location?: string | null
    workingPressure?: number | null
    currentTemp?: number | null
    currentPressure?: number | null
    installationDate?: Date | string | null
    warrantyDate?: Date | string | null
    lastCIP?: Date | string | null
    nextCIP?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    cipIntervalDays?: number
    inspectionIntervalDays?: number
    annualMaintenanceDays?: number
    currentBatchId?: string | null
    currentBatchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    purchaseDate?: Date | string | null
    capabilities?: EquipmentCreatecapabilitiesInput | string[]
    CIPLog?: CIPLogCreateNestedManyWithoutEquipmentInput
    Tenant: TenantCreateNestedOneWithoutEquipmentInput
    ProblemReport?: ProblemReportCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutMaintenanceLogInput = {
    id: string
    tenantId: string
    name: string
    type: string
    status?: string
    capacity?: number | null
    model?: string | null
    manufacturer?: string | null
    serialNumber?: string | null
    location?: string | null
    workingPressure?: number | null
    currentTemp?: number | null
    currentPressure?: number | null
    installationDate?: Date | string | null
    warrantyDate?: Date | string | null
    lastCIP?: Date | string | null
    nextCIP?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    cipIntervalDays?: number
    inspectionIntervalDays?: number
    annualMaintenanceDays?: number
    currentBatchId?: string | null
    currentBatchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    purchaseDate?: Date | string | null
    capabilities?: EquipmentCreatecapabilitiesInput | string[]
    CIPLog?: CIPLogUncheckedCreateNestedManyWithoutEquipmentInput
    ProblemReport?: ProblemReportUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutMaintenanceLogInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutMaintenanceLogInput, EquipmentUncheckedCreateWithoutMaintenanceLogInput>
  }

  export type EquipmentUpsertWithoutMaintenanceLogInput = {
    update: XOR<EquipmentUpdateWithoutMaintenanceLogInput, EquipmentUncheckedUpdateWithoutMaintenanceLogInput>
    create: XOR<EquipmentCreateWithoutMaintenanceLogInput, EquipmentUncheckedCreateWithoutMaintenanceLogInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutMaintenanceLogInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutMaintenanceLogInput, EquipmentUncheckedUpdateWithoutMaintenanceLogInput>
  }

  export type EquipmentUpdateWithoutMaintenanceLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workingPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    currentTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cipIntervalDays?: IntFieldUpdateOperationsInput | number
    inspectionIntervalDays?: IntFieldUpdateOperationsInput | number
    annualMaintenanceDays?: IntFieldUpdateOperationsInput | number
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBatchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capabilities?: EquipmentUpdatecapabilitiesInput | string[]
    CIPLog?: CIPLogUpdateManyWithoutEquipmentNestedInput
    Tenant?: TenantUpdateOneRequiredWithoutEquipmentNestedInput
    ProblemReport?: ProblemReportUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutMaintenanceLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workingPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    currentTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cipIntervalDays?: IntFieldUpdateOperationsInput | number
    inspectionIntervalDays?: IntFieldUpdateOperationsInput | number
    annualMaintenanceDays?: IntFieldUpdateOperationsInput | number
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBatchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capabilities?: EquipmentUpdatecapabilitiesInput | string[]
    CIPLog?: CIPLogUncheckedUpdateManyWithoutEquipmentNestedInput
    ProblemReport?: ProblemReportUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentCreateWithoutProblemReportInput = {
    id: string
    name: string
    type: string
    status?: string
    capacity?: number | null
    model?: string | null
    manufacturer?: string | null
    serialNumber?: string | null
    location?: string | null
    workingPressure?: number | null
    currentTemp?: number | null
    currentPressure?: number | null
    installationDate?: Date | string | null
    warrantyDate?: Date | string | null
    lastCIP?: Date | string | null
    nextCIP?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    cipIntervalDays?: number
    inspectionIntervalDays?: number
    annualMaintenanceDays?: number
    currentBatchId?: string | null
    currentBatchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    purchaseDate?: Date | string | null
    capabilities?: EquipmentCreatecapabilitiesInput | string[]
    CIPLog?: CIPLogCreateNestedManyWithoutEquipmentInput
    Tenant: TenantCreateNestedOneWithoutEquipmentInput
    MaintenanceLog?: MaintenanceLogCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutProblemReportInput = {
    id: string
    tenantId: string
    name: string
    type: string
    status?: string
    capacity?: number | null
    model?: string | null
    manufacturer?: string | null
    serialNumber?: string | null
    location?: string | null
    workingPressure?: number | null
    currentTemp?: number | null
    currentPressure?: number | null
    installationDate?: Date | string | null
    warrantyDate?: Date | string | null
    lastCIP?: Date | string | null
    nextCIP?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    cipIntervalDays?: number
    inspectionIntervalDays?: number
    annualMaintenanceDays?: number
    currentBatchId?: string | null
    currentBatchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    purchaseDate?: Date | string | null
    capabilities?: EquipmentCreatecapabilitiesInput | string[]
    CIPLog?: CIPLogUncheckedCreateNestedManyWithoutEquipmentInput
    MaintenanceLog?: MaintenanceLogUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutProblemReportInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutProblemReportInput, EquipmentUncheckedCreateWithoutProblemReportInput>
  }

  export type EquipmentUpsertWithoutProblemReportInput = {
    update: XOR<EquipmentUpdateWithoutProblemReportInput, EquipmentUncheckedUpdateWithoutProblemReportInput>
    create: XOR<EquipmentCreateWithoutProblemReportInput, EquipmentUncheckedCreateWithoutProblemReportInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutProblemReportInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutProblemReportInput, EquipmentUncheckedUpdateWithoutProblemReportInput>
  }

  export type EquipmentUpdateWithoutProblemReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workingPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    currentTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cipIntervalDays?: IntFieldUpdateOperationsInput | number
    inspectionIntervalDays?: IntFieldUpdateOperationsInput | number
    annualMaintenanceDays?: IntFieldUpdateOperationsInput | number
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBatchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capabilities?: EquipmentUpdatecapabilitiesInput | string[]
    CIPLog?: CIPLogUpdateManyWithoutEquipmentNestedInput
    Tenant?: TenantUpdateOneRequiredWithoutEquipmentNestedInput
    MaintenanceLog?: MaintenanceLogUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutProblemReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workingPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    currentTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cipIntervalDays?: IntFieldUpdateOperationsInput | number
    inspectionIntervalDays?: IntFieldUpdateOperationsInput | number
    annualMaintenanceDays?: IntFieldUpdateOperationsInput | number
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBatchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capabilities?: EquipmentUpdatecapabilitiesInput | string[]
    CIPLog?: CIPLogUncheckedUpdateManyWithoutEquipmentNestedInput
    MaintenanceLog?: MaintenanceLogUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type LotCreateWithoutTankAssignmentInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
    Lot?: LotCreateNestedOneWithoutOther_LotInput
    other_Lot?: LotCreateNestedManyWithoutLotInput
    LotBatch?: LotBatchCreateNestedManyWithoutLotInput
    LotReading?: LotReadingCreateNestedManyWithoutLotInput
    QCTest?: QCTestCreateNestedManyWithoutLotInput
    Transfer_Transfer_destLotIdToLot?: TransferCreateNestedManyWithoutLot_Transfer_destLotIdToLotInput
    Transfer_Transfer_sourceLotIdToLot?: TransferCreateNestedManyWithoutLot_Transfer_sourceLotIdToLotInput
  }

  export type LotUncheckedCreateWithoutTankAssignmentInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    parentLotId?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
    other_Lot?: LotUncheckedCreateNestedManyWithoutLotInput
    LotBatch?: LotBatchUncheckedCreateNestedManyWithoutLotInput
    LotReading?: LotReadingUncheckedCreateNestedManyWithoutLotInput
    QCTest?: QCTestUncheckedCreateNestedManyWithoutLotInput
    Transfer_Transfer_destLotIdToLot?: TransferUncheckedCreateNestedManyWithoutLot_Transfer_destLotIdToLotInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUncheckedCreateNestedManyWithoutLot_Transfer_sourceLotIdToLotInput
  }

  export type LotCreateOrConnectWithoutTankAssignmentInput = {
    where: LotWhereUniqueInput
    create: XOR<LotCreateWithoutTankAssignmentInput, LotUncheckedCreateWithoutTankAssignmentInput>
  }

  export type TankCreateWithoutTankAssignmentInput = {
    id?: string
    name: string
    type: $Enums.TankType
    capacity: Decimal | DecimalJsLike | number | string
    status?: $Enums.TankStatus
    currentBatchId?: string | null
    location?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: TankCreatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: string | null
    currentPhase?: $Enums.LotPhase | null
    defaultTurnaroundHours?: number | null
    maxFillPercent?: number | null
    minFillPercent?: number | null
    batches?: BatchCreateNestedManyWithoutTankInput
    LotReading?: LotReadingCreateNestedManyWithoutTankInput
    tenant: TenantCreateNestedOneWithoutTanksInput
    occupations?: TankOccupationCreateNestedManyWithoutTankInput
    Transfer_Transfer_destTankIdToTank?: TransferCreateNestedManyWithoutTank_Transfer_destTankIdToTankInput
    Transfer_Transfer_sourceTankIdToTank?: TransferCreateNestedManyWithoutTank_Transfer_sourceTankIdToTankInput
  }

  export type TankUncheckedCreateWithoutTankAssignmentInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.TankType
    capacity: Decimal | DecimalJsLike | number | string
    status?: $Enums.TankStatus
    currentBatchId?: string | null
    location?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: TankCreatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: string | null
    currentPhase?: $Enums.LotPhase | null
    defaultTurnaroundHours?: number | null
    maxFillPercent?: number | null
    minFillPercent?: number | null
    batches?: BatchUncheckedCreateNestedManyWithoutTankInput
    LotReading?: LotReadingUncheckedCreateNestedManyWithoutTankInput
    occupations?: TankOccupationUncheckedCreateNestedManyWithoutTankInput
    Transfer_Transfer_destTankIdToTank?: TransferUncheckedCreateNestedManyWithoutTank_Transfer_destTankIdToTankInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUncheckedCreateNestedManyWithoutTank_Transfer_sourceTankIdToTankInput
  }

  export type TankCreateOrConnectWithoutTankAssignmentInput = {
    where: TankWhereUniqueInput
    create: XOR<TankCreateWithoutTankAssignmentInput, TankUncheckedCreateWithoutTankAssignmentInput>
  }

  export type LotUpsertWithoutTankAssignmentInput = {
    update: XOR<LotUpdateWithoutTankAssignmentInput, LotUncheckedUpdateWithoutTankAssignmentInput>
    create: XOR<LotCreateWithoutTankAssignmentInput, LotUncheckedCreateWithoutTankAssignmentInput>
    where?: LotWhereInput
  }

  export type LotUpdateToOneWithWhereWithoutTankAssignmentInput = {
    where?: LotWhereInput
    data: XOR<LotUpdateWithoutTankAssignmentInput, LotUncheckedUpdateWithoutTankAssignmentInput>
  }

  export type LotUpdateWithoutTankAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Lot?: LotUpdateOneWithoutOther_LotNestedInput
    other_Lot?: LotUpdateManyWithoutLotNestedInput
    LotBatch?: LotBatchUpdateManyWithoutLotNestedInput
    LotReading?: LotReadingUpdateManyWithoutLotNestedInput
    QCTest?: QCTestUpdateManyWithoutLotNestedInput
    Transfer_Transfer_destLotIdToLot?: TransferUpdateManyWithoutLot_Transfer_destLotIdToLotNestedInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUpdateManyWithoutLot_Transfer_sourceLotIdToLotNestedInput
  }

  export type LotUncheckedUpdateWithoutTankAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_Lot?: LotUncheckedUpdateManyWithoutLotNestedInput
    LotBatch?: LotBatchUncheckedUpdateManyWithoutLotNestedInput
    LotReading?: LotReadingUncheckedUpdateManyWithoutLotNestedInput
    QCTest?: QCTestUncheckedUpdateManyWithoutLotNestedInput
    Transfer_Transfer_destLotIdToLot?: TransferUncheckedUpdateManyWithoutLot_Transfer_destLotIdToLotNestedInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUncheckedUpdateManyWithoutLot_Transfer_sourceLotIdToLotNestedInput
  }

  export type TankUpsertWithoutTankAssignmentInput = {
    update: XOR<TankUpdateWithoutTankAssignmentInput, TankUncheckedUpdateWithoutTankAssignmentInput>
    create: XOR<TankCreateWithoutTankAssignmentInput, TankUncheckedCreateWithoutTankAssignmentInput>
    where?: TankWhereInput
  }

  export type TankUpdateToOneWithWhereWithoutTankAssignmentInput = {
    where?: TankWhereInput
    data: XOR<TankUpdateWithoutTankAssignmentInput, TankUncheckedUpdateWithoutTankAssignmentInput>
  }

  export type TankUpdateWithoutTankAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTankTypeFieldUpdateOperationsInput | $Enums.TankType
    capacity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFieldUpdateOperationsInput | $Enums.TankStatus
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: TankUpdatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPhase?: NullableEnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase | null
    defaultTurnaroundHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    minFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    batches?: BatchUpdateManyWithoutTankNestedInput
    LotReading?: LotReadingUpdateManyWithoutTankNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTanksNestedInput
    occupations?: TankOccupationUpdateManyWithoutTankNestedInput
    Transfer_Transfer_destTankIdToTank?: TransferUpdateManyWithoutTank_Transfer_destTankIdToTankNestedInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUpdateManyWithoutTank_Transfer_sourceTankIdToTankNestedInput
  }

  export type TankUncheckedUpdateWithoutTankAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTankTypeFieldUpdateOperationsInput | $Enums.TankType
    capacity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFieldUpdateOperationsInput | $Enums.TankStatus
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: TankUpdatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPhase?: NullableEnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase | null
    defaultTurnaroundHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    minFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    batches?: BatchUncheckedUpdateManyWithoutTankNestedInput
    LotReading?: LotReadingUncheckedUpdateManyWithoutTankNestedInput
    occupations?: TankOccupationUncheckedUpdateManyWithoutTankNestedInput
    Transfer_Transfer_destTankIdToTank?: TransferUncheckedUpdateManyWithoutTank_Transfer_destTankIdToTankNestedInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUncheckedUpdateManyWithoutTank_Transfer_sourceTankIdToTankNestedInput
  }

  export type LotCreateWithoutTransfer_Transfer_destLotIdToLotInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
    Lot?: LotCreateNestedOneWithoutOther_LotInput
    other_Lot?: LotCreateNestedManyWithoutLotInput
    LotBatch?: LotBatchCreateNestedManyWithoutLotInput
    LotReading?: LotReadingCreateNestedManyWithoutLotInput
    QCTest?: QCTestCreateNestedManyWithoutLotInput
    TankAssignment?: TankAssignmentCreateNestedManyWithoutLotInput
    Transfer_Transfer_sourceLotIdToLot?: TransferCreateNestedManyWithoutLot_Transfer_sourceLotIdToLotInput
  }

  export type LotUncheckedCreateWithoutTransfer_Transfer_destLotIdToLotInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    parentLotId?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
    other_Lot?: LotUncheckedCreateNestedManyWithoutLotInput
    LotBatch?: LotBatchUncheckedCreateNestedManyWithoutLotInput
    LotReading?: LotReadingUncheckedCreateNestedManyWithoutLotInput
    QCTest?: QCTestUncheckedCreateNestedManyWithoutLotInput
    TankAssignment?: TankAssignmentUncheckedCreateNestedManyWithoutLotInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUncheckedCreateNestedManyWithoutLot_Transfer_sourceLotIdToLotInput
  }

  export type LotCreateOrConnectWithoutTransfer_Transfer_destLotIdToLotInput = {
    where: LotWhereUniqueInput
    create: XOR<LotCreateWithoutTransfer_Transfer_destLotIdToLotInput, LotUncheckedCreateWithoutTransfer_Transfer_destLotIdToLotInput>
  }

  export type TankCreateWithoutTransfer_Transfer_destTankIdToTankInput = {
    id?: string
    name: string
    type: $Enums.TankType
    capacity: Decimal | DecimalJsLike | number | string
    status?: $Enums.TankStatus
    currentBatchId?: string | null
    location?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: TankCreatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: string | null
    currentPhase?: $Enums.LotPhase | null
    defaultTurnaroundHours?: number | null
    maxFillPercent?: number | null
    minFillPercent?: number | null
    batches?: BatchCreateNestedManyWithoutTankInput
    LotReading?: LotReadingCreateNestedManyWithoutTankInput
    tenant: TenantCreateNestedOneWithoutTanksInput
    TankAssignment?: TankAssignmentCreateNestedManyWithoutTankInput
    occupations?: TankOccupationCreateNestedManyWithoutTankInput
    Transfer_Transfer_sourceTankIdToTank?: TransferCreateNestedManyWithoutTank_Transfer_sourceTankIdToTankInput
  }

  export type TankUncheckedCreateWithoutTransfer_Transfer_destTankIdToTankInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.TankType
    capacity: Decimal | DecimalJsLike | number | string
    status?: $Enums.TankStatus
    currentBatchId?: string | null
    location?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: TankCreatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: string | null
    currentPhase?: $Enums.LotPhase | null
    defaultTurnaroundHours?: number | null
    maxFillPercent?: number | null
    minFillPercent?: number | null
    batches?: BatchUncheckedCreateNestedManyWithoutTankInput
    LotReading?: LotReadingUncheckedCreateNestedManyWithoutTankInput
    TankAssignment?: TankAssignmentUncheckedCreateNestedManyWithoutTankInput
    occupations?: TankOccupationUncheckedCreateNestedManyWithoutTankInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUncheckedCreateNestedManyWithoutTank_Transfer_sourceTankIdToTankInput
  }

  export type TankCreateOrConnectWithoutTransfer_Transfer_destTankIdToTankInput = {
    where: TankWhereUniqueInput
    create: XOR<TankCreateWithoutTransfer_Transfer_destTankIdToTankInput, TankUncheckedCreateWithoutTransfer_Transfer_destTankIdToTankInput>
  }

  export type LotCreateWithoutTransfer_Transfer_sourceLotIdToLotInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
    Lot?: LotCreateNestedOneWithoutOther_LotInput
    other_Lot?: LotCreateNestedManyWithoutLotInput
    LotBatch?: LotBatchCreateNestedManyWithoutLotInput
    LotReading?: LotReadingCreateNestedManyWithoutLotInput
    QCTest?: QCTestCreateNestedManyWithoutLotInput
    TankAssignment?: TankAssignmentCreateNestedManyWithoutLotInput
    Transfer_Transfer_destLotIdToLot?: TransferCreateNestedManyWithoutLot_Transfer_destLotIdToLotInput
  }

  export type LotUncheckedCreateWithoutTransfer_Transfer_sourceLotIdToLotInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    parentLotId?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
    other_Lot?: LotUncheckedCreateNestedManyWithoutLotInput
    LotBatch?: LotBatchUncheckedCreateNestedManyWithoutLotInput
    LotReading?: LotReadingUncheckedCreateNestedManyWithoutLotInput
    QCTest?: QCTestUncheckedCreateNestedManyWithoutLotInput
    TankAssignment?: TankAssignmentUncheckedCreateNestedManyWithoutLotInput
    Transfer_Transfer_destLotIdToLot?: TransferUncheckedCreateNestedManyWithoutLot_Transfer_destLotIdToLotInput
  }

  export type LotCreateOrConnectWithoutTransfer_Transfer_sourceLotIdToLotInput = {
    where: LotWhereUniqueInput
    create: XOR<LotCreateWithoutTransfer_Transfer_sourceLotIdToLotInput, LotUncheckedCreateWithoutTransfer_Transfer_sourceLotIdToLotInput>
  }

  export type TankCreateWithoutTransfer_Transfer_sourceTankIdToTankInput = {
    id?: string
    name: string
    type: $Enums.TankType
    capacity: Decimal | DecimalJsLike | number | string
    status?: $Enums.TankStatus
    currentBatchId?: string | null
    location?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: TankCreatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: string | null
    currentPhase?: $Enums.LotPhase | null
    defaultTurnaroundHours?: number | null
    maxFillPercent?: number | null
    minFillPercent?: number | null
    batches?: BatchCreateNestedManyWithoutTankInput
    LotReading?: LotReadingCreateNestedManyWithoutTankInput
    tenant: TenantCreateNestedOneWithoutTanksInput
    TankAssignment?: TankAssignmentCreateNestedManyWithoutTankInput
    occupations?: TankOccupationCreateNestedManyWithoutTankInput
    Transfer_Transfer_destTankIdToTank?: TransferCreateNestedManyWithoutTank_Transfer_destTankIdToTankInput
  }

  export type TankUncheckedCreateWithoutTransfer_Transfer_sourceTankIdToTankInput = {
    id?: string
    tenantId: string
    name: string
    type: $Enums.TankType
    capacity: Decimal | DecimalJsLike | number | string
    status?: $Enums.TankStatus
    currentBatchId?: string | null
    location?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: TankCreatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: string | null
    currentPhase?: $Enums.LotPhase | null
    defaultTurnaroundHours?: number | null
    maxFillPercent?: number | null
    minFillPercent?: number | null
    batches?: BatchUncheckedCreateNestedManyWithoutTankInput
    LotReading?: LotReadingUncheckedCreateNestedManyWithoutTankInput
    TankAssignment?: TankAssignmentUncheckedCreateNestedManyWithoutTankInput
    occupations?: TankOccupationUncheckedCreateNestedManyWithoutTankInput
    Transfer_Transfer_destTankIdToTank?: TransferUncheckedCreateNestedManyWithoutTank_Transfer_destTankIdToTankInput
  }

  export type TankCreateOrConnectWithoutTransfer_Transfer_sourceTankIdToTankInput = {
    where: TankWhereUniqueInput
    create: XOR<TankCreateWithoutTransfer_Transfer_sourceTankIdToTankInput, TankUncheckedCreateWithoutTransfer_Transfer_sourceTankIdToTankInput>
  }

  export type LotUpsertWithoutTransfer_Transfer_destLotIdToLotInput = {
    update: XOR<LotUpdateWithoutTransfer_Transfer_destLotIdToLotInput, LotUncheckedUpdateWithoutTransfer_Transfer_destLotIdToLotInput>
    create: XOR<LotCreateWithoutTransfer_Transfer_destLotIdToLotInput, LotUncheckedCreateWithoutTransfer_Transfer_destLotIdToLotInput>
    where?: LotWhereInput
  }

  export type LotUpdateToOneWithWhereWithoutTransfer_Transfer_destLotIdToLotInput = {
    where?: LotWhereInput
    data: XOR<LotUpdateWithoutTransfer_Transfer_destLotIdToLotInput, LotUncheckedUpdateWithoutTransfer_Transfer_destLotIdToLotInput>
  }

  export type LotUpdateWithoutTransfer_Transfer_destLotIdToLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Lot?: LotUpdateOneWithoutOther_LotNestedInput
    other_Lot?: LotUpdateManyWithoutLotNestedInput
    LotBatch?: LotBatchUpdateManyWithoutLotNestedInput
    LotReading?: LotReadingUpdateManyWithoutLotNestedInput
    QCTest?: QCTestUpdateManyWithoutLotNestedInput
    TankAssignment?: TankAssignmentUpdateManyWithoutLotNestedInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUpdateManyWithoutLot_Transfer_sourceLotIdToLotNestedInput
  }

  export type LotUncheckedUpdateWithoutTransfer_Transfer_destLotIdToLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_Lot?: LotUncheckedUpdateManyWithoutLotNestedInput
    LotBatch?: LotBatchUncheckedUpdateManyWithoutLotNestedInput
    LotReading?: LotReadingUncheckedUpdateManyWithoutLotNestedInput
    QCTest?: QCTestUncheckedUpdateManyWithoutLotNestedInput
    TankAssignment?: TankAssignmentUncheckedUpdateManyWithoutLotNestedInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUncheckedUpdateManyWithoutLot_Transfer_sourceLotIdToLotNestedInput
  }

  export type TankUpsertWithoutTransfer_Transfer_destTankIdToTankInput = {
    update: XOR<TankUpdateWithoutTransfer_Transfer_destTankIdToTankInput, TankUncheckedUpdateWithoutTransfer_Transfer_destTankIdToTankInput>
    create: XOR<TankCreateWithoutTransfer_Transfer_destTankIdToTankInput, TankUncheckedCreateWithoutTransfer_Transfer_destTankIdToTankInput>
    where?: TankWhereInput
  }

  export type TankUpdateToOneWithWhereWithoutTransfer_Transfer_destTankIdToTankInput = {
    where?: TankWhereInput
    data: XOR<TankUpdateWithoutTransfer_Transfer_destTankIdToTankInput, TankUncheckedUpdateWithoutTransfer_Transfer_destTankIdToTankInput>
  }

  export type TankUpdateWithoutTransfer_Transfer_destTankIdToTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTankTypeFieldUpdateOperationsInput | $Enums.TankType
    capacity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFieldUpdateOperationsInput | $Enums.TankStatus
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: TankUpdatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPhase?: NullableEnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase | null
    defaultTurnaroundHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    minFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    batches?: BatchUpdateManyWithoutTankNestedInput
    LotReading?: LotReadingUpdateManyWithoutTankNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTanksNestedInput
    TankAssignment?: TankAssignmentUpdateManyWithoutTankNestedInput
    occupations?: TankOccupationUpdateManyWithoutTankNestedInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUpdateManyWithoutTank_Transfer_sourceTankIdToTankNestedInput
  }

  export type TankUncheckedUpdateWithoutTransfer_Transfer_destTankIdToTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTankTypeFieldUpdateOperationsInput | $Enums.TankType
    capacity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFieldUpdateOperationsInput | $Enums.TankStatus
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: TankUpdatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPhase?: NullableEnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase | null
    defaultTurnaroundHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    minFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    batches?: BatchUncheckedUpdateManyWithoutTankNestedInput
    LotReading?: LotReadingUncheckedUpdateManyWithoutTankNestedInput
    TankAssignment?: TankAssignmentUncheckedUpdateManyWithoutTankNestedInput
    occupations?: TankOccupationUncheckedUpdateManyWithoutTankNestedInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUncheckedUpdateManyWithoutTank_Transfer_sourceTankIdToTankNestedInput
  }

  export type LotUpsertWithoutTransfer_Transfer_sourceLotIdToLotInput = {
    update: XOR<LotUpdateWithoutTransfer_Transfer_sourceLotIdToLotInput, LotUncheckedUpdateWithoutTransfer_Transfer_sourceLotIdToLotInput>
    create: XOR<LotCreateWithoutTransfer_Transfer_sourceLotIdToLotInput, LotUncheckedCreateWithoutTransfer_Transfer_sourceLotIdToLotInput>
    where?: LotWhereInput
  }

  export type LotUpdateToOneWithWhereWithoutTransfer_Transfer_sourceLotIdToLotInput = {
    where?: LotWhereInput
    data: XOR<LotUpdateWithoutTransfer_Transfer_sourceLotIdToLotInput, LotUncheckedUpdateWithoutTransfer_Transfer_sourceLotIdToLotInput>
  }

  export type LotUpdateWithoutTransfer_Transfer_sourceLotIdToLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Lot?: LotUpdateOneWithoutOther_LotNestedInput
    other_Lot?: LotUpdateManyWithoutLotNestedInput
    LotBatch?: LotBatchUpdateManyWithoutLotNestedInput
    LotReading?: LotReadingUpdateManyWithoutLotNestedInput
    QCTest?: QCTestUpdateManyWithoutLotNestedInput
    TankAssignment?: TankAssignmentUpdateManyWithoutLotNestedInput
    Transfer_Transfer_destLotIdToLot?: TransferUpdateManyWithoutLot_Transfer_destLotIdToLotNestedInput
  }

  export type LotUncheckedUpdateWithoutTransfer_Transfer_sourceLotIdToLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_Lot?: LotUncheckedUpdateManyWithoutLotNestedInput
    LotBatch?: LotBatchUncheckedUpdateManyWithoutLotNestedInput
    LotReading?: LotReadingUncheckedUpdateManyWithoutLotNestedInput
    QCTest?: QCTestUncheckedUpdateManyWithoutLotNestedInput
    TankAssignment?: TankAssignmentUncheckedUpdateManyWithoutLotNestedInput
    Transfer_Transfer_destLotIdToLot?: TransferUncheckedUpdateManyWithoutLot_Transfer_destLotIdToLotNestedInput
  }

  export type TankUpsertWithoutTransfer_Transfer_sourceTankIdToTankInput = {
    update: XOR<TankUpdateWithoutTransfer_Transfer_sourceTankIdToTankInput, TankUncheckedUpdateWithoutTransfer_Transfer_sourceTankIdToTankInput>
    create: XOR<TankCreateWithoutTransfer_Transfer_sourceTankIdToTankInput, TankUncheckedCreateWithoutTransfer_Transfer_sourceTankIdToTankInput>
    where?: TankWhereInput
  }

  export type TankUpdateToOneWithWhereWithoutTransfer_Transfer_sourceTankIdToTankInput = {
    where?: TankWhereInput
    data: XOR<TankUpdateWithoutTransfer_Transfer_sourceTankIdToTankInput, TankUncheckedUpdateWithoutTransfer_Transfer_sourceTankIdToTankInput>
  }

  export type TankUpdateWithoutTransfer_Transfer_sourceTankIdToTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTankTypeFieldUpdateOperationsInput | $Enums.TankType
    capacity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFieldUpdateOperationsInput | $Enums.TankStatus
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: TankUpdatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPhase?: NullableEnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase | null
    defaultTurnaroundHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    minFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    batches?: BatchUpdateManyWithoutTankNestedInput
    LotReading?: LotReadingUpdateManyWithoutTankNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTanksNestedInput
    TankAssignment?: TankAssignmentUpdateManyWithoutTankNestedInput
    occupations?: TankOccupationUpdateManyWithoutTankNestedInput
    Transfer_Transfer_destTankIdToTank?: TransferUpdateManyWithoutTank_Transfer_destTankIdToTankNestedInput
  }

  export type TankUncheckedUpdateWithoutTransfer_Transfer_sourceTankIdToTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTankTypeFieldUpdateOperationsInput | $Enums.TankType
    capacity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFieldUpdateOperationsInput | $Enums.TankStatus
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: TankUpdatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPhase?: NullableEnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase | null
    defaultTurnaroundHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    minFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    batches?: BatchUncheckedUpdateManyWithoutTankNestedInput
    LotReading?: LotReadingUncheckedUpdateManyWithoutTankNestedInput
    TankAssignment?: TankAssignmentUncheckedUpdateManyWithoutTankNestedInput
    occupations?: TankOccupationUncheckedUpdateManyWithoutTankNestedInput
    Transfer_Transfer_destTankIdToTank?: TransferUncheckedUpdateManyWithoutTank_Transfer_destTankIdToTankNestedInput
  }

  export type BatchCreateWithoutKegInput = {
    id?: string
    batchNumber: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    recipe: RecipeCreateNestedOneWithoutBatchesInput
    tank?: TankCreateNestedOneWithoutBatchesInput
    tenant: TenantCreateNestedOneWithoutBatchesInput
    ingredients?: BatchIngredientCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunCreateNestedManyWithoutBatchInput
    QCTest?: QCTestCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutKegInput = {
    id?: string
    tenantId: string
    batchNumber: string
    recipeId: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    tankId?: string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    ingredients?: BatchIngredientUncheckedCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineUncheckedCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingUncheckedCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerUncheckedCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchUncheckedCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunUncheckedCreateNestedManyWithoutBatchInput
    QCTest?: QCTestUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutKegInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutKegInput, BatchUncheckedCreateWithoutKegInput>
  }

  export type CustomerCreateWithoutKegInput = {
    id?: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    kegReturnDays?: number
    kegDepositRequired?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCustomersInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    orders?: SalesOrderCreateNestedManyWithoutCustomerInput
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutKegInput = {
    id?: string
    tenantId: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    kegReturnDays?: number
    kegDepositRequired?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutKegInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutKegInput, CustomerUncheckedCreateWithoutKegInput>
  }

  export type TenantCreateWithoutKegInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchCreateNestedManyWithoutTenantInput
    budgets?: BudgetCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentCreateNestedManyWithoutTenantInput
    expenses?: ExpenseCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    recipes?: RecipeCreateNestedManyWithoutTenantInput
    orders?: SalesOrderCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    tanks?: TankCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutKegInput = {
    id?: string
    name: string
    slug: string
    plan?: $Enums.PlanType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code: string
    legalName?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    website?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankSwift?: string | null
    batches?: BatchUncheckedCreateNestedManyWithoutTenantInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutTenantInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutTenantInput
    inventory?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutTenantInput
    orders?: SalesOrderUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    tanks?: TankUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutKegInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutKegInput, TenantUncheckedCreateWithoutKegInput>
  }

  export type KegMovementCreateWithoutKegInput = {
    id?: string
    tenantId: string
    action: $Enums.KegAction
    fromStatus: $Enums.KegStatus
    toStatus: $Enums.KegStatus
    productId?: string | null
    productName?: string | null
    customerId?: string | null
    customerName?: string | null
    orderId?: string | null
    batchId?: string | null
    notes?: string | null
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type KegMovementUncheckedCreateWithoutKegInput = {
    id?: string
    tenantId: string
    action: $Enums.KegAction
    fromStatus: $Enums.KegStatus
    toStatus: $Enums.KegStatus
    productId?: string | null
    productName?: string | null
    customerId?: string | null
    customerName?: string | null
    orderId?: string | null
    batchId?: string | null
    notes?: string | null
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type KegMovementCreateOrConnectWithoutKegInput = {
    where: KegMovementWhereUniqueInput
    create: XOR<KegMovementCreateWithoutKegInput, KegMovementUncheckedCreateWithoutKegInput>
  }

  export type KegMovementCreateManyKegInputEnvelope = {
    data: KegMovementCreateManyKegInput | KegMovementCreateManyKegInput[]
    skipDuplicates?: boolean
  }

  export type BatchUpsertWithoutKegInput = {
    update: XOR<BatchUpdateWithoutKegInput, BatchUncheckedUpdateWithoutKegInput>
    create: XOR<BatchCreateWithoutKegInput, BatchUncheckedCreateWithoutKegInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutKegInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutKegInput, BatchUncheckedUpdateWithoutKegInput>
  }

  export type BatchUpdateWithoutKegInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    recipe?: RecipeUpdateOneRequiredWithoutBatchesNestedInput
    tank?: TankUpdateOneWithoutBatchesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutBatchesNestedInput
    ingredients?: BatchIngredientUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutKegInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tankId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: BatchIngredientUncheckedUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUncheckedUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUncheckedUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUncheckedUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUncheckedUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUncheckedUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type CustomerUpsertWithoutKegInput = {
    update: XOR<CustomerUpdateWithoutKegInput, CustomerUncheckedUpdateWithoutKegInput>
    create: XOR<CustomerCreateWithoutKegInput, CustomerUncheckedCreateWithoutKegInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutKegInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutKegInput, CustomerUncheckedUpdateWithoutKegInput>
  }

  export type CustomerUpdateWithoutKegInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    kegReturnDays?: IntFieldUpdateOperationsInput | number
    kegDepositRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    orders?: SalesOrderUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutKegInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    kegReturnDays?: IntFieldUpdateOperationsInput | number
    kegDepositRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type TenantUpsertWithoutKegInput = {
    update: XOR<TenantUpdateWithoutKegInput, TenantUncheckedUpdateWithoutKegInput>
    create: XOR<TenantCreateWithoutKegInput, TenantUncheckedCreateWithoutKegInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutKegInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutKegInput, TenantUncheckedUpdateWithoutKegInput>
  }

  export type TenantUpdateWithoutKegInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    tanks?: TankUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutKegInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    plan?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankSwift?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUncheckedUpdateManyWithoutTenantNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutTenantNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutTenantNestedInput
    inventory?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutTenantNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    tanks?: TankUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type KegMovementUpsertWithWhereUniqueWithoutKegInput = {
    where: KegMovementWhereUniqueInput
    update: XOR<KegMovementUpdateWithoutKegInput, KegMovementUncheckedUpdateWithoutKegInput>
    create: XOR<KegMovementCreateWithoutKegInput, KegMovementUncheckedCreateWithoutKegInput>
  }

  export type KegMovementUpdateWithWhereUniqueWithoutKegInput = {
    where: KegMovementWhereUniqueInput
    data: XOR<KegMovementUpdateWithoutKegInput, KegMovementUncheckedUpdateWithoutKegInput>
  }

  export type KegMovementUpdateManyWithWhereWithoutKegInput = {
    where: KegMovementScalarWhereInput
    data: XOR<KegMovementUpdateManyMutationInput, KegMovementUncheckedUpdateManyWithoutKegInput>
  }

  export type KegMovementScalarWhereInput = {
    AND?: KegMovementScalarWhereInput | KegMovementScalarWhereInput[]
    OR?: KegMovementScalarWhereInput[]
    NOT?: KegMovementScalarWhereInput | KegMovementScalarWhereInput[]
    id?: StringFilter<"KegMovement"> | string
    tenantId?: StringFilter<"KegMovement"> | string
    kegId?: StringFilter<"KegMovement"> | string
    action?: EnumKegActionFilter<"KegMovement"> | $Enums.KegAction
    fromStatus?: EnumKegStatusFilter<"KegMovement"> | $Enums.KegStatus
    toStatus?: EnumKegStatusFilter<"KegMovement"> | $Enums.KegStatus
    productId?: StringNullableFilter<"KegMovement"> | string | null
    productName?: StringNullableFilter<"KegMovement"> | string | null
    customerId?: StringNullableFilter<"KegMovement"> | string | null
    customerName?: StringNullableFilter<"KegMovement"> | string | null
    orderId?: StringNullableFilter<"KegMovement"> | string | null
    batchId?: StringNullableFilter<"KegMovement"> | string | null
    notes?: StringNullableFilter<"KegMovement"> | string | null
    createdAt?: DateTimeFilter<"KegMovement"> | Date | string
    createdBy?: StringNullableFilter<"KegMovement"> | string | null
  }

  export type KegCreateWithoutMovementsInput = {
    id?: string
    kegNumber: string
    size: number
    status?: $Enums.KegStatus
    condition?: $Enums.KegCondition
    filledAt?: Date | string | null
    productName?: string | null
    lotNumber?: string | null
    orderId?: string | null
    sentAt?: Date | string | null
    returnedAt?: Date | string | null
    deposit?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Batch?: BatchCreateNestedOneWithoutKegInput
    Customer?: CustomerCreateNestedOneWithoutKegInput
    Tenant: TenantCreateNestedOneWithoutKegInput
  }

  export type KegUncheckedCreateWithoutMovementsInput = {
    id?: string
    tenantId: string
    kegNumber: string
    size: number
    status?: $Enums.KegStatus
    condition?: $Enums.KegCondition
    batchId?: string | null
    filledAt?: Date | string | null
    productName?: string | null
    lotNumber?: string | null
    customerId?: string | null
    orderId?: string | null
    sentAt?: Date | string | null
    returnedAt?: Date | string | null
    deposit?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KegCreateOrConnectWithoutMovementsInput = {
    where: KegWhereUniqueInput
    create: XOR<KegCreateWithoutMovementsInput, KegUncheckedCreateWithoutMovementsInput>
  }

  export type KegUpsertWithoutMovementsInput = {
    update: XOR<KegUpdateWithoutMovementsInput, KegUncheckedUpdateWithoutMovementsInput>
    create: XOR<KegCreateWithoutMovementsInput, KegUncheckedCreateWithoutMovementsInput>
    where?: KegWhereInput
  }

  export type KegUpdateToOneWithWhereWithoutMovementsInput = {
    where?: KegWhereInput
    data: XOR<KegUpdateWithoutMovementsInput, KegUncheckedUpdateWithoutMovementsInput>
  }

  export type KegUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    kegNumber?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    status?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    condition?: EnumKegConditionFieldUpdateOperationsInput | $Enums.KegCondition
    filledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateOneWithoutKegNestedInput
    Customer?: CustomerUpdateOneWithoutKegNestedInput
    Tenant?: TenantUpdateOneRequiredWithoutKegNestedInput
  }

  export type KegUncheckedUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kegNumber?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    status?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    condition?: EnumKegConditionFieldUpdateOperationsInput | $Enums.KegCondition
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    filledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchCreateWithoutQCTestInput = {
    id?: string
    batchNumber: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    recipe: RecipeCreateNestedOneWithoutBatchesInput
    tank?: TankCreateNestedOneWithoutBatchesInput
    tenant: TenantCreateNestedOneWithoutBatchesInput
    ingredients?: BatchIngredientCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerCreateNestedManyWithoutBatchInput
    Keg?: KegCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutQCTestInput = {
    id?: string
    tenantId: string
    batchNumber: string
    recipeId: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    tankId?: string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
    ingredients?: BatchIngredientUncheckedCreateNestedManyWithoutBatchInput
    timeline?: BatchTimelineUncheckedCreateNestedManyWithoutBatchInput
    gravityReadings?: GravityReadingUncheckedCreateNestedManyWithoutBatchInput
    ledgerEntries?: InventoryLedgerUncheckedCreateNestedManyWithoutBatchInput
    Keg?: KegUncheckedCreateNestedManyWithoutBatchInput
    LotBatch?: LotBatchUncheckedCreateNestedManyWithoutBatchInput
    packagingRuns?: PackagingRunUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutQCTestInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutQCTestInput, BatchUncheckedCreateWithoutQCTestInput>
  }

  export type LotCreateWithoutQCTestInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
    Lot?: LotCreateNestedOneWithoutOther_LotInput
    other_Lot?: LotCreateNestedManyWithoutLotInput
    LotBatch?: LotBatchCreateNestedManyWithoutLotInput
    LotReading?: LotReadingCreateNestedManyWithoutLotInput
    TankAssignment?: TankAssignmentCreateNestedManyWithoutLotInput
    Transfer_Transfer_destLotIdToLot?: TransferCreateNestedManyWithoutLot_Transfer_destLotIdToLotInput
    Transfer_Transfer_sourceLotIdToLot?: TransferCreateNestedManyWithoutLot_Transfer_sourceLotIdToLotInput
  }

  export type LotUncheckedCreateWithoutQCTestInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    parentLotId?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
    other_Lot?: LotUncheckedCreateNestedManyWithoutLotInput
    LotBatch?: LotBatchUncheckedCreateNestedManyWithoutLotInput
    LotReading?: LotReadingUncheckedCreateNestedManyWithoutLotInput
    TankAssignment?: TankAssignmentUncheckedCreateNestedManyWithoutLotInput
    Transfer_Transfer_destLotIdToLot?: TransferUncheckedCreateNestedManyWithoutLot_Transfer_destLotIdToLotInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUncheckedCreateNestedManyWithoutLot_Transfer_sourceLotIdToLotInput
  }

  export type LotCreateOrConnectWithoutQCTestInput = {
    where: LotWhereUniqueInput
    create: XOR<LotCreateWithoutQCTestInput, LotUncheckedCreateWithoutQCTestInput>
  }

  export type BatchUpsertWithoutQCTestInput = {
    update: XOR<BatchUpdateWithoutQCTestInput, BatchUncheckedUpdateWithoutQCTestInput>
    create: XOR<BatchCreateWithoutQCTestInput, BatchUncheckedCreateWithoutQCTestInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutQCTestInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutQCTestInput, BatchUncheckedUpdateWithoutQCTestInput>
  }

  export type BatchUpdateWithoutQCTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    recipe?: RecipeUpdateOneRequiredWithoutBatchesNestedInput
    tank?: TankUpdateOneWithoutBatchesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutBatchesNestedInput
    ingredients?: BatchIngredientUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUpdateManyWithoutBatchNestedInput
    Keg?: KegUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutQCTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tankId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: BatchIngredientUncheckedUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUncheckedUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUncheckedUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUncheckedUpdateManyWithoutBatchNestedInput
    Keg?: KegUncheckedUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUncheckedUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type LotUpsertWithoutQCTestInput = {
    update: XOR<LotUpdateWithoutQCTestInput, LotUncheckedUpdateWithoutQCTestInput>
    create: XOR<LotCreateWithoutQCTestInput, LotUncheckedCreateWithoutQCTestInput>
    where?: LotWhereInput
  }

  export type LotUpdateToOneWithWhereWithoutQCTestInput = {
    where?: LotWhereInput
    data: XOR<LotUpdateWithoutQCTestInput, LotUncheckedUpdateWithoutQCTestInput>
  }

  export type LotUpdateWithoutQCTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Lot?: LotUpdateOneWithoutOther_LotNestedInput
    other_Lot?: LotUpdateManyWithoutLotNestedInput
    LotBatch?: LotBatchUpdateManyWithoutLotNestedInput
    LotReading?: LotReadingUpdateManyWithoutLotNestedInput
    TankAssignment?: TankAssignmentUpdateManyWithoutLotNestedInput
    Transfer_Transfer_destLotIdToLot?: TransferUpdateManyWithoutLot_Transfer_destLotIdToLotNestedInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUpdateManyWithoutLot_Transfer_sourceLotIdToLotNestedInput
  }

  export type LotUncheckedUpdateWithoutQCTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_Lot?: LotUncheckedUpdateManyWithoutLotNestedInput
    LotBatch?: LotBatchUncheckedUpdateManyWithoutLotNestedInput
    LotReading?: LotReadingUncheckedUpdateManyWithoutLotNestedInput
    TankAssignment?: TankAssignmentUncheckedUpdateManyWithoutLotNestedInput
    Transfer_Transfer_destLotIdToLot?: TransferUncheckedUpdateManyWithoutLot_Transfer_destLotIdToLotNestedInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUncheckedUpdateManyWithoutLot_Transfer_sourceLotIdToLotNestedInput
  }

  export type TourCreateWithoutMuseumInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourUncheckedCreateWithoutMuseumInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourCreateOrConnectWithoutMuseumInput = {
    where: TourWhereUniqueInput
    create: XOR<TourCreateWithoutMuseumInput, TourUncheckedCreateWithoutMuseumInput>
  }

  export type TourCreateManyMuseumInputEnvelope = {
    data: TourCreateManyMuseumInput | TourCreateManyMuseumInput[]
    skipDuplicates?: boolean
  }

  export type TourUpsertWithWhereUniqueWithoutMuseumInput = {
    where: TourWhereUniqueInput
    update: XOR<TourUpdateWithoutMuseumInput, TourUncheckedUpdateWithoutMuseumInput>
    create: XOR<TourCreateWithoutMuseumInput, TourUncheckedCreateWithoutMuseumInput>
  }

  export type TourUpdateWithWhereUniqueWithoutMuseumInput = {
    where: TourWhereUniqueInput
    data: XOR<TourUpdateWithoutMuseumInput, TourUncheckedUpdateWithoutMuseumInput>
  }

  export type TourUpdateManyWithWhereWithoutMuseumInput = {
    where: TourScalarWhereInput
    data: XOR<TourUpdateManyMutationInput, TourUncheckedUpdateManyWithoutMuseumInput>
  }

  export type TourScalarWhereInput = {
    AND?: TourScalarWhereInput | TourScalarWhereInput[]
    OR?: TourScalarWhereInput[]
    NOT?: TourScalarWhereInput | TourScalarWhereInput[]
    id?: StringFilter<"Tour"> | string
    museumId?: StringFilter<"Tour"> | string
    createdAt?: DateTimeFilter<"Tour"> | Date | string
    updatedAt?: DateTimeFilter<"Tour"> | Date | string
  }

  export type MuseumCreateWithoutToursInput = {
    id?: string
    name: string
    description?: string | null
    city?: string | null
    address?: string | null
    nameEn?: string | null
    descriptionEn?: string | null
    cityEn?: string | null
    addressEn?: string | null
    nameRu?: string | null
    descriptionRu?: string | null
    cityRu?: string | null
    addressRu?: string | null
    nameDe?: string | null
    descriptionDe?: string | null
    cityDe?: string | null
    addressDe?: string | null
    nameFr?: string | null
    descriptionFr?: string | null
    cityFr?: string | null
    addressFr?: string | null
    slug: string
    coverImage?: string | null
    latitude?: number | null
    longitude?: number | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    showMap?: boolean
    showQrScanner?: boolean
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MuseumUncheckedCreateWithoutToursInput = {
    id?: string
    name: string
    description?: string | null
    city?: string | null
    address?: string | null
    nameEn?: string | null
    descriptionEn?: string | null
    cityEn?: string | null
    addressEn?: string | null
    nameRu?: string | null
    descriptionRu?: string | null
    cityRu?: string | null
    addressRu?: string | null
    nameDe?: string | null
    descriptionDe?: string | null
    cityDe?: string | null
    addressDe?: string | null
    nameFr?: string | null
    descriptionFr?: string | null
    cityFr?: string | null
    addressFr?: string | null
    slug: string
    coverImage?: string | null
    latitude?: number | null
    longitude?: number | null
    contactEmail?: string | null
    contactPhone?: string | null
    website?: string | null
    showMap?: boolean
    showQrScanner?: boolean
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MuseumCreateOrConnectWithoutToursInput = {
    where: MuseumWhereUniqueInput
    create: XOR<MuseumCreateWithoutToursInput, MuseumUncheckedCreateWithoutToursInput>
  }

  export type MuseumUpsertWithoutToursInput = {
    update: XOR<MuseumUpdateWithoutToursInput, MuseumUncheckedUpdateWithoutToursInput>
    create: XOR<MuseumCreateWithoutToursInput, MuseumUncheckedCreateWithoutToursInput>
    where?: MuseumWhereInput
  }

  export type MuseumUpdateToOneWithWhereWithoutToursInput = {
    where?: MuseumWhereInput
    data: XOR<MuseumUpdateWithoutToursInput, MuseumUncheckedUpdateWithoutToursInput>
  }

  export type MuseumUpdateWithoutToursInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    cityEn?: NullableStringFieldUpdateOperationsInput | string | null
    addressEn?: NullableStringFieldUpdateOperationsInput | string | null
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionRu?: NullableStringFieldUpdateOperationsInput | string | null
    cityRu?: NullableStringFieldUpdateOperationsInput | string | null
    addressRu?: NullableStringFieldUpdateOperationsInput | string | null
    nameDe?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionDe?: NullableStringFieldUpdateOperationsInput | string | null
    cityDe?: NullableStringFieldUpdateOperationsInput | string | null
    addressDe?: NullableStringFieldUpdateOperationsInput | string | null
    nameFr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFr?: NullableStringFieldUpdateOperationsInput | string | null
    cityFr?: NullableStringFieldUpdateOperationsInput | string | null
    addressFr?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    showMap?: BoolFieldUpdateOperationsInput | boolean
    showQrScanner?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuseumUncheckedUpdateWithoutToursInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    cityEn?: NullableStringFieldUpdateOperationsInput | string | null
    addressEn?: NullableStringFieldUpdateOperationsInput | string | null
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionRu?: NullableStringFieldUpdateOperationsInput | string | null
    cityRu?: NullableStringFieldUpdateOperationsInput | string | null
    addressRu?: NullableStringFieldUpdateOperationsInput | string | null
    nameDe?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionDe?: NullableStringFieldUpdateOperationsInput | string | null
    cityDe?: NullableStringFieldUpdateOperationsInput | string | null
    addressDe?: NullableStringFieldUpdateOperationsInput | string | null
    nameFr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionFr?: NullableStringFieldUpdateOperationsInput | string | null
    cityFr?: NullableStringFieldUpdateOperationsInput | string | null
    addressFr?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    showMap?: BoolFieldUpdateOperationsInput | boolean
    showQrScanner?: BoolFieldUpdateOperationsInput | boolean
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchCreateManyTenantInput = {
    id?: string
    batchNumber: string
    recipeId: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    tankId?: string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
  }

  export type BudgetCreateManyTenantInput = {
    id?: string
    category: $Enums.ExpenseCategory
    year: number
    month?: number | null
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateManyTenantInput = {
    id?: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    kegReturnDays?: number
    kegDepositRequired?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCreateManyTenantInput = {
    id: string
    name: string
    type: string
    status?: string
    capacity?: number | null
    model?: string | null
    manufacturer?: string | null
    serialNumber?: string | null
    location?: string | null
    workingPressure?: number | null
    currentTemp?: number | null
    currentPressure?: number | null
    installationDate?: Date | string | null
    warrantyDate?: Date | string | null
    lastCIP?: Date | string | null
    nextCIP?: Date | string | null
    lastMaintenance?: Date | string | null
    nextMaintenance?: Date | string | null
    cipIntervalDays?: number
    inspectionIntervalDays?: number
    annualMaintenanceDays?: number
    currentBatchId?: string | null
    currentBatchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    purchaseDate?: Date | string | null
    capabilities?: EquipmentCreatecapabilitiesInput | string[]
  }

  export type ExpenseCreateManyTenantInput = {
    id?: string
    category: $Enums.ExpenseCategory
    supplierId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    invoiceNumber?: string | null
    invoiceId?: string | null
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    receiptUrl?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemCreateManyTenantInput = {
    id?: string
    sku: string
    name: string
    category?: $Enums.InventoryCategory
    ingredientType?: string | null
    unit?: string
    reorderPoint?: Decimal | DecimalJsLike | number | string | null
    supplier?: string | null
    location?: string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: Decimal | DecimalJsLike | number | string
    costPerUnit?: Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyTenantInput = {
    id?: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    customerId?: string | null
    supplierId?: string | null
    orderId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KegCreateManyTenantInput = {
    id?: string
    kegNumber: string
    size: number
    status?: $Enums.KegStatus
    condition?: $Enums.KegCondition
    batchId?: string | null
    filledAt?: Date | string | null
    productName?: string | null
    lotNumber?: string | null
    customerId?: string | null
    orderId?: string | null
    sentAt?: Date | string | null
    returnedAt?: Date | string | null
    deposit?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyTenantInput = {
    id?: string
    invoiceId?: string | null
    orderId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PaymentMethod
    date?: Date | string
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type RecipeCreateManyTenantInput = {
    id?: string
    createdBy?: string | null
    name: string
    style?: string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    ibu?: number | null
    color?: number | null
    og?: Decimal | DecimalJsLike | number | string | null
    fg?: Decimal | DecimalJsLike | number | string | null
    batchSize?: Decimal | DecimalJsLike | number | string | null
    boilTime?: number | null
    efficiency?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    notes?: string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.RecipeStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    yeastStrain?: string | null
  }

  export type SalesOrderCreateManyTenantInput = {
    id?: string
    orderNumber: string
    customerId: string
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    orderedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdBy: string
    updatedAt?: Date | string
  }

  export type SupplierCreateManyTenantInput = {
    id?: string
    name: string
    category?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    taxId?: string | null
    bankAccount?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TankCreateManyTenantInput = {
    id?: string
    name: string
    type: $Enums.TankType
    capacity: Decimal | DecimalJsLike | number | string
    status?: $Enums.TankStatus
    currentBatchId?: string | null
    location?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    capabilities?: TankCreatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: string | null
    currentPhase?: $Enums.LotPhase | null
    defaultTurnaroundHours?: number | null
    maxFillPercent?: number | null
    minFillPercent?: number | null
  }

  export type TransactionCreateManyTenantInput = {
    id?: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    customerId?: string | null
    supplierId?: string | null
    orderId?: string | null
    invoiceId?: string | null
    expenseId?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyTenantInput = {
    id?: string
    email: string
    name: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    password?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
  }

  export type BatchUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    recipe?: RecipeUpdateOneRequiredWithoutBatchesNestedInput
    tank?: TankUpdateOneWithoutBatchesNestedInput
    ingredients?: BatchIngredientUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUpdateManyWithoutBatchNestedInput
    Keg?: KegUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tankId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: BatchIngredientUncheckedUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUncheckedUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUncheckedUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUncheckedUpdateManyWithoutBatchNestedInput
    Keg?: KegUncheckedUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUncheckedUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUncheckedUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tankId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BudgetUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    year?: IntFieldUpdateOperationsInput | number
    month?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    year?: IntFieldUpdateOperationsInput | number
    month?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    year?: IntFieldUpdateOperationsInput | number
    month?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    kegReturnDays?: IntFieldUpdateOperationsInput | number
    kegDepositRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    Keg?: KegUpdateManyWithoutCustomerNestedInput
    orders?: SalesOrderUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    kegReturnDays?: IntFieldUpdateOperationsInput | number
    kegDepositRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    Keg?: KegUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    kegReturnDays?: IntFieldUpdateOperationsInput | number
    kegDepositRequired?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workingPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    currentTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cipIntervalDays?: IntFieldUpdateOperationsInput | number
    inspectionIntervalDays?: IntFieldUpdateOperationsInput | number
    annualMaintenanceDays?: IntFieldUpdateOperationsInput | number
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBatchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capabilities?: EquipmentUpdatecapabilitiesInput | string[]
    CIPLog?: CIPLogUpdateManyWithoutEquipmentNestedInput
    MaintenanceLog?: MaintenanceLogUpdateManyWithoutEquipmentNestedInput
    ProblemReport?: ProblemReportUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workingPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    currentTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cipIntervalDays?: IntFieldUpdateOperationsInput | number
    inspectionIntervalDays?: IntFieldUpdateOperationsInput | number
    annualMaintenanceDays?: IntFieldUpdateOperationsInput | number
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBatchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capabilities?: EquipmentUpdatecapabilitiesInput | string[]
    CIPLog?: CIPLogUncheckedUpdateManyWithoutEquipmentNestedInput
    MaintenanceLog?: MaintenanceLogUncheckedUpdateManyWithoutEquipmentNestedInput
    ProblemReport?: ProblemReportUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    workingPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    currentTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    currentPressure?: NullableFloatFieldUpdateOperationsInput | number | null
    installationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCIP?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cipIntervalDays?: IntFieldUpdateOperationsInput | number
    inspectionIntervalDays?: IntFieldUpdateOperationsInput | number
    annualMaintenanceDays?: IntFieldUpdateOperationsInput | number
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBatchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    capabilities?: EquipmentUpdatecapabilitiesInput | string[]
  }

  export type ExpenseUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneWithoutExpensesNestedInput
    transactions?: TransactionUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    ingredientType?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderPoint?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledger?: InventoryLedgerUpdateManyWithoutItemNestedInput
    recipeIngredients?: RecipeIngredientUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    ingredientType?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderPoint?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledger?: InventoryLedgerUncheckedUpdateManyWithoutItemNestedInput
    recipeIngredients?: RecipeIngredientUncheckedUpdateManyWithoutInventoryItemNestedInput
  }

  export type InventoryItemUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumInventoryCategoryFieldUpdateOperationsInput | $Enums.InventoryCategory
    ingredientType?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderPoint?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    cachedBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    costPerUnit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    balanceUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutInvoicesNestedInput
    order?: SalesOrderUpdateOneWithoutInvoiceNestedInput
    supplier?: SupplierUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KegUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    kegNumber?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    status?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    condition?: EnumKegConditionFieldUpdateOperationsInput | $Enums.KegCondition
    filledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateOneWithoutKegNestedInput
    Customer?: CustomerUpdateOneWithoutKegNestedInput
    movements?: KegMovementUpdateManyWithoutKegNestedInput
  }

  export type KegUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    kegNumber?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    status?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    condition?: EnumKegConditionFieldUpdateOperationsInput | $Enums.KegCondition
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    filledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: KegMovementUncheckedUpdateManyWithoutKegNestedInput
  }

  export type KegUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    kegNumber?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    status?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    condition?: EnumKegConditionFieldUpdateOperationsInput | $Enums.KegCondition
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    filledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutPaymentsNestedInput
    order?: SalesOrderUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    style?: NullableStringFieldUpdateOperationsInput | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ibu?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableIntFieldUpdateOperationsInput | number | null
    og?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    batchSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boilTime?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumRecipeStatusFieldUpdateOperationsInput | $Enums.RecipeStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yeastStrain?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    style?: NullableStringFieldUpdateOperationsInput | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ibu?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableIntFieldUpdateOperationsInput | number | null
    og?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    batchSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boilTime?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumRecipeStatusFieldUpdateOperationsInput | $Enums.RecipeStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yeastStrain?: NullableStringFieldUpdateOperationsInput | string | null
    batches?: BatchUncheckedUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    style?: NullableStringFieldUpdateOperationsInput | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    ibu?: NullableIntFieldUpdateOperationsInput | number | null
    color?: NullableIntFieldUpdateOperationsInput | number | null
    og?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    batchSize?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    boilTime?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    process?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumRecipeStatusFieldUpdateOperationsInput | $Enums.RecipeStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yeastStrain?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalesOrderUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    transactions?: TransactionUpdateManyWithoutOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: ExpenseUpdateManyWithoutSupplierNestedInput
    invoices?: InvoiceUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: ExpenseUncheckedUpdateManyWithoutSupplierNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSupplierNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TankUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTankTypeFieldUpdateOperationsInput | $Enums.TankType
    capacity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFieldUpdateOperationsInput | $Enums.TankStatus
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: TankUpdatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPhase?: NullableEnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase | null
    defaultTurnaroundHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    minFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    batches?: BatchUpdateManyWithoutTankNestedInput
    LotReading?: LotReadingUpdateManyWithoutTankNestedInput
    TankAssignment?: TankAssignmentUpdateManyWithoutTankNestedInput
    occupations?: TankOccupationUpdateManyWithoutTankNestedInput
    Transfer_Transfer_destTankIdToTank?: TransferUpdateManyWithoutTank_Transfer_destTankIdToTankNestedInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUpdateManyWithoutTank_Transfer_sourceTankIdToTankNestedInput
  }

  export type TankUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTankTypeFieldUpdateOperationsInput | $Enums.TankType
    capacity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFieldUpdateOperationsInput | $Enums.TankStatus
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: TankUpdatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPhase?: NullableEnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase | null
    defaultTurnaroundHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    minFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    batches?: BatchUncheckedUpdateManyWithoutTankNestedInput
    LotReading?: LotReadingUncheckedUpdateManyWithoutTankNestedInput
    TankAssignment?: TankAssignmentUncheckedUpdateManyWithoutTankNestedInput
    occupations?: TankOccupationUncheckedUpdateManyWithoutTankNestedInput
    Transfer_Transfer_destTankIdToTank?: TransferUncheckedUpdateManyWithoutTank_Transfer_destTankIdToTankNestedInput
    Transfer_Transfer_sourceTankIdToTank?: TransferUncheckedUpdateManyWithoutTank_Transfer_sourceTankIdToTankNestedInput
  }

  export type TankUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTankTypeFieldUpdateOperationsInput | $Enums.TankType
    capacity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTankStatusFieldUpdateOperationsInput | $Enums.TankStatus
    currentBatchId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capabilities?: TankUpdatecapabilitiesInput | $Enums.TankCapability[]
    currentLotId?: NullableStringFieldUpdateOperationsInput | string | null
    currentPhase?: NullableEnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase | null
    defaultTurnaroundHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
    minFillPercent?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TransactionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    expense?: ExpenseUpdateOneWithoutTransactionsNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
    order?: SalesOrderUpdateOneWithoutTransactionsNestedInput
    supplier?: SupplierUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    expenseId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    expenseId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BatchCreateManyRecipeInput = {
    id?: string
    tenantId: string
    batchNumber: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    tankId?: string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
  }

  export type RecipeIngredientCreateManyRecipeInput = {
    id?: string
    inventoryItemId?: string | null
    name: string
    category: $Enums.IngredientCategory
    amount: Decimal | DecimalJsLike | number | string
    unit: string
    additionTime?: number | null
    specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BatchUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    tank?: TankUpdateOneWithoutBatchesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutBatchesNestedInput
    ingredients?: BatchIngredientUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUpdateManyWithoutBatchNestedInput
    Keg?: KegUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tankId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: BatchIngredientUncheckedUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUncheckedUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUncheckedUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUncheckedUpdateManyWithoutBatchNestedInput
    Keg?: KegUncheckedUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUncheckedUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUncheckedUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tankId?: NullableStringFieldUpdateOperationsInput | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeIngredientUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumIngredientCategoryFieldUpdateOperationsInput | $Enums.IngredientCategory
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    additionTime?: NullableIntFieldUpdateOperationsInput | number | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    inventoryItem?: InventoryItemUpdateOneWithoutRecipeIngredientsNestedInput
  }

  export type RecipeIngredientUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumIngredientCategoryFieldUpdateOperationsInput | $Enums.IngredientCategory
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    additionTime?: NullableIntFieldUpdateOperationsInput | number | null
    specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RecipeIngredientUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumIngredientCategoryFieldUpdateOperationsInput | $Enums.IngredientCategory
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    additionTime?: NullableIntFieldUpdateOperationsInput | number | null
    specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InventoryLedgerCreateManyItemInput = {
    id?: string
    tenantId: string
    quantity: Decimal | DecimalJsLike | number | string
    type: $Enums.LedgerEntryType
    batchId?: string | null
    orderId?: string | null
    packagingId?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type RecipeIngredientCreateManyInventoryItemInput = {
    id?: string
    recipeId: string
    name: string
    category: $Enums.IngredientCategory
    amount: Decimal | DecimalJsLike | number | string
    unit: string
    additionTime?: number | null
    specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InventoryLedgerUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    packagingId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: BatchUpdateOneWithoutLedgerEntriesNestedInput
  }

  export type InventoryLedgerUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    packagingId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLedgerUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    packagingId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeIngredientUpdateWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumIngredientCategoryFieldUpdateOperationsInput | $Enums.IngredientCategory
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    additionTime?: NullableIntFieldUpdateOperationsInput | number | null
    specs?: NullableJsonNullValueInput | InputJsonValue
    recipe?: RecipeUpdateOneRequiredWithoutIngredientsNestedInput
  }

  export type RecipeIngredientUncheckedUpdateWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumIngredientCategoryFieldUpdateOperationsInput | $Enums.IngredientCategory
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    additionTime?: NullableIntFieldUpdateOperationsInput | number | null
    specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RecipeIngredientUncheckedUpdateManyWithoutInventoryItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumIngredientCategoryFieldUpdateOperationsInput | $Enums.IngredientCategory
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    additionTime?: NullableIntFieldUpdateOperationsInput | number | null
    specs?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BatchIngredientCreateManyBatchInput = {
    id?: string
    inventoryItemId?: string | null
    name: string
    category: $Enums.IngredientCategory
    plannedAmount: Decimal | DecimalJsLike | number | string
    actualAmount?: Decimal | DecimalJsLike | number | string | null
    unit: string
    lotNumber?: string | null
    addedAt?: Date | string | null
  }

  export type BatchTimelineCreateManyBatchInput = {
    id?: string
    type: $Enums.TimelineEventType
    title: string
    description?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdBy: string
    createdAt?: Date | string
  }

  export type GravityReadingCreateManyBatchInput = {
    id?: string
    gravity: Decimal | DecimalJsLike | number | string
    temperature: Decimal | DecimalJsLike | number | string
    notes?: string | null
    recordedBy: string
    recordedAt?: Date | string
  }

  export type InventoryLedgerCreateManyBatchInput = {
    id?: string
    tenantId: string
    itemId: string
    quantity: Decimal | DecimalJsLike | number | string
    type: $Enums.LedgerEntryType
    orderId?: string | null
    packagingId?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type KegCreateManyBatchInput = {
    id?: string
    tenantId: string
    kegNumber: string
    size: number
    status?: $Enums.KegStatus
    condition?: $Enums.KegCondition
    filledAt?: Date | string | null
    productName?: string | null
    lotNumber?: string | null
    customerId?: string | null
    orderId?: string | null
    sentAt?: Date | string | null
    returnedAt?: Date | string | null
    deposit?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LotBatchCreateManyBatchInput = {
    id: string
    lotId: string
    volumeContribution: Decimal | DecimalJsLike | number | string
    batchPercentage?: Decimal | DecimalJsLike | number | string
    addedAt?: Date | string
  }

  export type PackagingRunCreateManyBatchInput = {
    id?: string
    tenantId: string
    packageType: $Enums.PackageType
    quantity: number
    volumeTotal: Decimal | DecimalJsLike | number | string
    lotNumber?: string | null
    performedBy: string
    notes?: string | null
    performedAt?: Date | string
  }

  export type QCTestCreateManyBatchInput = {
    id: string
    tenantId: string
    lotId?: string | null
    testType: $Enums.QCTestType
    status?: $Enums.QCTestStatus
    priority?: $Enums.QCTestPriority
    scheduledDate: Date | string
    completedDate?: Date | string | null
    minValue?: Decimal | DecimalJsLike | number | string | null
    maxValue?: Decimal | DecimalJsLike | number | string | null
    targetValue?: Decimal | DecimalJsLike | number | string | null
    result?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    performedBy?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type BatchIngredientUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumIngredientCategoryFieldUpdateOperationsInput | $Enums.IngredientCategory
    plannedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BatchIngredientUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumIngredientCategoryFieldUpdateOperationsInput | $Enums.IngredientCategory
    plannedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BatchIngredientUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryItemId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumIngredientCategoryFieldUpdateOperationsInput | $Enums.IngredientCategory
    plannedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: StringFieldUpdateOperationsInput | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BatchTimelineUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTimelineEventTypeFieldUpdateOperationsInput | $Enums.TimelineEventType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchTimelineUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTimelineEventTypeFieldUpdateOperationsInput | $Enums.TimelineEventType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchTimelineUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTimelineEventTypeFieldUpdateOperationsInput | $Enums.TimelineEventType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GravityReadingUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    gravity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    temperature?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GravityReadingUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    gravity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    temperature?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GravityReadingUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    gravity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    temperature?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLedgerUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    packagingId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: InventoryItemUpdateOneRequiredWithoutLedgerNestedInput
  }

  export type InventoryLedgerUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    packagingId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLedgerUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    packagingId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KegUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    kegNumber?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    status?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    condition?: EnumKegConditionFieldUpdateOperationsInput | $Enums.KegCondition
    filledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Customer?: CustomerUpdateOneWithoutKegNestedInput
    Tenant?: TenantUpdateOneRequiredWithoutKegNestedInput
    movements?: KegMovementUpdateManyWithoutKegNestedInput
  }

  export type KegUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kegNumber?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    status?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    condition?: EnumKegConditionFieldUpdateOperationsInput | $Enums.KegCondition
    filledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: KegMovementUncheckedUpdateManyWithoutKegNestedInput
  }

  export type KegUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kegNumber?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    status?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    condition?: EnumKegConditionFieldUpdateOperationsInput | $Enums.KegCondition
    filledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LotBatchUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    volumeContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lot?: LotUpdateOneRequiredWithoutLotBatchNestedInput
  }

  export type LotBatchUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotId?: StringFieldUpdateOperationsInput | string
    volumeContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LotBatchUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotId?: StringFieldUpdateOperationsInput | string
    volumeContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackagingRunUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    packageType?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    quantity?: IntFieldUpdateOperationsInput | number
    volumeTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackagingRunUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    packageType?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    quantity?: IntFieldUpdateOperationsInput | number
    volumeTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackagingRunUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    packageType?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    quantity?: IntFieldUpdateOperationsInput | number
    volumeTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QCTestUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    testType?: EnumQCTestTypeFieldUpdateOperationsInput | $Enums.QCTestType
    status?: EnumQCTestStatusFieldUpdateOperationsInput | $Enums.QCTestStatus
    priority?: EnumQCTestPriorityFieldUpdateOperationsInput | $Enums.QCTestPriority
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    minValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lot?: LotUpdateOneWithoutQCTestNestedInput
  }

  export type QCTestUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: EnumQCTestTypeFieldUpdateOperationsInput | $Enums.QCTestType
    status?: EnumQCTestStatusFieldUpdateOperationsInput | $Enums.QCTestStatus
    priority?: EnumQCTestPriorityFieldUpdateOperationsInput | $Enums.QCTestPriority
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    minValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QCTestUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotId?: NullableStringFieldUpdateOperationsInput | string | null
    testType?: EnumQCTestTypeFieldUpdateOperationsInput | $Enums.QCTestType
    status?: EnumQCTestStatusFieldUpdateOperationsInput | $Enums.QCTestStatus
    priority?: EnumQCTestPriorityFieldUpdateOperationsInput | $Enums.QCTestPriority
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    minValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchCreateManyTankInput = {
    id?: string
    tenantId: string
    batchNumber: string
    recipeId: string
    status?: $Enums.BatchStatus
    volume: Decimal | DecimalJsLike | number | string
    packagedVolume?: Decimal | DecimalJsLike | number | string | null
    originalGravity?: Decimal | DecimalJsLike | number | string | null
    currentGravity?: Decimal | DecimalJsLike | number | string | null
    finalGravity?: Decimal | DecimalJsLike | number | string | null
    abv?: Decimal | DecimalJsLike | number | string | null
    plannedDate: Date | string
    brewedAt?: Date | string | null
    fermentationStartedAt?: Date | string | null
    conditioningStartedAt?: Date | string | null
    readyAt?: Date | string | null
    completedAt?: Date | string | null
    createdBy: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetOg?: Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: string | null
  }

  export type LotReadingCreateManyTankInput = {
    id: string
    lotId: string
    readingType: $Enums.ReadingType
    value: Decimal | DecimalJsLike | number | string
    unit: string
    notes?: string | null
    recordedBy: string
    recordedAt?: Date | string
  }

  export type TankAssignmentCreateManyTankInput = {
    id: string
    tenantId: string
    lotId: string
    phase: $Enums.LotPhase
    plannedStart?: Date | string | null
    plannedEnd?: Date | string | null
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.AssignmentStatus
    plannedVolume?: Decimal | DecimalJsLike | number | string | null
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: boolean
    isSplitSource?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    notes?: string | null
  }

  export type TankOccupationCreateManyTankInput = {
    id?: string
    tenantId: string
    batchId: string
    phase: $Enums.OccupationPhase
    startedAt?: Date | string
    endedAt?: Date | string | null
  }

  export type TransferCreateManyTank_Transfer_destTankIdToTankInput = {
    id: string
    tenantId: string
    transferCode: string
    sourceLotId?: string | null
    sourceTankId: string
    destLotId?: string | null
    transferType: $Enums.TransferType
    volume: Decimal | DecimalJsLike | number | string
    plannedAt: Date | string
    executedAt?: Date | string | null
    status?: $Enums.TransferStatus
    measuredLoss?: Decimal | DecimalJsLike | number | string | null
    lossReason?: string | null
    performedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyTank_Transfer_sourceTankIdToTankInput = {
    id: string
    tenantId: string
    transferCode: string
    sourceLotId?: string | null
    destLotId?: string | null
    destTankId: string
    transferType: $Enums.TransferType
    volume: Decimal | DecimalJsLike | number | string
    plannedAt: Date | string
    executedAt?: Date | string | null
    status?: $Enums.TransferStatus
    measuredLoss?: Decimal | DecimalJsLike | number | string | null
    lossReason?: string | null
    performedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchUpdateWithoutTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    recipe?: RecipeUpdateOneRequiredWithoutBatchesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutBatchesNestedInput
    ingredients?: BatchIngredientUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUpdateManyWithoutBatchNestedInput
    Keg?: KegUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: BatchIngredientUncheckedUpdateManyWithoutBatchNestedInput
    timeline?: BatchTimelineUncheckedUpdateManyWithoutBatchNestedInput
    gravityReadings?: GravityReadingUncheckedUpdateManyWithoutBatchNestedInput
    ledgerEntries?: InventoryLedgerUncheckedUpdateManyWithoutBatchNestedInput
    Keg?: KegUncheckedUpdateManyWithoutBatchNestedInput
    LotBatch?: LotBatchUncheckedUpdateManyWithoutBatchNestedInput
    packagingRuns?: PackagingRunUncheckedUpdateManyWithoutBatchNestedInput
    QCTest?: QCTestUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    packagedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalGravity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    abv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plannedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    brewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fermentationStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conditioningStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetOg?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fermentationTankId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LotReadingUpdateWithoutTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lot?: LotUpdateOneRequiredWithoutLotReadingNestedInput
  }

  export type LotReadingUncheckedUpdateWithoutTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotId?: StringFieldUpdateOperationsInput | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LotReadingUncheckedUpdateManyWithoutTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotId?: StringFieldUpdateOperationsInput | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TankAssignmentUpdateWithoutTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    plannedStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    plannedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: BoolFieldUpdateOperationsInput | boolean
    isSplitSource?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    Lot?: LotUpdateOneRequiredWithoutTankAssignmentNestedInput
  }

  export type TankAssignmentUncheckedUpdateWithoutTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotId?: StringFieldUpdateOperationsInput | string
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    plannedStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    plannedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: BoolFieldUpdateOperationsInput | boolean
    isSplitSource?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TankAssignmentUncheckedUpdateManyWithoutTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotId?: StringFieldUpdateOperationsInput | string
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    plannedStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    plannedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: BoolFieldUpdateOperationsInput | boolean
    isSplitSource?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TankOccupationUpdateWithoutTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    phase?: EnumOccupationPhaseFieldUpdateOperationsInput | $Enums.OccupationPhase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TankOccupationUncheckedUpdateWithoutTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    phase?: EnumOccupationPhaseFieldUpdateOperationsInput | $Enums.OccupationPhase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TankOccupationUncheckedUpdateManyWithoutTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    phase?: EnumOccupationPhaseFieldUpdateOperationsInput | $Enums.OccupationPhase
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransferUpdateWithoutTank_Transfer_destTankIdToTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    measuredLoss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lot_Transfer_destLotIdToLot?: LotUpdateOneWithoutTransfer_Transfer_destLotIdToLotNestedInput
    Lot_Transfer_sourceLotIdToLot?: LotUpdateOneWithoutTransfer_Transfer_sourceLotIdToLotNestedInput
    Tank_Transfer_sourceTankIdToTank?: TankUpdateOneRequiredWithoutTransfer_Transfer_sourceTankIdToTankNestedInput
  }

  export type TransferUncheckedUpdateWithoutTank_Transfer_destTankIdToTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    sourceLotId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceTankId?: StringFieldUpdateOperationsInput | string
    destLotId?: NullableStringFieldUpdateOperationsInput | string | null
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    measuredLoss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateManyWithoutTank_Transfer_destTankIdToTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    sourceLotId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceTankId?: StringFieldUpdateOperationsInput | string
    destLotId?: NullableStringFieldUpdateOperationsInput | string | null
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    measuredLoss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutTank_Transfer_sourceTankIdToTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    measuredLoss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lot_Transfer_destLotIdToLot?: LotUpdateOneWithoutTransfer_Transfer_destLotIdToLotNestedInput
    Tank_Transfer_destTankIdToTank?: TankUpdateOneRequiredWithoutTransfer_Transfer_destTankIdToTankNestedInput
    Lot_Transfer_sourceLotIdToLot?: LotUpdateOneWithoutTransfer_Transfer_sourceLotIdToLotNestedInput
  }

  export type TransferUncheckedUpdateWithoutTank_Transfer_sourceTankIdToTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    sourceLotId?: NullableStringFieldUpdateOperationsInput | string | null
    destLotId?: NullableStringFieldUpdateOperationsInput | string | null
    destTankId?: StringFieldUpdateOperationsInput | string
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    measuredLoss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateManyWithoutTank_Transfer_sourceTankIdToTankInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    sourceLotId?: NullableStringFieldUpdateOperationsInput | string | null
    destLotId?: NullableStringFieldUpdateOperationsInput | string | null
    destTankId?: StringFieldUpdateOperationsInput | string
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    measuredLoss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyCustomerInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    supplierId?: string | null
    orderId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KegCreateManyCustomerInput = {
    id?: string
    tenantId: string
    kegNumber: string
    size: number
    status?: $Enums.KegStatus
    condition?: $Enums.KegCondition
    batchId?: string | null
    filledAt?: Date | string | null
    productName?: string | null
    lotNumber?: string | null
    orderId?: string | null
    sentAt?: Date | string | null
    returnedAt?: Date | string | null
    deposit?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesOrderCreateManyCustomerInput = {
    id?: string
    tenantId: string
    orderNumber: string
    status?: $Enums.OrderStatus
    paymentStatus?: $Enums.PaymentStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    orderedAt?: Date | string
    shippedAt?: Date | string | null
    deliveredAt?: Date | string | null
    createdBy: string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyCustomerInput = {
    id?: string
    tenantId: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    supplierId?: string | null
    orderId?: string | null
    invoiceId?: string | null
    expenseId?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: SalesOrderUpdateOneWithoutInvoiceNestedInput
    supplier?: SupplierUpdateOneWithoutInvoicesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KegUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    kegNumber?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    status?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    condition?: EnumKegConditionFieldUpdateOperationsInput | $Enums.KegCondition
    filledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateOneWithoutKegNestedInput
    Tenant?: TenantUpdateOneRequiredWithoutKegNestedInput
    movements?: KegMovementUpdateManyWithoutKegNestedInput
  }

  export type KegUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kegNumber?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    status?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    condition?: EnumKegConditionFieldUpdateOperationsInput | $Enums.KegCondition
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    filledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    movements?: KegMovementUncheckedUpdateManyWithoutKegNestedInput
  }

  export type KegUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kegNumber?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    status?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    condition?: EnumKegConditionFieldUpdateOperationsInput | $Enums.KegCondition
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    filledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    transactions?: TransactionUpdateManyWithoutOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    orderedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expense?: ExpenseUpdateOneWithoutTransactionsNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
    order?: SalesOrderUpdateOneWithoutTransactionsNestedInput
    supplier?: SupplierUpdateOneWithoutTransactionsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    expenseId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    expenseId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateManySupplierInput = {
    id?: string
    tenantId: string
    category: $Enums.ExpenseCategory
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    description?: string | null
    invoiceNumber?: string | null
    invoiceId?: string | null
    isPaid?: boolean
    paidAt?: Date | string | null
    paymentMethod?: $Enums.PaymentMethod | null
    receiptUrl?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManySupplierInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    customerId?: string | null
    orderId?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManySupplierInput = {
    id?: string
    tenantId: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    customerId?: string | null
    orderId?: string | null
    invoiceId?: string | null
    expenseId?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutExpensesNestedInput
    transactions?: TransactionUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutExpenseNestedInput
  }

  export type ExpenseUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    category?: EnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutInvoicesNestedInput
    order?: SalesOrderUpdateOneWithoutInvoiceNestedInput
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    expense?: ExpenseUpdateOneWithoutTransactionsNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
    order?: SalesOrderUpdateOneWithoutTransactionsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    expenseId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    expenseId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    productName: string
    packageType: $Enums.PackageType
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    batchId?: string | null
  }

  export type PaymentCreateManyOrderInput = {
    id?: string
    tenantId: string
    invoiceId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PaymentMethod
    date?: Date | string
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type TransactionCreateManyOrderInput = {
    id?: string
    tenantId: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    customerId?: string | null
    supplierId?: string | null
    invoiceId?: string | null
    expenseId?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    packageType?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    packageType?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    packageType?: EnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutPaymentsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    expense?: ExpenseUpdateOneWithoutTransactionsNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
    supplier?: SupplierUpdateOneWithoutTransactionsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    expenseId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    expenseId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unit?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    productName?: string | null
    packageType?: $Enums.PackageType | null
    batchId?: string | null
    sortOrder?: number
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: string
    tenantId: string
    orderId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method?: $Enums.PaymentMethod
    date?: Date | string
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type TransactionCreateManyInvoiceInput = {
    id?: string
    tenantId: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    customerId?: string | null
    supplierId?: string | null
    orderId?: string | null
    expenseId?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableEnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableEnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    packageType?: NullableEnumPackageTypeFieldUpdateOperationsInput | $Enums.PackageType | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: SalesOrderUpdateOneWithoutPaymentsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    expense?: ExpenseUpdateOneWithoutTransactionsNestedInput
    order?: SalesOrderUpdateOneWithoutTransactionsNestedInput
    supplier?: SupplierUpdateOneWithoutTransactionsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    expenseId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    expenseId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyExpenseInput = {
    id?: string
    tenantId: string
    type: $Enums.TransactionType
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    incomeCategory?: $Enums.IncomeCategory | null
    expenseCategory?: $Enums.ExpenseCategory | null
    description?: string | null
    customerId?: string | null
    supplierId?: string | null
    orderId?: string | null
    invoiceId?: string | null
    paymentId?: string | null
    paymentMethod?: $Enums.PaymentMethod | null
    reference?: string | null
    notes?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    invoice?: InvoiceUpdateOneWithoutTransactionsNestedInput
    order?: SalesOrderUpdateOneWithoutTransactionsNestedInput
    supplier?: SupplierUpdateOneWithoutTransactionsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incomeCategory?: NullableEnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory | null
    expenseCategory?: NullableEnumExpenseCategoryFieldUpdateOperationsInput | $Enums.ExpenseCategory | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CIPLogCreateManyEquipmentInput = {
    id: string
    cipType: string
    date: Date | string
    duration: number
    temperature?: number | null
    causticConcentration?: number | null
    performedBy: string
    result: string
    notes?: string | null
    createdAt?: Date | string
  }

  export type MaintenanceLogCreateManyEquipmentInput = {
    id: string
    type: string
    status: string
    priority?: string | null
    scheduledDate?: Date | string | null
    completedDate?: Date | string | null
    duration?: number | null
    performedBy?: string | null
    cost?: number | null
    partsUsed?: MaintenanceLogCreatepartsUsedInput | string[]
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type ProblemReportCreateManyEquipmentInput = {
    id: string
    problemType: string
    severity: string
    status?: string
    description: string
    reportedDate: Date | string
    reportedBy: string
    resolvedDate?: Date | string | null
    resolvedBy?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type CIPLogUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    cipType?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    causticConcentration?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CIPLogUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    cipType?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    causticConcentration?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CIPLogUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    cipType?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    causticConcentration?: NullableFloatFieldUpdateOperationsInput | number | null
    performedBy?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceLogUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    partsUsed?: MaintenanceLogUpdatepartsUsedInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceLogUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    partsUsed?: MaintenanceLogUpdatepartsUsedInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceLogUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    partsUsed?: MaintenanceLogUpdatepartsUsedInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProblemReportUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    problemType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProblemReportUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    problemType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProblemReportUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    problemType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    reportedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    resolvedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LotCreateManyLotInput = {
    id: string
    tenantId: string
    lotCode?: string | null
    phase?: $Enums.LotPhase
    status?: $Enums.LotStatus
    plannedVolume: Decimal | DecimalJsLike | number | string
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    splitRatio?: Decimal | DecimalJsLike | number | string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    lotNumber?: string | null
    blendedAt?: Date | string | null
    isBlendResult?: boolean | null
    splitAt?: Date | string | null
  }

  export type LotBatchCreateManyLotInput = {
    id: string
    batchId: string
    volumeContribution: Decimal | DecimalJsLike | number | string
    batchPercentage?: Decimal | DecimalJsLike | number | string
    addedAt?: Date | string
  }

  export type LotReadingCreateManyLotInput = {
    id: string
    tankId: string
    readingType: $Enums.ReadingType
    value: Decimal | DecimalJsLike | number | string
    unit: string
    notes?: string | null
    recordedBy: string
    recordedAt?: Date | string
  }

  export type QCTestCreateManyLotInput = {
    id: string
    tenantId: string
    batchId: string
    testType: $Enums.QCTestType
    status?: $Enums.QCTestStatus
    priority?: $Enums.QCTestPriority
    scheduledDate: Date | string
    completedDate?: Date | string | null
    minValue?: Decimal | DecimalJsLike | number | string | null
    maxValue?: Decimal | DecimalJsLike | number | string | null
    targetValue?: Decimal | DecimalJsLike | number | string | null
    result?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    notes?: string | null
    performedBy?: string | null
    createdBy: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TankAssignmentCreateManyLotInput = {
    id: string
    tenantId: string
    tankId: string
    phase: $Enums.LotPhase
    plannedStart?: Date | string | null
    plannedEnd?: Date | string | null
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.AssignmentStatus
    plannedVolume?: Decimal | DecimalJsLike | number | string | null
    actualVolume?: Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: boolean
    isSplitSource?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startTime?: Date | string | null
    endTime?: Date | string | null
    notes?: string | null
  }

  export type TransferCreateManyLot_Transfer_destLotIdToLotInput = {
    id: string
    tenantId: string
    transferCode: string
    sourceLotId?: string | null
    sourceTankId: string
    destTankId: string
    transferType: $Enums.TransferType
    volume: Decimal | DecimalJsLike | number | string
    plannedAt: Date | string
    executedAt?: Date | string | null
    status?: $Enums.TransferStatus
    measuredLoss?: Decimal | DecimalJsLike | number | string | null
    lossReason?: string | null
    performedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransferCreateManyLot_Transfer_sourceLotIdToLotInput = {
    id: string
    tenantId: string
    transferCode: string
    sourceTankId: string
    destLotId?: string | null
    destTankId: string
    transferType: $Enums.TransferType
    volume: Decimal | DecimalJsLike | number | string
    plannedAt: Date | string
    executedAt?: Date | string | null
    status?: $Enums.TransferStatus
    measuredLoss?: Decimal | DecimalJsLike | number | string | null
    lossReason?: string | null
    performedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LotUpdateWithoutLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_Lot?: LotUpdateManyWithoutLotNestedInput
    LotBatch?: LotBatchUpdateManyWithoutLotNestedInput
    LotReading?: LotReadingUpdateManyWithoutLotNestedInput
    QCTest?: QCTestUpdateManyWithoutLotNestedInput
    TankAssignment?: TankAssignmentUpdateManyWithoutLotNestedInput
    Transfer_Transfer_destLotIdToLot?: TransferUpdateManyWithoutLot_Transfer_destLotIdToLotNestedInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUpdateManyWithoutLot_Transfer_sourceLotIdToLotNestedInput
  }

  export type LotUncheckedUpdateWithoutLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_Lot?: LotUncheckedUpdateManyWithoutLotNestedInput
    LotBatch?: LotBatchUncheckedUpdateManyWithoutLotNestedInput
    LotReading?: LotReadingUncheckedUpdateManyWithoutLotNestedInput
    QCTest?: QCTestUncheckedUpdateManyWithoutLotNestedInput
    TankAssignment?: TankAssignmentUncheckedUpdateManyWithoutLotNestedInput
    Transfer_Transfer_destLotIdToLot?: TransferUncheckedUpdateManyWithoutLot_Transfer_destLotIdToLotNestedInput
    Transfer_Transfer_sourceLotIdToLot?: TransferUncheckedUpdateManyWithoutLot_Transfer_sourceLotIdToLotNestedInput
  }

  export type LotUncheckedUpdateManyWithoutLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    lotCode?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    status?: EnumLotStatusFieldUpdateOperationsInput | $Enums.LotStatus
    plannedVolume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    splitRatio?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    blendedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBlendResult?: NullableBoolFieldUpdateOperationsInput | boolean | null
    splitAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LotBatchUpdateWithoutLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    volumeContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateOneRequiredWithoutLotBatchNestedInput
  }

  export type LotBatchUncheckedUpdateWithoutLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    volumeContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LotBatchUncheckedUpdateManyWithoutLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    volumeContribution?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LotReadingUpdateWithoutLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Tank?: TankUpdateOneRequiredWithoutLotReadingNestedInput
  }

  export type LotReadingUncheckedUpdateWithoutLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tankId?: StringFieldUpdateOperationsInput | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LotReadingUncheckedUpdateManyWithoutLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tankId?: StringFieldUpdateOperationsInput | string
    readingType?: EnumReadingTypeFieldUpdateOperationsInput | $Enums.ReadingType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QCTestUpdateWithoutLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    testType?: EnumQCTestTypeFieldUpdateOperationsInput | $Enums.QCTestType
    status?: EnumQCTestStatusFieldUpdateOperationsInput | $Enums.QCTestStatus
    priority?: EnumQCTestPriorityFieldUpdateOperationsInput | $Enums.QCTestPriority
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    minValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Batch?: BatchUpdateOneRequiredWithoutQCTestNestedInput
  }

  export type QCTestUncheckedUpdateWithoutLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    testType?: EnumQCTestTypeFieldUpdateOperationsInput | $Enums.QCTestType
    status?: EnumQCTestStatusFieldUpdateOperationsInput | $Enums.QCTestStatus
    priority?: EnumQCTestPriorityFieldUpdateOperationsInput | $Enums.QCTestPriority
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    minValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QCTestUncheckedUpdateManyWithoutLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    batchId?: StringFieldUpdateOperationsInput | string
    testType?: EnumQCTestTypeFieldUpdateOperationsInput | $Enums.QCTestType
    status?: EnumQCTestStatusFieldUpdateOperationsInput | $Enums.QCTestStatus
    priority?: EnumQCTestPriorityFieldUpdateOperationsInput | $Enums.QCTestPriority
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    minValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    targetValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    result?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TankAssignmentUpdateWithoutLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    plannedStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    plannedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: BoolFieldUpdateOperationsInput | boolean
    isSplitSource?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    Tank?: TankUpdateOneRequiredWithoutTankAssignmentNestedInput
  }

  export type TankAssignmentUncheckedUpdateWithoutLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tankId?: StringFieldUpdateOperationsInput | string
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    plannedStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    plannedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: BoolFieldUpdateOperationsInput | boolean
    isSplitSource?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TankAssignmentUncheckedUpdateManyWithoutLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tankId?: StringFieldUpdateOperationsInput | string
    phase?: EnumLotPhaseFieldUpdateOperationsInput | $Enums.LotPhase
    plannedStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plannedEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    plannedVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actualVolume?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isBlendTarget?: BoolFieldUpdateOperationsInput | boolean
    isSplitSource?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransferUpdateWithoutLot_Transfer_destLotIdToLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    measuredLoss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Tank_Transfer_destTankIdToTank?: TankUpdateOneRequiredWithoutTransfer_Transfer_destTankIdToTankNestedInput
    Lot_Transfer_sourceLotIdToLot?: LotUpdateOneWithoutTransfer_Transfer_sourceLotIdToLotNestedInput
    Tank_Transfer_sourceTankIdToTank?: TankUpdateOneRequiredWithoutTransfer_Transfer_sourceTankIdToTankNestedInput
  }

  export type TransferUncheckedUpdateWithoutLot_Transfer_destLotIdToLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    sourceLotId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceTankId?: StringFieldUpdateOperationsInput | string
    destTankId?: StringFieldUpdateOperationsInput | string
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    measuredLoss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateManyWithoutLot_Transfer_destLotIdToLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    sourceLotId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceTankId?: StringFieldUpdateOperationsInput | string
    destTankId?: StringFieldUpdateOperationsInput | string
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    measuredLoss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUpdateWithoutLot_Transfer_sourceLotIdToLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    measuredLoss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lot_Transfer_destLotIdToLot?: LotUpdateOneWithoutTransfer_Transfer_destLotIdToLotNestedInput
    Tank_Transfer_destTankIdToTank?: TankUpdateOneRequiredWithoutTransfer_Transfer_destTankIdToTankNestedInput
    Tank_Transfer_sourceTankIdToTank?: TankUpdateOneRequiredWithoutTransfer_Transfer_sourceTankIdToTankNestedInput
  }

  export type TransferUncheckedUpdateWithoutLot_Transfer_sourceLotIdToLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    sourceTankId?: StringFieldUpdateOperationsInput | string
    destLotId?: NullableStringFieldUpdateOperationsInput | string | null
    destTankId?: StringFieldUpdateOperationsInput | string
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    measuredLoss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransferUncheckedUpdateManyWithoutLot_Transfer_sourceLotIdToLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    transferCode?: StringFieldUpdateOperationsInput | string
    sourceTankId?: StringFieldUpdateOperationsInput | string
    destLotId?: NullableStringFieldUpdateOperationsInput | string | null
    destTankId?: StringFieldUpdateOperationsInput | string
    transferType?: EnumTransferTypeFieldUpdateOperationsInput | $Enums.TransferType
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    plannedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    measuredLoss?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lossReason?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KegMovementCreateManyKegInput = {
    id?: string
    tenantId: string
    action: $Enums.KegAction
    fromStatus: $Enums.KegStatus
    toStatus: $Enums.KegStatus
    productId?: string | null
    productName?: string | null
    customerId?: string | null
    customerName?: string | null
    orderId?: string | null
    batchId?: string | null
    notes?: string | null
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type KegMovementUpdateWithoutKegInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    action?: EnumKegActionFieldUpdateOperationsInput | $Enums.KegAction
    fromStatus?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    toStatus?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KegMovementUncheckedUpdateWithoutKegInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    action?: EnumKegActionFieldUpdateOperationsInput | $Enums.KegAction
    fromStatus?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    toStatus?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KegMovementUncheckedUpdateManyWithoutKegInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    action?: EnumKegActionFieldUpdateOperationsInput | $Enums.KegAction
    fromStatus?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    toStatus?: EnumKegStatusFieldUpdateOperationsInput | $Enums.KegStatus
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TourCreateManyMuseumInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TourUpdateWithoutMuseumInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourUncheckedUpdateWithoutMuseumInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TourUncheckedUpdateManyWithoutMuseumInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use TenantCountOutputTypeDefaultArgs instead
     */
    export type TenantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeCountOutputTypeDefaultArgs instead
     */
    export type RecipeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryItemCountOutputTypeDefaultArgs instead
     */
    export type InventoryItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BatchCountOutputTypeDefaultArgs instead
     */
    export type BatchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BatchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TankCountOutputTypeDefaultArgs instead
     */
    export type TankCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TankCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerCountOutputTypeDefaultArgs instead
     */
    export type CustomerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierCountOutputTypeDefaultArgs instead
     */
    export type SupplierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalesOrderCountOutputTypeDefaultArgs instead
     */
    export type SalesOrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalesOrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceCountOutputTypeDefaultArgs instead
     */
    export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpenseCountOutputTypeDefaultArgs instead
     */
    export type ExpenseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpenseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EquipmentCountOutputTypeDefaultArgs instead
     */
    export type EquipmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EquipmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LotCountOutputTypeDefaultArgs instead
     */
    export type LotCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LotCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KegCountOutputTypeDefaultArgs instead
     */
    export type KegCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KegCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MuseumCountOutputTypeDefaultArgs instead
     */
    export type MuseumCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MuseumCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantDefaultArgs instead
     */
    export type TenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeDefaultArgs instead
     */
    export type RecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeIngredientDefaultArgs instead
     */
    export type RecipeIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeIngredientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryItemDefaultArgs instead
     */
    export type InventoryItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryLedgerDefaultArgs instead
     */
    export type InventoryLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryLedgerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngredientCatalogDefaultArgs instead
     */
    export type IngredientCatalogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngredientCatalogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BatchDefaultArgs instead
     */
    export type BatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BatchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BatchIngredientDefaultArgs instead
     */
    export type BatchIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BatchIngredientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GravityReadingDefaultArgs instead
     */
    export type GravityReadingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GravityReadingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BatchTimelineDefaultArgs instead
     */
    export type BatchTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BatchTimelineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TankDefaultArgs instead
     */
    export type TankArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TankDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TankOccupationDefaultArgs instead
     */
    export type TankOccupationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TankOccupationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PackagingRunDefaultArgs instead
     */
    export type PackagingRunArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PackagingRunDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerDefaultArgs instead
     */
    export type CustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierDefaultArgs instead
     */
    export type SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalesOrderDefaultArgs instead
     */
    export type SalesOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalesOrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderItemDefaultArgs instead
     */
    export type OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceItemDefaultArgs instead
     */
    export type InvoiceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpenseDefaultArgs instead
     */
    export type ExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpenseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudgetDefaultArgs instead
     */
    export type BudgetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudgetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlendingConfigDefaultArgs instead
     */
    export type BlendingConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlendingConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CIPLogDefaultArgs instead
     */
    export type CIPLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CIPLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EquipmentDefaultArgs instead
     */
    export type EquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EquipmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LotDefaultArgs instead
     */
    export type LotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LotBatchDefaultArgs instead
     */
    export type LotBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LotBatchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LotReadingDefaultArgs instead
     */
    export type LotReadingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LotReadingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaintenanceLogDefaultArgs instead
     */
    export type MaintenanceLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaintenanceLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProblemReportDefaultArgs instead
     */
    export type ProblemReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProblemReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TankAssignmentDefaultArgs instead
     */
    export type TankAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TankAssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransferDefaultArgs instead
     */
    export type TransferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransferDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KegDefaultArgs instead
     */
    export type KegArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KegDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KegMovementDefaultArgs instead
     */
    export type KegMovementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KegMovementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QCTestDefaultArgs instead
     */
    export type QCTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QCTestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConfigurationDefaultArgs instead
     */
    export type ConfigurationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConfigurationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MuseumDefaultArgs instead
     */
    export type MuseumArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MuseumDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TourDefaultArgs instead
     */
    export type TourArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TourDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}